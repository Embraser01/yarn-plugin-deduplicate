module.exports = {};

module.exports.factory = function (require) {
  var plugin =
  /******/ (function(modules) { // webpackBootstrap
  /******/ 	// The module cache
  /******/ 	var installedModules = {};
  /******/
  /******/ 	// The require function
  /******/ 	function __webpack_require__(moduleId) {
  /******/
  /******/ 		// Check if module is in cache
  /******/ 		if(installedModules[moduleId]) {
  /******/ 			return installedModules[moduleId].exports;
  /******/ 		}
  /******/ 		// Create a new module (and put it into the cache)
  /******/ 		var module = installedModules[moduleId] = {
  /******/ 			i: moduleId,
  /******/ 			l: false,
  /******/ 			exports: {}
  /******/ 		};
  /******/
  /******/ 		// Execute the module function
  /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
  /******/
  /******/ 		// Flag the module as loaded
  /******/ 		module.l = true;
  /******/
  /******/ 		// Return the exports of the module
  /******/ 		return module.exports;
  /******/ 	}
  /******/
  /******/
  /******/ 	// expose the modules object (__webpack_modules__)
  /******/ 	__webpack_require__.m = modules;
  /******/
  /******/ 	// expose the module cache
  /******/ 	__webpack_require__.c = installedModules;
  /******/
  /******/ 	// define getter function for harmony exports
  /******/ 	__webpack_require__.d = function(exports, name, getter) {
  /******/ 		if(!__webpack_require__.o(exports, name)) {
  /******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
  /******/ 		}
  /******/ 	};
  /******/
  /******/ 	// define __esModule on exports
  /******/ 	__webpack_require__.r = function(exports) {
  /******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
  /******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
  /******/ 		}
  /******/ 		Object.defineProperty(exports, '__esModule', { value: true });
  /******/ 	};
  /******/
  /******/ 	// create a fake namespace object
  /******/ 	// mode & 1: value is a module id, require it
  /******/ 	// mode & 2: merge all properties of value into the ns
  /******/ 	// mode & 4: return value when already ns object
  /******/ 	// mode & 8|1: behave like require
  /******/ 	__webpack_require__.t = function(value, mode) {
  /******/ 		if(mode & 1) value = __webpack_require__(value);
  /******/ 		if(mode & 8) return value;
  /******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
  /******/ 		var ns = Object.create(null);
  /******/ 		__webpack_require__.r(ns);
  /******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
  /******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
  /******/ 		return ns;
  /******/ 	};
  /******/
  /******/ 	// getDefaultExport function for compatibility with non-harmony modules
  /******/ 	__webpack_require__.n = function(module) {
  /******/ 		var getter = module && module.__esModule ?
  /******/ 			function getDefault() { return module['default']; } :
  /******/ 			function getModuleExports() { return module; };
  /******/ 		__webpack_require__.d(getter, 'a', getter);
  /******/ 		return getter;
  /******/ 	};
  /******/
  /******/ 	// Object.prototype.hasOwnProperty.call
  /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
  /******/
  /******/ 	// __webpack_public_path__
  /******/ 	__webpack_require__.p = "";
  /******/
  /******/
  /******/ 	// Load entry module and return exports
  /******/ 	return __webpack_require__(__webpack_require__.s = 0);
  /******/ })
  /************************************************************************/
  /******/ ([
  /* 0 */
  /***/ (function(module, __webpack_exports__, __webpack_require__) {

  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony import */ var _commands_deduplicate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);

  const plugin = {
    commands: [_commands_deduplicate__WEBPACK_IMPORTED_MODULE_0__["default"]]
  }; // eslint-disable-next-line arca/no-default-export

  /* harmony default export */ __webpack_exports__["default"] = (plugin);

  /***/ }),
  /* 1 */
  /***/ (function(module, __webpack_exports__, __webpack_require__) {

  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DeduplicateCommand; });
  /* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
  /* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__);
  /* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
  /* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__);
  /* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(224);
  /* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(clipanion__WEBPACK_IMPORTED_MODULE_2__);
  /* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(437);
  /* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_3__);
  var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };





   // eslint-disable-next-line arca/no-default-export

  class DeduplicateCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__["BaseCommand"] {
    async execute() {
      const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__["Configuration"].find(this.context.cwd, this.context.plugins);
      const {
        project
      } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__["Project"].find(configuration, this.context.cwd);
      const deduplicateReport = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__["StreamReport"].start({
        configuration,
        stdout: this.context.stdout,
        includeFooter: false
      }, async report => {
        report.startTimerSync('deduplication step', () => {
          deduplicate(project, report);
        });
      });
      if (deduplicateReport.hasErrors()) return deduplicateReport.exitCode();
      const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__["Cache"].find(configuration);
      const installReport = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__["StreamReport"].start({
        configuration,
        stdout: this.context.stdout,
        includeLogs: true
      }, async report => {
        await project.install({
          cache,
          report
        });
      });
      return installReport.exitCode();
    }

  }
  DeduplicateCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_2__["Command"].Usage({
    category: `Workspace-related commands`,
    description: `Reduces dependencies with overlapping ranges to a smaller set of packages`,
    details: `https://github.com/atlassian/yarn-deduplicate for yarn v2`,
    examples: []
  });

  __decorate([clipanion__WEBPACK_IMPORTED_MODULE_2__["Command"].Path(`deduplicate`)], DeduplicateCommand.prototype, "execute", null);

  function deduplicate(project, report) {
    const locatorsByIdent = new Map();

    for (const [descriptorHash, locatorHash] of project.storedResolutions.entries()) {
      const value = locatorHash;
      const descriptor = project.storedDescriptors.get(descriptorHash);
      const key = descriptor.identHash;
      const locators = locatorsByIdent.get(key);

      if (locators === undefined) {
        locatorsByIdent.set(key, new Set([value]));
      } else {
        locatorsByIdent.set(key, locators.add(value));
      }
    }

    for (const descriptorHash of project.storedResolutions.keys()) {
      const descriptor = project.storedDescriptors.get(descriptorHash);
      const locatorHashes = locatorsByIdent.get(descriptor.identHash);
      const semverMatch = descriptor.range.match(/^npm:(.*)$/);
      if (semverMatch === null) continue;

      if (locatorHashes !== undefined && locatorHashes.size > 1) {
        const candidates = Array.from(locatorHashes).map(locatorHash => {
          const pkg = project.storedPackages.get(locatorHash);

          if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__["structUtils"].isVirtualLocator(pkg)) {
            const sourceLocator = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__["structUtils"].devirtualizeLocator(pkg);
            return project.storedPackages.get(sourceLocator.locatorHash);
          }

          return pkg;
        }).filter(sourcePackage => {
          if (sourcePackage.version === null) return false;
          return semver__WEBPACK_IMPORTED_MODULE_3__["satisfies"](sourcePackage.version, semverMatch[1]);
        }).sort((a, b) => {
          return semver__WEBPACK_IMPORTED_MODULE_3__["gt"](a.version, b.version) ? -1 : 1;
        });

        if (candidates.length > 1) {
          const newLocatorHash = candidates[0].locatorHash;
          const oldLocatorHash = project.storedResolutions.get(descriptorHash);
          const newPkg = project.storedPackages.get(newLocatorHash);
          const oldPkg = project.storedPackages.get(oldLocatorHash);

          if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__["structUtils"].areLocatorsEqual(oldPkg, newPkg) === false) {
            report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__["MessageName"].UNNAMED, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__["structUtils"].stringifyDescriptor(descriptor)} can be deduplicated from ${oldPkg.name}@${oldPkg.version} to ${newPkg.name}@${newPkg.version}`);
            project.storedResolutions.set(descriptorHash, newLocatorHash);
          }
        }
      }
    }
  }

  /***/ }),
  /* 2 */
  /***/ (function(module, exports) {

  throw new Error("Module build failed (from ./.yarn/virtual/ts-loader-virtual-7a8a881e02/0/cache/ts-loader-npm-5.4.5-fa17d5ca99.zip/node_modules/ts-loader/index.js):\nError: TypeScript emitted no output for /home/eps1lon/Development/src/js/yarn-plugin-deduplicate/.yarn/cache/@yarnpkg-cli-npm-2.0.0-rc.4-899aa45593.zip/node_modules/@yarnpkg/cli/sources/index.ts. By default, ts-loader will not compile .ts files in node_modules.\nYou should not need to recompile .ts files there, but if you really want to, use the allowTsInNodeModules option.\nSee: https://github.com/Microsoft/TypeScript/issues/12358\n    at makeSourceMapAndFinish (/home/eps1lon/Development/src/js/yarn-plugin-deduplicate/.yarn/virtual/ts-loader-virtual-7a8a881e02/0/cache/ts-loader-npm-5.4.5-fa17d5ca99.zip/node_modules/ts-loader/dist/index.js:78:15)\n    at successLoader (/home/eps1lon/Development/src/js/yarn-plugin-deduplicate/.yarn/virtual/ts-loader-virtual-7a8a881e02/0/cache/ts-loader-npm-5.4.5-fa17d5ca99.zip/node_modules/ts-loader/dist/index.js:68:9)\n    at Object.loader (/home/eps1lon/Development/src/js/yarn-plugin-deduplicate/.yarn/virtual/ts-loader-virtual-7a8a881e02/0/cache/ts-loader-npm-5.4.5-fa17d5ca99.zip/node_modules/ts-loader/dist/index.js:22:12)");

  /***/ }),
  /* 3 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      result["default"] = mod;
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const execUtils = __importStar(__webpack_require__(4));
  exports.execUtils = execUtils;
  const folderUtils = __importStar(__webpack_require__(43));
  exports.folderUtils = folderUtils;
  const httpUtils = __importStar(__webpack_require__(45));
  exports.httpUtils = httpUtils;
  const miscUtils = __importStar(__webpack_require__(128));
  exports.miscUtils = miscUtils;
  const scriptUtils = __importStar(__webpack_require__(130));
  exports.scriptUtils = scriptUtils;
  const structUtils = __importStar(__webpack_require__(173));
  exports.structUtils = structUtils;
  const tgzUtils = __importStar(__webpack_require__(179));
  exports.tgzUtils = tgzUtils;
  var Cache_1 = __webpack_require__(210);
  exports.Cache = Cache_1.Cache;
  var Configuration_1 = __webpack_require__(211);
  exports.Configuration = Configuration_1.Configuration;
  exports.SettingsType = Configuration_1.SettingsType;
  var Installer_1 = __webpack_require__(242);
  exports.BuildType = Installer_1.BuildType;
  var LightReport_1 = __webpack_require__(243);
  exports.LightReport = LightReport_1.LightReport;
  var Manifest_1 = __webpack_require__(172);
  exports.Manifest = Manifest_1.Manifest;
  var Project_1 = __webpack_require__(244);
  exports.Project = Project_1.Project;
  var Report_1 = __webpack_require__(177);
  exports.ReportError = Report_1.ReportError;
  exports.Report = Report_1.Report;
  exports.MessageName = Report_1.MessageName;
  var StreamReport_1 = __webpack_require__(176);
  exports.StreamReport = StreamReport_1.StreamReport;
  var ThrowReport_1 = __webpack_require__(254);
  exports.ThrowReport = ThrowReport_1.ThrowReport;
  var VirtualFetcher_1 = __webpack_require__(235);
  exports.VirtualFetcher = VirtualFetcher_1.VirtualFetcher;
  var WorkspaceResolver_1 = __webpack_require__(238);
  exports.WorkspaceResolver = WorkspaceResolver_1.WorkspaceResolver;
  var Workspace_1 = __webpack_require__(255);
  exports.Workspace = Workspace_1.Workspace;
  var types_1 = __webpack_require__(239);
  exports.LinkType = types_1.LinkType;


  /***/ }),
  /* 4 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importDefault = (this && this.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const fslib_1 = __webpack_require__(5);
  const cross_spawn_1 = __importDefault(__webpack_require__(27));
  async function pipevp(fileName, args, { cwd, env = process.env, strict = false, stdin = null, stdout, stderr }) {
      const stdio = [`pipe`, `pipe`, `pipe`];
      if (stdin === null)
          stdio[0] = `ignore`;
      else if (stdin === process.stdin)
          stdio[0] = stdin;
      if (stdout === process.stdout)
          stdio[1] = stdout;
      if (stderr === process.stderr)
          stdio[2] = stderr;
      const subprocess = cross_spawn_1.default(fileName, args, {
          cwd: fslib_1.NodeFS.fromPortablePath(cwd),
          env,
          stdio,
      });
      if (stdin !== process.stdin && stdin !== null)
          stdin.pipe(subprocess.stdin);
      if (stdout !== process.stdout)
          subprocess.stdout.pipe(stdout);
      if (stderr !== process.stderr)
          subprocess.stderr.pipe(stderr);
      return new Promise((resolve, reject) => {
          subprocess.on(`close`, (code) => {
              if (code === 0 || !strict) {
                  resolve({ code });
              }
              else {
                  reject(new Error(`Child "${fileName}" exited with exit code ${code}`));
              }
          });
      });
  }
  exports.pipevp = pipevp;
  async function execvp(fileName, args, { cwd, env = process.env, encoding = `utf8`, strict = false }) {
      const stdio = [`ignore`, `pipe`, `pipe`];
      const stdoutChunks = [];
      const stderrChunks = [];
      const subprocess = cross_spawn_1.default(fileName, args, {
          cwd: fslib_1.NodeFS.fromPortablePath(cwd),
          env,
          stdio,
      });
      subprocess.stdout.on(`data`, (chunk) => {
          stdoutChunks.push(chunk);
      });
      subprocess.stderr.on(`data`, (chunk) => {
          stderrChunks.push(chunk);
      });
      return await new Promise((resolve, reject) => {
          subprocess.on(`close`, (code) => {
              const stdout = encoding === `buffer`
                  ? Buffer.concat(stdoutChunks)
                  : Buffer.concat(stdoutChunks).toString(encoding);
              const stderr = encoding === `buffer`
                  ? Buffer.concat(stderrChunks)
                  : Buffer.concat(stderrChunks).toString(encoding);
              if (code === 0 || !strict) {
                  resolve({ code, stdout, stderr });
              }
              else {
                  reject(new Error(`Child "${fileName}" exited with exit code ${code}\n\n${stderr}`));
              }
          });
      });
  }
  exports.execvp = execvp;


  /***/ }),
  /* 5 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importDefault = (this && this.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const tmp_1 = __importDefault(__webpack_require__(6));
  const NodeFS_1 = __webpack_require__(11);
  var path_1 = __webpack_require__(13);
  exports.PortablePath = path_1.PortablePath;
  var path_2 = __webpack_require__(13);
  exports.npath = path_2.npath;
  exports.ppath = path_2.ppath;
  exports.toFilename = path_2.toFilename;
  exports.fromPortablePath = path_2.fromPortablePath;
  exports.toPortablePath = path_2.toPortablePath;
  var AliasFS_1 = __webpack_require__(14);
  exports.AliasFS = AliasFS_1.AliasFS;
  var FakeFS_1 = __webpack_require__(12);
  exports.FakeFS = FakeFS_1.FakeFS;
  var CwdFS_1 = __webpack_require__(16);
  exports.CwdFS = CwdFS_1.CwdFS;
  var JailFS_1 = __webpack_require__(17);
  exports.JailFS = JailFS_1.JailFS;
  var LazyFS_1 = __webpack_require__(18);
  exports.LazyFS = LazyFS_1.LazyFS;
  var NodeFS_2 = __webpack_require__(11);
  exports.NodeFS = NodeFS_2.NodeFS;
  var PosixFS_1 = __webpack_require__(19);
  exports.PosixFS = PosixFS_1.PosixFS;
  var ProxiedFS_1 = __webpack_require__(15);
  exports.ProxiedFS = ProxiedFS_1.ProxiedFS;
  var VirtualFS_1 = __webpack_require__(20);
  exports.VirtualFS = VirtualFS_1.VirtualFS;
  var ZipFS_1 = __webpack_require__(21);
  exports.ZipFS = ZipFS_1.ZipFS;
  var ZipOpenFS_1 = __webpack_require__(26);
  exports.ZipOpenFS = ZipOpenFS_1.ZipOpenFS;
  function patchFs(patchedFs, fakeFs) {
      const SYNC_IMPLEMENTATIONS = new Set([
          `accessSync`,
          `appendFileSync`,
          `createReadStream`,
          `chmodSync`,
          `closeSync`,
          `copyFileSync`,
          `lstatSync`,
          `openSync`,
          `readSync`,
          `readlinkSync`,
          `readFileSync`,
          `readdirSync`,
          `readlinkSync`,
          `realpathSync`,
          `rmdirSync`,
          `statSync`,
          `symlinkSync`,
          `unlinkSync`,
          `utimesSync`,
          `watch`,
          `writeFileSync`,
          `writeSync`,
      ]);
      const ASYNC_IMPLEMENTATIONS = new Set([
          `accessPromise`,
          `appendFilePromise`,
          `chmodPromise`,
          `closePromise`,
          `copyFilePromise`,
          `lstatPromise`,
          `openPromise`,
          `readdirPromise`,
          `realpathPromise`,
          `readFilePromise`,
          `readdirPromise`,
          `readlinkPromise`,
          `rmdirPromise`,
          `statPromise`,
          `symlinkPromise`,
          `unlinkPromise`,
          `utimesPromise`,
          `writeFilePromise`,
          `writeSync`,
      ]);
      patchedFs.existsSync = (p) => {
          try {
              return fakeFs.existsSync(p);
          }
          catch (error) {
              return false;
          }
      };
      patchedFs.exists = (p, ...args) => {
          const hasCallback = typeof args[args.length - 1] === `function`;
          const callback = hasCallback ? args.pop() : () => { };
          process.nextTick(() => {
              fakeFs.existsPromise(p).then(exists => {
                  callback(exists);
              }, () => {
                  callback(false);
              });
          });
      };
      patchedFs.read = (p, buffer, ...args) => {
          const hasCallback = typeof args[args.length - 1] === `function`;
          const callback = hasCallback ? args.pop() : () => { };
          process.nextTick(() => {
              fakeFs.readPromise(p, buffer, ...args).then(bytesRead => {
                  callback(undefined, bytesRead, buffer);
              }, error => {
                  callback(error);
              });
          });
      };
      for (const fnName of ASYNC_IMPLEMENTATIONS) {
          const fakeImpl = fakeFs[fnName].bind(fakeFs);
          const origName = fnName.replace(/Promise$/, ``);
          patchedFs[origName] = (...args) => {
              const hasCallback = typeof args[args.length - 1] === `function`;
              const callback = hasCallback ? args.pop() : () => { };
              process.nextTick(() => {
                  fakeImpl(...args).then((result) => {
                      callback(undefined, result);
                  }, (error) => {
                      callback(error);
                  });
              });
          };
      }
      for (const fnName of SYNC_IMPLEMENTATIONS) {
          const fakeImpl = fakeFs[fnName].bind(fakeFs);
          const origName = fnName;
          patchedFs[origName] = fakeImpl;
      }
      patchedFs.realpathSync.native = patchedFs.realpathSync;
      patchedFs.realpath.native = patchedFs.realpath;
  }
  exports.patchFs = patchFs;
  function extendFs(realFs, fakeFs) {
      const patchedFs = Object.create(realFs);
      patchFs(patchedFs, fakeFs);
      return patchedFs;
  }
  exports.extendFs = extendFs;
  exports.xfs = Object.assign(new NodeFS_1.NodeFS(), {
      mktempSync(cb) {
          const { name, removeCallback } = tmp_1.default.dirSync({ unsafeCleanup: true });
          if (typeof cb === `undefined`) {
              return NodeFS_1.NodeFS.toPortablePath(name);
          }
          else {
              try {
                  return cb(NodeFS_1.NodeFS.toPortablePath(name));
              }
              finally {
                  removeCallback();
              }
          }
      },
      mktempPromise(cb) {
          if (typeof cb === `undefined`) {
              return new Promise((resolve, reject) => {
                  tmp_1.default.dir({ unsafeCleanup: true }, (err, path) => {
                      if (err) {
                          reject(err);
                      }
                      else {
                          resolve(NodeFS_1.NodeFS.toPortablePath(path));
                      }
                  });
              });
          }
          else {
              return new Promise((resolve, reject) => {
                  tmp_1.default.dir({ unsafeCleanup: true }, (err, path, cleanup) => {
                      if (err) {
                          reject(err);
                      }
                      else {
                          Promise.resolve(NodeFS_1.NodeFS.toPortablePath(path)).then(cb).then(result => {
                              cleanup();
                              resolve(result);
                          }, error => {
                              cleanup();
                              reject(error);
                          });
                      }
                  });
              });
          }
      },
  });


  /***/ }),
  /* 6 */
  /***/ (function(module, exports, __webpack_require__) {

  /*!
   * Tmp
   *
   * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
   *
   * MIT Licensed
   */

  /*
   * Module dependencies.
   */
  const fs = __webpack_require__(7);
  const path = __webpack_require__(8);
  const crypto = __webpack_require__(9);
  const osTmpDir = __webpack_require__(10);
  const _c = process.binding('constants');

  /*
   * The working inner variables.
   */
  const
    /**
     * The temporary directory.
     * @type {string}
     */
    tmpDir = osTmpDir(),

    // the random characters to choose from
    RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',

    TEMPLATE_PATTERN = /XXXXXX/,

    DEFAULT_TRIES = 3,

    CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),

    EBADF = _c.EBADF || _c.os.errno.EBADF,
    ENOENT = _c.ENOENT || _c.os.errno.ENOENT,

    DIR_MODE = 448 /* 0o700 */,
    FILE_MODE = 384 /* 0o600 */,

    // this will hold the objects need to be removed on exit
    _removeObjects = [];

  var
    _gracefulCleanup = false,
    _uncaughtException = false;

  /**
   * Random name generator based on crypto.
   * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript
   *
   * @param {number} howMany
   * @returns {string} the generated random name
   * @private
   */
  function _randomChars(howMany) {
    var
      value = [],
      rnd = null;

    // make sure that we do not fail because we ran out of entropy
    try {
      rnd = crypto.randomBytes(howMany);
    } catch (e) {
      rnd = crypto.pseudoRandomBytes(howMany);
    }

    for (var i = 0; i < howMany; i++) {
      value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);
    }

    return value.join('');
  }

  /**
   * Checks whether the `obj` parameter is defined or not.
   *
   * @param {Object} obj
   * @returns {boolean} true if the object is undefined
   * @private
   */
  function _isUndefined(obj) {
    return typeof obj === 'undefined';
  }

  /**
   * Parses the function arguments.
   *
   * This function helps to have optional arguments.
   *
   * @param {(Options|Function)} options
   * @param {Function} callback
   * @returns {Array} parsed arguments
   * @private
   */
  function _parseArguments(options, callback) {
    if (typeof options == 'function') {
      return [callback || {}, options];
    }

    if (_isUndefined(options)) {
      return [{}, callback];
    }

    return [options, callback];
  }

  /**
   * Generates a new temporary name.
   *
   * @param {Object} opts
   * @returns {string} the new random name according to opts
   * @private
   */
  function _generateTmpName(opts) {
    if (opts.name) {
      return path.join(opts.dir || tmpDir, opts.name);
    }

    // mkstemps like template
    if (opts.template) {
      return opts.template.replace(TEMPLATE_PATTERN, _randomChars(6));
    }

    // prefix and postfix
    const name = [
      opts.prefix || 'tmp-',
      process.pid,
      _randomChars(12),
      opts.postfix || ''
    ].join('');

    return path.join(opts.dir || tmpDir, name);
  }

  /**
   * Gets a temporary file name.
   *
   * @param {(Options|tmpNameCallback)} options options or callback
   * @param {?tmpNameCallback} callback the callback function
   */
  function tmpName(options, callback) {
    var
      args = _parseArguments(options, callback),
      opts = args[0],
      cb = args[1],
      tries = opts.name ? 1 : opts.tries || DEFAULT_TRIES;

    if (isNaN(tries) || tries < 0)
      return cb(new Error('Invalid tries'));

    if (opts.template && !opts.template.match(TEMPLATE_PATTERN))
      return cb(new Error('Invalid template provided'));

    (function _getUniqueName() {
      const name = _generateTmpName(opts);

      // check whether the path exists then retry if needed
      fs.stat(name, function (err) {
        if (!err) {
          if (tries-- > 0) return _getUniqueName();

          return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));
        }

        cb(null, name);
      });
    }());
  }

  /**
   * Synchronous version of tmpName.
   *
   * @param {Object} options
   * @returns {string} the generated random name
   * @throws {Error} if the options are invalid or could not generate a filename
   */
  function tmpNameSync(options) {
    var
      args = _parseArguments(options),
      opts = args[0],
      tries = opts.name ? 1 : opts.tries || DEFAULT_TRIES;

    if (isNaN(tries) || tries < 0)
      throw new Error('Invalid tries');

    if (opts.template && !opts.template.match(TEMPLATE_PATTERN))
      throw new Error('Invalid template provided');

    do {
      const name = _generateTmpName(opts);
      try {
        fs.statSync(name);
      } catch (e) {
        return name;
      }
    } while (tries-- > 0);

    throw new Error('Could not get a unique tmp filename, max tries reached');
  }

  /**
   * Creates and opens a temporary file.
   *
   * @param {(Options|fileCallback)} options the config options or the callback function
   * @param {?fileCallback} callback
   */
  function file(options, callback) {
    var
      args = _parseArguments(options, callback),
      opts = args[0],
      cb = args[1];

    opts.postfix = (_isUndefined(opts.postfix)) ? '.tmp' : opts.postfix;

    // gets a temporary filename
    tmpName(opts, function _tmpNameCreated(err, name) {
      if (err) return cb(err);

      // create and open the file
      fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {
        if (err) return cb(err);

        if (opts.discardDescriptor) {
          return fs.close(fd, function _discardCallback(err) {
            if (err) {
              // Low probability, and the file exists, so this could be
              // ignored.  If it isn't we certainly need to unlink the
              // file, and if that fails too its error is more
              // important.
              try {
                fs.unlinkSync(name);
              } catch (e) {
                if (!isENOENT(e)) {
                  err = e;
                }
              }
              return cb(err);
            }
            cb(null, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts));
          });
        }
        if (opts.detachDescriptor) {
          return cb(null, name, fd, _prepareTmpFileRemoveCallback(name, -1, opts));
        }
        cb(null, name, fd, _prepareTmpFileRemoveCallback(name, fd, opts));
      });
    });
  }

  /**
   * Synchronous version of file.
   *
   * @param {Options} options
   * @returns {FileSyncObject} object consists of name, fd and removeCallback
   * @throws {Error} if cannot create a file
   */
  function fileSync(options) {
    var
      args = _parseArguments(options),
      opts = args[0];

    opts.postfix = opts.postfix || '.tmp';

    const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
    const name = tmpNameSync(opts);
    var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
    if (opts.discardDescriptor) {
      fs.closeSync(fd);
      fd = undefined;
    }

    return {
      name: name,
      fd: fd,
      removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts)
    };
  }

  /**
   * Removes files and folders in a directory recursively.
   *
   * @param {string} root
   * @private
   */
  function _rmdirRecursiveSync(root) {
    const dirs = [root];

    do {
      var
        dir = dirs.pop(),
        deferred = false,
        files = fs.readdirSync(dir);

      for (var i = 0, length = files.length; i < length; i++) {
        var
          file = path.join(dir, files[i]),
          stat = fs.lstatSync(file); // lstat so we don't recurse into symlinked directories

        if (stat.isDirectory()) {
          if (!deferred) {
            deferred = true;
            dirs.push(dir);
          }
          dirs.push(file);
        } else {
          fs.unlinkSync(file);
        }
      }

      if (!deferred) {
        fs.rmdirSync(dir);
      }
    } while (dirs.length !== 0);
  }

  /**
   * Creates a temporary directory.
   *
   * @param {(Options|dirCallback)} options the options or the callback function
   * @param {?dirCallback} callback
   */
  function dir(options, callback) {
    var
      args = _parseArguments(options, callback),
      opts = args[0],
      cb = args[1];

    // gets a temporary filename
    tmpName(opts, function _tmpNameCreated(err, name) {
      if (err) return cb(err);

      // create the directory
      fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {
        if (err) return cb(err);

        cb(null, name, _prepareTmpDirRemoveCallback(name, opts));
      });
    });
  }

  /**
   * Synchronous version of dir.
   *
   * @param {Options} options
   * @returns {DirSyncObject} object consists of name and removeCallback
   * @throws {Error} if it cannot create a directory
   */
  function dirSync(options) {
    var
      args = _parseArguments(options),
      opts = args[0];

    const name = tmpNameSync(opts);
    fs.mkdirSync(name, opts.mode || DIR_MODE);

    return {
      name: name,
      removeCallback: _prepareTmpDirRemoveCallback(name, opts)
    };
  }

  /**
   * Prepares the callback for removal of the temporary file.
   *
   * @param {string} name the path of the file
   * @param {number} fd file descriptor
   * @param {Object} opts
   * @returns {fileCallback}
   * @private
   */
  function _prepareTmpFileRemoveCallback(name, fd, opts) {
    const removeCallback = _prepareRemoveCallback(function _removeCallback(fdPath) {
      try {
        if (0 <= fdPath[0]) {
          fs.closeSync(fdPath[0]);
        }
      }
      catch (e) {
        // under some node/windows related circumstances, a temporary file
        // may have not be created as expected or the file was already closed
        // by the user, in which case we will simply ignore the error
        if (!isEBADF(e) && !isENOENT(e)) {
          // reraise any unanticipated error
          throw e;
        }
      }
      try {
        fs.unlinkSync(fdPath[1]);
      }
      catch (e) {
        if (!isENOENT(e)) {
          // reraise any unanticipated error
          throw e;
        }
      }
    }, [fd, name]);

    if (!opts.keep) {
      _removeObjects.unshift(removeCallback);
    }

    return removeCallback;
  }

  /**
   * Prepares the callback for removal of the temporary directory.
   *
   * @param {string} name
   * @param {Object} opts
   * @returns {Function} the callback
   * @private
   */
  function _prepareTmpDirRemoveCallback(name, opts) {
    const removeFunction = opts.unsafeCleanup ? _rmdirRecursiveSync : fs.rmdirSync.bind(fs);
    const removeCallback = _prepareRemoveCallback(removeFunction, name);

    if (!opts.keep) {
      _removeObjects.unshift(removeCallback);
    }

    return removeCallback;
  }

  /**
   * Creates a guarded function wrapping the removeFunction call.
   *
   * @param {Function} removeFunction
   * @param {Object} arg
   * @returns {Function}
   * @private
   */
  function _prepareRemoveCallback(removeFunction, arg) {
    var called = false;

    return function _cleanupCallback(next) {
      if (!called) {
        const index = _removeObjects.indexOf(_cleanupCallback);
        if (index >= 0) {
          _removeObjects.splice(index, 1);
        }

        called = true;
        removeFunction(arg);
      }

      if (next) next(null);
    };
  }

  /**
   * The garbage collector.
   *
   * @private
   */
  function _garbageCollector() {
    if (_uncaughtException && !_gracefulCleanup) {
      return;
    }

    // the function being called removes itself from _removeObjects,
    // loop until _removeObjects is empty
    while (_removeObjects.length) {
      try {
        _removeObjects[0].call(null);
      } catch (e) {
        // already removed?
      }
    }
  }

  /**
   * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.
   */
  function isEBADF(error) {
    return isExpectedError(error, -EBADF, 'EBADF');
  }

  /**
   * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.
   */
  function isENOENT(error) {
    return isExpectedError(error, -ENOENT, 'ENOENT');
  }

  /**
   * Helper to determine whether the expected error code matches the actual code and errno,
   * which will differ between the supported node versions.
   *
   * - Node >= 7.0:
   *   error.code {String}
   *   error.errno {String|Number} any numerical value will be negated
   *
   * - Node >= 6.0 < 7.0:
   *   error.code {String}
   *   error.errno {Number} negated
   *
   * - Node >= 4.0 < 6.0: introduces SystemError
   *   error.code {String}
   *   error.errno {Number} negated
   *
   * - Node >= 0.10 < 4.0:
   *   error.code {Number} negated
   *   error.errno n/a
   */
  function isExpectedError(error, code, errno) {
    return error.code == code || error.code == errno;
  }

  /**
   * Sets the graceful cleanup.
   *
   * Also removes the created files and directories when an uncaught exception occurs.
   */
  function setGracefulCleanup() {
    _gracefulCleanup = true;
  }

  const version = process.versions.node.split('.').map(function (value) {
    return parseInt(value, 10);
  });

  if (version[0] === 0 && (version[1] < 9 || version[1] === 9 && version[2] < 5)) {
    process.addListener('uncaughtException', function _uncaughtExceptionThrown(err) {
      _uncaughtException = true;
      _garbageCollector();

      throw err;
    });
  }

  process.addListener('exit', function _exit(code) {
    if (code) _uncaughtException = true;
    _garbageCollector();
  });

  /**
   * Configuration options.
   *
   * @typedef {Object} Options
   * @property {?number} tries the number of tries before give up the name generation
   * @property {?string} template the "mkstemp" like filename template
   * @property {?string} name fix name
   * @property {?string} dir the tmp directory to use
   * @property {?string} prefix prefix for the generated name
   * @property {?string} postfix postfix for the generated name
   */

  /**
   * @typedef {Object} FileSyncObject
   * @property {string} name the name of the file
   * @property {string} fd the file descriptor
   * @property {fileCallback} removeCallback the callback function to remove the file
   */

  /**
   * @typedef {Object} DirSyncObject
   * @property {string} name the name of the directory
   * @property {fileCallback} removeCallback the callback function to remove the directory
   */

  /**
   * @callback tmpNameCallback
   * @param {?Error} err the error object if anything goes wrong
   * @param {string} name the temporary file name
   */

  /**
   * @callback fileCallback
   * @param {?Error} err the error object if anything goes wrong
   * @param {string} name the temporary file name
   * @param {number} fd the file descriptor
   * @param {cleanupCallback} fn the cleanup callback function
   */

  /**
   * @callback dirCallback
   * @param {?Error} err the error object if anything goes wrong
   * @param {string} name the temporary file name
   * @param {cleanupCallback} fn the cleanup callback function
   */

  /**
   * Removes the temporary created file or directory.
   *
   * @callback cleanupCallback
   * @param {simpleCallback} [next] function to call after entry was removed
   */

  /**
   * Callback function for function composition.
   * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}
   *
   * @callback simpleCallback
   */

  // exporting all the needed methods
  module.exports.tmpdir = tmpDir;

  module.exports.dir = dir;
  module.exports.dirSync = dirSync;

  module.exports.file = file;
  module.exports.fileSync = fileSync;

  module.exports.tmpName = tmpName;
  module.exports.tmpNameSync = tmpNameSync;

  module.exports.setGracefulCleanup = setGracefulCleanup;


  /***/ }),
  /* 7 */
  /***/ (function(module, exports) {

  module.exports = require("fs");

  /***/ }),
  /* 8 */
  /***/ (function(module, exports) {

  module.exports = require("path");

  /***/ }),
  /* 9 */
  /***/ (function(module, exports) {

  module.exports = require("crypto");

  /***/ }),
  /* 10 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var isWindows = process.platform === 'win32';
  var trailingSlashRe = isWindows ? /[^:]\\$/ : /.\/$/;

  // https://github.com/nodejs/node/blob/3e7a14381497a3b73dda68d05b5130563cdab420/lib/os.js#L25-L43
  module.exports = function () {
  	var path;

  	if (isWindows) {
  		path = process.env.TEMP ||
  			process.env.TMP ||
  			(process.env.SystemRoot || process.env.windir) + '\\temp';
  	} else {
  		path = process.env.TMPDIR ||
  			process.env.TMP ||
  			process.env.TEMP ||
  			'/tmp';
  	}

  	if (trailingSlashRe.test(path)) {
  		path = path.slice(0, -1);
  	}

  	return path;
  };


  /***/ }),
  /* 11 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importDefault = (this && this.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const fs_1 = __importDefault(__webpack_require__(7));
  const FakeFS_1 = __webpack_require__(12);
  const path_1 = __webpack_require__(13);
  const path_2 = __webpack_require__(13);
  class NodeFS extends FakeFS_1.BasePortableFakeFS {
      constructor(realFs = fs_1.default) {
          super();
          this.realFs = realFs;
      }
      getRealPath() {
          return path_1.PortablePath.root;
      }
      async openPromise(p, flags, mode) {
          return await new Promise((resolve, reject) => {
              this.realFs.open(NodeFS.fromPortablePath(p), flags, mode, this.makeCallback(resolve, reject));
          });
      }
      openSync(p, flags, mode) {
          return this.realFs.openSync(NodeFS.fromPortablePath(p), flags, mode);
      }
      async readPromise(fd, buffer, offset = 0, length = 0, position = -1) {
          return await new Promise((resolve, reject) => {
              this.realFs.read(fd, buffer, offset, length, position, (error, bytesRead) => {
                  if (error) {
                      reject(error);
                  }
                  else {
                      resolve(bytesRead);
                  }
              });
          });
      }
      readSync(fd, buffer, offset, length, position) {
          return this.realFs.readSync(fd, buffer, offset, length, position);
      }
      async writePromise(fd, buffer, offset, length, position) {
          return await new Promise((resolve, reject) => {
              if (typeof buffer === `string`) {
                  return this.realFs.write(fd, buffer, offset, this.makeCallback(resolve, reject));
              }
              else {
                  return this.realFs.write(fd, buffer, offset, length, position, this.makeCallback(resolve, reject));
              }
          });
      }
      writeSync(fd, buffer, offset, length, position) {
          if (typeof buffer === `string`) {
              return this.realFs.writeSync(fd, buffer, offset);
          }
          else {
              return this.realFs.writeSync(fd, buffer, offset, length, position);
          }
      }
      async closePromise(fd) {
          await new Promise((resolve, reject) => {
              this.realFs.close(fd, this.makeCallback(resolve, reject));
          });
      }
      closeSync(fd) {
          this.realFs.closeSync(fd);
      }
      createReadStream(p, opts) {
          const realPath = (p !== null ? NodeFS.fromPortablePath(p) : p);
          return this.realFs.createReadStream(realPath, opts);
      }
      createWriteStream(p, opts) {
          const realPath = (p !== null ? NodeFS.fromPortablePath(p) : p);
          return this.realFs.createWriteStream(realPath, opts);
      }
      async realpathPromise(p) {
          return await new Promise((resolve, reject) => {
              this.realFs.realpath(NodeFS.fromPortablePath(p), {}, this.makeCallback(resolve, reject));
          }).then(path => {
              return NodeFS.toPortablePath(path);
          });
      }
      realpathSync(p) {
          return NodeFS.toPortablePath(this.realFs.realpathSync(NodeFS.fromPortablePath(p), {}));
      }
      async existsPromise(p) {
          return await new Promise(resolve => {
              this.realFs.exists(NodeFS.fromPortablePath(p), resolve);
          });
      }
      accessSync(p, mode) {
          return this.realFs.accessSync(NodeFS.fromPortablePath(p), mode);
      }
      async accessPromise(p, mode) {
          return await new Promise((resolve, reject) => {
              this.realFs.access(NodeFS.fromPortablePath(p), mode, this.makeCallback(resolve, reject));
          });
      }
      existsSync(p) {
          return this.realFs.existsSync(NodeFS.fromPortablePath(p));
      }
      async statPromise(p) {
          return await new Promise((resolve, reject) => {
              this.realFs.stat(NodeFS.fromPortablePath(p), this.makeCallback(resolve, reject));
          });
      }
      statSync(p) {
          return this.realFs.statSync(NodeFS.fromPortablePath(p));
      }
      async lstatPromise(p) {
          return await new Promise((resolve, reject) => {
              this.realFs.lstat(NodeFS.fromPortablePath(p), this.makeCallback(resolve, reject));
          });
      }
      lstatSync(p) {
          return this.realFs.lstatSync(NodeFS.fromPortablePath(p));
      }
      async chmodPromise(p, mask) {
          return await new Promise((resolve, reject) => {
              this.realFs.chmod(NodeFS.fromPortablePath(p), mask, this.makeCallback(resolve, reject));
          });
      }
      chmodSync(p, mask) {
          return this.realFs.chmodSync(NodeFS.fromPortablePath(p), mask);
      }
      async renamePromise(oldP, newP) {
          return await new Promise((resolve, reject) => {
              this.realFs.rename(NodeFS.fromPortablePath(oldP), NodeFS.fromPortablePath(newP), this.makeCallback(resolve, reject));
          });
      }
      renameSync(oldP, newP) {
          return this.realFs.renameSync(NodeFS.fromPortablePath(oldP), NodeFS.fromPortablePath(newP));
      }
      async copyFilePromise(sourceP, destP, flags = 0) {
          return await new Promise((resolve, reject) => {
              this.realFs.copyFile(NodeFS.fromPortablePath(sourceP), NodeFS.fromPortablePath(destP), flags, this.makeCallback(resolve, reject));
          });
      }
      copyFileSync(sourceP, destP, flags = 0) {
          return this.realFs.copyFileSync(NodeFS.fromPortablePath(sourceP), NodeFS.fromPortablePath(destP), flags);
      }
      async appendFilePromise(p, content, opts) {
          return await new Promise((resolve, reject) => {
              const fsNativePath = typeof p === `string` ? NodeFS.fromPortablePath(p) : p;
              if (opts) {
                  this.realFs.appendFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
              }
              else {
                  this.realFs.appendFile(fsNativePath, content, this.makeCallback(resolve, reject));
              }
          });
      }
      appendFileSync(p, content, opts) {
          const fsNativePath = typeof p === `string` ? NodeFS.fromPortablePath(p) : p;
          if (opts) {
              this.realFs.appendFileSync(fsNativePath, content, opts);
          }
          else {
              this.realFs.appendFileSync(fsNativePath, content);
          }
      }
      async writeFilePromise(p, content, opts) {
          return await new Promise((resolve, reject) => {
              const fsNativePath = typeof p === `string` ? NodeFS.fromPortablePath(p) : p;
              if (opts) {
                  this.realFs.writeFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
              }
              else {
                  this.realFs.writeFile(fsNativePath, content, this.makeCallback(resolve, reject));
              }
          });
      }
      writeFileSync(p, content, opts) {
          const fsNativePath = typeof p === `string` ? NodeFS.fromPortablePath(p) : p;
          if (opts) {
              this.realFs.writeFileSync(fsNativePath, content, opts);
          }
          else {
              this.realFs.writeFileSync(fsNativePath, content);
          }
      }
      async unlinkPromise(p) {
          return await new Promise((resolve, reject) => {
              this.realFs.unlink(NodeFS.fromPortablePath(p), this.makeCallback(resolve, reject));
          });
      }
      unlinkSync(p) {
          return this.realFs.unlinkSync(NodeFS.fromPortablePath(p));
      }
      async utimesPromise(p, atime, mtime) {
          return await new Promise((resolve, reject) => {
              this.realFs.utimes(NodeFS.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
          });
      }
      utimesSync(p, atime, mtime) {
          this.realFs.utimesSync(NodeFS.fromPortablePath(p), atime, mtime);
      }
      async mkdirPromise(p) {
          return await new Promise((resolve, reject) => {
              this.realFs.mkdir(NodeFS.fromPortablePath(p), this.makeCallback(resolve, reject));
          });
      }
      mkdirSync(p) {
          return this.realFs.mkdirSync(NodeFS.fromPortablePath(p));
      }
      async rmdirPromise(p) {
          return await new Promise((resolve, reject) => {
              this.realFs.rmdir(NodeFS.fromPortablePath(p), this.makeCallback(resolve, reject));
          });
      }
      rmdirSync(p) {
          return this.realFs.rmdirSync(NodeFS.fromPortablePath(p));
      }
      async symlinkPromise(target, p) {
          const type = target.endsWith(`/`) ? `dir` : `file`;
          return await new Promise((resolve, reject) => {
              this.realFs.symlink(NodeFS.fromPortablePath(target.replace(/\/+$/, ``)), NodeFS.fromPortablePath(p), type, this.makeCallback(resolve, reject));
          });
      }
      symlinkSync(target, p) {
          const type = target.endsWith(`/`) ? `dir` : `file`;
          return this.realFs.symlinkSync(NodeFS.fromPortablePath(target.replace(/\/+$/, ``)), NodeFS.fromPortablePath(p), type);
      }
      async readFilePromise(p, encoding) {
          return await new Promise((resolve, reject) => {
              const fsNativePath = typeof p === `string` ? NodeFS.fromPortablePath(p) : p;
              this.realFs.readFile(fsNativePath, encoding, this.makeCallback(resolve, reject));
          });
      }
      readFileSync(p, encoding) {
          const fsNativePath = typeof p === `string` ? NodeFS.fromPortablePath(p) : p;
          return this.realFs.readFileSync(fsNativePath, encoding);
      }
      async readdirPromise(p) {
          return await new Promise((resolve, reject) => {
              this.realFs.readdir(NodeFS.fromPortablePath(p), this.makeCallback(resolve, reject));
          });
      }
      readdirSync(p) {
          return this.realFs.readdirSync(NodeFS.fromPortablePath(p));
      }
      async readlinkPromise(p) {
          return await new Promise((resolve, reject) => {
              this.realFs.readlink(NodeFS.fromPortablePath(p), this.makeCallback(resolve, reject));
          }).then(path => {
              return NodeFS.toPortablePath(path);
          });
      }
      readlinkSync(p) {
          return NodeFS.toPortablePath(this.realFs.readlinkSync(NodeFS.fromPortablePath(p)));
      }
      watch(p, a, b) {
          return this.realFs.watch(NodeFS.fromPortablePath(p),
          // @ts-ignore
          a, b);
      }
      makeCallback(resolve, reject) {
          return (err, result) => {
              if (err) {
                  reject(err);
              }
              else {
                  resolve(result);
              }
          };
      }
      static fromPortablePath(p) {
          return path_2.fromPortablePath(p);
      }
      static toPortablePath(p) {
          return path_2.toPortablePath(p);
      }
  }
  exports.NodeFS = NodeFS;


  /***/ }),
  /* 12 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const path_1 = __webpack_require__(13);
  const path_2 = __webpack_require__(13);
  class FakeFS {
      constructor(pathUtils) {
          this.pathUtils = pathUtils;
      }
      async removePromise(p) {
          let stat;
          try {
              stat = await this.lstatPromise(p);
          }
          catch (error) {
              if (error.code === `ENOENT`) {
                  return;
              }
              else {
                  throw error;
              }
          }
          if (stat.isDirectory()) {
              for (const entry of await this.readdirPromise(p))
                  await this.removePromise(this.pathUtils.resolve(p, entry));
              // 5 gives 1s worth of retries at worst
              for (let t = 0; t < 5; ++t) {
                  try {
                      await this.rmdirPromise(p);
                      break;
                  }
                  catch (error) {
                      if (error.code === `EBUSY` || error.code === `ENOTEMPTY`) {
                          await new Promise(resolve => setTimeout(resolve, t * 100));
                          continue;
                      }
                      else {
                          throw error;
                      }
                  }
              }
          }
          else {
              await this.unlinkPromise(p);
          }
      }
      removeSync(p) {
          let stat;
          try {
              stat = this.lstatSync(p);
          }
          catch (error) {
              if (error.code === `ENOENT`) {
                  return;
              }
              else {
                  throw error;
              }
          }
          if (stat.isDirectory()) {
              for (const entry of this.readdirSync(p))
                  this.removeSync(this.pathUtils.resolve(p, entry));
              this.rmdirSync(p);
          }
          else {
              this.unlinkSync(p);
          }
      }
      async mkdirpPromise(p, { chmod, utimes } = {}) {
          p = this.resolve(p);
          if (p === this.pathUtils.dirname(p))
              return;
          const parts = p.split(this.pathUtils.sep);
          for (let u = 2; u <= parts.length; ++u) {
              const subPath = parts.slice(0, u).join(this.pathUtils.sep);
              if (!this.existsSync(subPath)) {
                  try {
                      await this.mkdirPromise(subPath);
                  }
                  catch (error) {
                      if (error.code === `EEXIST`) {
                          continue;
                      }
                      else {
                          throw error;
                      }
                  }
                  if (chmod != null)
                      await this.chmodPromise(subPath, chmod);
                  if (utimes != null) {
                      await this.utimesPromise(subPath, utimes[0], utimes[1]);
                  }
              }
          }
      }
      mkdirpSync(p, { chmod, utimes } = {}) {
          p = this.resolve(p);
          if (p === this.pathUtils.dirname(p))
              return;
          const parts = p.split(this.pathUtils.sep);
          for (let u = 2; u <= parts.length; ++u) {
              const subPath = parts.slice(0, u).join(this.pathUtils.sep);
              if (!this.existsSync(subPath)) {
                  try {
                      this.mkdirSync(subPath);
                  }
                  catch (error) {
                      if (error.code === `EEXIST`) {
                          continue;
                      }
                      else {
                          throw error;
                      }
                  }
                  if (chmod != null)
                      this.chmodSync(subPath, chmod);
                  if (utimes != null) {
                      this.utimesSync(subPath, utimes[0], utimes[1]);
                  }
              }
          }
      }
      async copyPromise(destination, source, { baseFs = this, overwrite = true } = {}) {
          const stat = await baseFs.lstatPromise(source);
          const exists = await this.existsSync(destination);
          if (stat.isDirectory()) {
              await this.mkdirpPromise(destination);
              const directoryListing = await baseFs.readdirPromise(source);
              await Promise.all(directoryListing.map(entry => {
                  return this.copyPromise(this.pathUtils.join(destination, entry), baseFs.pathUtils.join(source, entry), { baseFs, overwrite });
              }));
          }
          else if (stat.isFile()) {
              if (!exists || overwrite) {
                  if (exists)
                      await this.removePromise(destination);
                  const content = await baseFs.readFilePromise(source);
                  await this.writeFilePromise(destination, content);
              }
          }
          else if (stat.isSymbolicLink()) {
              if (!exists || overwrite) {
                  if (exists)
                      await this.removePromise(destination);
                  const target = await baseFs.readlinkPromise(source);
                  await this.symlinkPromise(path_2.convertPath(this.pathUtils, target), destination);
              }
          }
          else {
              throw new Error(`Unsupported file type (file: ${source}, mode: 0o${stat.mode.toString(8).padStart(6, `0`)})`);
          }
          const mode = stat.mode & 0o777;
          await this.chmodPromise(destination, mode);
      }
      copySync(destination, source, { baseFs = this, overwrite = true } = {}) {
          const stat = baseFs.lstatSync(source);
          const exists = this.existsSync(destination);
          if (stat.isDirectory()) {
              this.mkdirpSync(destination);
              const directoryListing = baseFs.readdirSync(source);
              for (const entry of directoryListing) {
                  this.copySync(this.pathUtils.join(destination, entry), baseFs.pathUtils.join(source, entry), { baseFs, overwrite });
              }
          }
          else if (stat.isFile()) {
              if (!exists || overwrite) {
                  if (exists)
                      this.removeSync(destination);
                  const content = baseFs.readFileSync(source);
                  this.writeFileSync(destination, content);
              }
          }
          else if (stat.isSymbolicLink()) {
              if (!exists || overwrite) {
                  if (exists)
                      this.removeSync(destination);
                  const target = baseFs.readlinkSync(source);
                  this.symlinkSync(path_2.convertPath(this.pathUtils, target), destination);
              }
          }
          else {
              throw new Error(`Unsupported file type (file: ${source}, mode: 0o${stat.mode.toString(8).padStart(6, `0`)})`);
          }
          const mode = stat.mode & 0o777;
          this.chmodSync(destination, mode);
      }
      async changeFilePromise(p, content) {
          try {
              const current = await this.readFilePromise(p, `utf8`);
              if (current === content) {
                  return;
              }
          }
          catch (error) {
              // ignore errors, no big deal
          }
          await this.writeFilePromise(p, content);
      }
      changeFileSync(p, content) {
          try {
              const current = this.readFileSync(p, `utf8`);
              if (current === content) {
                  return;
              }
          }
          catch (error) {
              // ignore errors, no big deal
          }
          this.writeFileSync(p, content);
      }
      async movePromise(fromP, toP) {
          try {
              await this.renamePromise(fromP, toP);
          }
          catch (error) {
              if (error.code === `EXDEV`) {
                  await this.copyPromise(toP, fromP);
                  await this.removePromise(fromP);
              }
              else {
                  throw error;
              }
          }
      }
      moveSync(fromP, toP) {
          try {
              this.renameSync(fromP, toP);
          }
          catch (error) {
              if (error.code === `EXDEV`) {
                  this.copySync(toP, fromP);
                  this.removeSync(fromP);
              }
              else {
                  throw error;
              }
          }
      }
      async lockPromise(affectedPath, callback) {
          const lockPath = `${affectedPath}.lock`;
          const interval = 1000 / 60;
          const timeout = Date.now() + 60 * 1000;
          let fd = null;
          while (fd === null) {
              try {
                  fd = await this.openPromise(lockPath, `wx`);
              }
              catch (error) {
                  if (error.code === `EEXIST`) {
                      if (Date.now() < timeout) {
                          await new Promise(resolve => setTimeout(resolve, interval));
                      }
                      else {
                          throw new Error(`Couldn't acquire a lock in a reasonable time (via ${lockPath})`);
                      }
                  }
                  else {
                      throw error;
                  }
              }
          }
          try {
              return await callback();
          }
          finally {
              await this.closePromise(fd);
              await this.unlinkPromise(lockPath);
          }
      }
      async readJsonPromise(p) {
          const content = await this.readFilePromise(p, `utf8`);
          try {
              return JSON.parse(content);
          }
          catch (error) {
              error.message += ` (in ${p})`;
              throw error;
          }
      }
      async readJsonSync(p) {
          const content = this.readFileSync(p, `utf8`);
          try {
              return JSON.parse(content);
          }
          catch (error) {
              error.message += ` (in ${p})`;
              throw error;
          }
      }
      async writeJsonPromise(p, data) {
          return await this.writeFilePromise(p, `${JSON.stringify(data, null, 2)}\n`);
      }
      writeJsonSync(p, data) {
          return this.writeFileSync(p, `${JSON.stringify(data, null, 2)}\n`);
      }
  }
  exports.FakeFS = FakeFS;
  ;
  class BasePortableFakeFS extends FakeFS {
      constructor() {
          super(path_2.ppath);
      }
      resolve(p) {
          return this.pathUtils.resolve(path_1.PortablePath.root, p);
      }
  }
  exports.BasePortableFakeFS = BasePortableFakeFS;


  /***/ }),
  /* 13 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importDefault = (this && this.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const path_1 = __importDefault(__webpack_require__(8));
  exports.PortablePath = {
      root: `/`,
      dot: `.`,
  };
  exports.npath = path_1.default;
  exports.ppath = path_1.default.posix;
  const WINDOWS_PATH_REGEXP = /^[a-zA-Z]:.*$/;
  const PORTABLE_PATH_REGEXP = /^\/[a-zA-Z]:.*$/;
  // Path should look like "/N:/berry/scripts/plugin-pack.js"
  // And transform to "N:\berry\scripts\plugin-pack.js"
  function fromPortablePath(p) {
      if (process.platform !== 'win32')
          return p;
      return p.match(PORTABLE_PATH_REGEXP) ? p.substring(1).replace(/\//g, `\\`) : p;
  }
  exports.fromPortablePath = fromPortablePath;
  // Path should look like "N:/berry/scripts/plugin-pack.js"
  // And transform to "/N:/berry/scripts/plugin-pack.js"
  function toPortablePath(p) {
      if (process.platform !== 'win32')
          return p;
      return (p.match(WINDOWS_PATH_REGEXP) ? `/${p}` : p).replace(/\\/g, `/`);
  }
  exports.toPortablePath = toPortablePath;
  function convertPath(targetPathUtils, sourcePath) {
      return (targetPathUtils === exports.npath ? fromPortablePath(sourcePath) : toPortablePath(sourcePath));
  }
  exports.convertPath = convertPath;
  function toFilename(filename) {
      if (exports.npath.parse(filename).dir !== '' || exports.ppath.parse(filename).dir !== '')
          throw new Error(`Invalid filename: "${filename}"`);
      return filename;
  }
  exports.toFilename = toFilename;


  /***/ }),
  /* 14 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const ProxiedFS_1 = __webpack_require__(15);
  class AliasFS extends ProxiedFS_1.ProxiedFS {
      constructor(target, { baseFs, pathUtils }) {
          super(pathUtils);
          this.target = target;
          this.baseFs = baseFs;
      }
      getRealPath() {
          return this.target;
      }
      getBaseFs() {
          return this.baseFs;
      }
      mapFromBase(p) {
          return p;
      }
      mapToBase(p) {
          return p;
      }
  }
  exports.AliasFS = AliasFS;


  /***/ }),
  /* 15 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const FakeFS_1 = __webpack_require__(12);
  class ProxiedFS extends FakeFS_1.FakeFS {
      resolve(path) {
          return this.mapFromBase(this.baseFs.resolve(this.mapToBase(path)));
      }
      getRealPath() {
          return this.mapFromBase(this.baseFs.getRealPath());
      }
      openPromise(p, flags, mode) {
          return this.baseFs.openPromise(this.mapToBase(p), flags, mode);
      }
      openSync(p, flags, mode) {
          return this.baseFs.openSync(this.mapToBase(p), flags, mode);
      }
      async readPromise(fd, buffer, offset, length, position) {
          return await this.baseFs.readPromise(fd, buffer, offset, length, position);
      }
      readSync(fd, buffer, offset, length, position) {
          return this.baseFs.readSync(fd, buffer, offset, length, position);
      }
      async writePromise(fd, buffer, offset, length, position) {
          if (typeof buffer === `string`) {
              return await this.baseFs.writePromise(fd, buffer, offset);
          }
          else {
              return await this.baseFs.writePromise(fd, buffer, offset, length, position);
          }
      }
      writeSync(fd, buffer, offset, length, position) {
          if (typeof buffer === `string`) {
              return this.baseFs.writeSync(fd, buffer, offset);
          }
          else {
              return this.baseFs.writeSync(fd, buffer, offset, length, position);
          }
      }
      closePromise(fd) {
          return this.baseFs.closePromise(fd);
      }
      closeSync(fd) {
          this.baseFs.closeSync(fd);
      }
      createReadStream(p, opts) {
          return this.baseFs.createReadStream(p !== null ? this.mapToBase(p) : p, opts);
      }
      createWriteStream(p, opts) {
          return this.baseFs.createWriteStream(p !== null ? this.mapToBase(p) : p, opts);
      }
      async realpathPromise(p) {
          return this.mapFromBase(await this.baseFs.realpathPromise(this.mapToBase(p)));
      }
      realpathSync(p) {
          return this.mapFromBase(this.baseFs.realpathSync(this.mapToBase(p)));
      }
      existsPromise(p) {
          return this.baseFs.existsPromise(this.mapToBase(p));
      }
      existsSync(p) {
          return this.baseFs.existsSync(this.mapToBase(p));
      }
      accessSync(p, mode) {
          return this.baseFs.accessSync(this.mapToBase(p), mode);
      }
      accessPromise(p, mode) {
          return this.baseFs.accessPromise(this.mapToBase(p), mode);
      }
      statPromise(p) {
          return this.baseFs.statPromise(this.mapToBase(p));
      }
      statSync(p) {
          return this.baseFs.statSync(this.mapToBase(p));
      }
      lstatPromise(p) {
          return this.baseFs.lstatPromise(this.mapToBase(p));
      }
      lstatSync(p) {
          return this.baseFs.lstatSync(this.mapToBase(p));
      }
      chmodPromise(p, mask) {
          return this.baseFs.chmodPromise(this.mapToBase(p), mask);
      }
      chmodSync(p, mask) {
          return this.baseFs.chmodSync(this.mapToBase(p), mask);
      }
      renamePromise(oldP, newP) {
          return this.baseFs.renamePromise(this.mapToBase(oldP), this.mapToBase(newP));
      }
      renameSync(oldP, newP) {
          return this.baseFs.renameSync(this.mapToBase(oldP), this.mapToBase(newP));
      }
      copyFilePromise(sourceP, destP, flags = 0) {
          return this.baseFs.copyFilePromise(this.mapToBase(sourceP), this.mapToBase(destP), flags);
      }
      copyFileSync(sourceP, destP, flags = 0) {
          return this.baseFs.copyFileSync(this.mapToBase(sourceP), this.mapToBase(destP), flags);
      }
      appendFilePromise(p, content, opts) {
          return this.baseFs.appendFilePromise(this.fsMapToBase(p), content, opts);
      }
      appendFileSync(p, content, opts) {
          return this.baseFs.appendFileSync(this.fsMapToBase(p), content, opts);
      }
      writeFilePromise(p, content, opts) {
          return this.baseFs.writeFilePromise(this.fsMapToBase(p), content, opts);
      }
      writeFileSync(p, content, opts) {
          return this.baseFs.writeFileSync(this.fsMapToBase(p), content, opts);
      }
      unlinkPromise(p) {
          return this.baseFs.unlinkPromise(this.mapToBase(p));
      }
      unlinkSync(p) {
          return this.baseFs.unlinkSync(this.mapToBase(p));
      }
      utimesPromise(p, atime, mtime) {
          return this.baseFs.utimesPromise(this.mapToBase(p), atime, mtime);
      }
      utimesSync(p, atime, mtime) {
          return this.baseFs.utimesSync(this.mapToBase(p), atime, mtime);
      }
      mkdirPromise(p) {
          return this.baseFs.mkdirPromise(this.mapToBase(p));
      }
      mkdirSync(p) {
          return this.baseFs.mkdirSync(this.mapToBase(p));
      }
      rmdirPromise(p) {
          return this.baseFs.rmdirPromise(this.mapToBase(p));
      }
      rmdirSync(p) {
          return this.baseFs.rmdirSync(this.mapToBase(p));
      }
      symlinkPromise(target, p) {
          return this.baseFs.symlinkPromise(this.mapToBase(target), this.mapToBase(p));
      }
      symlinkSync(target, p) {
          return this.baseFs.symlinkSync(this.mapToBase(target), this.mapToBase(p));
      }
      readFilePromise(p, encoding) {
          // This weird condition is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
          if (encoding === 'utf8') {
              return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
          }
          else {
              return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
          }
      }
      readFileSync(p, encoding) {
          // This weird condition is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
          if (encoding === 'utf8') {
              return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
          }
          else {
              return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
          }
      }
      readdirPromise(p) {
          return this.baseFs.readdirPromise(this.mapToBase(p));
      }
      readdirSync(p) {
          return this.baseFs.readdirSync(this.mapToBase(p));
      }
      async readlinkPromise(p) {
          return this.mapFromBase(await this.baseFs.readlinkPromise(this.mapToBase(p)));
      }
      readlinkSync(p) {
          return this.mapFromBase(this.baseFs.readlinkSync(this.mapToBase(p)));
      }
      watch(p, a, b) {
          return this.baseFs.watch(this.mapToBase(p),
          // @ts-ignore
          a, b);
      }
      fsMapToBase(p) {
          if (typeof p === `number`) {
              return p;
          }
          else {
              return this.mapToBase(p);
          }
      }
  }
  exports.ProxiedFS = ProxiedFS;


  /***/ }),
  /* 16 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const NodeFS_1 = __webpack_require__(11);
  const ProxiedFS_1 = __webpack_require__(15);
  const path_1 = __webpack_require__(13);
  class CwdFS extends ProxiedFS_1.ProxiedFS {
      constructor(target, { baseFs = new NodeFS_1.NodeFS() } = {}) {
          super(path_1.ppath);
          this.target = target;
          this.baseFs = baseFs;
      }
      getRealPath() {
          return this.pathUtils.resolve(this.baseFs.getRealPath(), this.target);
      }
      mapFromBase(path) {
          return this.pathUtils.relative(this.getRealPath(), path);
      }
      mapToBase(path) {
          return this.pathUtils.resolve(this.getRealPath(), path);
      }
  }
  exports.CwdFS = CwdFS;


  /***/ }),
  /* 17 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const NodeFS_1 = __webpack_require__(11);
  const ProxiedFS_1 = __webpack_require__(15);
  const path_1 = __webpack_require__(13);
  const JAIL_ROOT = path_1.PortablePath.root;
  class JailFS extends ProxiedFS_1.ProxiedFS {
      constructor(target, { baseFs = new NodeFS_1.NodeFS() } = {}) {
          super(path_1.ppath);
          this.target = this.pathUtils.resolve(path_1.PortablePath.root, target);
          this.baseFs = baseFs;
      }
      getRealPath() {
          return this.pathUtils.resolve(this.baseFs.getRealPath(), this.pathUtils.relative(path_1.PortablePath.root, this.target));
      }
      getTarget() {
          return this.target;
      }
      getBaseFs() {
          return this.baseFs;
      }
      mapToBase(p) {
          const normalized = this.pathUtils.normalize(p);
          if (this.pathUtils.isAbsolute(p))
              return this.pathUtils.resolve(this.target, this.pathUtils.relative(JAIL_ROOT, p));
          if (normalized.match(/^\.\.\//))
              throw new Error(`Resolving this path (${p}) would escape the jail`);
          return this.pathUtils.resolve(this.target, p);
      }
      mapFromBase(p) {
          return this.pathUtils.resolve(JAIL_ROOT, this.pathUtils.relative(this.target, p));
      }
  }
  exports.JailFS = JailFS;


  /***/ }),
  /* 18 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const ProxiedFS_1 = __webpack_require__(15);
  class LazyFS extends ProxiedFS_1.ProxiedFS {
      constructor(factory, pathUtils) {
          super(pathUtils);
          this.instance = null;
          this.factory = factory;
      }
      get baseFs() {
          if (!this.instance)
              this.instance = this.factory();
          return this.instance;
      }
      mapFromBase(p) {
          return p;
      }
      mapToBase(p) {
          return p;
      }
  }
  exports.LazyFS = LazyFS;


  /***/ }),
  /* 19 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const NodeFS_1 = __webpack_require__(11);
  const ProxiedFS_1 = __webpack_require__(15);
  const path_1 = __webpack_require__(13);
  class PosixFS extends ProxiedFS_1.ProxiedFS {
      constructor(baseFs) {
          super(path_1.npath);
          this.baseFs = baseFs;
      }
      mapFromBase(path) {
          return NodeFS_1.NodeFS.fromPortablePath(path);
      }
      mapToBase(path) {
          return NodeFS_1.NodeFS.toPortablePath(path);
      }
  }
  exports.PosixFS = PosixFS;


  /***/ }),
  /* 20 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const NodeFS_1 = __webpack_require__(11);
  const ProxiedFS_1 = __webpack_require__(15);
  const path_1 = __webpack_require__(13);
  // https://github.com/benjamingr/RegExp.escape/blob/master/polyfill.js
  const escapeRegexp = (s) => s.replace(/[\\^$*+?.()|[\]{}]/g, '\\$&');
  class VirtualFS extends ProxiedFS_1.ProxiedFS {
      static makeVirtualPath(base, component, to) {
          // Obtains the relative distance between the virtual path and its actual target
          const target = path_1.ppath.relative(path_1.ppath.dirname(base), to);
          const segments = target.split(`/`);
          // Counts how many levels we need to go back to start applying the rest of the path
          let depth = 0;
          while (depth < segments.length && segments[depth] === `..`)
              depth += 1;
          const finalSegments = segments.slice(depth);
          const fullVirtualPath = path_1.ppath.join(base, component, String(depth), ...finalSegments);
          return fullVirtualPath;
      }
      constructor(virtual, { baseFs = new NodeFS_1.NodeFS() } = {}) {
          super(path_1.ppath);
          this.baseFs = baseFs;
          this.target = path_1.ppath.dirname(virtual);
          this.virtual = virtual;
          this.mapToBaseRegExp = new RegExp(`^(${escapeRegexp(this.virtual)})((?:/([^\/]+)(?:/([^/]+))?)?((?:/.*)?))$`);
      }
      getRealPath() {
          return this.pathUtils.resolve(this.baseFs.getRealPath(), this.target);
      }
      realpathSync(p) {
          const match = p.match(this.mapToBaseRegExp);
          if (!match)
              return this.baseFs.realpathSync(p);
          if (!match[5])
              return p;
          const realpath = this.baseFs.realpathSync(this.mapToBase(p));
          return VirtualFS.makeVirtualPath(this.virtual, match[3], realpath);
      }
      async realpathPromise(p) {
          const match = p.match(this.mapToBaseRegExp);
          if (!match)
              return await this.baseFs.realpathPromise(p);
          if (!match[5])
              return p;
          const realpath = await this.baseFs.realpathPromise(this.mapToBase(p));
          return VirtualFS.makeVirtualPath(this.virtual, match[3], realpath);
      }
      mapToBase(p) {
          const match = p.match(this.mapToBaseRegExp);
          if (!match)
              return p;
          if (match[3])
              return this.mapToBase(path_1.ppath.join(this.target, `../`.repeat(Number(match[4])), match[5]));
          return this.target;
      }
      mapFromBase(p) {
          return p;
      }
  }
  exports.VirtualFS = VirtualFS;


  /***/ }),
  /* 21 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importDefault = (this && this.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const libzip_1 = __importDefault(__webpack_require__(22));
  const fs_1 = __webpack_require__(7);
  const stream_1 = __webpack_require__(24);
  const util_1 = __webpack_require__(25);
  const FakeFS_1 = __webpack_require__(12);
  const NodeFS_1 = __webpack_require__(11);
  const path_1 = __webpack_require__(13);
  const S_IFMT = 0o170000;
  const S_IFDIR = 0o040000;
  const S_IFREG = 0o100000;
  const S_IFLNK = 0o120000;
  class StatEntry {
      constructor() {
          this.dev = 0;
          this.ino = 0;
          this.mode = 0;
          this.nlink = 1;
          this.rdev = 0;
          this.blocks = 1;
      }
      isBlockDevice() {
          return false;
      }
      isCharacterDevice() {
          return false;
      }
      isDirectory() {
          return (this.mode & S_IFMT) === S_IFDIR;
      }
      isFIFO() {
          return false;
      }
      isFile() {
          return (this.mode & S_IFMT) === S_IFREG;
      }
      isSocket() {
          return false;
      }
      isSymbolicLink() {
          return (this.mode & S_IFMT) === S_IFLNK;
      }
  }
  function makeDefaultStats() {
      return Object.assign(new StatEntry(), {
          uid: 0,
          gid: 0,
          size: 0,
          blksize: 0,
          atimeMs: 0,
          mtimeMs: 0,
          ctimeMs: 0,
          birthtimeMs: 0,
          atime: new Date(0),
          mtime: new Date(0),
          ctime: new Date(0),
          birthtime: new Date(0),
          mode: S_IFREG | 0o644,
      });
  }
  function toUnixTimestamp(time) {
      if (typeof time === 'string' && String(+time) === time)
          return +time;
      // @ts-ignore
      if (Number.isFinite(time)) {
          if (time < 0) {
              return Date.now() / 1000;
          }
          else {
              return time;
          }
      }
      // convert to 123.456 UNIX timestamp
      if (util_1.isDate(time))
          return time.getTime() / 1000;
      throw new Error(`Invalid time`);
  }
  class ZipFS extends FakeFS_1.BasePortableFakeFS {
      constructor(source, opts) {
          super();
          this.listings = new Map();
          this.entries = new Map();
          this.fds = new Map();
          this.nextFd = 0;
          this.ready = false;
          const pathOptions = opts;
          if (typeof source === `string`) {
              const { baseFs = new NodeFS_1.NodeFS() } = pathOptions;
              this.baseFs = baseFs;
              this.path = source;
          }
          else {
              this.path = null;
              this.baseFs = null;
          }
          if (opts.stats) {
              this.stats = opts.stats;
          }
          else {
              if (typeof source === `string`) {
                  try {
                      this.stats = this.baseFs.statSync(source);
                  }
                  catch (error) {
                      if (error.code === `ENOENT` && pathOptions.create) {
                          this.stats = makeDefaultStats();
                      }
                      else {
                          throw error;
                      }
                  }
              }
              else {
                  this.stats = makeDefaultStats();
              }
          }
          const errPtr = libzip_1.default.malloc(4);
          try {
              let flags = 0;
              if (typeof source === `string` && pathOptions.create)
                  flags |= libzip_1.default.ZIP_CREATE | libzip_1.default.ZIP_TRUNCATE;
              if (opts.readOnly)
                  flags |= libzip_1.default.ZIP_RDONLY;
              if (typeof source === `string`) {
                  this.zip = libzip_1.default.open(NodeFS_1.NodeFS.fromPortablePath(source), flags, errPtr);
              }
              else {
                  const lzSource = this.allocateUnattachedSource(source);
                  try {
                      this.zip = libzip_1.default.openFromSource(lzSource, flags, errPtr);
                  }
                  catch (error) {
                      libzip_1.default.source.free(lzSource);
                      throw error;
                  }
              }
              if (this.zip === 0) {
                  const error = libzip_1.default.struct.errorS();
                  libzip_1.default.error.initWithCode(error, libzip_1.default.getValue(errPtr, `i32`));
                  throw new Error(libzip_1.default.error.strerror(error));
              }
          }
          finally {
              libzip_1.default.free(errPtr);
          }
          this.listings.set(path_1.PortablePath.root, new Set());
          const entryCount = libzip_1.default.getNumEntries(this.zip, 0);
          for (let t = 0; t < entryCount; ++t) {
              const raw = libzip_1.default.getName(this.zip, t, 0);
              if (path_1.ppath.isAbsolute(raw))
                  continue;
              const p = path_1.ppath.resolve(path_1.PortablePath.root, raw);
              this.registerEntry(p, t);
              // If the raw path is a directory, register it
              // to prevent empty folder being skipped
              if (raw.endsWith('/')) {
                  this.registerListing(p);
              }
          }
          this.ready = true;
      }
      getAllFiles() {
          return Array.from(this.entries.keys());
      }
      getRealPath() {
          if (!this.path)
              throw new Error(`ZipFS don't have real paths when loaded from a buffer`);
          return this.path;
      }
      saveAndClose() {
          if (!this.path || !this.baseFs)
              throw new Error(`ZipFS cannot be saved and must be discarded when loaded from a buffer`);
          if (!this.ready)
              throw Object.assign(new Error(`EBUSY: archive closed, close`), { code: `EBUSY` });
          const previousMod = this.baseFs.existsSync(this.path)
              ? this.baseFs.statSync(this.path).mode & 0o777
              : null;
          const rc = libzip_1.default.close(this.zip);
          if (rc === -1)
              throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
          // Libzip overrides the chmod when writing the archive, which is a weird
          // behavior I don't totally understand (plus the umask seems bogus in some
          // weird cases - maybe related to emscripten?)
          //
          // See also https://github.com/nih-at/libzip/issues/77
          if (previousMod !== null && previousMod !== (this.baseFs.statSync(this.path).mode & 0o777))
              this.baseFs.chmodSync(this.path, previousMod);
          this.ready = false;
      }
      discardAndClose() {
          libzip_1.default.discard(this.zip);
          this.ready = false;
      }
      async openPromise(p, flags, mode) {
          return this.openSync(p, flags, mode);
      }
      openSync(p, flags, mode) {
          const fd = this.nextFd++;
          this.fds.set(fd, { cursor: 0, p });
          return fd;
      }
      async readPromise(fd, buffer, offset, length, position) {
          return this.readSync(fd, buffer, offset, length, position);
      }
      readSync(fd, buffer, offset = 0, length = 0, position = -1) {
          const entry = this.fds.get(fd);
          if (typeof entry === `undefined`)
              throw Object.assign(new Error(`EBADF: bad file descriptor, read`), { code: `EBADF` });
          let realPosition;
          if (position === -1 || position === null)
              realPosition = entry.cursor;
          else
              realPosition = position;
          const source = this.readFileSync(entry.p);
          source.copy(buffer, offset, realPosition, realPosition + length);
          const bytesRead = Math.max(0, Math.min(source.length - realPosition, length));
          if (position === -1)
              entry.cursor += bytesRead;
          return bytesRead;
      }
      async writePromise(fd, buffer, offset, length, position) {
          if (typeof buffer === `string`) {
              return this.writeSync(fd, buffer, position);
          }
          else {
              return this.writeSync(fd, buffer, offset, length, position);
          }
      }
      writeSync(fd, buffer, offset, length, position) {
          const entry = this.fds.get(fd);
          if (typeof entry === `undefined`)
              throw Object.assign(new Error(`EBADF: bad file descriptor, read`), { code: `EBADF` });
          throw new Error(`Unimplemented`);
      }
      async closePromise(fd) {
          return this.closeSync(fd);
      }
      closeSync(fd) {
          const entry = this.fds.get(fd);
          if (typeof entry === `undefined`)
              throw Object.assign(new Error(`EBADF: bad file descriptor, read`), { code: `EBADF` });
          this.fds.delete(fd);
      }
      createReadStream(p, { encoding } = {}) {
          if (p === null)
              throw new Error(`Unimplemented`);
          const stream = Object.assign(new stream_1.PassThrough(), {
              bytesRead: 0,
              path: p,
              close: () => {
                  clearImmediate(immediate);
              },
          });
          const immediate = setImmediate(() => {
              try {
                  const data = this.readFileSync(p, encoding);
                  stream.bytesRead = data.length;
                  stream.write(data);
                  stream.end();
              }
              catch (error) {
                  stream.emit(`error`, error);
                  stream.end();
              }
          });
          return stream;
      }
      createWriteStream(p, { encoding } = {}) {
          if (p === null)
              throw new Error(`Unimplemented`);
          const stream = Object.assign(new stream_1.PassThrough(), {
              bytesWritten: 0,
              path: p,
              close: () => {
                  stream.end();
              },
          });
          const chunks = [];
          stream.on(`data`, chunk => {
              const chunkBuffer = Buffer.from(chunk);
              stream.bytesWritten += chunkBuffer.length;
              chunks.push(chunkBuffer);
          });
          stream.on(`end`, () => {
              this.writeFileSync(p, Buffer.concat(chunks), encoding);
          });
          return stream;
      }
      async realpathPromise(p) {
          return this.realpathSync(p);
      }
      realpathSync(p) {
          const resolvedP = this.resolveFilename(`lstat '${p}'`, p);
          if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
              throw Object.assign(new Error(`ENOENT: no such file or directory, lstat '${p}'`), { code: `ENOENT` });
          return resolvedP;
      }
      async existsPromise(p) {
          return this.existsSync(p);
      }
      existsSync(p) {
          let resolvedP;
          try {
              resolvedP = this.resolveFilename(`stat '${p}'`, p);
          }
          catch (error) {
              return false;
          }
          return this.entries.has(resolvedP) || this.listings.has(resolvedP);
      }
      async accessPromise(p, mode) {
          return this.accessSync(p, mode);
      }
      accessSync(p, mode) {
          const resolvedP = this.resolveFilename(`access '${p}'`, p);
          if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) {
              throw Object.assign(new Error(`ENOENT: no such file or directory, access '${p}'`), { code: `ENOENT` });
          }
      }
      async statPromise(p) {
          return this.statSync(p);
      }
      statSync(p) {
          const resolvedP = this.resolveFilename(`stat '${p}'`, p);
          if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
              throw Object.assign(new Error(`ENOENT: no such file or directory, stat '${p}'`), { code: `ENOENT` });
          if (p[p.length - 1] === `/` && !this.listings.has(resolvedP))
              throw Object.assign(new Error(`ENOTDIR: not a directory, stat '${p}'`), { code: `ENOTDIR` });
          return this.statImpl(`stat '${p}'`, resolvedP);
      }
      async lstatPromise(p) {
          return this.lstatSync(p);
      }
      lstatSync(p) {
          const resolvedP = this.resolveFilename(`lstat '${p}'`, p, false);
          if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
              throw Object.assign(new Error(`ENOENT: no such file or directory, lstat '${p}'`), { code: `ENOENT` });
          if (p[p.length - 1] === `/` && !this.listings.has(resolvedP))
              throw Object.assign(new Error(`ENOTDIR: not a directory, lstat '${p}'`), { code: `ENOTDIR` });
          return this.statImpl(`lstat '${p}'`, resolvedP);
      }
      statImpl(reason, p) {
          if (this.listings.has(p)) {
              const uid = this.stats.uid;
              const gid = this.stats.gid;
              const size = 0;
              const blksize = 512;
              const blocks = 0;
              const atimeMs = this.stats.mtimeMs;
              const birthtimeMs = this.stats.mtimeMs;
              const ctimeMs = this.stats.mtimeMs;
              const mtimeMs = this.stats.mtimeMs;
              const atime = new Date(atimeMs);
              const birthtime = new Date(birthtimeMs);
              const ctime = new Date(ctimeMs);
              const mtime = new Date(mtimeMs);
              const mode = S_IFDIR | 0o755;
              return Object.assign(new StatEntry(), { uid, gid, size, blksize, blocks, atime, birthtime, ctime, mtime, atimeMs, birthtimeMs, ctimeMs, mtimeMs, mode });
          }
          const entry = this.entries.get(p);
          if (entry !== undefined) {
              const stat = libzip_1.default.struct.statS();
              const rc = libzip_1.default.statIndex(this.zip, entry, 0, 0, stat);
              if (rc === -1)
                  throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
              const uid = this.stats.uid;
              const gid = this.stats.gid;
              const size = (libzip_1.default.struct.statSize(stat) >>> 0);
              const blksize = 512;
              const blocks = Math.ceil(size / blksize);
              const mtimeMs = (libzip_1.default.struct.statMtime(stat) >>> 0) * 1000;
              const atimeMs = mtimeMs;
              const birthtimeMs = mtimeMs;
              const ctimeMs = mtimeMs;
              const atime = new Date(atimeMs);
              const birthtime = new Date(birthtimeMs);
              const ctime = new Date(ctimeMs);
              const mtime = new Date(mtimeMs);
              const mode = this.getUnixMode(entry, S_IFREG | 0o644);
              return Object.assign(new StatEntry(), { uid, gid, size, blksize, blocks, atime, birthtime, ctime, mtime, atimeMs, birthtimeMs, ctimeMs, mtimeMs, mode });
          }
          throw new Error(`Unreachable`);
      }
      getUnixMode(index, defaultMode) {
          const rc = libzip_1.default.file.getExternalAttributes(this.zip, index, 0, 0, libzip_1.default.uint08S, libzip_1.default.uint32S);
          if (rc === -1)
              throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
          const opsys = libzip_1.default.getValue(libzip_1.default.uint08S, `i8`) >>> 0;
          if (opsys !== libzip_1.default.ZIP_OPSYS_UNIX)
              return defaultMode;
          return libzip_1.default.getValue(libzip_1.default.uint32S, `i32`) >>> 16;
      }
      registerListing(p) {
          let listing = this.listings.get(p);
          if (listing)
              return listing;
          const parentListing = this.registerListing(path_1.ppath.dirname(p));
          listing = new Set();
          parentListing.add(path_1.ppath.basename(p));
          this.listings.set(p, listing);
          return listing;
      }
      registerEntry(p, index) {
          const parentListing = this.registerListing(path_1.ppath.dirname(p));
          parentListing.add(path_1.ppath.basename(p));
          this.entries.set(p, index);
      }
      resolveFilename(reason, p, resolveLastComponent = true) {
          if (!this.ready)
              throw Object.assign(new Error(`EBUSY: archive closed, ${reason}`), { code: `EBUSY` });
          let resolvedP = path_1.ppath.resolve(path_1.PortablePath.root, p);
          if (resolvedP === `/`)
              return path_1.PortablePath.root;
          while (true) {
              const parentP = this.resolveFilename(reason, path_1.ppath.dirname(resolvedP), true);
              const isDir = this.listings.has(parentP);
              const doesExist = this.entries.has(parentP);
              if (!isDir && !doesExist)
                  throw Object.assign(new Error(`ENOENT: no such file or directory, ${reason}`), { code: `ENOENT` });
              if (!isDir)
                  throw Object.assign(new Error(`ENOTDIR: not a directory, ${reason}`), { code: `ENOTDIR` });
              resolvedP = path_1.ppath.resolve(parentP, path_1.ppath.basename(resolvedP));
              if (!resolveLastComponent)
                  break;
              const index = libzip_1.default.name.locate(this.zip, resolvedP);
              if (index === -1)
                  break;
              if (this.isSymbolicLink(index)) {
                  const target = this.getFileSource(index).toString();
                  resolvedP = path_1.ppath.resolve(path_1.ppath.dirname(resolvedP), target);
              }
              else {
                  break;
              }
          }
          return resolvedP;
      }
      allocateBuffer(content) {
          if (!Buffer.isBuffer(content))
              content = Buffer.from(content);
          const buffer = libzip_1.default.malloc(content.byteLength);
          if (!buffer)
              throw new Error(`Couldn't allocate enough memory`);
          // Copy the file into the Emscripten heap
          const heap = new Uint8Array(libzip_1.default.HEAPU8.buffer, buffer, content.byteLength);
          heap.set(content);
          return { buffer, byteLength: content.byteLength };
      }
      allocateUnattachedSource(content) {
          const error = libzip_1.default.struct.errorS();
          const { buffer, byteLength } = this.allocateBuffer(content);
          const source = libzip_1.default.source.fromUnattachedBuffer(buffer, byteLength, 0, true, error);
          if (source === 0) {
              libzip_1.default.free(error);
              throw new Error(libzip_1.default.error.strerror(error));
          }
          return source;
      }
      allocateSource(content) {
          const { buffer, byteLength } = this.allocateBuffer(content);
          const source = libzip_1.default.source.fromBuffer(this.zip, buffer, byteLength, 0, true);
          if (source === 0) {
              libzip_1.default.free(buffer);
              throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
          }
          return source;
      }
      setFileSource(p, content) {
          const target = path_1.ppath.relative(path_1.PortablePath.root, p);
          const lzSource = this.allocateSource(content);
          try {
              return libzip_1.default.file.add(this.zip, target, lzSource, libzip_1.default.ZIP_FL_OVERWRITE);
          }
          catch (error) {
              libzip_1.default.source.free(lzSource);
              throw error;
          }
      }
      isSymbolicLink(index) {
          const attrs = libzip_1.default.file.getExternalAttributes(this.zip, index, 0, 0, libzip_1.default.uint08S, libzip_1.default.uint32S);
          if (attrs === -1)
              throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
          const opsys = libzip_1.default.getValue(libzip_1.default.uint08S, `i8`) >>> 0;
          if (opsys !== libzip_1.default.ZIP_OPSYS_UNIX)
              return false;
          const attributes = libzip_1.default.getValue(libzip_1.default.uint32S, `i32`) >>> 16;
          return (attributes & S_IFMT) === S_IFLNK;
      }
      getFileSource(index) {
          const stat = libzip_1.default.struct.statS();
          const rc = libzip_1.default.statIndex(this.zip, index, 0, 0, stat);
          if (rc === -1)
              throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
          const size = libzip_1.default.struct.statSize(stat);
          const buffer = libzip_1.default.malloc(size);
          try {
              const file = libzip_1.default.fopenIndex(this.zip, index, 0, 0);
              if (file === 0)
                  throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
              try {
                  const rc = libzip_1.default.fread(file, buffer, size, 0);
                  if (rc === -1)
                      throw new Error(libzip_1.default.error.strerror(libzip_1.default.file.getError(file)));
                  else if (rc < size)
                      throw new Error(`Incomplete read`);
                  else if (rc > size)
                      throw new Error(`Overread`);
                  const memory = libzip_1.default.HEAPU8.subarray(buffer, buffer + size);
                  const data = Buffer.from(memory);
                  return data;
              }
              finally {
                  libzip_1.default.fclose(file);
              }
          }
          finally {
              libzip_1.default.free(buffer);
          }
      }
      async chmodPromise(p, mask) {
          return this.chmodSync(p, mask);
      }
      chmodSync(p, mask) {
          const resolvedP = this.resolveFilename(`chmod '${p}'`, p, false);
          // We silently ignore chmod requests for directories
          if (this.listings.has(resolvedP))
              return;
          const entry = this.entries.get(resolvedP);
          if (entry === undefined)
              throw new Error(`Unreachable`);
          const oldMod = this.getUnixMode(entry, S_IFREG | 0o000);
          const newMod = oldMod & (~0o777) | mask;
          const rc = libzip_1.default.file.setExternalAttributes(this.zip, entry, 0, 0, libzip_1.default.ZIP_OPSYS_UNIX, newMod << 16);
          if (rc === -1) {
              throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
          }
      }
      async renamePromise(oldP, newP) {
          return this.renameSync(oldP, newP);
      }
      renameSync(oldP, newP) {
          throw new Error(`Unimplemented`);
      }
      async copyFilePromise(sourceP, destP, flags) {
          return this.copyFileSync(sourceP, destP, flags);
      }
      copyFileSync(sourceP, destP, flags = 0) {
          if ((flags & fs_1.constants.COPYFILE_FICLONE_FORCE) !== 0)
              throw Object.assign(new Error(`ENOSYS: unsupported clone operation, copyfile '${sourceP}' -> ${destP}'`), { code: `ENOSYS` });
          const resolvedSourceP = this.resolveFilename(`copyfile '${sourceP} -> ${destP}'`, sourceP);
          const indexSource = this.entries.get(resolvedSourceP);
          if (typeof indexSource === `undefined`)
              throw Object.assign(new Error(`EINVAL: invalid argument, copyfile '${sourceP}' -> '${destP}'`), { code: `EINVAL` });
          const resolvedDestP = this.resolveFilename(`copyfile '${sourceP}' -> ${destP}'`, destP);
          const indexDest = this.entries.get(resolvedDestP);
          if ((flags & (fs_1.constants.COPYFILE_EXCL | fs_1.constants.COPYFILE_FICLONE_FORCE)) !== 0 && typeof indexDest !== `undefined`)
              throw Object.assign(new Error(`EEXIST: file already exists, copyfile '${sourceP}' -> '${destP}'`), { code: `EEXIST` });
          const source = this.getFileSource(indexSource);
          const newIndex = this.setFileSource(resolvedDestP, source);
          if (newIndex !== indexDest) {
              this.registerEntry(resolvedDestP, newIndex);
          }
      }
      async appendFilePromise(p, content, opts) {
          return this.appendFileSync(p, content, opts);
      }
      appendFileSync(p, content, opts = {}) {
          if (typeof opts === `undefined`)
              opts = { flag: `a` };
          else if (typeof opts === `string`)
              opts = { flag: `a`, encoding: opts };
          else if (typeof opts.flag === `undefined`)
              opts = Object.assign({ flag: `a` }, opts);
          return this.writeFileSync(p, content, opts);
      }
      async writeFilePromise(p, content, opts) {
          return this.writeFileSync(p, content, opts);
      }
      writeFileSync(p, content, opts) {
          if (typeof p !== `string`)
              throw Object.assign(new Error(`EBADF: bad file descriptor, read`), { code: `EBADF` });
          const resolvedP = this.resolveFilename(`open '${p}'`, p);
          if (this.listings.has(resolvedP))
              throw Object.assign(new Error(`EISDIR: illegal operation on a directory, open '${p}'`), { code: `EISDIR` });
          const index = this.entries.get(resolvedP);
          if (index !== undefined && typeof opts === `object` && opts.flag && opts.flag.includes(`a`))
              content = Buffer.concat([this.getFileSource(index), Buffer.from(content)]);
          let encoding = null;
          if (typeof opts === `string`)
              encoding = opts;
          else if (typeof opts === `object` && opts.encoding)
              encoding = opts.encoding;
          if (encoding !== null)
              content = content.toString(encoding);
          const newIndex = this.setFileSource(resolvedP, content);
          if (newIndex !== index) {
              this.registerEntry(resolvedP, newIndex);
          }
      }
      async unlinkPromise(p) {
          return this.unlinkSync(p);
      }
      unlinkSync(p) {
          throw new Error(`Unimplemented`);
      }
      async utimesPromise(p, atime, mtime) {
          return this.utimesSync(p, atime, mtime);
      }
      utimesSync(p, atime, mtime) {
          const resolvedP = this.resolveFilename(`chmod '${p}'`, p);
          return this.utimesImpl(resolvedP, mtime);
      }
      async lutimesPromise(p, atime, mtime) {
          return this.lutimesSync(p, atime, mtime);
      }
      lutimesSync(p, atime, mtime) {
          const resolvedP = this.resolveFilename(`chmod '${p}'`, p, false);
          return this.utimesImpl(resolvedP, mtime);
      }
      utimesImpl(resolvedP, mtime) {
          if (this.listings.has(resolvedP))
              if (!this.entries.has(resolvedP))
                  this.hydrateDirectory(resolvedP);
          const entry = this.entries.get(resolvedP);
          if (entry === undefined)
              throw new Error(`Unreachable`);
          const rc = libzip_1.default.file.setMtime(this.zip, entry, 0, toUnixTimestamp(mtime), 0);
          if (rc === -1) {
              throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
          }
      }
      async mkdirPromise(p) {
          return this.mkdirSync(p);
      }
      mkdirSync(p) {
          const resolvedP = this.resolveFilename(`mkdir '${p}'`, p);
          if (this.entries.has(resolvedP) || this.listings.has(resolvedP))
              throw Object.assign(new Error(`EEXIST: file already exists, mkdir '${p}'`), { code: `EEXIST` });
          this.hydrateDirectory(resolvedP);
      }
      async rmdirPromise(p) {
          return this.rmdirSync(p);
      }
      rmdirSync(p) {
          throw new Error(`Unimplemented`);
      }
      hydrateDirectory(resolvedP) {
          const index = libzip_1.default.dir.add(this.zip, path_1.ppath.relative(path_1.PortablePath.root, resolvedP));
          if (index === -1)
              throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
          this.registerListing(resolvedP);
          this.registerEntry(resolvedP, index);
          return index;
      }
      async symlinkPromise(target, p) {
          return this.symlinkSync(target, p);
      }
      symlinkSync(target, p) {
          const resolvedP = this.resolveFilename(`symlink '${target}' -> '${p}'`, p);
          if (this.listings.has(resolvedP))
              throw Object.assign(new Error(`EISDIR: illegal operation on a directory, symlink '${target}' -> '${p}'`), { code: `EISDIR` });
          if (this.entries.has(resolvedP))
              throw Object.assign(new Error(`EEXIST: file already exists, symlink '${target}' -> '${p}'`), { code: `EEXIST` });
          const index = this.setFileSource(resolvedP, target);
          this.registerEntry(resolvedP, index);
          const rc = libzip_1.default.file.setExternalAttributes(this.zip, index, 0, 0, libzip_1.default.ZIP_OPSYS_UNIX, (0o120000 | 0o777) << 16);
          if (rc === -1) {
              throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
          }
      }
      async readFilePromise(p, encoding) {
          // This weird switch is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
          switch (encoding) {
              case `utf8`:
                  return this.readFileSync(p, encoding);
              default:
                  return this.readFileSync(p, encoding);
          }
      }
      readFileSync(p, encoding) {
          if (typeof p !== `string`)
              throw Object.assign(new Error(`EBADF: bad file descriptor, read`), { code: `EBADF` });
          // This is messed up regarding the TS signatures
          if (typeof encoding === `object`)
              // @ts-ignore
              encoding = encoding ? encoding.encoding : undefined;
          const resolvedP = this.resolveFilename(`open '${p}'`, p);
          if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
              throw Object.assign(new Error(`ENOENT: no such file or directory, open '${p}'`), { code: `ENOENT` });
          // Ensures that the last component is a directory, if the user said so (even if it is we'll throw right after with EISDIR anyway)
          if (p[p.length - 1] === `/` && !this.listings.has(resolvedP))
              throw Object.assign(new Error(`ENOTDIR: not a directory, open '${p}'`), { code: `ENOTDIR` });
          if (this.listings.has(resolvedP))
              throw Object.assign(new Error(`EISDIR: illegal operation on a directory, read`), { code: `EISDIR` });
          const entry = this.entries.get(resolvedP);
          if (entry === undefined)
              throw new Error(`Unreachable`);
          const data = this.getFileSource(entry);
          return encoding ? data.toString(encoding) : data;
      }
      async readdirPromise(p) {
          return this.readdirSync(p);
      }
      readdirSync(p) {
          const resolvedP = this.resolveFilename(`scandir '${p}'`, p);
          if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
              throw Object.assign(new Error(`ENOENT: no such file or directory, scandir '${p}'`), { code: `ENOENT` });
          const directoryListing = this.listings.get(resolvedP);
          if (!directoryListing)
              throw Object.assign(new Error(`ENOTDIR: not a directory, scandir '${p}'`), { code: `ENOTDIR` });
          return Array.from(directoryListing);
      }
      async readlinkPromise(p) {
          return this.readlinkSync(p);
      }
      readlinkSync(p) {
          const resolvedP = this.resolveFilename(`readlink '${p}'`, p, false);
          if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
              throw Object.assign(new Error(`ENOENT: no such file or directory, readlink '${p}'`), { code: `ENOENT` });
          // Ensure that the last component is a directory (if it is we'll throw right after with EISDIR anyway)
          if (p[p.length - 1] === `/` && !this.listings.has(resolvedP))
              throw Object.assign(new Error(`ENOTDIR: not a directory, open '${p}'`), { code: `ENOTDIR` });
          if (this.listings.has(resolvedP))
              throw Object.assign(new Error(`EINVAL: invalid argument, readlink '${p}'`), { code: `EINVAL` });
          const entry = this.entries.get(resolvedP);
          if (entry === undefined)
              throw new Error(`Unreachable`);
          const rc = libzip_1.default.file.getExternalAttributes(this.zip, entry, 0, 0, libzip_1.default.uint08S, libzip_1.default.uint32S);
          if (rc === -1)
              throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
          const opsys = libzip_1.default.getValue(libzip_1.default.uint08S, `i8`) >>> 0;
          if (opsys !== libzip_1.default.ZIP_OPSYS_UNIX)
              throw Object.assign(new Error(`EINVAL: invalid argument, readlink '${p}'`), { code: `EINVAL` });
          const attributes = libzip_1.default.getValue(libzip_1.default.uint32S, `i32`) >>> 16;
          if ((attributes & 0o170000) !== 0o120000)
              throw Object.assign(new Error(`EINVAL: invalid argument, readlink '${p}'`), { code: `EINVAL` });
          return this.getFileSource(entry).toString();
      }
      watch(p, a, b) {
          let persistent;
          switch (typeof a) {
              case `function`:
              case `string`:
              case `undefined`:
                  {
                      persistent = true;
                  }
                  break;
              default:
                  {
                      // @ts-ignore
                      ({ persistent = true } = a);
                  }
                  break;
          }
          if (!persistent)
              return { on: () => { }, close: () => { } };
          const interval = setInterval(() => { }, 24 * 60 * 60 * 1000);
          return { on: () => { }, close: () => { clearInterval(interval); } };
      }
  }
  exports.ZipFS = ZipFS;
  ;


  /***/ }),
  /* 22 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importDefault = (this && this.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const libzip_1 = __importDefault(__webpack_require__(23));
  const number64 = [
      `number`,
      `number`,
  ];
  // eslint-disable-next-line arca/no-default-export
  exports.default = {
      // Those are getters because they can change after memory growth
      get HEAP8() { return libzip_1.default.HEAP8; },
      get HEAPU8() { return libzip_1.default.HEAPU8; },
      ZIP_CHECKCONS: 4,
      ZIP_CREATE: 1,
      ZIP_EXCL: 2,
      ZIP_TRUNCATE: 8,
      ZIP_RDONLY: 16,
      ZIP_FL_OVERWRITE: 8192,
      ZIP_OPSYS_DOS: 0x00,
      ZIP_OPSYS_AMIGA: 0x01,
      ZIP_OPSYS_OPENVMS: 0x02,
      ZIP_OPSYS_UNIX: 0x03,
      ZIP_OPSYS_VM_CMS: 0x04,
      ZIP_OPSYS_ATARI_ST: 0x05,
      ZIP_OPSYS_OS_2: 0x06,
      ZIP_OPSYS_MACINTOSH: 0x07,
      ZIP_OPSYS_Z_SYSTEM: 0x08,
      ZIP_OPSYS_CPM: 0x09,
      ZIP_OPSYS_WINDOWS_NTFS: 0x0a,
      ZIP_OPSYS_MVS: 0x0b,
      ZIP_OPSYS_VSE: 0x0c,
      ZIP_OPSYS_ACORN_RISC: 0x0d,
      ZIP_OPSYS_VFAT: 0x0e,
      ZIP_OPSYS_ALTERNATE_MVS: 0x0f,
      ZIP_OPSYS_BEOS: 0x10,
      ZIP_OPSYS_TANDEM: 0x11,
      ZIP_OPSYS_OS_400: 0x12,
      ZIP_OPSYS_OS_X: 0x13,
      uint08S: libzip_1.default._malloc(1),
      uint16S: libzip_1.default._malloc(2),
      uint32S: libzip_1.default._malloc(4),
      uint64S: libzip_1.default._malloc(8),
      malloc: libzip_1.default._malloc,
      free: libzip_1.default._free,
      getValue: libzip_1.default.getValue,
      open: libzip_1.default.cwrap(`zip_open`, `number`, [`string`, `number`, `number`]),
      openFromSource: libzip_1.default.cwrap(`zip_open_from_source`, `number`, [`number`, `number`, `number`]),
      close: libzip_1.default.cwrap(`zip_close`, `number`, [`number`]),
      discard: libzip_1.default.cwrap(`zip_discard`, null, [`number`]),
      getError: libzip_1.default.cwrap(`zip_get_error`, `number`, [`number`]),
      getName: libzip_1.default.cwrap(`zip_get_name`, `string`, [`number`, `number`, `number`]),
      getNumEntries: libzip_1.default.cwrap(`zip_get_num_entries`, `number`, [`number`, `number`]),
      stat: libzip_1.default.cwrap(`zip_stat`, `number`, [`number`, `string`, `number`, `number`]),
      statIndex: libzip_1.default.cwrap(`zip_stat_index`, `number`, [`number`, ...number64, `number`, `number`]),
      fopen: libzip_1.default.cwrap(`zip_fopen`, `number`, [`number`, `string`, `number`]),
      fopenIndex: libzip_1.default.cwrap(`zip_fopen_index`, `number`, [`number`, ...number64, `number`]),
      fread: libzip_1.default.cwrap(`zip_fread`, `number`, [`number`, `number`, `number`, `number`]),
      fclose: libzip_1.default.cwrap(`zip_fclose`, `number`, [`number`]),
      dir: {
          add: libzip_1.default.cwrap(`zip_dir_add`, `number`, [`number`, `string`]),
      },
      file: {
          add: libzip_1.default.cwrap(`zip_file_add`, `number`, [`number`, `string`, `number`, `number`]),
          getError: libzip_1.default.cwrap(`zip_file_get_error`, `number`, [`number`]),
          getExternalAttributes: libzip_1.default.cwrap(`zip_file_get_external_attributes`, `number`, [`number`, ...number64, `number`, `number`, `number`]),
          setExternalAttributes: libzip_1.default.cwrap(`zip_file_set_external_attributes`, `number`, [`number`, ...number64, `number`, `number`, `number`]),
          setMtime: libzip_1.default.cwrap(`zip_file_set_mtime`, `number`, [`number`, ...number64, `number`, `number`]),
      },
      error: {
          initWithCode: libzip_1.default.cwrap(`zip_error_init_with_code`, null, [`number`, `number`]),
          strerror: libzip_1.default.cwrap(`zip_error_strerror`, `string`, [`number`]),
      },
      name: {
          locate: libzip_1.default.cwrap(`zip_name_locate`, `number`, [`number`, `string`, `number`]),
      },
      source: {
          fromUnattachedBuffer: libzip_1.default.cwrap(`zip_source_buffer_create`, `number`, [`number`, `number`, `number`, `number`]),
          fromBuffer: libzip_1.default.cwrap(`zip_source_buffer`, `number`, [`number`, `number`, ...number64, `number`]),
          free: libzip_1.default.cwrap(`zip_source_free`, null, [`number`]),
      },
      struct: {
          stat: libzip_1.default.cwrap(`zipstruct_stat`, `number`, []),
          statS: libzip_1.default.cwrap(`zipstruct_statS`, `number`, []),
          statName: libzip_1.default.cwrap(`zipstruct_stat_name`, `string`, [`number`]),
          statIndex: libzip_1.default.cwrap(`zipstruct_stat_index`, `number`, [`number`]),
          statSize: libzip_1.default.cwrap(`zipstruct_stat_size`, `number`, [`number`]),
          statMtime: libzip_1.default.cwrap(`zipstruct_stat_mtime`, `number`, [`number`]),
          error: libzip_1.default.cwrap(`zipstruct_error`, `number`, []),
          errorS: libzip_1.default.cwrap(`zipstruct_errorS`, `number`, []),
      },
  };


  /***/ }),
  /* 23 */
  /***/ (function(module, exports, __webpack_require__) {

  var frozenFs = Object.assign({}, __webpack_require__(7));
  var Module=typeof Module!=="undefined"?Module:{};var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key]}}Module["arguments"]=[];Module["thisProgram"]="./this.program";Module["quit"]=function(status,toThrow){throw toThrow};Module["preRun"]=[];Module["postRun"]=[];var ENVIRONMENT_IS_WORKER=false;var ENVIRONMENT_IS_NODE=true;if(Module["ENVIRONMENT"]){throw new Error("Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)")}var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}else{return scriptDirectory+path}}if(ENVIRONMENT_IS_NODE){if(!(typeof process==="object"&&"function"==="function"))throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");scriptDirectory=__dirname+"/";var nodeFS;var nodePath;Module["read"]=function shell_read(filename,binary){var ret;ret=tryParseAsDataURI(filename);if(!ret){if(!nodeFS)nodeFS=frozenFs;if(!nodePath)nodePath=__webpack_require__(8);filename=nodePath["normalize"](filename);ret=nodeFS["readFileSync"](filename)}return binary?ret:ret.toString()};Module["readBinary"]=function readBinary(filename){var ret=Module["read"](filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}assert(ret.buffer);return ret};if(process["argv"].length>1){Module["thisProgram"]=process["argv"][1].replace(/\\/g,"/")}Module["arguments"]=process["argv"].slice(2);if(true){module["exports"]=Module}(function(){})("uncaughtException",function(ex){if(!(ex instanceof ExitStatus)){throw ex}});(function(){})("unhandledRejection",abort);Module["quit"]=function(status){process["exit"](status)};Module["inspect"]=function(){return"[Emscripten Module object]"}}else{throw new Error("environment detection error")}var out=Module["print"]||(typeof console!=="undefined"?console.log.bind(console):typeof print!=="undefined"?print:null);var err=Module["printErr"]||(typeof printErr!=="undefined"?printErr:typeof console!=="undefined"&&console.warn.bind(console)||out);for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key]}}moduleOverrides=undefined;assert(typeof Module["memoryInitializerPrefixURL"]==="undefined","Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead");assert(typeof Module["pthreadMainPrefixURL"]==="undefined","Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead");assert(typeof Module["cdInitializerPrefixURL"]==="undefined","Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead");assert(typeof Module["filePackagePrefixURL"]==="undefined","Module.filePackagePrefixURL option was removed, use Module.locateFile instead");stackSave=stackRestore=stackAlloc=function(){abort("cannot use the stack before compiled code is ready to run, and has provided stack access")};function dynamicAlloc(size){assert(DYNAMICTOP_PTR);var ret=HEAP32[DYNAMICTOP_PTR>>2];var end=ret+size+15&-16;if(end<=_emscripten_get_heap_size()){HEAP32[DYNAMICTOP_PTR>>2]=end}else{var success=_emscripten_resize_heap(end);if(!success)return 0}return ret}function getNativeTypeSize(type){switch(type){case"i1":case"i8":return 1;case"i16":return 2;case"i32":return 4;case"i64":return 8;case"float":return 4;case"double":return 8;default:{if(type[type.length-1]==="*"){return 4}else if(type[0]==="i"){var bits=parseInt(type.substr(1));assert(bits%8===0,"getNativeTypeSize invalid bits "+bits+", type "+type);return bits/8}else{return 0}}}}function warnOnce(text){if(!warnOnce.shown)warnOnce.shown={};if(!warnOnce.shown[text]){warnOnce.shown[text]=1;err(text)}}var asm2wasmImports={"f64-rem":function(x,y){return x%y},"debugger":function(){debugger}};var functionPointers=new Array(0);var tempRet0=0;var setTempRet0=function(value){tempRet0=value};if(typeof WebAssembly!=="object"){abort("No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.")}function getValue(ptr,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";if(noSafe){switch(type){case"i1":return HEAP8[ptr>>0];case"i8":return HEAP8[ptr>>0];case"i16":return HEAP16[ptr>>1];case"i32":return HEAP32[ptr>>2];case"i64":return HEAP32[ptr>>2];case"float":return HEAPF32[ptr>>2];case"double":return HEAPF64[ptr>>3];default:abort("invalid type for getValue: "+type)}}else{switch(type){case"i1":return SAFE_HEAP_LOAD(ptr|0,1,0)|0;case"i8":return SAFE_HEAP_LOAD(ptr|0,1,0)|0;case"i16":return SAFE_HEAP_LOAD(ptr|0,2,0)|0;case"i32":return SAFE_HEAP_LOAD(ptr|0,4,0)|0;case"i64":return SAFE_HEAP_LOAD(ptr|0,8,0)|0;case"float":return Math_fround(SAFE_HEAP_LOAD_D(ptr|0,4,0));case"double":return+SAFE_HEAP_LOAD_D(ptr|0,8,0);default:abort("invalid type for getValue: "+type)}}return null}function getSafeHeapType(bytes,isFloat){switch(bytes){case 1:return"i8";case 2:return"i16";case 4:return isFloat?"float":"i32";case 8:return"double";default:assert(0)}}function SAFE_HEAP_STORE(dest,value,bytes,isFloat){if(dest<=0)abort("segmentation fault storing "+bytes+" bytes to address "+dest);if(dest%bytes!==0)abort("alignment error storing to address "+dest+", which was expected to be aligned to a multiple of "+bytes);if(dest+bytes>HEAP32[DYNAMICTOP_PTR>>2])abort("segmentation fault, exceeded the top of the available dynamic heap when storing "+bytes+" bytes to address "+dest+". DYNAMICTOP="+HEAP32[DYNAMICTOP_PTR>>2]);assert(DYNAMICTOP_PTR);assert(HEAP32[DYNAMICTOP_PTR>>2]<=HEAP8.length);setValue(dest,value,getSafeHeapType(bytes,isFloat),1)}function SAFE_HEAP_STORE_D(dest,value,bytes){SAFE_HEAP_STORE(dest,value,bytes,true)}function SAFE_HEAP_LOAD(dest,bytes,unsigned,isFloat){if(dest<=0)abort("segmentation fault loading "+bytes+" bytes from address "+dest);if(dest%bytes!==0)abort("alignment error loading from address "+dest+", which was expected to be aligned to a multiple of "+bytes);if(dest+bytes>HEAP32[DYNAMICTOP_PTR>>2])abort("segmentation fault, exceeded the top of the available dynamic heap when loading "+bytes+" bytes from address "+dest+". DYNAMICTOP="+HEAP32[DYNAMICTOP_PTR>>2]);assert(DYNAMICTOP_PTR);assert(HEAP32[DYNAMICTOP_PTR>>2]<=HEAP8.length);var type=getSafeHeapType(bytes,isFloat);var ret=getValue(dest,type,1);if(unsigned)ret=unSign(ret,parseInt(type.substr(1)),1);return ret}function SAFE_HEAP_LOAD_D(dest,bytes,unsigned){return SAFE_HEAP_LOAD(dest,bytes,unsigned,true)}function segfault(){abort("segmentation fault")}function alignfault(){abort("alignment fault")}var wasmMemory;var wasmTable;var ABORT=false;var EXITSTATUS=0;function assert(condition,text){if(!condition){abort("Assertion failed: "+text)}}function getCFunc(ident){var func=Module["_"+ident];assert(func,"Cannot call unknown function "+ident+", make sure it is exported");return func}function ccall(ident,returnType,argTypes,args,opts){var toC={"string":function(str){var ret=0;if(str!==null&&str!==undefined&&str!==0){var len=(str.length<<2)+1;ret=stackAlloc(len);stringToUTF8(str,ret,len)}return ret},"array":function(arr){var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}};function convertReturnValue(ret){if(returnType==="string")return UTF8ToString(ret);if(returnType==="boolean")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;assert(returnType!=="array",'Return type should not be "array".');if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func.apply(null,cArgs);ret=convertReturnValue(ret);if(stack!==0)stackRestore(stack);return ret}function cwrap(ident,returnType,argTypes,opts){return function(){return ccall(ident,returnType,argTypes,arguments,opts)}}function setValue(ptr,value,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";if(noSafe){switch(type){case"i1":HEAP8[ptr>>0]=value;break;case"i8":HEAP8[ptr>>0]=value;break;case"i16":HEAP16[ptr>>1]=value;break;case"i32":HEAP32[ptr>>2]=value;break;case"i64":tempI64=[value>>>0,(tempDouble=value,+Math_abs(tempDouble)>=1?tempDouble>0?(Math_min(+Math_floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math_ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[ptr>>2]=tempI64[0],HEAP32[ptr+4>>2]=tempI64[1];break;case"float":HEAPF32[ptr>>2]=value;break;case"double":HEAPF64[ptr>>3]=value;break;default:abort("invalid type for setValue: "+type)}}else{switch(type){case"i1":SAFE_HEAP_STORE(ptr|0,value|0,1);break;case"i8":SAFE_HEAP_STORE(ptr|0,value|0,1);break;case"i16":SAFE_HEAP_STORE(ptr|0,value|0,2);break;case"i32":SAFE_HEAP_STORE(ptr|0,value|0,4);break;case"i64":tempI64=[value>>>0,(tempDouble=value,+Math_abs(tempDouble)>=1?tempDouble>0?(Math_min(+Math_floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math_ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],SAFE_HEAP_STORE(ptr|0,tempI64[0]|0,4),SAFE_HEAP_STORE(ptr+4|0,tempI64[1]|0,4);break;case"float":SAFE_HEAP_STORE_D(ptr|0,Math_fround(value),4);break;case"double":SAFE_HEAP_STORE_D(ptr|0,+value,8);break;default:abort("invalid type for setValue: "+type)}}}var ALLOC_NORMAL=0;var ALLOC_NONE=3;function allocate(slab,types,allocator,ptr){var zeroinit,size;if(typeof slab==="number"){zeroinit=true;size=slab}else{zeroinit=false;size=slab.length}var singleType=typeof types==="string"?types:null;var ret;if(allocator==ALLOC_NONE){ret=ptr}else{ret=[_malloc,stackAlloc,dynamicAlloc][allocator](Math.max(size,singleType?1:types.length))}if(zeroinit){var stop;ptr=ret;assert((ret&3)==0);stop=ret+(size&~3);for(;ptr<stop;ptr+=4){HEAP32[ptr>>2]=0}stop=ret+size;while(ptr<stop){HEAP8[ptr++>>0]=0}return ret}if(singleType==="i8"){if(slab.subarray||slab.slice){HEAPU8.set(slab,ret)}else{HEAPU8.set(new Uint8Array(slab),ret)}return ret}var i=0,type,typeSize,previousType;while(i<size){var curr=slab[i];type=singleType||types[i];if(type===0){i++;continue}assert(type,"Must know what type to store in allocate!");if(type=="i64")type="i32";setValue(ret+i,curr,type);if(previousType!==type){typeSize=getNativeTypeSize(type);previousType=type}i+=typeSize}return ret}function getMemory(size){if(!runtimeInitialized)return dynamicAlloc(size);return _malloc(size)}var UTF8Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(u8Array,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(u8Array[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&u8Array.subarray&&UTF8Decoder){return UTF8Decoder.decode(u8Array.subarray(idx,endPtr))}else{var str="";while(idx<endPtr){var u0=u8Array[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=u8Array[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=u8Array[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{if((u0&248)!=240)warnOnce("Invalid UTF-8 leading byte 0x"+u0.toString(16)+" encountered when deserializing a UTF-8 string on the asm.js/wasm heap to a JS string!");u0=(u0&7)<<18|u1<<12|u2<<6|u8Array[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):""}function stringToUTF8Array(str,outU8Array,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;outU8Array[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;outU8Array[outIdx++]=192|u>>6;outU8Array[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;outU8Array[outIdx++]=224|u>>12;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;if(u>=2097152)warnOnce("Invalid Unicode code point 0x"+u.toString(16)+" encountered when serializing a JS string to an UTF-8 string on the asm.js/wasm heap! (Valid unicode code points should be in range 0-0x1FFFFF).");outU8Array[outIdx++]=240|u>>18;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}}outU8Array[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){assert(typeof maxBytesToWrite=="number","stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!");return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127)++len;else if(u<=2047)len+=2;else if(u<=65535)len+=3;else len+=4}return len}var UTF16Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf-16le"):undefined;function writeArrayToMemory(array,buffer){assert(array.length>=0,"writeArrayToMemory array must have a length (should be an array or typed array)");HEAP8.set(array,buffer)}function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){assert(str.charCodeAt(i)===str.charCodeAt(i)&255);SAFE_HEAP_STORE(buffer++|0,str.charCodeAt(i)|0,1)}if(!dontAddNull)SAFE_HEAP_STORE(buffer|0,0|0,1)}function demangle(func){warnOnce("warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling");return func}function demangleAll(text){var regex=/__Z[\w\d_]+/g;return text.replace(regex,function(x){var y=demangle(x);return x===y?x:y+" ["+x+"]"})}function jsStackTrace(){var err=new Error;if(!err.stack){try{throw new Error(0)}catch(e){err=e}if(!err.stack){return"(no stack trace available)"}}return err.stack.toString()}function stackTrace(){var js=jsStackTrace();if(Module["extraStackTrace"])js+="\n"+Module["extraStackTrace"]();return demangleAll(js)}var WASM_PAGE_SIZE=65536;function alignUp(x,multiple){if(x%multiple>0){x+=multiple-x%multiple}return x}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferViews(){Module["HEAP8"]=HEAP8=new Int8Array(buffer);Module["HEAP16"]=HEAP16=new Int16Array(buffer);Module["HEAP32"]=HEAP32=new Int32Array(buffer);Module["HEAPU8"]=HEAPU8=new Uint8Array(buffer);Module["HEAPU16"]=HEAPU16=new Uint16Array(buffer);Module["HEAPU32"]=HEAPU32=new Uint32Array(buffer);Module["HEAPF32"]=HEAPF32=new Float32Array(buffer);Module["HEAPF64"]=HEAPF64=new Float64Array(buffer)}var STACK_BASE=22720,STACK_MAX=5265600,DYNAMIC_BASE=5265600,DYNAMICTOP_PTR=22464;assert(STACK_BASE%16===0,"stack must start aligned");assert(DYNAMIC_BASE%16===0,"heap must start aligned");var TOTAL_STACK=5242880;if(Module["TOTAL_STACK"])assert(TOTAL_STACK===Module["TOTAL_STACK"],"the stack size can no longer be determined at runtime");var INITIAL_TOTAL_MEMORY=Module["TOTAL_MEMORY"]||16777216;if(INITIAL_TOTAL_MEMORY<TOTAL_STACK)err("TOTAL_MEMORY should be larger than TOTAL_STACK, was "+INITIAL_TOTAL_MEMORY+"! (TOTAL_STACK="+TOTAL_STACK+")");assert(typeof Int32Array!=="undefined"&&typeof Float64Array!=="undefined"&&Int32Array.prototype.subarray!==undefined&&Int32Array.prototype.set!==undefined,"JS engine does not provide full typed array support");if(Module["buffer"]){buffer=Module["buffer"];assert(buffer.byteLength===INITIAL_TOTAL_MEMORY,"provided buffer should be "+INITIAL_TOTAL_MEMORY+" bytes, but it is "+buffer.byteLength)}else{if(typeof WebAssembly==="object"&&typeof WebAssembly.Memory==="function"){assert(INITIAL_TOTAL_MEMORY%WASM_PAGE_SIZE===0);wasmMemory=new WebAssembly.Memory({"initial":INITIAL_TOTAL_MEMORY/WASM_PAGE_SIZE});buffer=wasmMemory.buffer}else{buffer=new ArrayBuffer(INITIAL_TOTAL_MEMORY)}assert(buffer.byteLength===INITIAL_TOTAL_MEMORY)}updateGlobalBufferViews();HEAP32[DYNAMICTOP_PTR>>2]=DYNAMIC_BASE;function writeStackCookie(){assert((STACK_MAX&3)==0);HEAPU32[(STACK_MAX>>2)-1]=34821223;HEAPU32[(STACK_MAX>>2)-2]=2310721022}function checkStackCookie(){if(HEAPU32[(STACK_MAX>>2)-1]!=34821223||HEAPU32[(STACK_MAX>>2)-2]!=2310721022){abort("Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x"+HEAPU32[(STACK_MAX>>2)-2].toString(16)+" "+HEAPU32[(STACK_MAX>>2)-1].toString(16))}if(HEAP32[0]!==1668509029)throw"Runtime error: The application has corrupted its heap memory area (address zero)!"}function abortStackOverflow(allocSize){abort("Stack overflow! Attempted to allocate "+allocSize+" bytes on the stack, but stack has only "+(STACK_MAX-stackSave()+allocSize)+" bytes available!")}HEAP32[0]=1668509029;HEAP16[1]=25459;if(HEAPU8[2]!==115||HEAPU8[3]!==99)throw"Runtime error: expected the system to be little-endian!";function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback();continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){Module["dynCall_v"](func)}else{Module["dynCall_vi"](func,callback.arg)}}else{func(callback.arg===undefined?null:callback.arg)}}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeExited=false;function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function ensureInitRuntime(){checkStackCookie();if(runtimeInitialized)return;runtimeInitialized=true;if(!Module["noFSInit"]&&!FS.init.initialized)FS.init();TTY.init();callRuntimeCallbacks(__ATINIT__)}function preMain(){checkStackCookie();FS.ignorePermissions=false;callRuntimeCallbacks(__ATMAIN__)}function postRun(){checkStackCookie();if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}function unSign(value,bits,ignore){if(value>=0){return value}return bits<=32?2*Math.abs(1<<bits-1)+value:Math.pow(2,bits)+value}assert(Math.imul,"This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");assert(Math.fround,"This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");assert(Math.clz32,"This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");assert(Math.trunc,"This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");var Math_abs=Math.abs;var Math_ceil=Math.ceil;var Math_floor=Math.floor;var Math_fround=Math.fround;var Math_min=Math.min;var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;var runDependencyTracking={};function getUniqueRunDependency(id){var orig=id;while(1){if(!runDependencyTracking[id])return id;id=orig+Math.random()}return id}function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(id){assert(!runDependencyTracking[id]);runDependencyTracking[id]=1;if(runDependencyWatcher===null&&typeof setInterval!=="undefined"){runDependencyWatcher=setInterval(function(){if(ABORT){clearInterval(runDependencyWatcher);runDependencyWatcher=null;return}var shown=false;for(var dep in runDependencyTracking){if(!shown){shown=true;err("still waiting on run dependencies:")}err("dependency: "+dep)}if(shown){err("(end of list)")}},1e4)}}else{err("warning: run dependency added without ID")}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(id){assert(runDependencyTracking[id]);delete runDependencyTracking[id]}else{err("warning: run dependency removed without ID")}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}Module["preloadedImages"]={};Module["preloadedAudios"]={};var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return String.prototype.startsWith?filename.startsWith(dataURIPrefix):filename.indexOf(dataURIPrefix)===0}var wasmBinaryFile="data:application/octet-stream;base64,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AgBLcgRAEAELIANBAXEEQBACCyADIAI7AQALJgEBfyAAIAFqIQIgAkEARiACQQFqIwEoAgBLcgRAEAELIAItAAALMAEBfyAAIAFqIQIgAkEARiACQQJqIwEoAgBLcgRAEAELIAJBAXEEQBACCyACLwEACzABAX8gACABaiECIAJBAEYgAkECaiMBKAIAS3IEQBABCyACQQFxBEAQAgsgAi4BAAvGDgEJfyAARQRADwtB9KIBQQAQKCEEIABBeGoiAyAAQXxqQQAQKCICQXhxIgBqIQUgAkEBcQR/IAMFAn8gA0EAECghASACQQNxRQRADwsgAyABayIDIARJBEAPCyAAIAFqIQAgA0H4ogFBABAoRgRAIAMgBUEEECgiAUEDcUEDRw0BGkHsogFBACAAECkgBUEEIAFBfnEQKSADQQQgAEEBchApIAAgA2pBACAAECkPCyABQQN2IQQgAUGAAkkEQCADQQgQKCIBIANBDBAoIgJGBEBB5KIBQQBB5KIBQQAQKEEBIAR0QX9zcRApBSABQQwgAhApIAJBCCABECkLIAMMAQsgA0EYECghByADIANBDBAoIgFGBEACQCADQRBqIgJBBGoiBEEAECgiAQRAIAQhAgUgAkEAECgiAUUEQEEAIQEMAgsLA0ACQCABQRRqIgRBABAoIgZFBEAgAUEQaiIEQQAQKCIGRQ0BCyAEIQIgBiEBDAELCyACQQBBABApCwUgA0EIECgiAkEMIAEQKSABQQggAhApCyAHBH8gAyADQRwQKCICQQJ0QZSlAWoiBEEAEChGBEAgBEEAIAEQKSABRQRAQeiiAUEAQeiiAUEAEChBASACdEF/c3EQKSADDAMLBSAHQRBqIgIgB0EUaiADIAJBABAoRhtBACABECkgAyABRQ0CGgsgAUEYIAcQKSADQRAQKCICBEAgAUEQIAIQKSACQRggARApCyADQRQQKCICBEAgAUEUIAIQKSACQRggARApCyADBSADCwsLIgcgBU8EQA8LIAVBBBAoIghBAXFFBEAPCyAIQQJxBEAgBUEEIAhBfnEQKSADQQQgAEEBchApIAAgB2pBACAAECkgACECBSAFQfyiAUEAEChGBEBB8KIBQQAgAEHwogFBABAoaiIAEClB/KIBQQAgAxApIANBBCAAQQFyEClB+KIBQQAQKCADRwRADwtB+KIBQQBBABApQeyiAUEAQQAQKQ8LQfiiAUEAECggBUYEQEHsogFBACAAQeyiAUEAEChqIgAQKUH4ogFBACAHECkgA0EEIABBAXIQKSAAIAdqQQAgABApDwsgCEEDdiEEIAhBgAJJBEAgBUEIECgiASAFQQwQKCICRgRAQeSiAUEAQeSiAUEAEChBASAEdEF/c3EQKQUgAUEMIAIQKSACQQggARApCwUCQCAFQRgQKCEJIAVBDBAoIgEgBUYEQAJAIAVBEGoiAkEEaiIEQQAQKCIBBEAgBCECBSACQQAQKCIBRQRAQQAhAQwCCwsDQAJAIAFBFGoiBEEAECgiBkUEQCABQRBqIgRBABAoIgZFDQELIAQhAiAGIQEMAQsLIAJBAEEAECkLBSAFQQgQKCICQQwgARApIAFBCCACECkLIAkEQCAFQRwQKCICQQJ0QZSlAWoiBEEAECggBUYEQCAEQQAgARApIAFFBEBB6KIBQQBB6KIBQQAQKEEBIAJ0QX9zcRApDAMLBSAJQRBqIgIgCUEUaiACQQAQKCAFRhtBACABECkgAUUNAgsgAUEYIAkQKSAFQRAQKCICBEAgAUEQIAIQKSACQRggARApCyAFQRQQKCICBEAgAUEUIAIQKSACQRggARApCwsLCyADQQQgACAIQXhxaiICQQFyECkgAiAHakEAIAIQKSADQfiiAUEAEChGBEBB7KIBQQAgAhApDwsLIAJBA3YhASACQYACSQRAIAFBA3RBjKMBaiEAQeSiAUEAECgiAkEBIAF0IgFxBH8gAEEIaiICQQAQKAVB5KIBQQAgASACchApIABBCGohAiAACyEBIAJBACADECkgAUEMIAMQKSADQQggARApIANBDCAAECkPCyACQQh2IgAEfyACQf///wdLBH9BHwUgACAAQYD+P2pBEHZBCHEiAXQiBEGA4B9qQRB2QQRxIQBBDiAAIAFyIAQgAHQiAEGAgA9qQRB2QQJxIgFyayAAIAF0QQ92aiIAQQF0IAIgAEEHanZBAXFyCwVBAAsiAUECdEGUpQFqIQAgA0EcIAEQKSADQRRBABApIANBEEEAEClB6KIBQQAQKCIEQQEgAXQiBnEEQAJAIAIgAEEAECgiAEEEEChBeHFGBEAgACEBBQJAIAJBAEEZIAFBAXZrIAFBH0YbdCEEA0AgAEEQaiAEQR92QQJ0aiIGQQAQKCIBBEAgBEEBdCEEIAIgAUEEEChBeHFGDQIgASEADAELCyAGQQAgAxApIANBGCAAECkgA0EMIAMQKSADQQggAxApDAILCyABQQgQKCIAQQwgAxApIAFBCCADECkgA0EIIAAQKSADQQwgARApIANBGEEAECkLBUHoogFBACAEIAZyECkgAEEAIAMQKSADQRggABApIANBDCADECkgA0EIIAMQKQtBhKMBQQBBhKMBQQAQKEF/aiIAECkgAARADwtBrKYBIQADQCAAQQAQKCIDQQhqIQAgAw0AC0GEowFBAEF/ECkLWwAgAEEATARAEAELIAAgAmojAkEAEChKBEAQAQsgAkEERgRAIABBA3EEQBACCyAAQQAgARApBSACQQFGBEAgAEEAIAEQKwUgAEEBcQRAEAILIABBACABEC4LCwuLOQENfyMDIQojA0EQaiQDIwMjBE4EQEEQEAALIABB9QFJBEBB5KIBQQAQKCIFQRAgAEELakF4cSAAQQtJGyICQQN2IgB2IgFBA3EEQCABQQFxQQFzIABqIgJBA3RBjKMBaiIAQQgQKCIDQQhqIgRBABAoIQEgACABRgRAQeSiAUEAQQEgAnRBf3MgBXEQKQUgAUEMIAAQKSAAQQggARApCyADQQQgAkEDdCIAQQNyECkgACADaiIAQQQgAEEEEChBAXIQKSAKJAMgBA8LIAJB7KIBQQAQKCIHSwR/IAEEQCABIAB0QQIgAHQiAEEAIABrcnEiAEEAIABrcUF/aiIAQQx2QRBxIgEgACABdiIAQQV2QQhxIgFyIAAgAXYiAEECdkEEcSIBciAAIAF2IgBBAXZBAnEiAXIgACABdiIAQQF2QQFxIgFyIAAgAXZqIgRBA3RBjKMBaiIAQQgQKCIBQQhqIgZBABAoIQMgACADRgRAQeSiAUEAQQEgBHRBf3MgBXEiABApBSADQQwgABApIABBCCADECkgBSEACyABQQQgAkEDchApIAEgAmoiCEEEIARBA3QiAyACayIFQQFyECkgASADakEAIAUQKSAHBEBB+KIBQQAQKCEDIAdBA3YiAkEDdEGMowFqIQFBASACdCICIABxBH8gAUEIaiICQQAQKAVB5KIBQQAgACACchApIAFBCGohAiABCyEAIAJBACADECkgAEEMIAMQKSADQQggABApIANBDCABECkLQeyiAUEA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BwJAAkBBoKYBQQAQKEEEcQRAQQAhAgUCQAJAAkBB/KIBQQAQKCIDRQ0AQaSmASEBA0ACQCABQQAQKCIJIANNBEAgCSABQQQQKGogA0sNAQsgAUEIECgiAQ0BDAILCyAIIAYgAmtxIgJB/////wdJBEAgAhBXIgMgAUEAECggAUEEEChqRgRAIANBf0cEQCADIQEMBwsFDAMLBUEAIQILDAILQQAQVyIBQX9GBH9BAAVBlKYBQQAQKCIGIAUgAUHApgFBABAoIgJBf2oiA2pBACACa3EgAWtBACABIANxG2oiAmohAyACQf////8HSSACIABLcQR/QZymAUEAECgiCARAIAMgBk0gAyAIS3IEQEEAIQIMBQsLIAEgAhBXIgNGDQUMAgVBAAsLIQIMAQsgAyEBIAFBf0cgAkH/////B0lxIAcgAktxRQRAIAFBf0YEQEEAIQIMAgUMBAsAC0HEpgFBABAoIgMgBCACa2pBACADa3EiA0H/////B08NAkEAIAJrIQQgAxBXQX9GBH8gBBBXGkEABSACIANqIQIMAwshAgtBoKYBQQBBoKYBQQAQKEEEchApCyAFQf////8HSQRAIAUQVyEBQQAQVyIDIAFrIgQgAEEoakshBSAEIAIgBRshAiAFQQFzIAFBf0ZyIAFBf0cgA0F/R3EgASADSXFBAXNyRQ0BCwwBC0GUpgFBACACQZSmAUEAEChqIgMQKSADQZimAUEAEChLBEBBmKYBQQAgAxApC0H8ogFBABAoIgUEQAJAQaSmASEDAkACQANAIAEgA0EAECgiBCADQQQQKCIGakYNASADQQgQKCIDDQALDAELIANBDBAoQQhxRQRAIAQgBU0gASAFS3EEQCADQQQgAiAGahApIAVBACAFQQhqIgFrQQdxQQAgAUEHcRsiA2ohASACQfCiAUEAEChqIgQgA2shAkH8ogFBACABEClB8KIBQQAgAhApIAFBBCACQQFyECkgBCAFakEEQSgQKUGAowFBAEHMpgFBABAoECkMAwsLCyABQfSiAUEAEChJBEBB9KIBQQAgARApCyABIAJqIQRBpKYBIQMCQAJAA0AgBCADQQAQKEYNASADQQgQKCIDDQALDAELIANBDBAoQQhxRQRAIANBACABECkgA0EEIAIgA0EEEChqECkgACABQQAgAUEIaiIBa0EHcUEAIAFB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AEEUECkgAEEEQQAQKQsgBRA1CyAEEFMLIAgkA0F/C5sDAQh/IABBuC1qIghBABAwIANB//8DcSIKIABBvC1qIglBABAoIgN0ciEHIAhBACAHEC4gA0ENSgRAAn8gAEEIaiIDQQAQKCELIABBFGoiBEEAECghBiAEQQAgBkEBahApIAsLIAZqQQAgBxArIAhBABAwQQh2IQcgA0EAECghBiAEQQAgBEEAECgiBUEBahApIAUgBmpBACAHECsgCEEAIApBECAJQQAQKCIFa3YQLiAJQQAgBUFzahApBSAJQQAgA0EDahApIABBFGohBCAAQQhqIQMLIAAQxQEgA0EAECghBSAEQQAgBEEAECgiAEEBahApIAAgBWpBACACECsgA0EAECghBSAEQQAgBEEAECgiAEEBahApIAAgBWpBACACQQh2IgYQKyADQQAQKCEFIARBACAEQQAQKCIAQQFqECkgACAFakEAIAJB/wFzECsgA0EAECghBSAEQQAgBEEAECgiAEEBahApIAAgBWpBACAGQf8BcxArIANBABAoIARBABAoaiABIAIQNhogBEEAIAIgBEEAEChqECkLogUBCH8gAEG0LWohBSAAQUBrIQYgAEH0ABAoIQEgAEEsECgiBCECA0ACQCAAQTwQKCABayAAQewAECgiA2shASADIAQgAkH6fWpqTwRAIABBOBAoIgIgAiAEaiAEIAFrEDYaIABB8AAgAEHwABAoIARrECkgAEHsACAAQewAECggBGsQKSAAQdwAIABB3AAQKCAEaxApIAAQ3AIgASAEaiEBCyAAQQAQKCICQQQQKEUNACAAQfQAIAIgAEH0ABAoIABBOBAoIABB7AAQKGpqIAEQmQEgAEH0ABAoaiIBECkgASAFQQAQKCICakECSwRAAkAgAEHIACAAQewAECggAmsiAyAAQTgQKCIHakEAEC8iCBApIABByAAgAEHUABAoIAcgA0EBampBABAvIAggAEHYABAodHNxECkDQCACRQ0BIABByAAgAEHUABAoIABBOBAoIANBAmpqQQAQLyAAQcgAECggAEHYABAodHNxIgEQKSAGQQAQKCADIABBNBAocUEBdGpBACAAQcQAECggAUEBdGpBABAxEC4gAEHEABAoIABByAAQKEEBdGpBACADEC4gBUEAIAVBABAoQX9qIgIQKSACIABB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IAAgASACIABBCGoQhAEL1wECAX8BfiADIAJBAEdyRQRAQQAPCyACIANBAXFqEDQiBUUEQCAEBEAgBEEAQQ4QKSAEQQRBABApC0EADwsgAq0hBiAABEACQCAAIAYQPSIABEAgBSAAIAIQNhoMAQsgBARAIARBAEEOECkgBEEEQQAQKQsgBRAyQQAPCwUgASAFIAYgBBCHAUEASARAIAUQMkEADwsLIANFBEAgBQ8LIAIgBWoiAUEAQQAQKyAFIQADQCAAIAFJBEAgAEEAEC1FBEAgAEEAQSAQKwsgAEEBaiEADAELCyAFC3oBAX4gAkIAUwR/IAMEQCADQQBBFBApIANBBEEAECkLQX8FAn8gACABIAIQTSIEQgBTBEAgAwRAIANBACAAQQwQKBApIANBBCAAQRAQKBApC0F/DAELIAQgAlMEfyADBEAgA0EAQREQKSADQQRBABApC0F/BUEACwsLC0QCAX8BfiAARQRAQQAPC0KFKiECA0AgAEEAEC0iAQRAIABBAWohACABQf8Bca0gAkIhfnxC/////w+DIQIMAQsLIAKnCyIAIAAgASACIAMQZiIABH8gAEEwEChBACACIAMQcAVBAAsLuAEBAn8gAEFAa0EAECggAadBBHRqQQAQKCIDRQRAIAIEQCACQQBBFBApIAJBBEEAECkLQgAPCwJ/IABBABAoIANByAAQKiIBQQAQSkEASCEEIABBABAoIQAgBAsEQCACBEAgAkEAIABBDBAoECkgAkEEIABBEBAoECkLQgAPCyAAIAIQhQIiAEEASARAQgAPCyABIACtfCIBQgBZBEAgAQ8LIAIEQCACQQBBBBApIAJBBEEbECkLQgALfQACQAJAA0ACQCAARQ0CIABBCBAwIAJB//8DcUYEQCADIABBBBAocUGABnENAQsgAEEAECghAAwBCwsMAQsgBARAIARBAEEJECkgBEEEQQAQKQtBAA8LIAEEQCABQQAgAEEKEDEQLgsgAEEKEDFFBEBBvacBDwsgAEEMECgLFwAgABCbASAAQQAQKBBfIABBBBAoEF8L/wECAX8BfiAARQRADwsgAEEAECgiAQRAIAEQWxogAEEAECgQOgsgAEEcECgQMiAAQSAQKBBJIABBJBAoEEkgAEHQABAoEPABIABBQGsiAUEAECgEQANAIAIgAEEwECpUBEAgAUEAECgg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IAcQKQueBgEMfyABQQAQKCEEIAFBCBAoIgJBABAoIQUgAkEMECghCCAAQdAoaiIGQQBBABApIABB1ChqIglBAEG9BBApQX8hAgNAIAMgCEgEQCADQQJ0IARqQQAQMQRAIAZBACAGQQAQKEEBaiICECkgAEHcFmogAkECdGpBACADECkgAyAAQdgoampBAEEAECsgAyECBSADQQJ0IARqQQJBABAuCyADQQFqIQMMAQsLIABBqC1qIQMgBUUhCyAAQawtaiEHIAIhCgNAIAZBABAoIgJBAkgEQCAGQQAgAkEBaiICECkgAEHcFmogAkECdGpBACAKQQFqIgxBACAKQQJIIg0bIgIQKSACQQJ0IARqQQBBARAuIAIgAEHYKGpqQQBBABArIANBACADQQAQKEF/ahApIAtFBEAgB0EAIAdBABAoIAJBAnQgBWpBAhAwaxApCyAMIAogDRshCgwBCwsgAUEEIAoQKSAGQQAQKEECbSECA0AgAkEASgRAIAAgBCACEJUBIAJBf2ohAgwBCwsgAEHgFmohBSAIIQIgBkEAECghAwNAIAVBABAoIQggBkEAIANBf2oQKSAFQQAgAEHcFmogA0ECdGpBABAoECkgACAEQQEQlQEgBUEAECghAyAJQQAgCUEAEChBf2oiBxApIABB3BZqIAdBAnRqQQAgCBApIAlBACAJQQAQKEF/aiIHECkgAEHcFmogB0ECdGpBACADECkgAkECdCAEakEAIAhBAnQgBGpBABAwIANBAnQgBGpBABAwahAuIAIgAEHYKGpqQQAgAyAAQdgoampBABAtIgcgCCAAQdgoampBABAtIgsgC0H/AXEgB0H/AXFIG0H/AXFBAWoQKyADQQJ0IARqQQIgAkH//wNxIgMQLiAIQQJ0IARqQQIgAxAuIAVBACACECkgACAEQQEQlQEgAkEBaiECIAZBABAoIgNBAUoNAAsgBUEAECghAiAJQQAgCUEAEChBf2oiAxApIABB3BZqIANBAnRqQQAgAhApIAAgAUEAECggAUEEECggAUEIECgQywIgBCAKIABBvBZqEMoCC44LARZ/IwMhBiMDQUBrJAMjAyMETgRAQcAAEAALIAZBIGohECAGIQ5BACEGA0AgBkEQRwRAIAZBAXQgEGpBAEEAEC4gBkEBaiEGDAELC0EAIQYDQCACIAZHBEAgBkEB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BSEDDAIFQQAhAwwDCwALCyACQSQQKCEEIAIgACADIARBD3FBEGoRBgAiBCADSQ0CIAAgA2ohACABIANrIQEgAkEUECghBAsLIAQgACABEDYaIAJBFCABIAJBFBAoahApIAEgA2ohBAsgBAuUAQIBfwJ+AkACQCAAvSIDQjSIIgSnQf8PcSICBEAgAkH/D0YEQAwDBQwCCwALIAFBACAARAAAAAAAAAAAYgR/IABEAAAAAAAA8EOiIAEQuAEhACABQQAQKEFAagVBAAsQKQwBCyABQQAgBKdB/w9xQYJ4ahApIANC/////////4eAf4NCgICAgICAgPA/hL8hAAsgAAsRACAABH8gACABELkCBUEACwuEAgEDfyABQf8BcSEEAkACQCACQQBHIgMgAEEDcUEAR3FFDQAgAUH/AXEhBQJAA0AgBSAAQQAQL0YNASACQX9qIgJBAEciAyAAQQFqIgBBA3FBAEdxDQALDAELDAELIAMEQAJAIAFB/wFxIgEgAEEAEC9GBEAgAkUNAQwDCyAEQYGChAhsIQMCQAJAIAJBA00NAANAIAMgAEEAEChzIgRB//37d2ogBEGAgYKEeHFBgIGChHhzcUUEQAEgAEEEaiEAIAJBfGoiAkEDSw0BDAILCwwBCyACRQ0BCwNAIABBABAvIAFB/wFxRg0DIABBAWohACACQX9qIgINAAsLC0EAIQALIAAL/wMDAX8BfgF8IAFBFE0EQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4KAAECAwQFBgcICQoLIAJBABAoQQNqQXxxIgFBABAoIQMgAkEAIAFBBGoQKSAAQQAgAxApDAkLIAJBABAoQQNqQXxxIgFBABAoIQMgAkEAIAFBBGoQKSAAQQAgA6wQLAwICyACQQAQKEEDakF8cSIBQQAQKCEDIAJBACABQQRqECkgAEEAIAOtECwMBwsgAkEAEChBB2pBeHEiAUEAECohBCACQQAgAUEIahApIABBACAEECwMBgsgAkEAEChBA2pBfHEiAUEAECghAyACQQAgAUEEahApIABBACADQf//A3FBEHRBEHWsECwMBQsgAkEAEChBA2pBfHEiAUEAECghAyACQQAgAUEEahApIABBACADQf//A3GtECwMBAsgAkEAEChBA2pBfHEiAUEAECghAyACQQAgAUEEahApIABB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akEAIAJB/wFzECsgAEEAECgQOCAGBEAgAEEAEChBDBAoIABBOBAoIABB3AAQKGogAyAGIAYgA0sbIgIQNhogAEEAECgiBkEMIAZBDBAoIAJqECkgAEEAECgiBkEQIAZBEBAoIAJrECkgAEEAECgiBkEUIAZBFBAoIAJqECkgAEHcACAAQdwAECggAmoQKSADIAJrIQMLIAMEQCAAQQAQKCICIAJBDBAoIAMQmQEaIABBABAoIgJBDCADIAJBDBAoahApIABBABAoIgJBECACQRAQKCADaxApIABBABAoIgJBFCADIAJBFBAoahApCyAAQQAQKCECIARFDQELCyANCyACQQQQKGsiAwR/An8gAyAAQSwQKCIESQR/IABBPBAoIABB7AAQKCICayADTQRAIABB7AAgAiAEayICECkgAEE4ECgiBiAEIAZqIAIQNhogAEGwLWoiAkEAECgiBEECSQRAIAJBACAEQQFqECkLCyAAQTgQKCAAQewAEChqIABBABAoQQAQKCADayADEDYaIABB7AAgAyAAQewAEChqIgIQKSAAQSwQKAUgAEGwLWpBAEECECkgAEE4ECggAkEAECggBGsgBBA2GiAAQewAIABBLBAoIgIQKSACCyEOIABB3AAgAhApIA4LIABBtC1qIgZBABAoIgdrIQQgBkEAIAcgBCADIAMgBEsbahApIAIFIABB7AAQKAshAyAAQcAtaiIEQQAQKCADSQRAIARBACADECkLIAUEQEEDDwsCQAJAIAEOBQEAAAABAAsgAEEAEChBBBAoRQRAIAMgAEHcABAoRgRAQQEPCwsLIABBABAoIgFBBBAoIgUgAEE8ECggA2tBf2oiAksEQCAAQdwAECgiByAAQSwQKCIGTgRAIABB3AAgByAGaxApIABB7AAgAyAGayIBECkgAEE4ECgiBSAFIAZqIAEQNhogAEGwLWoiAUEAECgiBUECSQRAIAFBACAFQQFqECkLIAIgAEEsEChqIQIgAEEAECgiAUEEECghBQsLIAUgAiACIAVLGyICBEAgASAAQTgQKCAAQewAEChqIAIQmQEaIABB7AAgAEHsABAoIAJqIgEQKQUgAEHsABAoIQELIARBABAoIAFJBEAgBEEAIAEQKQsCQAJAIAEgAEHcABAoIgNrIgEgAEEsECgiBSAAQQwQKCAJQQAQKEEqakEDdWsiAkH//wMgAkH//wNJGyICIAIgBUsbTw0AAkAgAQRAIAoNAQUgCEUNAQsgAEEAEChBBBAoQQBHIAEgAktyRQ0BCwwBCyAIBH8gAEEAEChBBBAoBH9BAAUgASACTQsFQQALIQUgACADIABBOBAoaiACIAEgASACSxsiASAFEHwgAEHcACAAQdwAECggAWoQKSAAQQAQKBA4IAUEQEECDwsLQQALoAIBBX8gABCYAQRAQX4PCyAAQRwQKCIBQQQQKCEEIAFBCBAoIgIEQCAAQSQQKCEBIABBKBAoIAIgAUEBcUE1ahEJACAAQRwQKCEBCyABQcQAECgiAgRAIABBJBAoIQEgAEEoECggAiABQQFxQTVqEQkAIABBHBAoIQELIAFBQGtBABAoIgIEQCAAQSQQKCEBIABBKBAoIAIgAUEBcUE1ahEJACAAQRwQKCEBCyABQTgQKCIFBEAgAEEkaiIDQQAQKCEBIABBKGoiAkEAECggBSABQQFxQTVqEQkAIABBHBAoIQEFIABBKGohAiAAQSRqIQMLIANBABAoIQMgAkEAECggASADQQFxQTVqEQkAIABBHEEAEClBfUEAIARB8QBGGwsuACABQgBTBH8gAgRAIAJBAEEEECkgAkEEQcsAECkLQX8FIAAgAUEAIAIQmgELCxcAIABCARA9IgBFBEAPCyAAQQAgARArCxcAIABCARA9IgBFBEBBAA8LIABBABAtC1oBAX9ByAAQNCIDRQRAQQAPCyADQQAgAhApIANBBCAAQQFxECsgA0EIQQkgASABQX9qQQhLGxApIANBDEEAECsgA0EwQQAQKSADQTRBABApIANBOEEAECkgAwscACABRQRAQQAPCyAAIAFBABAoIAFBBBAwrRBSC0IBAX8gAEUgAUVyBH8gACABRgUgAEEEEDEiAiABQQQQMUYEfyAAQQAQKCABQQAQKCACQf//A3EQS0UFQQALC0EBcQsnAQF/QQBBAEEAEDchASAARQRAIAEPCyABIABBABAoIABBBBAwEDcLoAIBAX4gAUEAECoiAkICg0IAUgRAIABBECABQRAQKhAsIAFBABAqIQILIAJCBINCAFIEQCAAQRggAUEYECoQLCABQQAQKiECCyACQgiDQgBSBEAgAEEgIAFBIBAqECwgAUEAECohAgsgAkIQg0IAUgRAIABBKCABQSgQKBApIAFBABAqIQILIAJCIINCAFIEQCAAQSwgAUEsECgQKSABQQAQKiECCyACQsAAg0IAUgRAIABBMCABQTAQMRAuIAFBABAqIQILIAJCgAGDQgBSBEAgAEEyIAFBMhAxEC4gAUEAECohAgsgAkKAAoNCAFEEQCAAQQAgAEEAECogAoQQLA8LIABBNCABQTQQKBApIABBACAAQQAQKiABQQAQKoQQLAuHBQEIfyMDIQUjA0FAayQDIwMjBE4EQEHAABAACwJAIABFDQAgAQRAIAFBMBAqIAJWBEAgA0EIcUUEQAJAIAFBQGtBABAoIgYgAqciB0EEdGpBCBAoRQRAIAdBBHQgBmpBDBAtQQFxRQ0BCyAAQQhqIgAEQCAAQQBBDxApIABBBEEAECkLDAQLCyABIAIgA0EIciAFEJwBQQBIBEAgAEEIaiIARQ0DIABBAEEUECkgAEEEQQAQKQwDCyADQSBxRSAFQTIQMUEAR3EhCCAFQTAQMSEJAn8CfwJAIAMgA0EDdkEEcXIiA0EEcUUiBw0AIAVBMBAxRQ0AQQAMAQtBAQshDCAIIARFcQRAIABBHBAoIgRFBEAgAEEIaiIARQ0FIABBAEEaECkgAEEEQQAQKQwFCwsgBUEgECpCAFEEQAJ/IABBAEIAQQAQoAEhCyAFJAMgCwsPCyABIAIgAyAAQQhqIgYQZiIDRQ0DIAFBABAoIAVBIBAqIAUgA0EMEDBBAXZBA3EgASACIAYQggMiA0UNAyADQSwgARApIAEgAxCAA0EASARAIAMQOgwECyAIBEBBAEEBIAVBMhAxIgZB//8DcUEBRxsiAQRAAkAgACADIAZBACAEIAFBAXFBIGoRAAAhASADEDogAQ0ADAYLBSAAQQhqIgBFDQUgAEEAQRgQKSAAQQRBABApDAULBSADIQELIAcgCUEAR3EEQCAAIAEgBUEwEDAQ2gEhAyABEDogA0UNBCADIQELIAwLBEAgACABQQEQ2QEhACABEDogAEUNAwUgASEACyAFJAMgAA8LCyAAQQhqIgAEQCAAQQBBEhApIABBBEEAECkLIAUkA0EADwsgBSQDQQALbgECfyMDIQIjA0EQaiQDIwMjBE4EQEEQEAALIABBJBAoQQFGBH8gAkEAIAEQLCACQQhBABApIAAgAkIQQQwQREI/h6chAyACJAMgAwUgAEEMaiIABEAgAEEAQRIQKSAAQQRBABApCyACJANBfwsLrQEAIANCEFQEfiAEBEAgBEEAQRIQKSAEQQRBABApC0J/BSACBH4CfgJAAkACQAJAAkAgAkEIECgOAwIAAQMLIAAgAkEAECp8IQAMAwsgASACQQAQKnwhAAwCCyACQQAQKiEADAELIAQEQCAEQQBBEhApIARBBEEAECkLQn8MAQsgAEIAUyAAIAFWcgR+IAQEQCAEQQBBEhApIARBBEEAECkLQn8FIAALCwVCfwsLC18BAX4gAxDXASIDBH8gAEEwIABBMBAoQQFqECkgA0EAIAAQKSADQQQgARApIANBCCACECkgA0EYQj8gACACQQBCAEEOIAFBB3FBJGoRBQAiBCAEQgBTGxAsIAMFQQALC48BAQF/QTgQNCIBBH8gAUEAQQAQKSABQQRBABApIAFBCEEAECkgAUEgQQAQKSABQSRBABApIAFBKEEAECsgAUEsQQAQKSABQTBBARApIAFBDEEAECkgAUEQQQAQKSABQRRBABApIAFBNEEAECsgAUE1QQAQKyABBSAABEAgAEEAQQ4QKSAAQQRBABApC0EACwtGAQF+IAIQ1wEiAgR/IAJBBCAAECkgAkEIIAEQKSACQRhCPyABQQBCAEEOIABBA3FBLGoRBAAiAyADQgBTGxAsIAIFQQALC54BAQF/IAFFBEAgAEEIaiIABEAgAEEAQRIQKSAAQQRBABApC0EADwtBOBA0IgMEfyADQQhBABApIANBDEEAECkgA0EQQQAQKSADQQAgAhApIANBBEEAECkgA0EoQgAQLCADQTBBAEEAQQAQNxApIANBGEIAECwgACABQQIgAxCfAQUgAEEIaiIABEAgAEEAQQ4QKSAAQQRBABApC0EACwsPACAAIAEgAkEAQQAQ3AELOgEBfyAARQRADwsgAEGowABqQQAQKEEEECghASAAQazAAGpBABAoIAFBA3FBMGoRAwAgABBUIAAQMguwAQEBfyABRQRAIABBCGoiAARAIABBAEESECkgAEEEQQAQKQtBAA8LQbCKAUHQigEgAxtBACACQf//A3FBCEYgAkF9S3IbIgVFBEAgAEEIaiIABEAgAEEAQRAQKSAAQQRBABApC0EADwsgAiADIAQgBRCOAyICRQRAIABBCGoiAARAIABBAEEOECkgAEEEQQAQKQtBAA8L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pwELBgBBpKcBCwgAQbSnARAkC6QBAQR/IwMhAiMDQRBqJAMjAyMETgRAQRAQAAsCQAJAIAAQRiIBQQZJDQAgACABakF6aiIEQYiaAUEGEEsNAEHkACEBAkADQCAEEKECIAJBAEGAAxApIAAgAhCzAiIDQX9KDQFBlKcBQQAQKEERRiABQX9qIgFBAEdxDQALIARBiJoBQQYQNhpBfyEDCwwBC0GUpwFBAEEWEClBfyEDCyACJAMgAwttAQN/IwMhASMDQRBqJAMjAyMETgRAQRAQAAtBACABECMaIAFBBHYgAGogAUEEEChBgYAEbHMhAgNAIAAgA2pBACACQQ9xQcEAaiACQQF0QSBxchArIAJBBXYhAiADQQFqIgNBBkcNAAsgASQDC1EBAX8jAyECIwNBEGokAyMDIwROBEBBEBAACyACQQAgABApIAJBBCABEClBJiACEB0iAEGAYEsEQEGUpwFBAEEAIABrEClBfyEACyACJAMgAAu+AQECfyACQcwAECgaIAJBygAgAkHKABAtIgQgBEH/AWpyECsgAkEIECggAkEEECgiBGsiA0EASgR/IAAgBCADIAEgAyABSRsiAxA2GiACQQQgAyACQQQQKGoQKSAAIANqIQAgASADawUgAQsiBARAAkADQAJAIAIQvwINACACQSAQKCEDIAIgACAEIANBD3FBEGoRBgAiA0EBakECSQ0AIAAgA2ohACAEIANrIgQNAQwCCwsgASAEayEBCwsgAQtnAQF/IABBKBAoIQEgAEEAIABBABAoQYABcQR/QQJBASAAQRQQKCAAQRwQKEsbBUEBCyABQQ9xQRBqEQYAIgFBAE4EQCAAQRQQKCAAQQQQKCABIABBCBAoa2pqIABBHBAoayEBCyABC0sBAX8jAyECIwNBEGokAyMDIwROBEBBEBAACyACQQAgABApIAJBBCABEClBDyACEB8iAEGAYEsEQEGUpwFBAEEAIABrECkLIAIkAwsuAQF/IAEEQAJAA38gACABQX9qIgFqIgJBABAtQS9GDQEgAQ0AQQALIQILCyACC7QBAQF/IAJBAUYEQCAAQQQQKCABIABBCBAoa2ohAQsCfwJAIABBFBAoIABBHBAoTQ0AIABBJBAoIQMgAEEAQQAgA0EPcUEQahEGABogAEEUECgNAEF/DAELIABBEEEAECkgAEEcQQAQ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EAALIAJBACABECkgAkEAEChBA2pBfHEiAUEAECghAyACQQAgAUEEahApIAJBEGoiAUEAIAAQKSABQQRBwoECECkgAUEIIAMQKUEFIAEQCiIAQYBgSwRAQZSnAUEAQQAgAGsQKUF/IQALIAIkAyAAC7cBAQN/IABBAEH1mQFBABBWEFUgAEEIQf2ZAUEAEIcCEIECIABBDEGBmgFBABCIAhCEAiAAQQ5Bg5oBQQAQLRArIAEEQCABIQJBDiEDA0AgAkEKbiEEIANBAWohAyACQQpPBEAgBCECDAELCyAAIANqQQBBABArA0AgACADQX9qIgNqQQAgASABQQpuIgJBdmxqQTByECsgAUEKTwRAIAIhAQwBCwsFIABBDkEwECsgAEEPQQAQKwsLzQEBBH8jAyECIwNBMGokAyMDIwROBEBBMBAACyACQShqIQQgAkEgaiIDQQAgABApIANBBCABEClBxQEgAxAeIgNBd0YEfyACQQAgABApIAJBBEEBEClB3QEgAhAEQQBIBH9BlKcBQQBBCRApQX8FIAIgABC0AiAEQQAgAhApIARBBCABEClBwwEgBBALIgBBgGBLBH9BlKcBQQBBACAAaxApQX8FIAALCwUgA0GAYEsEf0GUpwFBAEEAIANrEClBfwUgAwsLIQUgAiQDIAULTQEBfyMDIQEjA0EQaiQDIwMjBE4EQEEQEAALIAFBACAAEClBAEEGIAEQBiIAIABBfEYbIgBBgGBLBEBBlKcBQQBBACAAaxApCyABJAMLOQECfyACIABBEBAoIABBFBAoIgRrIgMgAyACSxshAyAEIAEgAxA2GiAAQRQgAEEUECggA2oQKSACC24BAX8gAEHKACAAQcoAEC0iASABQf8BanIQKyAAQQAQKCIBQQhxBH8gAEEAIAFBIHIQKUF/BSAAQQhBABApIABBBEEAECkgAEEcIABBLBAoIgEQKSAAQRQgARApIABBECABIABBMBAoahApQQALC7QCACAABH8CfyABQYABSQRAIABBACABECtBAQwBC0HkjgFBABAoQQAQKEUEQCABQYB/cUGAvwNGBEAgAEEAIAEQK0EBDAIFQZSnAUEAQdQAEClBfwwCCwALIAFBgBBJBEAgAEEAIAFBBnZBwAFyECsgAEEBIAFBP3FBgAFyECtBAgwBCyABQYBAcUGAwANGIAFBgLADSXIEQCAAQQAgAUEMdkHgAXIQKyAAQQEgAUEGdkE/cUGAAXIQKyAAQQIgAUE/cUGAAXIQK0EDDAELIAFBgIB8akGAgMAASQR/IABBACABQRJ2QfABchArIABBASABQQx2QT9xQYABchArIABBAiABQQZ2QT9xQYABchArIABBAyABQT9xQYABchArQQQFQZSnAUEAQdQAEClBfwsLBUEBCwv1FwMTfwN+AXwjAyEVIwNBsARqJAMjAyMETgRAQbAEEAALIBVBmARqIgtBAEEAECkgAb0iGUIAUwR/IAGaIhwhAUHQmQEhESAcvSEZQQEFQdOZAUHWmQFB0ZkBIARBAXEbIARBgBBxGyERIARBgRBxQQBHCyESIBVBIGohByAVIg4hECAOQZwEaiIJQQxqIQ8gGUKAgICAgICA+P8Ag0KAgICAgICA+P8AUQR/IABBICACIBJBA2oiAyAEQf//e3EQQSAAIBEgEhA/IABB65kBQe+ZASAFQSBxQQBHIgUbQeOZAUHnmQEgBRsgASABYhtBAxA/IABBICACIAMgBEGAwABzEEEgAwUCfyABIAsQuAFEAAAAAAAAAECiIgFEAAAAAAAAAABiIgYEQCALQQAgC0EAEChBf2oQKQsgBUEgciINQeEARgRAIBFBCWogESAFQSBxIgwbIQhBDCADayIHRSADQQtLckUEQEQAAAAAAAAgQCEcA0AgHEQAAAAAAAAwQKIhHCAHQX9qIgcNAAsgCEEAEC1BLUYEfCAcIAGaIByhoJoFIAEgHKAgHKELIQELIA9BACALQQAQKCIGayAGIAZBAEgbrCAPEGciB0YEQCAJQQtqIgdBAEEwECsLIBJBAnIhCiAHQX9qQQAgBkEfdUECcUErahArIAdBfmoiB0EAIAVBD2oQKyADQQFIIQkgBEEIcUUhCyAOIQUDQCAFQQAgDCABqiIGQaD7AGpBABAvchArIAEgBrehRAAAAAAAADBAoiEBIAVBAWoiBiAQa0EBRgR/IAsgCSABRAAAAAAAAAAAYXFxBH8gBgUgBkEAQS4QKyAFQQJqCwUgBgshBSABRAAAAAAAAAAAYg0ACwJ/AkAgA0UNACAFQX4gEGtqIANODQAgDyADQQJqaiAHayEJIAcMAQsgBSAPIBBrIAdraiEJIAcLIQMgAEEgIAIgCSAKaiIGIAQQQSAAIAggChA/IABBMCACIAYgBEGAgARzEEEgACAOIAUgEGsiBRA/IABBMCAJIAUgDyADayIDamtBAEEAEEEgACAHIAMQPyAAQSAgAiAGIARBgMAAcxBBIAYMAQsgBgRAIAtBACALQQAQKEFkaiIIECkgAUQAAAAAAACwQaIhAQUgC0EAECghCAsgByAHQaACaiAIQQBIGyIJIQYDQCAGQQAgAasiBxApIAZBBGohBiABIAe4oUQAAAAAZc3NQaIiAUQAAAAAAAAAAGINAAsgCEEASgRAIAkhBwNAIAhBHSAIQR1IGyEMIAZBfGoiCCAHTwRAIAytIRpBACEKA0AgCEEAIAqtIAhBABAorSAahnwiG0KAlOvcA4AiGUKA7JSjfH4gG3wQdCAZpyEKIAhBfGoiCCAHTw0ACyAKBEAgB0F8aiIHQQAgChApCwsgBiAHSwRAAkADfyAGQXxqIghBABAoDQEgCCAHSwR/IAghBgwBBSAICwshBgsLIAtBACALQQAQKCAMayIIECkgCEEASg0ACwUgCSEHC0EGIAMgA0EASBshDCAIQQBIBEAgDEEZakEJbUEBaiETIA1B5gBGIRYgBiEDA0BBACAIayIGQQkgBkEJSBshCiAJIAcgA0kEf0EBIAp0QX9qIRRBgJTr3AMgCnYhF0EAIQggByEGA0AgBkEAIAggBkEAECgiCCAKdmoQKSAXIAggFHFsIQggBkEEaiIGIANJDQALIAcgB0EEaiAHQQAQKBshGCAIBH8gA0EAIAgQKSADQQRqBSADCyEGIBgFIAMhBiAHIAdBBGogB0EAECgbCyIDIBYbIgcgE0ECdGogBiAGIAdrQQJ1IBNKGyEIIAtBACAKIAtBABAoaiIGECkgBkEASARAIAMhByAIIQMgBiEIDAELCwUgByEDIAYhCAsgCSELIAMgCEkEQCALIANrQQJ1QQlsIQcgA0EAECgiCUEKTwRAQQohBgNAIAdBAWohByAJIAZBCmwiBk8NAAsLBUEAIQcLIAxBACAHIA1B5gBGG2sgDUHnAEYiEyAMQQBHIhZxQR90QR91aiIGIAggC2tBAnVBCWxBd2pIBH8gBkGAyABqIgZBCW0iDUF3bCAGaiIGQQhIBEBBCiEJA0AgBkEBaiEKIAlBCmwhCSAGQQdIBEAgCiEGDAELCwVBCiEJCyAJIA1BAnQgC2pBhGBqIgZBABAoIg0gCW4iFGwhCiAIIAZBBGpGIhcgDSAKayINRXFFBEBEAQAAAAAAQENEAAAAAAAAQEMgFEEBcRshAUQAAAAAAADgP0QAAAAAAADwP0QAAAAAAAD4PyAXIA0gCUEBdiIURnEbIA0gFEkbIRwgEgRAIByaIBwgEUEAEC1BLUYiDRshHCABmiABIA0bIQELIAZBACAKECkgASAcoCABYgRAIAZBACAJIApqIgcQKSAHQf+T69wDSwRAA0AgBkEAQQAQKSAGQXxqIgYgA0kEQCADQXxqIgNBAEEAECkLIAZBACAGQQAQKEEBaiIHECkgB0H/k+vcA0sNAAsLIAsgA2tBAnVBCWwhByADQQAQKCIKQQpPBEBBCiEJA0AgB0EBaiEHIAogCUEKbCIJTw0ACwsLCyAHIQogBkEEaiIHIAggCCAHSxshBiADBSAHIQogCCEGIAMLIQcgBiAHSwR/An8gBiEDA38gA0F8aiIGQQAQKARAIAMhBkEBDAILIAYgB0sEfyAGIQMMAQVBAAsLCwVBAAshDSATBH8gFkEBcyAMaiIDIApKIApBe0pxBH8gA0F/aiAKayEIIAVBf2oFIANBf2ohCCAFQX5qCyEFIARBCHEEfyAIBSANBEAgBkF8akEAECgiDARAIAxBCnAEQEEAIQMFQQAhA0EKIQkDQCADQQFqIQMgDCAJQQpsIglwRQ0ACwsFQQkhAwsFQQkhAwsgBiALa0ECdUEJbEF3aiEJIAVBIHJB5gBGBH8gCCAJIANrIgNBACADQQBKGyIDIAggA0gbBSAIIAkgCmogA2siA0EAIANBAEobIgMgCCADSBsLCwUgDAshA0EAIAprIQkgAEEgIAIgBUEgckHmAEYiDAR/QQAhCCAKQQAgCkEAShsFIA8gCSAKIApBAEgbrCAPEGciCWtBAkgEQANAIAlBf2oiCUEAQTAQKyAPIAlrQQJIDQALCyAJQX9qQQAgCkEfdUECcUErahArIAlBfmoiCEEAIAUQKyAPIAhrCyADIBJBAWpqQQEgBEEDdkEBcSADQQBHIhMbamoiCiAEEEEgACARIBIQPyAAQTAgAiAKIARBgIAEcxBBIAwEQCAOQQlqIgkhCCAOQQhqIQ8gCyAHIAcgC0sbIgwhBwNAIAdBABAorSAJEGchBSAHIAxGBEAgBSAJRgRAIA9BAEEwECsgDyEFCwUgBSAOSwRAIA5BMCAFIBBrEEUaA0AgBUF/aiIFIA5LDQALCwsgACAFIAggBWsQPyAHQQRqIgUgC00EQCAFIQcMAQsLIARBCHFFIBNBAXNxRQRAIABB85kBQQEQPwsgAEEwIAUgBkkgA0EASnEEfwN/IAVBABAorSAJEGciByAOSwRAIA5BMCAHIBBrEEUaA0AgB0F/aiIHIA5LDQALCyAAIAcgA0EJIANBCUgbED8gA0F3aiEHIAVBBGoiBSAGSSADQQlKcQR/IAchAwwBBSAHCwsFIAMLQQlqQQlBABBBBSAAQTAgByAGIAdBBGogDRsiEkkgA0F/SnEEfyAEQQhxRSERIA5BCWoiCyENQQAgEGshECAOQQhqIQwgAyEFIAchBgN/IAsgBkEAECitIAsQZyIDRgRAIAxBAEEwECsgDCEDCwJAIAYgB0YEQCADQQFqIQkgACADQQEQPyARIAVBAUhxBEAgCSEDDAILIABB85kBQQEQPyAJIQMFIAMgDk0NASAOQTAgAyAQahBFGgNAIANBf2oiAyAOSw0ACwsLIAAgAyANIANrIgMgBSAFIANKGxA/IAZBBGoiBiASSSAFIANrIgVBf0pxDQAgBQsFIAMLQRJqQRJBABBBIAAgCCAPIAhrED8LIABBICACIAogBEGAwABzEEEgCgsLIQAgFSQDIAIgACAAIAJIGwsvACAAQgBSBEADQCABQX9qIgFBACAAp0EHcUEwchArIABCA4giAEIAUg0ACwsgAQs4ACAAQgBSBEADQCABQX9qIgFBACACIACnQQ9xQaD7AGpBABAvchArIABCBIgiAEIAUg0ACwsgAQvWAgEFfyMDIQMjA0HgAWokAyMDIwROBEBB4AEQAAsgA0GgAWoiBEEAQgAQLCAEQQhCABAsIARBEEIAECwgBEEYQgAQLCAEQSBCABAsIANB0AFqIgVBACACQQAQKBApQQAgASAFIANB0ABqIgIgBBCTAUEATgRAIABBzAAQKBogAEEAECghBiAAQcoAEC1BAUgEQCAAQQAgBkFfcRApCyAAQTAQKARAIAAgASAFIAIgBBCTARoFIABBLBAoIQcgAEEsIAMQKSAAQRwgAxApIABBFCADECkgAEEwQdAAECkgAEEQIANB0ABqECkgACABIAUgAiAEEJMBGiAHBEAgAEEkECghASAAQQBBACABQQ9xQRBqEQYAGiAAQSwgBxApIABBMEEAECkgAEEQQQAQKSAAQRxBABApIABBFEEAECkLCyAAQQAgAEEAECggBkEgcXIQKQsgAyQDC/sCAQJ/IwMhAyMDQYABaiQDIwMjBE4EQEGAARAACyADQQBBrIwBQQAQQhA5IANBCEG0jAFBABBCEDkgA0EQQbyMAUEAEEIQOSADQRhBxIwBQQAQQhA5IANBIEHMjAFBABBCEDkgA0EoQdSMAUEAEEIQOSADQTBB3IwBQQAQQhA5IANBOEHkjAFBABBCEDkgA0FAa0EAQeyMAUEAEEIQOSADQcgAQfSMAUEAEEIQOSADQdAAQfyMAUEAEEIQOSADQdgAQYSNAUEAEEIQOSADQeAAQYyNAUEAEEIQOSADQegAQZSNAUEAEEIQOSADQfAAQZyNAUEAEEIQOSADQfgAQaSNAUEAECgQKSADQTBBfiAAayIEQf////8HIARB/////wdJGyIEECkgA0EUIAAQKSADQSwgABApIANBECAAIARqIgAQKSADQRwgABApIAMgASACEL0CIAQEQCADQRQQKCIAIAAgA0EQEChGQR90QR91akEAQQAQKwsgAyQDC54BAQJ/IABBygAgAEHKABAtIgEgAUH/AWpyECsgAEEUECggAEEcEChLBEAgAEEkECghASAAQQBBACABQQ9xQRBqEQYAGgsgAEEQQQAQKSAAQRxBABApIABBFEEAECkgAEEAECgiAUEEcQR/IABBACABQSByEClBfwUgAEEIIABBLBAoIABBMBAoaiICECkgAEEEIAIQKSABQRt0QR91Cwt5AQN/IwMhAyMDQSBqJAMjAyMETgRAQSAQAAsgA0EQaiEEIABBJEEIECkgAEEAEChBwABxRQRAIANBACAAQTwQKBApIANBBEGTqAEQKSADQQggBBApQTYgAxAJBEAgAEHLAEF/ECsLCyAAIAEgAhC+ASEFIAMkAyAFC4oCAQR/IwMhBCMDQSBqJAMjAyMETgRAQSAQAAsgBEEAIAEQKSAEQQQgAiAAQTAQKCIDQQBHaxApIARBCCAAQSwQKBApIARBDCADECkgBEEQaiIDQQAgAEE8ECgQKSADQQQgBBApIANBCEECEClBkQEgAxAgIgNBgGBLBEBBlKcBQQBBACADaxApQX8hAwsgA0EBSARAIABBACAAQQAQKCADQTBxQRBzchApIAMhAgUgAyAEQQQQKCIGSwRAIABBBCAAQSwQKCIFECkgAEEIIAUgAyAGa2oQKSAAQTAQKARAIABBBCAFQQFqECkgASACQX9qakEAIAVBABAtECsLBSADIQILCyAEJAMgAgsGAEGUpwELiwEBAn8jAyEDIwNBIGokAyMDIwROBEBBIBAACyADQQAgAEE8ECgQKSADQQRBABApIANBCCABECkgA0EMIANBFGoQKSADQRAgAhApQYwBIAMQISIAQYBgSwR/QZSnAUEAQQAgAGsQKUF/BSAAC0EASAR/IANBFEF/EClBfwUgA0EUECgLIQQgAyQDIAQLTQEBfyMDIQEjA0EQaiQDIwMjBE4EQEEQEAALIAFBACAAQTwQKBApQQYgARAGIgBBgGBLBEBBlKcBQQBBACAAaxApQX8hAAsgASQDIAALrQYBFH8gAEEQdiEEIABB//8DcSEAIAJBAUYEQCAEIAAgAUEAEC9qIgBBj4B8aiAAIABB8P8DSxsiAmoiAUEQdCIAQYCAPGogACABQfD/A0sbIAJyDwsgAUUEQEEBDwsgAkEQSQRAA0AgAgRAIAAgAUEAEC9qIQAgAUEBaiEBIAJBf2ohAiAAIARqIQQMAQsLIARB8f8DcEEQdCAAQY+AfGogACAAQfD/A0sbcg8LIAEhBSAEIQEDQCACQa8rSwRAAn8gAkHQVGohFkHbAiEDIAUhAgNAIAAgAkEAEC9qIgcgAkEBEC9qIgggAkECEC9qIgkgAkEDEC9qIgogAkEEEC9qIgsgAkEFEC9qIgwgAkEGEC9qIg0gAkEHEC9qIg4gAkEIEC9qIg8gAkEJEC9qIhAgAkEKEC9qIhEgAkELEC9qIhIgAkEMEC9qIhMgAkENEC9qIhQgAkEOEC9qIgAgAkEPEC9qIQYgFCABIAdqIAhqIAlqIApqIAtqIAxqIA1qIA5qIA9qIBBqIBFqIBJqIBNqaiAAaiAGaiEBIAJBEGohAiADQX9qIgAEQCAAIQMgBiEADAELCyAFQbAraiEFIBYLIQIgAUHx/wNwIQEgBkHx/wNwIQAMAQsLIAIEQCACIAIgAkF/cyIEQXAgBEFwSxtqQRBqQXBxIhVrIQQgBSEDA0AgAkEPSwRAIAAgA0EAEC9qIgcgA0EBEC9qIgggA0ECEC9qIgkgA0EDEC9qIgogA0EEEC9qIgsgA0EFEC9qIgwgA0EGEC9qIg0gA0EHEC9qIg4gA0EIEC9qIg8gA0EJEC9qIhAgA0EKEC9qIhEgA0ELEC9qIhIgA0EMEC9qIhMgA0ENEC9qIhQgA0EOEC9qIgYgA0EPEC9qIQAgAkFwaiECIANBEGohAyABIAdqIAhqIAlqIApqIAtqIAxqIA1qIA5qIA9qIBBqIBFqIBJqIBNqIBRqIAZqIABqIQEMAQsLIAUgFWohAgNAIAQEQCAAIAJBABAvaiEAIARBf2ohBCACQQFqIQIgACABaiEBDAELCyABQfH/A3AhASAAQfH/A3AhAAsgACABQRB0cgsGACABEDILCQAgASACbBA0C4cFAgd/A34jAyEFIwNB8ABqJAMjAyMETgRAQfAAEAALAkACQCAAQQAQKBBYIgtCAFMNACAAQUBrIQYDQCAKIAJUBEAgACAGQQAQKCIDIAqnQQN0IAFqQQAQKqciB0EEdGoiCEEEaiAHQQR0IANqIAhBBBAoG0EAEChBgAQQeyIDQQBIDQMgBCADQQBHciEEIApCAXwhCgwBCwsgAEEAECgQWCIMQgBTDQAgBULiABBHIgNFBEAgAEEIakUNAiAAQQhBDhApIABBDEEAECkMAgsgDCALfSEKIAQgC0L/////D1YgAkL//wNWcnIEQCADQdOPAUEEEGggA0IsEEwgA0EtED4gA0EtED4gA0EAEEAgA0EAEEAgAyACEEwgAyACEEwgAyAKEEwgAyALEEwgA0HOjwFBBBBoIANBABBAIAMgDBBMIANBARBACyADQcmPAUEEEGggA0EAEEAgAkL+/wNWBEAgA0F/ED5BfyEBBSADIAKnQf//A3EiARA+CyADIAEQPiADQX8gCqcgCkL+////D1YbEEAgA0F/IAunIAtC/v///w9WGxBAIAMgAEEkaiAAQSBqIABBKBAtQQFxG0EAECgiAUUiBgR/QQAFIAFBBBAxCxA+IANBABAtQQFxRQRAIABBCGoEQCAAQQhBFBApIABBDEEAECkLIAMQNQwCCwJ/IAAgA0EEECgCfkIAIANBABAtQQFxRQ0AGiADQRAQKgsQUkEASCEJIAMQNSAJCw0BIAZFBEAgACABQQAQKCABQQQQMK0QUkEASA0CCyAFJAMgCg8LIABBABAoIQEgAEEIaiIABEAgAEEAIAFBDBAoECkgAEEEIAFBEBAoECkLCyAFJANCfws7AQN/A0AgAiAAQQFxciIDQQF0IQIgAEEBdiEAIAFBf2ohBCABQQFKBEAgBCEBDAELCyADQf////8HcQu7AQEEfyMDIQYjA0EgaiQDIwMjBE4EQEEgEAALQQEhAwNAIANBEEcEQCADQQF0IAZqQQAgBCADQX9qQQF0IAJqQQAQMGpBAXQiBBAuIANBAWohAwwBCwsDQCAFIAFMBEAgBUECdCAAakECEDEiAkH//wNxIQMgAgRAIANBAXQgBmoiAkEAEDEhBCACQQAgBEEBahAuIAVBAnQgAGpBACAEQf//A3EgAxDJAhAuCyAFQQFqIQUMAQsLIAYkAwuyBQENfyADQQAQKCEJIANBBBAoIQ4gA0EIECghCCADQRAQKCEGQQAhAwNAIANBEEcEQCAAQbwWaiADQQF0akEAQQAQLiADQQFqIQMMAQsLIABB3BZqIABB1ChqIgNBABAoQQJ0akEAEChBAnQgAWpBAkEAEC4gAEGoLWohCiAJRSEPIABBrC1qIQsgA0EAECghBANAAkAgBEEBaiEDIARBvARODQAgBiAAQdwWaiADQQJ0akEAECgiBEECdCABaiIHQQIQMEECdCABakECEDAiDEohDSAHQQIgDEEBaiAGIA0bIgwQLiAEIAJMBEAgAEG8FmogDEEBdGoiB0EAIAdBABAxQQFqEC4gCkEAIApBABAoIARBAnQgAWpBABAwIhAgBCAISAR/QQAFIAQgCGtBAnQgDmpBABAoCyIHIAxqbGoQKSAPRQRAIAtBACALQQAQKCAQIAcgBEECdCAJakECEDBqbGoQKQsLIAUgDUEBc2ohBSADIQQMAQsLIAVFBEAPCyAAQbwWaiAGQQF0aiEJIAUhBANAIAYhBQNAIABBvBZqIAVBf2oiB0EBdGoiCEEAEDEiC0UEQCAHIQUMAQsLIAhBACALQX9qEC4gAEG8FmogBUEBdGoiBUEAIAVBABAwQQJqEC4gCUEAIAlBABAxQX9qEC4gBEF+aiEFIARBAkoEQCAFIQQMAQsLA0AgBgRAIAZB//8DcSEJIABBvBZqIAZBAXRqQQAQMCEFA0ACQCAFRSEIIAMhBANAIAgNASAAQdwWaiAEQX9qIgRBAnRqQQAQKCIHIAJKDQALIAdBAnQgAWoiA0ECEDAiCCAGRwRAIApBACAKQQAQKCAHQQJ0IAFqQQAQMCAGIAhrbGoQKSADQQIgCRAuCyAFQX9qIQUgBCEDDAELCyAGQX9qIQYMAQsLC7MGARB/IABBuC1qIgRBABAwIAFB//0DakH//wNxIgkgAEG8LWoiCEEAECgiBnRyIQUgBEEAIAUQLiAIQQAgBkELSgR/An8gAEEIECghDSAAQRQgAEEUECgiB0EBahApIA0LIAdqQQAgBRArIARBABAwQQh2IQUCfyAAQQgQKCEOIABBFCAAQRQQKCIHQQFqECkgDgsgB2pBACAFECsgBEEAIAlBECAIQQAQKCIEa3YiBRAuIARBdWoFIAZBBWoLIgQQKSAAQbgtaiIGQQAgBUH//wNxIAJB//8DakH//wNxIgkgBHRyIgUQLiAIQQAgBEELSgR/An8gAEEIECghDyAAQRQgAEEUECgiB0EBahApIA8LIAdqQQAgBRArIAZBABAwQQh2IQUCfyAAQQgQKCEQIABBFCAAQRQQKCIHQQFqECkgEAsgB2pBACAFECsgBkEAIAlBECAIQQAQKCIEa3YiBRAuIARBdWoFIARBBWoLIgQQKSAAQbgtaiIHQQAgBUH//wNxIANB/P8DakH//wNxIgogBHRyIgUQLiAEQQxKBEAgAEEIaiIJQQAQKCELIABBFGoiBkEAECghBCAGQQAgBEEBahApIAQgC2pBACAFECsgB0EAEDBBCHYhBQJ/IAlBABAoIREgBkEAIAZBABAoIgtBAWoQKSARCyALakEAIAUQKyAHQQAgCkEQIAhBABAoIgRrdiIFEC4gCEEAIARBdGoiBBApBSAIQQAgBEEEaiIEECkgAEEIaiEJIABBFGohBgtBACEKA0AgCiADSARAIAdBACAFQf//A3EgACAKQYD1AGpBABAvQQJ0akH+FGpBABAwIgsgBHRyIgUQLiAIQQAgBEENSgR/An8gCUEAECghEiAGQQAgBkEAECgiDEEBahApIBILIAxqQQAgBRArIAdBABAwQQh2IQUCfyAJQQAQKCETIAZBACAGQQAQKCIMQQFqECkgEwsgDGpBACAFECsgB0EAIAtBECAIQQAQKCIEa3YiBRAuIARBc2oFIARBA2oLIgQQKSAKQQFqIQoMAQsLIAAgAEGUAWogAUF/ahDBASAAIABBiBNqIAJBf2oQwQELiwEBAX8gACAAQZQBaiAAQZwWakEAECgQwAEgACAAQYgTaiAAQagWakEAECgQwAEgACAAQbAWahCWAUESIQEDQAJAIAFBAk0NACAAIAFBgPUAakEAEC9BAnRqQf4UakEAEDENACABQX9qIQEMAQsLIABBqC1qIgBBACAAQQAQKCABQQNsQRFqahApIAELrgEBA39B/4D/n38hAgNAAkAgAUEgTw0AIAJBAXEEQCAAQZQBaiABQQJ0akEAEDEEQEENIQMMAgsLIAFBAWohASACQQF2IQIMAQsLIANBDUYEQEEADwsgAEG4ARAxBEBBAQ8LIABBvAEQMQRAQQEPCyAAQcgBEDEEQEEBDwtBICEBA38gAUGAAk8Ef0EABSAAQZQBaiABQQJ0akEAEDEEf0EBBSABQQFqIQEMAgsLCwvFAgEJfyAAQbgtaiIBQQAQMEECIABBvC1qIgRBABAoIgJ0ciEDIAFBACADEC4gBEEAIAJBDUoEfwJ/IABBCBAoIQYgAEEUIABBFBAoIgVBAWoQKSAGCyAFakEAIAMQKyABQQAQMEEIdiEDAn8gAEEIECghByAAQRQgAEEUECgiBUEBahApIAcLIAVqQQAgAxArIAFBAEECQRAgBEEAECgiAWt2IgMQLiABQXNqBSACQQNqCyIBECkgAUEJSgRAAn8gAEEIECghCCAAQRQgAEEUECgiAkEBahApIAgLIAJqQQAgAxArIABBuC1qIgNBABAwQQh2IQECfyAAQQgQKCEJIABBFCAAQRQQKCIFQQFqECkgCQsgBWpBACABECsgA0EAQQAQLiAEQQAgBEEAEChBd2oQKQUgBEEAIAFBB2oQKQsgABDEAQt5ACAAQZgWakEAIABBlAFqECkgAEGgFmpBAEHwigEQKSAAQaQWakEAIABBiBNqECkgAEGsFmpBAEGEiwEQKSAAQbAWakEAIABB/BRqECkgAEG4FmpBAEGYiwEQKSAAQbgtakEAQQAQLiAAQbwtakEAQQAQKSAAEMYBC90NASF/IABBABAoIgUgAEEEEChBe2pqIQ8gAEEMECgiBiAAQRAQKCICQf99amohECAAQRwQKCIJQSwQKCETIAlBMBAoIRQgCUE4ECghDSAJQdAAECghFSAJQdQAECghFkEBIAlB2AAQKHRBf2ohF0EBIAlB3AAQKHRBf2ohGCAJQcQ3aiEZIAlBNBAoIgxFIRogDCATaiEbIAYgAiABa2oiESAMayEcIAlBQGsiHUEAECghAiAJQTwQKCEIAkACQAJAAkADfyACQQ9JBH8gAkEQaiEDIAggBUEAEC8gAnRqIAVBARAvIAJBCGp0aiEIIAVBAmoFIAIhAyAFCyEBIAMhAiAIIBdxIQUCQAJAA0ACQCAFQQJ0IBVqQQAQXSIFQRB2IQMgCCAFQQh2Qf8BcSIEdiEIIAIgBGshAiAFQf8BcUUNACAFQRBxDQIgBUHAAHENByADQQEgBUH/AXF0QX9qIAhxaiEFDAELCyAGQQAgAxArIAZBAWohBgwBCyAFQQ9xIgcEQCACIAdJBH8gAkEIaiEEIAggAUEAEC8gAnRqIQggAUEBagUgAiEEIAELIQUgAyAIQQEgB3RBf2pxaiEDIAQgB2shAiAIIAd2IQgFIAEhBQsgAkEPSQR/IAJBEGohBCAIIAVBABAvIAJ0aiAFQQEQLyACQQhqdGohCCAFQQJqBSACIQQgBQshASAEIQUgCCAYcSECA0ACQCACQQJ0IBZqQQAQXSICQRB2IQogCCACQQh2Qf8BcSIEdiEIIAUgBGshBSACQRBxDQAgAkHAAHENBSAKQQEgAkH/AXF0QX9qIAhxaiECDAELCyAFIAJBD3EiB0kEfyABQQFqIQIgAUEAEC8gBXQgCGohCCAFQQhqIgQgB0kEfyABQQJqIQEgBUEQaiEFIAggAkEAEC8gBHRqBSACIQEgBCEFIAgLBSAICyICIAd2IQggBSAHayEFIAogAkEBIAd0QX9qcSISaiIOIAYiAiARayIETQRAIAIgDmshBANAIAJBACAEQQAQLRArIAJBASAEQQEQLRArIARBA2ohByACQQNqIQYgAkECIARBAhAtECsgA0F9aiIDQQJLBEAgByEEIAYhAgwBCwsgA0UEQCAFIQIMAgsgAkEEaiELIAZBACAHQQAQLRArIANBAUYEQCALIQYgBSECDAILIAtBACAEQQQQLRArIAJBBWohBiAFIQIMAQsgDiAEayIEIBRLBEAgGUEAECgNAwsgGgRAIBMgBGsgDWohByADIARLBH8CfyADIARrIR8CfyAKIBJqIAJrIR4gByEDA0AgAkEBaiEHIAJBACADQQAQLRArIANBAWohAyAEQX9qIgQEQCAHIQIMAQsLIB4LIAYgEWpqIgMhBiAfCyECIAMgDmsFIAIhBiADIQIgBwshAwUCQCAMIARPBEAgDCAEayANaiEHIAMgBE0EQCACIQYgAyECIAchAwwCCwJ/IAMgBGshIQJ/IAogEmogAmshICAHIQMDQCACQQFqIQcgAkEAIANBABAtECsgA0EBaiEDIARBf2oiBARAIAchAgwBCwsgIAsgBiARamoiAyEGICELIQIgAyAOayEDDAELIBsgBGsgDWohByADIAQgDGsiBEsEQCADIARrIQsgCiASaiACayEKIAchAwNAIAJBAWohByACQQAgA0EAEC0QKyADQQFqIQMgBEF/aiIEBEAgByECDAELCyAKIAYgHGpqIQQgCyAMSwR/An8gBiARaiEiIAwhAyANIQIgBCEGA0AgBkEBaiEEIAZBACACQQAQLRArIAJBAWohAiADQX9qIgMEQCAEIQYMAQsLICILIApqIgMhBiADIA5rIQMgCyAMawUgBCEGIA0hAyALCyECBSACIQYgAyECIAchAwsLCwNAIAJBAksEQCAGQQAgA0EAEC0QKyAGQQEgA0EBEC0QKyAGQQIgA0ECEC0QKyADQQNqIQMgBkEDaiEGIAJBfWohAgwBCwsgAgR/IAZBAWohBCAGQQAgA0EAEC0QKyACQQFGBEAgBCEGBSAEQQAgA0EBEC0QKyAGQQJqIQYLIAUFIAULIQILIAEgD0kgBiAQSXEEfyABIQUMAQUgAgsLIQUMAwsgAEEYQfuXARApIAlBBEHR/gAQKQwCCyAAQRhBmZgBECkgCUEEQdH+ABApDAELIAVBIHEEQCAJQQRBv/4AECkFIABBGEGvmAEQKSAJQQRB0f4AECkLIAIhBQsgAEEAIAEgBUEDdmsiARApIABBDCAGECkgAEEEIA8gAWtBBWoQKSAAQRAgECAGa0GBAmoQKSAJQTwgCEEBIAVBB3EiAHRBf2pxECkgHUEAIAAQKQuEAQEEfyAAEG4EQEF+DwsgAEEcECgiAUE4ECgiBARAIABBJGoiA0EAECghAiAAQShqIgFBABAoIAQgAkEBcUE1ahEJACABIQIgAEEcECghAQUgAEEoaiECIABBJGohAwsgA0EAECghAyACQQAQKCABIANBAXFBNWoRCQAgAEEcQQAQKUEAC7cCAQN/IABBHBAoIgNBOBAoIgRFBEAgAEEgECghBCADQTggAEEoEChBASADQSgQKHRBASAEQQ9xQRBqEQYAIgQQKSAERQRAQQEPCwsgA0EsECgiAEUEQCADQSxBASADQSgQKHQiABApIANBNEEAECkgA0EwQQAQKQsCQCAAIAJNBEAgBCABIABrIAAQNhogA0E0QQAQKQwBCyACIAAgA0E0ECgiBWsiACAAIAJLGyEAIAQgBWogASACayAAEDYaIAIgAGsiAgRAIANBOBAoIAEgAmsgAhA2GiADQTQgAhApDAELIANBNCADQTQQKCAAaiIBECkgA0E0QQAgASABIANBLBAoIgFGGxApIANBMBAoIgIgAU8EQEEADwsgA0EwIAAgAmoQKUEADwsgA0EwIANBLBAoEClBAAuwPgElfyMDIRMjA0EQaiQDIwMjBE4EQEEQEAALAkACQCAAEG4NACAAQQwQKCIVRQ0AIABBABAoIgVFBEAgAEEEECgNAQsgAEEcECgiAUEEECgiBEG//gBGBEAgAUEEQcD+ABApQcD+ACEEIABBDBAoIRUgAEEAECghBQsgAUHYAGohGCABQdwAaiEbIAFByDdqIRYgAUHMN2ohISABQcQ3aiEiIAFB8ABqIRkgAUG0CmoiHiEfIAFB9ABqISAgAUH0BWohHCABQUBrIhpBABAoIQMgAEEQECgiCCEKIABBBBAoIiMhBiABQTwQKCECAkACQAJAAkACQANAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIARBtP4Aaw4fAgMEBQYcByAiCBIXFwkTGAoLGRsdDCENJA4PEAABKy0LQQEhCwwpCyAIIQ8gCiENIAIhECADIREgBSESIAYhHUF9IQ4MJAsgAUEMECgiBEUEQCABQQRBwP4AECkMIwsDQCADQRBJBEAgBgRAIAIgBUEAEC8gA3RqIQIgA0EIaiEDIAZBf2ohBiAFQQFqIQUMAgUgCCEPIAohDSACIRAgAyERIAUhEiALIQ4MJgsACwsgAkGflgJGIARBAnFBAEdxBEAgAUEoEChFBEAgAUEoQQ8QKQsgAUEcQQBBAEEAEDciAhApIBNBAEEfECsgE0EBQYt/ECsgAUEcIAIgE0ECEDcQKSABQQRBtf4AEClBACECQQAhAwwjCyABQRRBABApIAFBJBAoIgcEfyAHQTBBfxApIAFBDBAoBSAEC0EBcQRAIAJBCHRBgP4DcSACQQh2akEfcEUEQCACQQ9xQQhHBEAgAEEYQZWVARApIAFBBEHR/gAQKQwlCyADQXxqIQMgAkEEdiIJQQ9xIgxBCGoiB0EPSyAHIAFBKBAoIgQEfyAEBSABQSggBxApIAcLS3IEfyAAQRhBsJUBECkgAUEEQdH+ABApIAkFIAFBGEGAAiAMdBApIAFBHEEAQQBBABBiIgMQKSAAQTAgAxApIAFBBCACQQx2QQJxQb/+AHMQKUEAIQNBAAshAgwkCwsgAEEYQf6UARApIAFBBEHR/gAQKQwiCwNAIANBEEkEQCAGBEAgBUEAEC8gA3QgAmohAiADQQhqIQMgBkF/aiEGIAVBAWohBQwCBSAIIQ8gCiENIAIhECADIREgBSESIAshDgwlCwALCyABQRQgAhApIAJB/wFxQQhHBEAgAEEYQZWVARApIAFBBEHR/gAQKQwiCyACQYDAA3EEQCAAQRhBxJUBECkgAUEEQdH+ABApDCILIAFBJBAoIgMEfyADQQAgAkEIdkEBcRApIAFBFBAoBSACC0GABHEEQCABQQwQKEEEcQRAIBNBACACECsgE0EBIAJBCHYQKyABQRwgAUEcECggE0ECEDcQKQsLIAFBBEG2/gAQKUEAIQQgBiEDQQAhBwwNCyADIQQgBiEDIAIhBwwMCyADIQQMEAsgAUEUECghBAwTCyABQRQQKCEHDBYLA0AgA0EgSQRAIAYEQCACIAVBABAvIAN0aiECIANBCGohAyAFQQFqIQUgBkF/aiEGDAIFIAghDyAKIQ0gAiEQIAMhESAFIRIgCyEODCALAAsLIAFBHCACEHgiAhApIABBMCACECkgAUEEQb7+ABApQQAhAkEAIQMMCQsgAiADQQdxdiECIANBeHEhAwNAIANBIEkEQCAGBEAgAiAFQQAQLyADdGohAiADQQhqIQMgBUEBaiEFIAZBf2ohBgwCBSAIIQ8gCiENIAIhECADIREgBSESIAshDgwfCwALCyACQf//A3EiBCACQRB2Qf//A3NGBEAgAUHEACAEECkgAUEEQcL+ABApQQAhAkEAIQMMCgUgAEEYQYSWARApIAFBBEHR/gAQKQwcCwALA0AgA0EOSQRAIAYEQCACIAVBABAvIAN0aiECIANBCGohAyAFQQFqIQUgBkF/aiEGDAIFIAghDyAKIQ0gAiEQIAMhESAFIRIgCyEODB4LAAsLIAFB5AAgAkEfcUGBAmoiBBApIAFB6AAgAkEFdkEfcSIHQQFqECkgAUHgACACQQp2QQ9xQQRqIgkQKSACQQ52IQIgA0FyaiEDIARBngJLIAdBHUtyBEAgAEEYQaGWARApIAFBBEHR/gAQKQwbBSABQewAQQAQKSABQQRBxf4AEClBACEEDAoLAAsgAUHsABAoIQQgAUHgABAoIQkMCAsgAUHMABAoIQQMEgsgAUHMABAoIQQMFQsgCEUEQEEAIQgMHAsgFUEAIAFBxAAQKBArIAFBBEHI/gAQKSAIQX9qIQggFUEBaiEVDBYLIAFBDBAoBEAgAiEEA0AgA0EgSQRAIAYEQCAEIAVBABAvIAN0aiEEIANBCGohAyAFQQFqIQUgBkF/aiEGDAIFIAghDyAKIQ0gBCEQIAMhESAFIRIgCyEODBoLAAsLIABBFCAKIAhrIgcgAEEUEChqECkgAUEgIAcgAUEgEChqECkgAUEMECgiAkEEcSIKRSAHRXIEfyAKBSABQRwQKCEKIBUgB2shAiABQRwgAUEUECgEfyAKIAIgBxA3BSAKIAIgBxBiCyIKECkgAEEwIAoQKSABQQwQKCICQQRxCwR/IAFBFBAoRSEKIAQQeCAEIAobIAFBHBAoRgR/QQAhB0EAIQMgAiEEIAgFIABBGEHPlwEQKSABQQRB0f4AECkgCCEKIAQhAgwYCwVBACEHQQAhAyACIQQgCAshCgUgAiEHQQAhBAsgAUEEQc/+ABApIAchAgwFCyABQQwQKCEEDAQLIAUhBiAEIQIgByEFA0AgAkEgSQRAIAMEQCAFIAZBABAvIAJ0aiEFIAZBAWohBiACQQhqIQIgA0F/aiEDDAIFIAghDyAKIQ0gBSEQIAIhESAGIRIgCyEODBcLAAsLIAFBJBAoIgIEQCACQQQgBRApCyABQRQQKEGABHEEQCABQQwQKEEEcQRAIBNBACAFECsgE0EBIAVBCHYQKyATQQIgBUEQdhArIBNBAyAFQRh2ECsgAUEcIAFBHBAoIBNBBBA3ECkLCyABQQRBt/4AECkgBiEFQQAhBCADIQZBACECDAQLIAFBEBAoRQ0VIAFBHEEAQQBBABBiIgQQKSAAQTAgBBApIAFBBEG//gAQKQwECyABQQRBw/4AECkMBAsDQCAEIAlJBEADQCADQQNJBEAgBgRAIAIgBUEAEC8gA3RqIQIgA0EIaiEDIAVBAWohBSAGQX9qIQYMAgUgCCEPIAohDSACIRAgAyERIAUhEiALIQ4MFgsACwsgAUHsACAEQQFqIgcQKSABQfQAaiAEQQF0QYDPAGpBABAwQQF0akEAIAJBB3EQLiACQQN2IQIgA0F9aiEDIAchBAwBCwsDQCAEQRNJBEAgAUHsACAEQQFqIgsQKSABQfQAaiAEQQF0QYDPAGpBABAwQQF0akEAQQAQLiALIQQMAQsLIBlBACAeECkgAUHQACAfECkgGEEAQQcQKUEAICBBEyAZIBggHBCXASILBEAgAEEYQcWWARApIAFBBEHR/gAQKQwRBSABQewAQQAQKSABQQRBxv4AEClBACELDAULAAsgBEUNEyABQRQQKEUNEwNAIANBIEkEQCAGBEAgAiAFQQAQLyADdGohAiADQQhqIQMgBUEBaiEFIAZBf2ohBgwCBSAIIQ8gCiENIAIhECADIREgBSESIAshDgwTCwALCyACIAFBIBAoRgRAQQAhAkEAIQMMFAsgAEEYQeSXARApIAFBBEHR/gAQKQwPCyAEIQMDQCADQRBJBEAgBgRAIAIgBUEAEC8gA3RqIQIgBUEBaiEFIANBCGohAyAGQX9qIQYMAgUgCCEPIAohDSACIRAgAyERIAUhEiALIQ4MEgsACwsgAUEkECgiAwRAIANBCCACQf8BcRApIAFBJBAoQQwgAkEIdhApCyABQRQQKCIEQYAEcQRAIAFBDBAoQQRxBEAgE0EAIAIQKyATQQEgAkEIdhArIAFBHCABQRwQKCATQQIQNxApCwsgAUEEQbj+ABApQQAhAkEAIQMMAwsgAUEIECgEQCABQQRBzv4AECkgAiADQQdxdiECIANBeHEhAwwOCwNAIANBA0kEQCAGBEAgAiAFQQAQLyADdGohAiADQQhqIQMgBUEBaiEFIAZBf2ohBgwCBSAIIQ8gCiENIAIhECADIREgBSESIAshDgwRCwALCyABQQggAkEBcRApAkACQAJAAkACQCACQQF2QQNxDgQAAQIDGQsgAUEEQcH+ABApDAMLIAFB0ABBsM8AECkgAUHYAEEJECkgAUHUAEGw3wAQKSABQdwAQQUQKSABQQRBx/4AECkMAgsgAUEEQcT+ABApDAELIABBGEHxlQEQKSABQQRB0f4AECkLIAJBA3YhAiADQX1qIQMMDQsgAUHEABAoIgRFBEAgAUEEQb/+ABApDA0LIAggBiAEIAQgBksbIgQgBCAISxsiBEUNESAVIAUgBBA2GiABQcQAIAFBxAAQKCAEaxApIAggBGshCCAEIBVqIRUgBCAFaiEFIAYgBGshBgwMCwJAAkADQAJAIAFB7AAQKCIJIAFB5AAQKCABQegAEChqIhRPDQMgAUHQABAoIQRBASAYQQAQKHRBf2ohDANAIAMgAiAMcUECdCAEakEAEF0iF0EIdkH/AXEiB0kEQCAGBEAgAiAFQQAQLyADdGohAiADQQhqIQMgBUEBaiEFIAZBf2ohBgwCBSAIIQ8gCiENIAIhECADIREgBSESIAshDgwTCwALCyAXQRB2IgRBEEgEQCABQewAIAlBAWoQKSABQfQAaiAJQQF0akEAIAQQLiACIAd2IQIgAyAHayEDBQJ/AkACQAJAIARBEHRBEHVBEGsOAgABAgsgB0ECaiEEA0AgAyAESQRAIAYEQCACIAVBABAvIAN0aiECIANBCGohAyAFQQFqIQUgBkF/aiEGDAIFIAghDyAKIQ0gAiEQIAMhESAFIRIgCyEODBcLAAsLIAIgB3YhBCADIAdrIQMgCUUNBCAJQQF0IAFqQfIAEDAhDCAEQQJ2IQIgBEEDcUEDaiEEIANBfmoMAgsgB0EDaiEEA0AgAyAESQRAIAYEQCACIAVBABAvIAN0aiECIANBCGohAyAFQQFqIQUgBkF/aiEGDAIFIAghDyAKIQ0gAiEQIAMhESAFIRIgCyEODBYLAAsLQQAhDCACIAd2IgRBA3YhAiAEQQdxQQNqIQQgAyAHa0F9agwBCyAHQQdqIQQDQCADIARJBEAgBgRAIAIgBUEAEC8gA3RqIQIgA0EIaiEDIAVBAWohBSAGQX9qIQYMAgUgCCEPIAohDSACIRAgAyERIAUhEiALIQ4MFQsACwtBACEMIAIgB3YiBEEHdiECIARB/wBxQQtqIQQgAyAHa0F5agshAyAEIAlqIBRLDQMgDEH//wNxIQcDQCAEBEAgAUHsACABQewAECgiCUEBahApIAFB9ABqIAlBAXRqQQAgBxAuIARBf2ohBAwBCwsLDAELCyAAQRhB3pYBECkgAUEEQdH+ABApIAQhAgwNCyAAQRhB3pYBECkgAUEEQdH+ABApDAwLIAFBBBAoQdH+AEYNCyABQfQEEDFFBEAgAEEYQfiWARApIAFBBEHR/gAQKQwMCyAZQQAgHhApIAFB0AAgHxApIBhBAEEJEClBASAgIAFB5AAQKCAZIBggHBCXASILBEAgAEEYQZ2XARApIAFBBEHR/gAQKQwMCyABQdQAIBlBABAoECkgG0EAQQYQKUECIAFB9ABqIAFB5AAQKEEBdGogAUHoABAoIBkgGyAcEJcBIgsEQCAAQRhBuZcBECkgAUEEQdH+ABApBSABQQRBx/4AEClBACELDAILDAsLIARBgAhxBEADQCADQRBJBEAgBgRAIAIgBUEAEC8gA3RqIQIgBUEBaiEFIANBCGohAyAGQX9qIQYMAgUgCCEPIAohDSACIRAgAyERIAUhEiALIQ4MDwsACwsgAUHEACACECkgAUEkECgiAwR/IANBFCACECkgAUEUECgFIAQLQYAEcQRAIAFBDBAoQQRxBEAgE0EAIAIQKyATQQEgAkEIdhArIAFBHCABQRwQKCATQQIQNxApCwtBACEDQQAhAgUgAUEkECgiBARAIARBEEEAECkLCyABQQRBuf4AECkMAQsgAUEEQcj+ABApDAELIAIhBCABQRQQKCICQYAIcQR/IAYgAUHEABAoIgcgByAGSxsiCQRAIAFBJBAoIgwEQCAMQRAQKCIUBEAgFCAMQRQQKCAHayICaiAFIAxBGBAoIgcgAmsgCSACIAlqIAdLGxA2GiABQRQQKCECCwsgAkGABHEEQCABQQwQKEEEcQRAIAFBHCABQRwQKCAFIAkQNxApCwsgAUHEACABQcQAECggCWsiBxApIAYgCWshBiAFIAlqIQULIAcEfyAEIQIMDwUgAgsFIAILIQcgAUHEAEEAECkgAUEEQbr+ABApIAQhAgwBCyAGQQVLIAhBgQJLcQRAIABBDCAVECkgAEEQIAgQKSAAQQAgBRApIABBBCAGECkgAUE8IAIQKSAaQQAgAxApIAAgChDRAiAAQQwQKCEVIABBEBAoIQggAEEAECghBSAAQQQQKCEGIAFBPBAoIQIgGkEAECghAyABQQQQKEG//gBHDQggFkEAQX8QKQwICyAWQQBBABApIAFB0AAQKCEMQQEgGEEAECh0QX9qIQcgAiEEIAMhAgNAIAIgBCAHcUECdCAMakEAEF0iA0EIdkH/AXEiCUkEQCAGBEAgBCAFQQAQLyACdGohBCACQQhqIQIgBUEBaiEFIAZBf2ohBgwCBSAIIQ8gCiENIAQhECACIREgBSESIAshDgwLCwALCyADQRB2IRQgA0H/AXEiBwRAAkAgB0EQSAR/IANBEHYhF0EBIAkgA0H/AXFqdEF/aiEDA0AgCSAXIAMgBHEgCXZqQQJ0IAxqQQAQXSIUQQh2Qf8BcSIHaiACSwRAIAYEQCAEIAVBABAvIAJ0aiEEIAJBCGohAiAFQQFqIQUgBkF/aiEGDAIFIAghDyAKIQ0gBCEQIAIhESAFIRIgCyEODA4LAAsLIBZBACAJECkgBCAJdiAHdiEEIAIgCWsgB2shAyAWQQAgByAJahApIAFBxAAgFEEQdhApIBRB/wFxIgcEfyAEBSAEIQIMAgsFIBZBACAJECkgAUHEACAUECkgAiAJayEDIAQgCXYLIQIgB0EgcQRAIBZBAEF/ECkgAUEEQb/+ABApDAoLIAdBwABxBEAgAEEYQa+YARApIAFBBEHR/gAQKQwKBSABQcwAIAdBD3EiBBApIAFBBEHJ/gAQKQwECwALBSAWQQAgCRApIAFBxAAgFBApIAIgCWshAyAEIAl2IQILIAFBBEHN/gAQKQwHCyAHQYAQcQRAIAZFBEBBACEGDA0LQQAhBwNAIAdBAWohBCAFIAdqQQAQLSEHIAFBJBAoIgkEQCAJQRwQKCIUBEAgAUHEABAoIgwgCUEgEChJBEAgAUHEACAMQQFqECkgDCAUakEAIAcQKwsLCyAHQQBHIAYgBEtxBEAgBCEHDAELCyABQRQQKEGABHEEQCABQQwQKEEEcQRAIAFBHCABQRwQKCAFIAQQNxApCwsgBiAEayEGIAQgBWohBSAHDQwFIAFBJBAoIgQEQCAEQRxBABApCwsgAUHEAEEAECkgAUEEQbv+ABApDAELICFBACAEBH8DQCADIARJBEAgBgRAIAIgBUEAEC8gA3RqIQIgA0EIaiEDIAVBAWohBSAGQX9qIQYMAgUgCCEPIAohDSACIRAgAyERIAUhEiALIQ4MCgsACwsgAUHEACABQcQAECggAkEBIAR0QX9qcWoiBxApIBZBACAEIBZBABAoahApIAIgBHYhAiADIARrIQMgBwUgAUHEABAoCxApIAFBBEHK/gAQKQwBCyABQRQQKEGAIHEEQCAGRQRAQQAhBgwLC0EAIQcDQCAHQQFqIQQgBSAHakEAEC0hByABQSQQKCIJBEAgCUEkECgiFARAIAFBxAAQKCIMIAlBKBAoSQRAIAFBxAAgDEEBahApIAwgFGpBACAHECsLCwsgB0EARyAGIARLcQRAIAQhBwwBCwsgAUEUEChBgARxBEAgAUEMEChBBHEEQCABQRwgAUEcECggBSAEEDcQKQsLIAYgBGshBiAEIAVqIQUgBw0KBSABQSQQKCIEBEAgBEEkQQAQKQsLIAFBBEG8/gAQKQwBCwJ/IAUhJSAGIQcgAUHUABAoIRRBASAbQQAQKHRBf2ohCSACIQYgAyEFICULIQIgByEDA0AgBSAGIAlxQQJ0IBRqQQAQXSIEQQh2Qf8BcSIHSQRAIAMEQCAGIAJBABAvIAV0aiEGIAVBCGohBSACQQFqIQIgA0F/aiEDDAIFIAghDyAKIQ0gBiEQIAUhESACIRIgCyEODAcLAAsLIARB/wFxIglBEEgEfyAEQRB2IQlBASAHIARB/wFxanRBf2ohFyAGIQQgBSEGIAIhBQNAIAcgCSAEIBdxIAd2akECdCAUakEAEF0iDEEIdkH/AXEiAmogBksEQCADBEAgBCAFQQAQLyAGdGohBCAGQQhqIQYgBUEBaiEFIANBf2ohAwwCBSAIIQ8gCiENIAQhECAGIREgBSESIAshDgwICwALCyAWQQAgByAWQQAQKGoiJBApIAQgB3YhFCAGIAdrIRcgAyEGIAxB/wFxIQkgDCEDICQFIAYhFCAFIRcgAiEFIAMhBiAHIQIgBCEDIBZBABAoCyEMIBQgAnYhBCAXIAJrIQcgFkEAIAIgDGoQKSAJQcAAcQR/IABBGEGZmAEQKSABQQRB0f4AECkgByEDIAQFIAFByAAgA0EQdhApIAFBzAAgCUEPcSIJECkgAUEEQcv+ABApIAQhAiAHIQMgCSEEDAILIQIMAwsgAUEUECgiBEGABHEEQANAIANBEEkEQCAGBEAgAiAFQQAQLyADdGohAiADQQhqIQMgBUEBaiEFIAZBf2ohBgwCBSAIIQ8gCiENIAIhECADIREgBSESIAshDgwHCwALCyABQQwQKEEEcQR/IAIgAUEcEChB//8DcUYEf0EAIQNBAAUgAEEYQd2VARApIAFBBEHR/gAQKQwFCwVBACEDQQALIQILIAFBJBAoIgcEQCAHQSwgBEEJdkEBcRApIAFBJBAoQTBBARApCyABQRxBAEEAQQAQNyIEECkgAEEwIAQQKSABQQRBv/4AECkMAgsgBARAA0AgAyAESQRAIAYEQCACIAVBABAvIAN0aiECIANBCGohAyAFQQFqIQUgBkF/aiEGDAIFIAghDyAKIQ0gAiEQIAMhESAFIRIgCyEODAYLAAsLIAFByAAgAUHIABAoIAJBASAEdEF/anFqECkgFkEAIAQgFkEAEChqECkgAyAEayEDIAIgBHYhAgsgAUEEQcz+ABApCyAIRQRAQQAhCAwGCyABQcgAECgiByAKIAhrIgRLBEAgByAEayIEIAFBMBAoSwRAICJBABAoBEAgAEEYQfuXARApIAFBBEHR/gAQKQwDCwsgBCABQTQQKCIHSwR/IAFBOBAoIAFBLBAoIAQgB2siBGtqBSABQTgQKCAHIARragshByABQcQAECgiCSAEIAQgCUsbIQwgCSEEBSABQcQAECgiBCEMIBUgB2shBwsgAUHEACAEIAggDCAMIAhLGyIUaxApIBQhCSAVIQQDQCAEQQFqIQwgBEEAIAdBABAtECsgB0EBaiEHIAlBf2oiCQRAIAwhBAwBCwsgCCAUayEIIBQgFWohFSABQcQAEChFBEAgAUEEQcj+ABApCwsgAUEEECghBAwBCwsMBAsgAEEMIBUQKSAAQRAgCBApIABBACAFECkgAEEEIAYQKSABQTwgAhApIBpBACADECkgEyQDQQIPCyABQQRB0P4AECkgCCEPIAohDSACIRAgAyERIAUhEiAGIR1BASEODAILIAghDyAKIQ0gAiEQIAMhESAFIRIgBiEdIAshDgwBCyATJANBfA8LIABBDCAVECkgAEEQIA8QKSAAQQAgEhApIABBBCAdECkgAUE8IBAQKSAaQQAgERApIABBEBAoIQgCQAJAIAFBLBAoDQAgCCANRgRAIA0hCAUgAUEEEChB0f4ASQ0BCwwBCyAAIABBDBAoIA0gCGsQ0wJFBEAgAEEQECghCAwBCyABQQRB0v4AECkgEyQDQXwPCyAAQQggIyAAQQQQKGsiCyAAQQgQKGoQKSAAQRQgDSAIayIIIABBFBAoahApIAFBICAIIAFBIBAoahApIAFBDBAoQQRxRSAIRXIEQAwCCyABQRwQKCEKIABBDBAoIAhrIQUgAUEcIAFBFBAoBH8gCiAFIAgQNwUgCiAFIAgQYgsiChApIABBMCAKECkMAQsgEyQDQX4PCyAAQSwgGkEAEChBwABBACABQQgQKBtqQYABQQAgAUEEECgiAEG//gBGG2pBgAJBACAAQcf+AEYgAEHC/gBGchtqECkgEyQDIA5BeyAOIAggC3JyGwu7AQEDfyAARQRAQX4PCyAAQRhBABApIABBIBAoIgFFBEAgAEEgQQcQKSAAQShBABApQQchAQsgAEEkEChFBEAgAEEkQQEQKQsgAEEoEChBAUHQNyABQQ9xQRBqEQYAIgFFBEBBfA8LIABBHCABECkgAUEAIAAQKSABQThBABApIAFBBEG0/gAQKSAAENYCIgJFBEBBAA8LIABBJBAoIQMgAEEoECggASADQQFxQTVqEQkAIABBHEEAECkgAgttAQN/IAAQbgRAQX4PCyAAQRwQKCEBQQ8iAkUEQEEAIQILIAFBOBAoIgMEQCABQSgQKCACRwRAIABBKBAoIAMgAEEkEChBAXFBNWoRCQAgAUE4QQAQKQsLIAFBDEEAECkgAUEoIAIQKSAAENcCCzEBAX8gABBuBEBBfg8LIABBHBAoIgFBLEEAECkgAUEwQQAQKSABQTRBABApIAAQ2AILxAEBAn8gABBuBEBBfg8LIABBHBAoIgFBIEEAECkgAEEUQQAQKSAAQQhBABApIABBGEEAECkgAUEMECgiAgRAIABBMCACQQFxECkLIAFBBEG0/gAQKSABQQhBABApIAFBEEEAECkgAUEYQYCAAhApIAFBJEEAECkgAUE8QQAQKSABQUBrQQBBABApIAFB8AAgAUG0CmoiABApIAFB1AAgABApIAFB0AAgABApIAFBxDdqQQBBARApIAFByDdqQQBBfxApQQAL1AgBD38gAUEARyENIABBpC1qIQkgAEGgLWohBiAAQZgtaiEKIABBiBNqIQsgAEGcLWohDAJAAkADQAJAAkACQCAAQfQAECgiBEGDAkkEQCAAEH0gAEH0ABAoIgRBggJLIA1yRQ0FIARFDQMgAEHgAEEAECkgBEECTQ0BBSAAQeAAQQAQKQsgAEHsABAoIgJFDQAgAiAAQTgQKGoiB0F/akEAEC0iBSAHQQAQLUcNACAHQQEQLSAFRw0AIAdBAhAtIAVHDQAgB0GCAmohDkECIQIDfwJ/IAIgB2oiCEEBaiIDQQAQLSAFRwRAIAMMAQsgCEECaiIDQQAQLSAFRwRAIAMMAQsgCEEDaiIDQQAQLSAFRwRAIAMMAQsgCEEEaiIDQQAQLSAFRwRAIAMMAQsgCEEFaiIDQQAQLSAFRwRAIAMMAQsgCEEGaiIDQQAQLSAFRwRAIAMMAQsgCEEHaiIDQQAQLSAFRwRAIAMMAQsgBSACQQhqIgIgB2oiA0EAEC1GIAJBggJJcQ0BIAMLCyAOa0GCAmoiAiAESyEDIABB4AAgBCACIAMbECkgBCACIAMbIgJBAk0NACAJQQAQKCAGQQAQKEEBdGpBAEEBEC4gCkEAECghBCAGQQAgBkEAECgiA0EBahApIAMgBGpBACACQf0BaiICECsgAkH/AXFBsOYAakEAEC9BgAJyQQJ0IABqQZgBaiICQQAgAkEAEDFBAWoQLiALQQAgC0EAEDFBAWoQLgJ/IAZBABAoIAxBABAoQX9qRiEPIABB9AAgAEH0ABAoIABB4AAQKCICaxApIABB7AAgAiAAQewAEChqIgIQKSAAQeAAQQAQKSAPCw0BDAMLIABBOBAoIABB7AAQKGpBABAtIQIgCUEAECggBkEAEChBAXRqQQBBABAuIApBABAoIQQgBkEAIAZBABAoIgNBAWoQKSADIARqQQAgAhArIABBlAFqIAJB/wFxQQJ0aiICQQAgAkEAEDFBAWoQLgJ/IAZBABAoIAxBABAoQX9qRiEQIABB9AAgAEH0ABAoQX9qECkgAEHsACAAQewAEChBAWoiAhApIBALDQAMAgsgACAAQdwAECgiBEF/SgR/IAQgAEE4EChqBUEACyACIARrQQAQQyAAQdwAIABB7AAQKBApIABBABAoEDggAEEAEChBEBAoDQEMAgsLIABBtC1qQQBBABApIAFBBEYEQCAAQdwAECgiAUF/TARAIABBACAAQewAECggAWtBARBDDAMLIAAgASAAQTgQKGogAEHsABAoIAFrQQEQQwwCCyAGQQAQKARAIAAgAEHcABAoIgFBf0oEfyABIABBOBAoagVBAAsgAEHsABAoIAFrQQAQQyAAQdwAIABB7AAQKBApIABBABAoEDggAEEAEChBEBAoRQRAQQAPCwtBAQ8LQQAPCyAAQdwAIABB7AAQKBApIABBABAoEDhBA0ECIABBABAoQRAQKBsLrgQBCH8gAEGkLWohBSAAQaAtaiEDIABBmC1qIQYgAEGcLWohBwJAAkADQAJAIABB9AAQKEUEQCAAEH0gAEH0ABAoRQ0BCyAAQeAAQQAQKSAAQTgQKCAAQewAEChqQQAQLSECIAVBABAoIANBABAoQQF0akEAQQAQLiAGQQAQKCEIIANBACADQQAQKCIEQQFqECkgBCAIakEAIAIQKyAAQZQBaiACQf8BcUECdGoiAkEAIAJBABAxQQFqEC4CfyADQQAQKCAHQQAQKEF/akYhCSAAQfQAIABB9AAQKEF/ahApIABB7AAgAEHsABAoQQFqIgQQKSAJCwRAIAAgAEHcABAoIgJBf0oEfyACIABBOBAoagVBAAsgBCACa0EAEEMgAEHcACAAQewAECgQKSAAQQAQKBA4IABBABAoQRAQKEUNAwsMAQsLDAELQQAPCyABRQRAQQAPCyAAQbQtakEAQQAQKQJAIAFBBEYEQCAAQdwAECgiAUF/TARAIABBACAAQewAECggAWtBARBDDAILIAAgASAAQTgQKGogAEHsABAoIAFrQQEQQwwBCyADQQAQKARAIAAgAEHcABAoIgFBf0oEfyABIABBOBAoagVBAAsgAEHsABAoIAFrQQAQQyAAQdwAIABB7AAQKBApIABBABAoEDggAEEAEChBEBAoRQRAQQAPCwtBAQ8LIABB3AAgAEHsABAoECkgAEEAECgQOEEDQQIgAEEAEChBEBAoGwvrGwEjfyAAEJgBIAFBBUtyBEBBfg8LIABBHBAoIQICQAJAIABBDBAoBEACQCAAQQQQKARAIABBABAoRQ0BCyABQQRGIAJBBBAoIgNBmgVHcgRAIABBEBAoRQ0DIAJBKBAoIQQgAkEoIAEQKSACQRQQKARAAkAgABA4IABBEBAoBEAgAkEEECghAwwBCwwGCwUgAEEEEChFBEAgAUEERgR/QQEFIAFBAXRBCUEAIAFBBEobayAEQQF0QQlBACAEQQRKG2tKC0UNBQsLAkACQAJAAkAgA0EqayIEBEAgBEHwBEcNASAAQQQQKEUNAgwICyACQTAQKCEEIAIgAkGIARAoQQFKBH9BAAUgAkGEARAoIgNBAkgEf0EABSADQQZIBH9BwAAFQYABQcABIANBBkYbCwsLIARBDHRBgJB+anIiAyADQSByIAJB7AAQKEUbIgMgA0EfcHJBH3MQbyACQewAECgEQCACIABBMBAoQRB2EG8gAiAAQTAQKEH//wNxEG8LIABBMEEAQQBBABBiECkgAkEEQfEAECkgABA4IAJBFBAoRQRAIAJBBBAoIQMMAQsMCAsCQAJAAkACQAJAIANBOUYEQAJAIABBMEEAQQBBABA3ECkCfyACQQgQKCEHIAJBFCACQRQQKCIEQQFqECkgBwsgBGpBAEEfECsCfyACQQgQKCEIIAJBFCACQRQQKCIEQQFqECkgCAsgBGpBAEGLfxArAn8gAkEIECghCSACQRQgAkEUECgiBEEBahApIAkLIARqQQBBCBArIAJBHBAoIgNFBEACfyACQQgQKCEKIAJBFCACQRQQKCIEQQFqECkgCgsgBGpBAEEAECsCfyACQQgQKCELIAJBFCACQRQQKCIEQQFqECkgCwsgBGpBAEEAECsCfyACQQgQKCEMIAJBFCACQRQQKCIEQQFqECkgDAsgBGpBAEEAECsCfyACQQgQKCENIAJBFCACQRQQKCIEQQFqECkgDQsgBGpBAEEAECsCfyACQQgQKCEOIAJBFCACQRQQKCIEQQFqECkgDgsgBGpBAEEAECsgAkGEARAoIgNBCUYEf0ECBUEEQQAgA0ECSCACQYgBEChBAUpyGwshAwJ/IAJBCBAoIQ8gAkEUIAJBFBAoIgVBAWoQKSAPCyAFakEAIAMQKwJ/IAJBCBAoIRAgAkEUIAJBFBAoIgRBAWoQKSAQCyAEakEAQQMQKyACQQRB8QAQKSAAEDggAkEUEChFBEAgAkEEECghAwwCCwwPCyADQQAQKEEAR0ECQQAgA0EsECgbckEEQQAgA0EQECgbckEIQQAgA0EcECgbckEQQQAgA0EkECgbckH/AXEhAwJ/IAJBCBAoIREgAkEUIAJBFBAoIgVBAWoQKSARCyAFakEAIAMQKyACQRwQKEEEEChB/wFxIQMCfyACQQgQKCESIAJBFCACQRQQKCIFQQFqECkgEgsgBWpBACADECsgAkEcEChBBBAoQQh2Qf8BcSEDAn8gAkEIECghEyACQRQgAkEUECgiBUEBahApIBMLIAVqQQAgAxArIAJBHBAoQQQQKEEQdkH/AXEhAwJ/IAJBCBAoIRQgAkEUIAJBFBAoIgVBAWoQKSAUCyAFakEAIAMQKyACQRwQKEEEEChBGHYhAwJ/IAJBCBAoIRUgAkEUIAJBFBAoIgVBAWoQKSAVCyAFakEAIAMQKyACQYQBECgiA0EJRgR/QQIFQQRBACADQQJIIAJBiAEQKEEBSnIbCyEDAn8gAkEIECghFiACQRQgAkEUECgiBUEBahApIBYLIAVqQQAgAxArIAJBHBAoQQwQKEH/AXEhAwJ/IAJBCBAoIRcgAkEUIAJBFBAoIgVBAWoQKSAXCyAFakEAIAMQKyACQRwQKCIDQRAQKARAIANBFBAoQf8BcSEDAn8gAkEIECghGCACQRQgAkEUECgiBUEBahApIBgLIAVqQQAgAxArIAJBHBAoQRQQKEEIdkH/AXEhAwJ/IAJBCBAoIRkgAkEUIAJBFBAoIgVBAWoQKSAZCyAFakEAIAMQKyACQRwQKCEDCyADQSwQKARAIABBMCAAQTAQKCACQQgQKCACQRQQKBA3ECkLIAJBIEEAECkgAkEEQcUAECkMAgsLIANBxQBGDQAgA0HJAEYNASADQdsARg0CIANB5wBGDQMMBAsgAkEcECgiA0EQECgEQCADQRQQKEH//wNxIAJBIBAoayEEIAJBFBAoIQMDQCADIARqIAJBDBAoIgVLBEAgAyACQQgQKGogAkEcEChBEBAoIAJBIBAoaiAFIANrIgUQNhogAkEUIAJBDBAoIgYQKSACQRwQKEEsEChBAEcgBiADS3EEQCAAQTAgAEEwECggAyACQQgQKGogBiADaxA3ECkLIAJBICAFIAJBIBAoahApIAAQOCACQRQQKA0OIAQgBWshBEEAIQMMAQsLIAMgAkEIEChqIAJBHBAoQRAQKCACQSAQKGogBBA2GiACQRQgBCACQRQQKGoiBBApIAJBHBAoQSwQKEEARyAEIANLcQRAIABBMCAAQTAQKCADIAJBCBAoaiAEIANrEDcQKQsgAkEgQQAQKQsgAkEEQckAECkLIAJBHBAoQRwQKARAIAJBFBAoIgQhAwNAIAJBDBAoIARGBEAgAkEcEChBLBAoQQBHIAQgA0txBEAgAEEwIABBMBAoIAMgAkEIEChqIAQgA2sQNxApCyAAEDggAkEUECgNDUEAIQNBACEECwJ/IAJBHBAoQRwQKCEaIAJBICACQSAQKCIGQQFqECkgGgsgBmpBABAtIQUgAkEIECghBiACQRQgBEEBahApIAQgBmpBACAFECsgBQRAIAJBFBAoIQQMAQsLIAJBHBAoQSwQKARAIAJBFBAoIgQgA0sEQCAAQTAgAEEwECggAyACQQgQKGogBCADaxA3ECkLCyACQSBBABApCyACQQRB2wAQKQsgAkEcEChBJBAoBEAgAkEUECgiBCEDA0AgAkEMECggBEYEQCACQRwQKEEsEChBAEcgBCADS3EEQCAAQTAgAEEwECggAyACQQgQKGogBCADaxA3ECkLIAAQOCACQRQQKA0MQQAhA0EAIQQLAn8gAkEcEChBJBAoIRsgAkEgIAJBIBAoIgZBAWoQKSAbCyAGakEAEC0hBSACQQgQKCEGIAJBFCAEQQFqECkgBCAGakEAIAUQKyAFBEAgAkEUECghBAwBCwsgAkEcEChBLBAoBEAgAkEUECgiBCADSwRAIABBMCAAQTAQKCADIAJBCBAoaiAEIANrEDcQKQsLCyACQQRB5wAQKQsgAkEcEChBLBAoBEAgAkEUECgiA0ECaiACQQwQKEsEQCAAEDggAkEUECgNCkEAIQMLIABBMBAoQf8BcSEEIAJBCBAoIQUgAkEUIANBAWoQKSADIAVqQQAgBBArIABBMBAoQQh2Qf8BcSEDAn8gAkEIECghHCACQRQgAkEUECgiBUEBahApIBwLIAVqQQAgAxArIABBMEEAQQBBABA3ECkLIAJBBEHxABApIAAQOCACQRQQKA0ICyAAQQQQKA0BCyACQfQAECgNACABBEAgAkEEEChBmgVHDQEFQQAPCwwBCwJAAkACQAJAIAJBhAEQKCIDBH8CfwJAAkACQCACQYgBEChBAmsOAgABAgsgAiABENoCDAILIAIgARDZAgwBCyADQQxsQYjOAGpBABAoIQMgAiABIANBB3FBCGoRAQALBSACIAEQyQELDgQDAgABBAsgAkEEQZoFECkMAgsgAkEEQZoFECkMAgsCQAJAAkAgAUEBaw4FAAEBAQIBCyACEM8CDAELIAJBAEEAQQAQfCABQQNGBEAgAkHEABAoIAJBzAAQKEF/akEBdGpBAEEAEC4gAkHEABAoQQAgAkHMABAoQQF0QX5qEEUaIAJB9AAQKEUEQCACQewAQQAQKSACQdwAQQAQKSACQbQtakEAQQAQKQsLCyAAEDggAEEQECgNAQwGCyAAQRAQKARAQQAPCwwFCyABQQRHBEBBAA8LIAJBGBAoIgNBAUgEQEEBDwsgAEEwECghASADQQJGBEACfyACQQgQKCEdIAJBFCACQRQQKCIEQQFqECkgHQsgBGpBACABECsgAEEwEChBCHZB/wFxIQECfyACQQgQKCEeIAJBFCACQRQQKCIEQQFqECkgHgsgBGpBACABECsgAEEwEChBEHZB/wFxIQECfyACQQgQKCEfIAJBFCACQRQQKCIEQQFqECkgHwsgBGpBACABECsgAEEwEChBGHYhAQJ/IAJBCBAoISAgAkEUIAJBFBAoIgRBAWoQKSAgCyAEakEAIAEQKyAAQQgQKEH/AXEhAQJ/IAJBCBAoISEgAkEUIAJBFBAoIgRBAWoQKSAhCyAEakEAIAEQKyAAQQgQKEEIdkH/AXEhAQJ/IAJBCBAoISIgAkEUIAJBFBAoIgRBAWoQKSAiCyAEakEAIAEQKyAAQQgQKEEQdkH/AXEhAQJ/IAJBCBAoISMgAkEUIAJBFBAoIgRBAWoQKSAjCyAEakEAIAEQKyAAQQgQKEEYdiEBAn8gAkEIECghJCACQRQgAkEUECgiBEEBahApICQLIARqQQAgARArBSACIAFBEHYQbyACIABBMBAoQf//A3EQbwsgABA4IAJBGBAoIgBBAEoEQCACQRhBACAAaxApCyACQRQQKEUPCwsLIABBGEHxmAEQKUF+DwsgAEEYQZ2ZARApQXsPCyACQShBfxApQQALmQEBBH8gAEEsECghASAAQcQAECggAEHMABAoIgJBAXRqIQMDQCADQX5qIgNBABAwIQQgA0EAQQAgBCABa0H//wNxIAEgBEsbEC4gAkF/aiICDQALIABBQGtBABAoIAFBAXRqIQIgASEAA0AgAkF+aiICQQAQMCEDIAJBAEEAIAMgAWtB//8DcSABIANLGxAuIABBf2oiAA0ACwvYDQERfyABQQBHIQ0gAEFAayELIABBpC1qIQYgAEGgLWohBCAAQZgtaiEHIABBnC1qIQwCQAJAA0ACQAJAAkAgAEH0ABAoQYYCTw0AIAAQfSAAQfQAECgiAkGFAksgDXJFDQQgAkUNAiACQQJLDQAgAEH4ACAAQeAAECgQKSAAQeQAIABB8AAQKBApIABB4ABBAhApQQIhAgwBCyAAQcgAIABB1AAQKCAAQTgQKCAAQewAECgiAkECampBABAvIABByAAQKCAAQdgAECh0c3EiAxApIAtBABAoIAIgAEE0EChxQQF0akEAIABBxAAQKCADQQF0akEAEDEiAhAuIABBxAAQKCAAQcgAEChBAXRqQQAgAEHsABAoEC4gAEH4ACAAQeAAECgiAxApIABB5AAgAEHwABAoECkgAEHgAEECECkgAkH//wNxIgIEQCADIABBgAEQKEkEQCAAQewAECggAmsgAEEsEChB+n1qSwRAQQIhAgUgAEHgACAAIAIQyAEiAhApIAJBBkkEQCAAQYgBEChBAUcEQCACQQNHDQUgAEHsABAoIABB8AAQKGtBgCBNBEBBAyECDAYLCyAAQeAAQQIQKUECIQILCwVBAiECCwVBAiECCwsgAEH4ABAoIgNBA0kgAiADS3IEQAJAIABB6AAQKEUEQCAAQegAQQEQKSAAQewAIABB7AAQKEEBahApIABB9AAgAEH0ABAoQX9qECkMAQsgAEE4ECggAEHsABAoQX9qakEAEC0hAiAGQQAQKCAEQQAQKEEBdGpBAEEAEC4CfyAHQQAQKCEOIARBACAEQQAQKCIFQQFqECkgDgsgBWpBACACECsgAEGUAWogAkH/AXFBAnRqIgJBACACQQAQMUEBahAuIARBABAoIAxBABAoQX9qRgRAIAAgAEHcABAoIgJBf0oEfyACIABBOBAoagVBAAsgAEHsABAoIAJrQQAQQyAAQdwAIABB7AAQKBApIABBABAoEDgLIABB7AAgAEHsABAoQQFqECkgAEH0ACAAQfQAEChBf2oQKSAAQQAQKEEQEChFDQQLBQJ/IABB9AAQKCEQIAZBABAoIARBABAoQQF0akEAIABB7AAQKCIIQf//A2ogAEHkABAoa0H//wNxIgIQLgJ/IAdBABAoIQ8gBEEAIARBABAoIgpBAWoQKSAPCyAKakEAIANB/QFqIgMQKyADQf8BcUGw5gBqQQAQL0GAAnJBAnQgAGpBmAFqIgNBACADQQAQMUEBahAuIAJBf2pBEHRBEHUiA0H//wNxIQIgEAsgCGpBfWohBSAAQYgTaiADQf//A3FBgAJIBH8gAkGw4gBqQQAQLwUgAkEHdkGw5ABqQQAQLwtBAnRqIgJBACACQQAQMUEBahAuIARBABAoAn8gDEEAEChBf2ohESAAQfQAIABB9AAQKCAAQfgAECgiAkF/amsQKSAAQfgAIAJBfmoiAhApA0AgAEHsACAAQewAECgiCkEBaiIDECkgAyAFTQRAIABByAAgAEHUABAoIABBOBAoIApBA2pqQQAQLyAAQcgAECggAEHYABAodHNxIgIQKSALQQAQKCADIABBNBAocUEBdGpBACAAQcQAECggAkEBdGpBABAxEC4gAEHEABAoIABByAAQKEEBdGpBACAAQewAECgQLiAAQfgAECghAgsgAEH4ACACQX9qIgIQKSACDQALIABB6ABBABApIABB4ABBAhApIABB7AAgAEHsABAoQQFqIgUQKSARC0YEQCAAIABB3AAQKCICQX9KBH8gAiAAQTgQKGoFQQALIAUgAmtBABBDIABB3AAgAEHsABAoECkgAEEAECgQOCAAQQAQKEEQEChFDQQLCwwBCwsgAEHoABAoBEAgAEE4ECggAEHsABAoQX9qakEAEC0hAiAGQQAQKCAEQQAQKEEBdGpBAEEAEC4CfyAHQQAQKCESIARBACAEQQAQKCIHQQFqECkgEgsgB2pBACACECsgAEGUAWogAkH/AXFBAnRqIgJBACACQQAQMUEBahAuIABB6ABBABApCyAAQbQtakEAIABB7AAQKCICQQIgAkECSRsQKSABQQRGBEAgAEHcABAoIgFBf0wEQCAAQQAgAiABa0EBEEMMAwsgACABIABBOBAoaiACIAFrQQEQQwwCCyAEQQAQKARAIAAgAEHcABAoIgFBf0oEfyABIABBOBAoagVBAAsgAiABa0EAEEMgAEHcACAAQewAECgQKSAAQQAQKBA4IABBABAoQRAQKEUEQEEADwsLQQEPC0EADwsgAEHcACAAQewAECgQKSAAQQAQKBA4QQNBAiAAQQAQKEEQECgbC9cKAQ1/IAFBAEchCyAAQUBrIQcgAEGkLWohCCAAQaAtaiEEIABBmC1qIQkgAEGcLWohCgJAAkADQAJAAkACQCAAQfQAEChBhgJJBEAgABB9IABB9AAQKCICQYUCSyALckUNBSACRQ0DIAJBAk0NAQsgAEHIACAAQdQAECggAEE4ECggAEHsABAoIgJBAmpqQQAQLyAAQcgAECggAEHYABAodHNxIgMQKSAHQQAQKCACIABBNBAocUEBdGpBACAAQcQAECggA0EBdGpBABAxIgIQLiAAQcQAECggAEHIABAoQQF0akEAIABB7AAQKBAuIAJFDQAgAEHsABAoIAJB//8DcSICayAAQSwQKEH6fWpLDQAgAEHgACAAIAIQyAEiAhApDAELIABB4AAQKCECCwJAAkAgAkECSwRAAkAgCEEAECggBEEAEChBAXRqQQAgAEHsABAoIABB8AAQKGtB//8DcSIDEC4CfyAJQQAQKCEMIARBACAEQQAQKCIGQQFqECkgDAsgBmpBACACQf0BaiICECsgAkH/AXFBsOYAakEAEC9BgAJyQQJ0IABqQZgBaiICQQAgAkEAEDFBAWoQLiADQX9qQRB0QRB1IgNB//8DcSECIABBiBNqIANB//8DcUGAAkgEfyACQbDiAGpBABAvBSACQQd2QbDkAGpBABAvC0ECdGoiAkEAIAJBABAxQQFqEC4gBEEAECggCkEAEChBf2pGIQMgAEH0ACAAQfQAECggAEHgABAoIgJrIgUQKSACIABBgAEQKE0gBUECS3FFBEAgAEHsACACIABB7AAQKGoiAhApIABB4ABBABApIABByAAgAiAAQTgQKCIFakEAEC8iBhApIABByAAgAEHUABAoIAUgAkEBampBABAvIAYgAEHYABAodHNxECkgA0UNAQwDCyAAQeAAIAJBf2oQKQNAIABB7AAgAEHsABAoIgJBAWoiBRApIABByAAgAEHUABAoIABBOBAoIAJBA2pqQQAQLyAAQcgAECggAEHYABAodHNxIgIQKSAHQQAQKCAFIABBNBAocUEBdGpBACAAQcQAECggAkEBdGpBABAxEC4gAEHEABAoIABByAAQKEEBdGpBACAAQewAECgQLiAAQeAAIABB4AAQKEF/aiICECkgAg0ACyAAQewAIABB7AAQKEEBaiICECkgAw0CCwUgAEE4ECggAEHsABAoakEAEC0hAiAIQQAQKCAEQQAQKEEBdGpBAEEAEC4CfyAJQQAQKCENIARBACAEQQAQKCIFQQFqECkgDQsgBWpBACACECsgAEGUAWogAkH/AXFBAnRqIgJBACACQQAQMUEBahAuAn8gBEEAECggCkEAEChBf2pGIQ4gAEH0ACAAQfQAEChBf2oQKSAAQewAIABB7AAQKEEBaiICECkgDgsNAQsMAQsgACAAQdwAECgiA0F/SgR/IAMgAEE4EChqBUEACyACIANrQQAQQyAAQdwAIABB7AAQKBApIABBABAoEDggAEEAEChBEBAoRQ0DCwwBCwsgAEG0LWpBACAAQewAECgiAkECIAJBAkkbECkg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KSAABH8gAUEAQQAQKSABQQRBABApIAFBCEEAECkgAUEMQQAQKSABQRBBABApIAFB1ABBABApIAFBFEIAEDkgAUEcQgAQOSABQSRBABApIAFBKEEAECsgAUEwQgAQLCABQThCABAsIAFBwABCABAsIAFByABCABAsIAEFIAEQMkEACwuaAQECfyAAQTAQKiABWARAIABBCGoiAARAIABBAEESECkgAEEEQQAQKQsPCyAAQQhqIQIgAEEYEChBAnEEQCACBEAgAkEAQRkQKSACQQRBABApCw8LIAAgAUEAIAIQiQEiA0UEQA8LIABB0AAQKCADIAIQpAFFBEAPCyAAIAEQ5AIEQA8LIABBQGtBABAoIAGnQQR0akEMQQEQKwsxACAAQQAQKBBYQgBTBEBBfw8LIAAgASACEMgCQgBTBH9BfwUgAEEAECgQWEI/h6cLC0QBAn4gAEEAEC1BAXEEQCABIABBEBAqIgJ8IgMgAVoEQCADIABBCBAqWARAIABBBBAoIAKnag8LCwsgAEEAQQAQK0EACwsAQQAgASACEM4BC50BAwN/AX4BfCMDIQIjA0GAQGskAyMDIwROBEBBgMAAEAALIAG6IQYgAEEIaiEDA38Cf0EAIAFCAFENABpBfyAAQQAQKCACIAFCgMAAIAFCgMAAVBtC/////w+DIgUgAxCHAUEASA0AGiAAIAIgBRBSQQBIBH9BfwUgAEHUABAoIAYgASAFfSIBuqEgBqMQgQEMAgsLCyEEIAIkAyAEC7cBAQF+IABBICACQQAQKiIDQv////8PIANC/////w9UGxB0IABBHCABECkgAEEQaiEBIABBBBAtQQFxBH8gASAAQQwQLUECdEEEcRDbAgUgARDUAgshASACQQAgAkEAECogAEEgECitfRAsAkACQAJAAkAgAUF7aw4HAQMDAwMCAAMLQQEPCyAAQRQQKEUEQEEDDwsMAQtBAA8LIABBABAoIgAEQCAAQQBBDRApIABBBCABECkLQQILCgAgAEEMQQEQKwtIACACQv////8PWARAIABBFBAoRQRAIABBFCACEHQgAEEQIAEQKUEBDwsLIABBABAoIgAEQCAAQQBBEhApIABBBEEAECkLQQALSAEBfyAAQRBqIQEgAEEEEC1BAXEEfyABEMoBBSABENICCyIBRQRAQQEPCyAAQQAQKCIABEAg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BQsgBEEAQQEQKSAEQQRBAhApIARBCEEDECkgBEEMQQQQKSAEQRBBBRApIARBFEEGECkgBEEYQQcQKSAEQRxBCBApIARBIEERECkgBEEkQQkQKSAEQShBDxApIARBLEEKECkgBEEwQQwQKSAEQTRBDRApIARBOEELECkgBEE8QX8QKUEAIAQQWQwECyAAQRAQKEE4ECoiAkIAUwR+IAAEQCAAQQBBHhApIABBBEHLABApC0J/BSACCwwDCyAAQRQQKEE4ECoiAkIAUwR+IAAEQCAAQQBBHhApIABBBEHLABApC0J/BSACCwwCCyACQgBTBH4gAARAIABBAEESECkgAEEEQQAQKQtCfwUgAEEUECggASACIAAQkQMLDAELIAAEQCAAQQBBHBApIABBBEEAECkLQn8LIQUgBCQDIAULCQAgAEEYECqnC6oBACAARQRAIAIEQCACQQBBEhApIAJBBEEAECkLQQAPCyAAQgEgASACEHEiAUUEQEEADwtBGBA0IgBFBEAgAgRAIAJBAEEOECkgAkEEQQAQKQsgARBRQQAPCyAAQRAgARApIABBFEEAECkgAEEMQQAQCBApIABBAEEAECkgAEEEQQAQKSAAQQhBABApQQEgACACENgBIgEEQCABDwsgAEEQECgQUSAAEDJBAAtIACAAQSQQKEEBRgRAIABBDGoiAARAIABBAEESECkgAEEEQQAQKQtBfw8LIABBACABQREQREIAUwRAQX8PCyAAQSRBARApQQALSAAgAEEkEChBAUYEQCAAQQxqIgAEQCAAQQBBEhApIABBBEEAECkLQX8PCyAAQQBCAEEIEERCAFMEQEF/DwsgAEEkQQEQKUEAC7EFAgZ/AX4gAEEwECogAVgEQCAAQQhqIgAEQCAAQQBBEhApIABBBEEAECkLQX8PCyAAQRgQKEECcQRAIABBCGoiAARAIABBAEEZECkgAEEEQQAQKQtBfw8LIAIEfyACQQAQLQR/IAIgAhBGQf//A3EgAyAAQQhqEH4iBEUEQEF/DwsgA0GAMHFFBEAgBEEAEGNBA0YEQCAEQQhBAhApCwsgBAVBAAsFQQALIQMgACACQQBBABCEASIKQn9VBEAgAxBJIAEgClEEQEEADwsgAEEIaiIABEAgAEEAQQoQKSAAQQRBABApC0F/DwsCQAJAAkAgAEFAa0EAECgiBiAB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dXJjZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZQBJbnZhbGlkIHNlZWsAQ3Jvc3MtZGV2aWNlIGxpbmsAUmVhZC1vbmx5IGZpbGUgc3lzdGVtAERpcmVjdG9yeSBub3QgZW1wdHkAQ29ubmVjdGlvbiByZXNldCBieSBwZWVyAE9wZXJhdGlvbiB0aW1lZCBvdXQAQ29ubmVjdGlvbiByZWZ1c2VkAEhvc3QgaXMgZG93bgBIb3N0IGlzIHVucmVhY2hhYmxlAEFkZHJlc3MgaW4gdXNlAEJyb2tlbiBwaXBlAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzAEJsb2NrIGRldmljZSByZXF1aXJlZABObyBzdWNoIGRldmljZQBOb3QgYSBkaXJlY3RvcnkASXMgYSBkaXJlY3RvcnkAVGV4dCBmaWxlIGJ1c3kARXhlYyBmb3JtYXQgZXJyb3IASW52YWxpZCBhcmd1bWVudABBcmd1bWVudCBsaXN0IHRvbyBsb25nAFN5bWJvbGljIGxpbmsgbG9vcABGaWxlbmFtZSB0b28gbG9uZwBUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbQBObyBmaWxlIGRlc2NyaXB0b3JzIGF2YWlsYWJsZQBCYWQgZmlsZSBkZXNjcmlwdG9yAE5vIGNoaWxkIHByb2Nlc3MAQmFkIGFkZHJlc3MARmlsZSB0b28gbGFyZ2UAVG9vIG1hbnkgbGlua3MATm8gbG9ja3MgYXZhaWxhYmxlAFJlc291cmNlIGRlYWRsb2NrIHdvdWxkIG9jY3VyAFN0YXRlIG5vdCByZWNvdmVyYWJsZQBQcmV2aW91cyBvd25lciBkaWVkAE9wZXJhdGlvbiBjYW5jZWxlZABGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQATm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUASWRlbnRpZmllciByZW1vdmVkAERldmljZSBub3QgYSBzdHJlYW0ATm8gZGF0YSBhdmFpbGFibGUARGV2aWNlIHRpbWVvdXQAT3V0IG9mIHN0cmVhbXMgcmVzb3VyY2VzAExpbmsgaGFzIGJlZW4gc2V2ZXJlZABQcm90b2NvbCBlcnJvcgBCYWQgbWVzc2FnZQBGaWxlIGRlc2NyaXB0b3IgaW4gYmFkIHN0YXRlAE5vdCBhIHNvY2tldABEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkAE1lc3NhZ2UgdG9vIGxhcmdlAFByb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldABQcm90b2NvbCBub3QgYXZhaWxhYmxlAFByb3RvY29sIG5vdCBzdXBwb3J0ZWQAU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZABOb3Qgc3VwcG9ydGVkAFByb3RvY29sIGZhbWlseSBub3Qgc3VwcG9ydGVkAEFkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wAQWRkcmVzcyBub3QgYXZhaWxhYmxlAE5ldHdvcmsgaXMgZG93bgBOZXR3b3JrIHVucmVhY2hhYmxlAENvbm5lY3Rpb24gcmVzZXQgYnkgbmV0d29yawBDb25uZWN0aW9uIGFib3J0ZWQATm8gYnVmZmVyIHNwYWNlIGF2YWlsYWJsZQBTb2NrZXQgaXMgY29ubmVjdGVkAFNvY2tldCBub3QgY29ubmVjdGVkAENhbm5vdCBzZW5kIGFmdGVyIHNvY2tldCBzaHV0ZG93bgBPcGVyYXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzcwBPcGVyYXRpb24gaW4gcHJvZ3Jlc3MAU3RhbGUgZmlsZSBoYW5kbGUAUmVtb3RlIEkvTyBlcnJvcgBRdW90YSBleGNlZWRlZABObyBtZWRpdW0gZm91bmQAV3JvbmcgbWVkaXVtIHR5cGUATm8gZXJyb3IgaW5mb3JtYXRpb24AAAAAAAD/////////////////////AQAAAAEAAAABAAAAAgAAAAMAAAABAAAAAgAAAAIAAAADAAAAAQAAAAEAAAACAAAAAwAAAAEAAAACAAAAAgAAAIA1AAAAOgAAAQEAAB4BAAAPAAAAgDQAAAA1AAAAAAAAHgAAAA8AAAAAAAAAMDQAAAAAAAATAAAABwAAAAUAQbiLAQsBBABB0IsBCw4EAAAABQAAABhNAAAABABB6IsBCwEBAEH3iwELBQr/////AEGojAELAqxFAEHQjAELAQYAQfeMAQsF//////8AQeSOAQsCfFMAQZyPAQvyCkFFAFBLAwQAUEsBAgBVbmtub3duIGVycm9yICVkADogACVzJXMlcwBQSwcIAFBLBQYAUEsGBwBQSwYGAE5vIGVycm9yAE11bHRpLWRpc2sgemlwIGFyY2hpdmVzIG5vdCBzdXBwb3J0ZWQAUmVuYW1pbmcgdGVtcG9yYXJ5IGZpbGUgZmFpbGVkAENsb3NpbmcgemlwIGFyY2hpdmUgZmFpbGVkAFNlZWsgZXJyb3IAUmVhZCBlcnJvcgBXcml0ZSBlcnJvcgBDUkMgZXJyb3IAQ29udGFpbmluZyB6aXAgYXJjaGl2ZSB3YXMgY2xvc2VkAE5vIHN1Y2ggZmlsZQBGaWxlIGFscmVhZHkgZXhpc3RzAENhbid0IG9wZW4gZmlsZQBGYWlsdXJlIHRvIGNyZWF0ZSB0ZW1wb3JhcnkgZmlsZQBabGliIGVycm9yAE1hbGxvYyBmYWlsdXJlAEVudHJ5IGhhcyBiZWVuIGNoYW5nZWQAQ29tcHJlc3Npb24gbWV0aG9kIG5vdCBzdXBwb3J0ZWQAUHJlbWF0dXJlIGVuZCBvZiBmaWxlAEludmFsaWQgYXJndW1lbnQATm90IGEgemlwIGFyY2hpdmUASW50ZXJuYWwgZXJyb3IAWmlwIGFyY2hpdmUgaW5jb25zaXN0ZW50AENhbid0IHJlbW92ZSBmaWxlAEVudHJ5IGhhcyBiZWVuIGRlbGV0ZWQARW5jcnlwdGlvbiBtZXRob2Qgbm90IHN1cHBvcnRlZABSZWFkLW9ubHkgYXJjaGl2ZQBObyBwYXNzd29yZCBwcm92aWRlZABXcm9uZyBwYXNzd29yZCBwcm92aWRlZABPcGVyYXRpb24gbm90IHN1cHBvcnRlZABSZXNvdXJjZSBzdGlsbCBpbiB1c2UAVGVsbCBlcnJvcgBDb21wcmVzc2VkIGRhdGEgaW52YWxpZAByYgAlcy5YWFhYWFgAcitiAGluY29ycmVjdCBoZWFkZXIgY2hlY2sAdW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QAaW52YWxpZCB3aW5kb3cgc2l6ZQB1bmtub3duIGhlYWRlciBmbGFncyBzZXQAaGVhZGVyIGNyYyBtaXNtYXRjaABpbnZhbGlkIGJsb2NrIHR5cGUAaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3RocwB0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scwBpbnZhbGlkIGNvZGUgbGVuZ3RocyBzZXQAaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdABpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2sAaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0AGludmFsaWQgZGlzdGFuY2VzIHNldABpbmNvcnJlY3QgZGF0YSBjaGVjawBpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrAGludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrAGludmFsaWQgZGlzdGFuY2UgY29kZQBpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUAbmVlZCBkaWN0aW9uYXJ5AHN0cmVhbSBlbmQAZmlsZSBlcnJvcgBzdHJlYW0gZXJyb3IAZGF0YSBlcnJvcgBpbnN1ZmZpY2llbnQgbWVtb3J5AGJ1ZmZlciBlcnJvcgBpbmNvbXBhdGlibGUgdmVyc2lvbgAtKyAgIDBYMHgAKG51bGwpAC0wWCswWCAwWC0weCsweCAweABpbmYASU5GAG5hbgBOQU4ALgAvcHJvYy9zZWxmL2ZkLwByd2EAWFhYWFhY";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinary(){try{if(Module["wasmBinary"]){return new Uint8Array(Module["wasmBinary"])}var binary=tryParseAsDataURI(wasmBinaryFile);if(binary){return binary}if(Module["readBinary"]){return Module["readBinary"](wasmBinaryFile)}else{throw"sync fetching of the wasm failed: you can preload it to Module['wasmBinary'] manually, or emcc.py will do that for you when generating HTML (but not JS)"}}catch(err){abort(err)}}function createWasm(env){var info={"env":env,"global":{"NaN":NaN,Infinity:Infinity},"global.Math":Math,"asm2wasm":asm2wasmImports};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;removeRunDependency("wasm-instantiate")}addRunDependency("wasm-instantiate");if(Module["instantiateWasm"]){try{return Module["instantiateWasm"](info,receiveInstance)}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}var instance;var module;try{module=new WebAssembly.Module(getBinary());instance=new WebAssembly.Instance(module,info)}catch(e){err("failed to compile wasm module: "+e);if(e.toString().indexOf("imported Memory with incompatible size")>=0){err("Memory size incompatibility issues may be due to changing TOTAL_MEMORY at runtime to something too large. Use ALLOW_MEMORY_GROWTH to allow any size memory (and also make sure not to set TOTAL_MEMORY at runtime to something smaller than it was at compile time).")}return false}receiveInstance(instance,module);return Module["asm"]}Module["asm"]=function(global,env,providedBuffer){env["memory"]=wasmMemory;env["table"]=wasmTable=new WebAssembly.Table({"initial":55,"maximum":55,"element":"anyfunc"});env["__memory_base"]=1024;env["__table_base"]=0;var exports=createWasm(env);assert(exports,"binaryen setup failed (no wasm support?)");return exports};__ATINIT__.push({func:function(){___emscripten_environ_constructor()}});var tempDoublePtr=22704;assert(tempDoublePtr%8==0);var ENV={};function ___buildEnvironment(environ){var MAX_ENV_VALUES=64;var TOTAL_ENV_SIZE=1024;var poolPtr;var envPtr;if(!___buildEnvironment.called){___buildEnvironment.called=true;ENV["USER"]=ENV["LOGNAME"]="web_user";ENV["PATH"]="/";ENV["PWD"]="/";ENV["HOME"]="/home/web_user";ENV["LANG"]="C.UTF-8";ENV["_"]=Module["thisProgram"];poolPtr=getMemory(TOTAL_ENV_SIZE);envPtr=getMemory(MAX_ENV_VALUES*4);SAFE_HEAP_STORE(envPtr|0,poolPtr|0,4);SAFE_HEAP_STORE(environ|0,envPtr|0,4)}else{envPtr=SAFE_HEAP_LOAD(environ|0,4,0)|0;poolPtr=SAFE_HEAP_LOAD(envPtr|0,4,0)|0}var strings=[];var totalSize=0;for(var key in ENV){if(typeof ENV[key]==="string"){var line=key+"="+ENV[key];strings.push(line);totalSize+=line.length}}if(totalSize>TOTAL_ENV_SIZE){throw new Error("Environment size exceeded TOTAL_ENV_SIZE!")}var ptrSize=4;for(var i=0;i<strings.length;i++){var line=strings[i];writeAsciiToMemory(line,poolPtr);SAFE_HEAP_STORE(envPtr+i*ptrSize|0,poolPtr|0,4);poolPtr+=line.length+1}SAFE_HEAP_STORE(envPtr+strings.length*ptrSize|0,0|0,4)}function _emscripten_get_now(){abort()}function _emscripten_get_now_is_monotonic(){return  false||ENVIRONMENT_IS_NODE}function ___setErrNo(value){if(Module["___errno_location"])SAFE_HEAP_STORE(Module["___errno_location"]()|0,value|0,4);else err("failed to set errno from JS");return value}function _clock_gettime(clk_id,tp){var now;if(clk_id===0){now=Date.now()}else if(clk_id===1&&_emscripten_get_now_is_monotonic()){now=_emscripten_get_now()}else{___setErrNo(22);return-1}SAFE_HEAP_STORE(tp|0,now/1e3|0|0,4);SAFE_HEAP_STORE(tp+4|0,now%1e3*1e3*1e3|0|0,4);return 0}function ___clock_gettime(a0,a1){return _clock_gettime(a0,a1)}function ___lock(){}var PATH={splitPath:function(filename){var splitPathRe=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;return splitPathRe.exec(filename).slice(1)},normalizeArray:function(parts,allowAboveRoot){var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last==="."){parts.splice(i,1)}else if(last===".."){parts.splice(i,1);up++}else if(up){parts.splice(i,1);up--}}if(allowAboveRoot){for(;up;up--){parts.unshift("..")}}return parts},normalize:function(path){var isAbsolute=path.charAt(0)==="/",trailingSlash=path.substr(-1)==="/";path=PATH.normalizeArray(path.split("/").filter(function(p){return!!p}),!isAbsolute).join("/");if(!path&&!isAbsolute){path="."}if(path&&trailingSlash){path+="/"}return(isAbsolute?"/":"")+path},dirname:function(path){var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){return"."}if(dir){dir=dir.substr(0,dir.length-1)}return root+dir},basename:function(path){if(path==="/")return"/";var lastSlash=path.lastIndexOf("/");if(lastSlash===-1)return path;return path.substr(lastSlash+1)},extname:function(path){return PATH.splitPath(path)[3]},join:function(){var paths=Array.prototype.slice.call(arguments,0);return PATH.normalize(paths.join("/"))},join2:function(l,r){return PATH.normalize(l+"/"+r)},resolve:function(){var resolvedPath="",resolvedAbsolute=false;for(var i=arguments.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?arguments[i]:FS.cwd();if(typeof path!=="string"){throw new TypeError("Arguments to path.resolve must be strings")}else if(!path){return""}resolvedPath=path+"/"+resolvedPath;resolvedAbsolute=path.charAt(0)==="/"}resolvedPath=PATH.normalizeArray(resolvedPath.split("/").filter(function(p){return!!p}),!resolvedAbsolute).join("/");return(resolvedAbsolute?"/":"")+resolvedPath||"."},relative:function(from,to){from=PATH.resolve(from).substr(1);to=PATH.resolve(to).substr(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!=="")break}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!=="")break}if(start>end)return[];return arr.slice(start,end-start+1)}var fromParts=trim(from.split("/"));var toParts=trim(to.split("/"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push("..")}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join("/")}};var TTY={ttys:[],init:function(){},shutdown:function(){},register:function(dev,ops){TTY.ttys[dev]={input:[],output:[],ops:ops};FS.registerDevice(dev,TTY.stream_ops)},stream_ops:{open:function(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}stream.tty=tty;stream.seekable=false},close:function(stream){stream.tty.ops.flush(stream.tty)},flush:function(stream){stream.tty.ops.flush(stream.tty)},read:function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.get_char){throw new FS.ErrnoError(ERRNO_CODES.ENXIO)}var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty)}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(ERRNO_CODES.EAGAIN)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.timestamp=Date.now()}return bytesRead},write:function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char){throw new FS.ErrnoError(ERRNO_CODES.ENXIO)}try{for(var i=0;i<length;i++){stream.tty.ops.put_char(stream.tty,buffer[offset+i])}}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO)}if(length){stream.node.timestamp=Date.now()}return i}},default_tty_ops:{get_char:function(tty){if(!tty.input.length){var result=null;if(ENVIRONMENT_IS_NODE){var BUFSIZE=256;var buf=new Buffer(BUFSIZE);var bytesRead=0;var isPosixPlatform=process.platform!="win32";var fd=process.stdin.fd;if(isPosixPlatform){var usingDevice=false;try{fd=fs.openSync("/dev/stdin","r");usingDevice=true}catch(e){}}try{bytesRead=fs.readSync(fd,buf,0,BUFSIZE,null)}catch(e){if(e.toString().indexOf("EOF")!=-1)bytesRead=0;else throw e}if(usingDevice){fs.closeSync(fd)}if(bytesRead>0){result=buf.slice(0,bytesRead).toString("utf-8")}else{result=null}}else if(typeof window!="undefined"&&typeof window.prompt=="function"){result=window.prompt("Input: ");if(result!==null){result+="\n"}}else if(typeof readline=="function"){result=readline();if(result!==null){result+="\n"}}if(!result){return null}tty.input=intArrayFromString(result,true)}return tty.input.shift()},put_char:function(tty,val){if(val===null||val===10){out(UTF8ArrayToString(tty.output,0));tty.output=[]}else{if(val!=0)tty.output.push(val)}},flush:function(tty){if(tty.output&&tty.output.length>0){out(UTF8ArrayToString(tty.output,0));tty.output=[]}}},default_tty1_ops:{put_char:function(tty,val){if(val===null||val===10){err(UTF8ArrayToString(tty.output,0));tty.output=[]}else{if(val!=0)tty.output.push(val)}},flush:function(tty){if(tty.output&&tty.output.length>0){err(UTF8ArrayToString(tty.output,0));tty.output=[]}}}};var MEMFS={ops_table:null,mount:function(mount){return MEMFS.createNode(null,"/",16384|511,0)},createNode:function(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode)){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}if(!MEMFS.ops_table){MEMFS.ops_table={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,allocate:MEMFS.stream_ops.allocate,mmap:MEMFS.stream_ops.mmap,msync:MEMFS.stream_ops.msync}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}}}var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={}}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;node.contents=null}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;node.stream_ops=MEMFS.ops_table.chrdev.stream}node.timestamp=Date.now();if(parent){parent.contents[name]=node}return node},getFileDataAsRegularArray:function(node){if(node.contents&&node.contents.subarray){var arr=[];for(var i=0;i<node.usedBytes;++i)arr.push(node.contents[i]);return arr}return node.contents},getFileDataAsTypedArray:function(node){if(!node.contents)return new Uint8Array;if(node.contents.subarray)return node.contents.subarray(0,node.usedBytes);return new Uint8Array(node.contents)},expandFileStorage:function(node,newCapacity){var prevCapacity=node.contents?node.contents.length:0;if(prevCapacity>=newCapacity)return;var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)|0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,256);var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0);return},resizeFileStorage:function(node,newSize){if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;node.usedBytes=0;return}if(!node.contents||node.contents.subarray){var oldContents=node.contents;node.contents=new Uint8Array(new ArrayBuffer(newSize));if(oldContents){node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)))}node.usedBytes=newSize;return}if(!node.contents)node.contents=[];if(node.contents.length>newSize)node.contents.length=newSize;else while(node.contents.length<newSize)node.contents.push(0);node.usedBytes=newSize},node_ops:{getattr:function(node){var attr={};attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode)){attr.size=4096}else if(FS.isFile(node.mode)){attr.size=node.usedBytes}else if(FS.isLink(node.mode)){attr.size=node.link.length}else{attr.size=0}attr.atime=new Date(node.timestamp);attr.mtime=new Date(node.timestamp);attr.ctime=new Date(node.timestamp);attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr},setattr:function(node,attr){if(attr.mode!==undefined){node.mode=attr.mode}if(attr.timestamp!==undefined){node.timestamp=attr.timestamp}if(attr.size!==undefined){MEMFS.resizeFileStorage(node,attr.size)}},lookup:function(parent,name){throw FS.genericErrors[ERRNO_CODES.ENOENT]},mknod:function(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev)},rename:function(old_node,new_dir,new_name){if(FS.isDir(old_node.mode)){var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(new_node){for(var i in new_node.contents){throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)}}}delete old_node.parent.contents[old_node.name];old_node.name=new_name;new_dir.contents[new_name]=old_node;old_node.parent=new_dir},unlink:function(parent,name){delete parent.contents[name]},rmdir:function(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents){throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)}delete parent.contents[name]},readdir:function(node){var entries=[".",".."];for(var key in node.contents){if(!node.contents.hasOwnProperty(key)){continue}entries.push(key)}return entries},symlink:function(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|40960,0);node.link=oldpath;return node},readlink:function(node){if(!FS.isLink(node.mode)){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return node.link}},stream_ops:{read:function(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);assert(size>=0);if(size>8&&contents.subarray){buffer.set(contents.subarray(position,position+size),offset)}else{for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i]}return size},write:function(stream,buffer,offset,length,position,canOwn){if(canOwn){warnOnce("file packager has copied file data into memory, but in memory growth we are forced to copy it again (see --no-heap-copy)")}canOwn=false;if(!length)return 0;var node=stream.node;node.timestamp=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray)){if(canOwn){assert(position===0,"canOwn must imply no weird position inside the file");node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length}else if(node.usedBytes===0&&position===0){node.contents=new Uint8Array(buffer.subarray(offset,offset+length));node.usedBytes=length;return length}else if(position+length<=node.usedBytes){node.contents.set(buffer.subarray(offset,offset+length),position);return length}}MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray)node.contents.set(buffer.subarray(offset,offset+length),position);else{for(var i=0;i<length;i++){node.contents[position+i]=buffer[offset+i]}}node.usedBytes=Math.max(node.usedBytes,position+length);return length},llseek:function(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.usedBytes}}if(position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return position},allocate:function(stream,offset,length){MEMFS.expandFileStorage(stream.node,offset+length);stream.node.usedBytes=Math.max(stream.node.usedBytes,offset+length)},mmap:function(stream,buffer,offset,length,position,prot,flags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}var ptr;var allocated;var contents=stream.node.contents;if(!(flags&2)&&(contents.buffer===buffer||contents.buffer===buffer.buffer)){allocated=false;ptr=contents.byteOffset}else{if(position>0||position+length<stream.node.usedBytes){if(contents.subarray){contents=contents.subarray(position,position+length)}else{contents=Array.prototype.slice.call(contents,position,position+length)}}allocated=true;ptr=_malloc(length);if(!ptr){throw new FS.ErrnoError(ERRNO_CODES.ENOMEM)}buffer.set(contents,ptr)}return{ptr:ptr,allocated:allocated}},msync:function(stream,buffer,offset,length,mmapFlags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}if(mmapFlags&2){return 0}var bytesWritten=MEMFS.stream_ops.write(stream,buffer,0,length,offset,false);return 0}}};var NODEFS={isWindows:false,staticInit:function(){NODEFS.isWindows=!!process.platform.match(/^win/);var flags=process["binding"]("constants");if(flags["fs"]){flags=flags["fs"]}NODEFS.flagsForNodeMap={1024:flags["O_APPEND"],64:flags["O_CREAT"],128:flags["O_EXCL"],0:flags["O_RDONLY"],2:flags["O_RDWR"],4096:flags["O_SYNC"],512:flags["O_TRUNC"],1:flags["O_WRONLY"]}},bufferFrom:function(arrayBuffer){return Buffer.alloc?Buffer.from(arrayBuffer):new Buffer(arrayBuffer)},mount:function(mount){assert(ENVIRONMENT_IS_NODE);return NODEFS.createNode(null,"/",NODEFS.getMode(mount.opts.root),0)},createNode:function(parent,name,mode,dev){if(!FS.isDir(mode)&&!FS.isFile(mode)&&!FS.isLink(mode)){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}var node=FS.createNode(parent,name,mode);node.node_ops=NODEFS.node_ops;node.stream_ops=NODEFS.stream_ops;return node},getMode:function(path){var stat;try{stat=fs.lstatSync(path);if(NODEFS.isWindows){stat.mode=stat.mode|(stat.mode&292)>>2}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}return stat.mode},realPath:function(node){var parts=[];while(node.parent!==node){parts.push(node.name);node=node.parent}parts.push(node.mount.opts.root);parts.reverse();return PATH.join.apply(null,parts)},flagsForNode:function(flags){flags&=~2097152;flags&=~2048;flags&=~32768;flags&=~524288;var newFlags=0;for(var k in NODEFS.flagsForNodeMap){if(flags&k){newFlags|=NODEFS.flagsForNodeMap[k];flags^=k}}if(!flags){return newFlags}else{throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}},node_ops:{getattr:function(node){var path=NODEFS.realPath(node);var stat;try{stat=fs.lstatSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}if(NODEFS.isWindows&&!stat.blksize){stat.blksize=4096}if(NODEFS.isWindows&&!stat.blocks){stat.blocks=(stat.size+stat.blksize-1)/stat.blksize|0}return{dev:stat.dev,ino:stat.ino,mode:stat.mode,nlink:stat.nlink,uid:stat.uid,gid:stat.gid,rdev:stat.rdev,size:stat.size,atime:stat.atime,mtime:stat.mtime,ctime:stat.ctime,blksize:stat.blksize,blocks:stat.blocks}},setattr:function(node,attr){var path=NODEFS.realPath(node);try{if(attr.mode!==undefined){fs.chmodSync(path,attr.mode);node.mode=attr.mode}if(attr.timestamp!==undefined){var date=new Date(attr.timestamp);fs.utimesSync(path,date,date)}if(attr.size!==undefined){fs.truncateSync(path,attr.size)}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}},lookup:function(parent,name){var path=PATH.join2(NODEFS.realPath(parent),name);var mode=NODEFS.getMode(path);return NODEFS.createNode(parent,name,mode)},mknod:function(parent,name,mode,dev){var node=NODEFS.createNode(parent,name,mode,dev);var path=NODEFS.realPath(node);try{if(FS.isDir(node.mode)){fs.mkdirSync(path,node.mode)}else{fs.writeFileSync(path,"",{mode:node.mode})}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}return node},rename:function(oldNode,newDir,newName){var oldPath=NODEFS.realPath(oldNode);var newPath=PATH.join2(NODEFS.realPath(newDir),newName);try{fs.renameSync(oldPath,newPath)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}},unlink:function(parent,name){var path=PATH.join2(NODEFS.realPath(parent),name);try{fs.unlinkSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}},rmdir:function(parent,name){var path=PATH.join2(NODEFS.realPath(parent),name);try{fs.rmdirSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}},readdir:function(node){var path=NODEFS.realPath(node);try{return fs.readdirSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}},symlink:function(parent,newName,oldPath){var newPath=PATH.join2(NODEFS.realPath(parent),newName);try{fs.symlinkSync(oldPath,newPath)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}},readlink:function(node){var path=NODEFS.realPath(node);try{path=fs.readlinkSync(path);path=NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root),path);return path}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}},stream_ops:{open:function(stream){var path=NODEFS.realPath(stream.node);try{if(FS.isFile(stream.node.mode)){stream.nfd=fs.openSync(path,NODEFS.flagsForNode(stream.flags))}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}},close:function(stream){try{if(FS.isFile(stream.node.mode)&&stream.nfd){fs.closeSync(stream.nfd)}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}},read:function(stream,buffer,offset,length,position){if(length===0)return 0;try{return fs.readSync(stream.nfd,NODEFS.bufferFrom(buffer.buffer),offset,length,position)}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code])}},write:function(stream,buffer,offset,length,position){try{return fs.writeSync(stream.nfd,NODEFS.bufferFrom(buffer.buffer),offset,length,position)}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code])}},llseek:function(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){try{var stat=fs.fstatSync(stream.nfd);position+=stat.size}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code])}}}if(position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return position}}};var ERRNO_CODES={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};var NODERAWFS={lookupPath:function(path){return{path:path,node:{mode:NODEFS.getMode(path)}}},createStandardStreams:function(){FS.streams[0]={fd:0,nfd:0,position:0,path:"",flags:0,tty:true,seekable:false};for(var i=1;i<3;i++){FS.streams[i]={fd:i,nfd:i,position:0,path:"",flags:577,tty:true,seekable:false}}},cwd:function(){return process.cwd()},chdir:function(){process.chdir.apply(void 0,arguments)},mknod:function(path,mode){if(FS.isDir(path)){fs.mkdirSync(path,mode)}else{fs.writeFileSync(path,"",{mode:mode})}},mkdir:function(){fs.mkdirSync.apply(void 0,arguments)},symlink:function(){fs.symlinkSync.apply(void 0,arguments)},rename:function(){fs.renameSync.apply(void 0,arguments)},rmdir:function(){fs.rmdirSync.apply(void 0,arguments)},readdir:function(){fs.readdirSync.apply(void 0,arguments)},unlink:function(){fs.unlinkSync.apply(void 0,arguments)},readlink:function(){return fs.readlinkSync.apply(void 0,arguments)},stat:function(){return fs.statSync.apply(void 0,arguments)},lstat:function(){return fs.lstatSync.apply(void 0,arguments)},chmod:function(){fs.chmodSync.apply(void 0,arguments)},fchmod:function(){fs.fchmodSync.apply(void 0,arguments)},chown:function(){fs.chownSync.apply(void 0,arguments)},fchown:function(){fs.fchownSync.apply(void 0,arguments)},truncate:function(){fs.truncateSync.apply(void 0,arguments)},ftruncate:function(){fs.ftruncateSync.apply(void 0,arguments)},utime:function(){fs.utimesSync.apply(void 0,arguments)},open:function(path,flags,mode,suggestFD){if(typeof flags==="string"){flags=VFS.modeStringToFlags(flags)}var nfd=fs.openSync(path,NODEFS.flagsForNode(flags),mode);var fd=suggestFD!=null?suggestFD:FS.nextfd(nfd);var stream={fd:fd,nfd:nfd,position:0,path:path,flags:flags,seekable:true};FS.streams[fd]=stream;return stream},close:function(stream){if(!stream.stream_ops){fs.closeSync(stream.nfd)}FS.closeStream(stream.fd)},llseek:function(stream,offset,whence){if(stream.stream_ops){return VFS.llseek(stream,offset,whence)}var position=offset;if(whence===1){position+=stream.position}else if(whence===2){position+=fs.fstatSync(stream.nfd).size}else if(whence!==0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}if(position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}stream.position=position;return position},read:function(stream,buffer,offset,length,position){if(stream.stream_ops){return VFS.read(stream,buffer,offset,length,position)}var seeking=typeof position!=="undefined";if(!seeking&&stream.seekable)position=stream.position;var bytesRead=fs.readSync(stream.nfd,NODEFS.bufferFrom(buffer.buffer),offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead},write:function(stream,buffer,offset,length,position){if(stream.stream_ops){return VFS.write(stream,buffer,offset,length,position)}if(stream.flags&+"1024"){FS.llseek(stream,0,+"2")}var seeking=typeof position!=="undefined";if(!seeking&&stream.seekable)position=stream.position;var bytesWritten=fs.writeSync(stream.nfd,NODEFS.bufferFrom(buffer.buffer),offset,length,position);if(!seeking)stream.position+=bytesWritten;return bytesWritten},allocate:function(){throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP)},mmap:function(){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)},msync:function(){return 0},munmap:function(){return 0},ioctl:function(){throw new FS.ErrnoError(ERRNO_CODES.ENOTTY)}};var ERRNO_MESSAGES={0:"Success",1:"Not super-user",2:"No such file or directory",3:"No such process",4:"Interrupted system call",5:"I/O error",6:"No such device or address",7:"Arg list too long",8:"Exec format error",9:"Bad file number",10:"No children",11:"No more processes",12:"Not enough core",13:"Permission denied",14:"Bad address",15:"Block device required",16:"Mount device busy",17:"File exists",18:"Cross-device link",19:"No such device",20:"Not a directory",21:"Is a directory",22:"Invalid argument",23:"Too many open files in system",24:"Too many open files",25:"Not a typewriter",26:"Text file busy",27:"File too large",28:"No space left on device",29:"Illegal seek",30:"Read only file system",31:"Too many links",32:"Broken pipe",33:"Math arg out of domain of func",34:"Math result not representable",35:"File locking deadlock error",36:"File or path name too long",37:"No record locks available",38:"Function not implemented",39:"Directory not empty",40:"Too many symbolic links",42:"No message of desired type",43:"Identifier removed",44:"Channel number out of range",45:"Level 2 not synchronized",46:"Level 3 halted",47:"Level 3 reset",48:"Link number out of range",49:"Protocol driver not attached",50:"No CSI structure available",51:"Level 2 halted",52:"Invalid exchange",53:"Invalid request descriptor",54:"Exchange full",55:"No anode",56:"Invalid request code",57:"Invalid slot",59:"Bad font file fmt",60:"Device not a stream",61:"No data (for no delay io)",62:"Timer expired",63:"Out of streams resources",64:"Machine is not on the network",65:"Package not installed",66:"The object is remote",67:"The link has been severed",68:"Advertise error",69:"Srmount error",70:"Communication error on send",71:"Protocol error",72:"Multihop attempted",73:"Cross mount point (not really error)",74:"Trying to read unreadable message",75:"Value too large for defined data type",76:"Given log. name not unique",77:"f.d. invalid for this operation",78:"Remote address changed",79:"Can   access a needed shared lib",80:"Accessing a corrupted shared lib",81:".lib section in a.out corrupted",82:"Attempting to link in too many libs",83:"Attempting to exec a shared library",84:"Illegal byte sequence",86:"Streams pipe error",87:"Too many users",88:"Socket operation on non-socket",89:"Destination address required",90:"Message too long",91:"Protocol wrong type for socket",92:"Protocol not available",93:"Unknown protocol",94:"Socket type not supported",95:"Not supported",96:"Protocol family not supported",97:"Address family not supported by protocol family",98:"Address already in use",99:"Address not available",100:"Network interface is not configured",101:"Network is unreachable",102:"Connection reset by network",103:"Connection aborted",104:"Connection reset by peer",105:"No buffer space available",106:"Socket is already connected",107:"Socket is not connected",108:"Can't send after socket shutdown",109:"Too many references",110:"Connection timed out",111:"Connection refused",112:"Host is down",113:"Host is unreachable",114:"Socket already connected",115:"Connection already in progress",116:"Stale file handle",122:"Quota exceeded",123:"No medium (in tape drive)",125:"Operation canceled",130:"Previous owner died",131:"State not recoverable"};var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,handleFSError:function(e){if(!(e instanceof FS.ErrnoError))throw e+" : "+stackTrace();return ___setErrNo(e.errno)},lookupPath:function(path,opts){path=PATH.resolve(FS.cwd(),path);opts=opts||{};if(!path)return{path:"",node:null};var defaults={follow_mount:true,recurse_count:0};for(var key in defaults){if(opts[key]===undefined){opts[key]=defaults[key]}}if(opts.recurse_count>8){throw new FS.ErrnoError(40)}var parts=PATH.normalizeArray(path.split("/").filter(function(p){return!!p}),false);var current=FS.root;var current_path="/";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent){break}current=FS.lookupNode(current,parts[i]);current_path=PATH.join2(current_path,parts[i]);if(FS.isMountpoint(current)){if(!islast||islast&&opts.follow_mount){current=current.mounted.root}}if(!islast||opts.follow){var count=0;while(FS.isLink(current.mode)){var link=FS.readlink(current_path);current_path=PATH.resolve(PATH.dirname(current_path),link);var lookup=FS.lookupPath(current_path,{recurse_count:opts.recurse_count});current=lookup.node;if(count++>40){throw new FS.ErrnoError(40)}}}}return{path:current_path,node:current}},getPath:function(node){var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!=="/"?mount+"/"+path:mount+path}path=path?node.name+"/"+path:node.name;node=node.parent}},hashName:function(parentid,name){var hash=0;for(var i=0;i<name.length;i++){hash=(hash<<5)-hash+name.charCodeAt(i)|0}return(parentid+hash>>>0)%FS.nameTable.length},hashAddNode:function(node){var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node},hashRemoveNode:function(node){var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node){FS.nameTable[hash]=node.name_next}else{var current=FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break}current=current.name_next}}},lookupNode:function(parent,name){var err=FS.mayLookup(parent);if(err){throw new FS.ErrnoError(err,parent)}var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name){return node}}return FS.lookup(parent,name)},createNode:function(parent,name,mode,rdev){if(!FS.FSNode){FS.FSNode=function(parent,name,mode,rdev){if(!parent){parent=this}this.parent=parent;this.mount=parent.mount;this.mounted=null;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.node_ops={};this.stream_ops={};this.rdev=rdev};FS.FSNode.prototype={};var readMode=292|73;var writeMode=146;Object.defineProperties(FS.FSNode.prototype,{read:{get:function(){return(this.mode&readMode)===readMode},set:function(val){val?this.mode|=readMode:this.mode&=~readMode}},write:{get:function(){return(this.mode&writeMode)===writeMode},set:function(val){val?this.mode|=writeMode:this.mode&=~writeMode}},isFolder:{get:function(){return FS.isDir(this.mode)}},isDevice:{get:function(){return FS.isChrdev(this.mode)}}})}var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node},destroyNode:function(node){FS.hashRemoveNode(node)},isRoot:function(node){return node===node.parent},isMountpoint:function(node){return!!node.mounted},isFile:function(mode){return(mode&61440)===32768},isDir:function(mode){return(mode&61440)===16384},isLink:function(mode){return(mode&61440)===40960},isChrdev:function(mode){return(mode&61440)===8192},isBlkdev:function(mode){return(mode&61440)===24576},isFIFO:function(mode){return(mode&61440)===4096},isSocket:function(mode){return(mode&49152)===49152},flagModes:{"r":0,"rs":1052672,"r+":2,"w":577,"wx":705,"xw":705,"w+":578,"wx+":706,"xw+":706,"a":1089,"ax":1217,"xa":1217,"a+":1090,"ax+":1218,"xa+":1218},modeStringToFlags:function(str){var flags=FS.flagModes[str];if(typeof flags==="undefined"){throw new Error("Unknown file open mode: "+str)}return flags},flagsToPermissionString:function(flag){var perms=["r","w","rw"][flag&3];if(flag&512){perms+="w"}return perms},nodePermissions:function(node,perms){if(FS.ignorePermissions){return 0}if(perms.indexOf("r")!==-1&&!(node.mode&292)){return 13}else if(perms.indexOf("w")!==-1&&!(node.mode&146)){return 13}else if(perms.indexOf("x")!==-1&&!(node.mode&73)){return 13}return 0},mayLookup:function(dir){var err=FS.nodePermissions(dir,"x");if(err)return err;if(!dir.node_ops.lookup)return 13;return 0},mayCreate:function(dir,name){try{var node=FS.lookupNode(dir,name);return 17}catch(e){}return FS.nodePermissions(dir,"wx")},mayDelete:function(dir,name,isdir){var node;try{node=FS.lookupNode(dir,name)}catch(e){return e.errno}var err=FS.nodePermissions(dir,"wx");if(err){return err}if(isdir){if(!FS.isDir(node.mode)){return 20}if(FS.isRoot(node)||FS.getPath(node)===FS.cwd()){return 16}}else{if(FS.isDir(node.mode)){return 21}}return 0},mayOpen:function(node,flags){if(!node){return 2}if(FS.isLink(node.mode)){return 40}else if(FS.isDir(node.mode)){if(FS.flagsToPermissionString(flags)!=="r"||flags&512){return 21}}return FS.nodePermissions(node,FS.flagsToPermissionString(flags))},MAX_OPEN_FDS:4096,nextfd:function(fd_start,fd_end){fd_start=fd_start||0;fd_end=fd_end||FS.MAX_OPEN_FDS;for(var fd=fd_start;fd<=fd_end;fd++){if(!FS.streams[fd]){return fd}}throw new FS.ErrnoError(24)},getStream:function(fd){return FS.streams[fd]},createStream:function(stream,fd_start,fd_end){if(!FS.FSStream){FS.FSStream=function(){};FS.FSStream.prototype={};Object.defineProperties(FS.FSStream.prototype,{object:{get:function(){return this.node},set:function(val){this.node=val}},isRead:{get:function(){return(this.flags&2097155)!==1}},isWrite:{get:function(){return(this.flags&2097155)!==0}},isAppend:{get:function(){return this.flags&1024}}})}var newStream=new FS.FSStream;for(var p in stream){newStream[p]=stream[p]}stream=newStream;var fd=FS.nextfd(fd_start,fd_end);stream.fd=fd;FS.streams[fd]=stream;return stream},closeStream:function(fd){FS.streams[fd]=null},chrdev_stream_ops:{open:function(stream){var device=FS.getDevice(stream.node.rdev);stream.stream_ops=device.stream_ops;if(stream.stream_ops.open){stream.stream_ops.open(stream)}},llseek:function(){throw new FS.ErrnoError(29)}},major:function(dev){return dev>>8},minor:function(dev){return dev&255},makedev:function(ma,mi){return ma<<8|mi},registerDevice:function(dev,ops){FS.devices[dev]={stream_ops:ops}},getDevice:function(dev){return FS.devices[dev]},getMounts:function(mount){var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push.apply(check,m.mounts)}return mounts},syncfs:function(populate,callback){if(typeof populate==="function"){callback=populate;populate=false}FS.syncFSRequests++;if(FS.syncFSRequests>1){console.log("warning: "+FS.syncFSRequests+" FS.syncfs operations in flight at once, probably just doing extra work")}var mounts=FS.getMounts(FS.root.mount);var completed=0;function doCallback(err){assert(FS.syncFSRequests>0);FS.syncFSRequests--;return callback(err)}function done(err){if(err){if(!done.errored){done.errored=true;return doCallback(err)}return}if(++completed>=mounts.length){doCallback(null)}}mounts.forEach(function(mount){if(!mount.type.syncfs){return done(null)}mount.type.syncfs(mount,populate,done)})},mount:function(type,opts,mountpoint){var root=mountpoint==="/";var pseudo=!mountpoint;var node;if(root&&FS.root){throw new FS.ErrnoError(16)}else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;node=lookup.node;if(FS.isMountpoint(node)){throw new FS.ErrnoError(16)}if(!FS.isDir(node.mode)){throw new FS.ErrnoError(20)}}var mount={type:type,opts:opts,mountpoint:mountpoint,mounts:[]};var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root){FS.root=mountRoot}else if(node){node.mounted=mount;if(node.mount){node.mount.mounts.push(mount)}}return mountRoot},unmount:function(mountpoint){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node)){throw new FS.ErrnoError(22)}var node=lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);Object.keys(FS.nameTable).forEach(function(hash){var current=FS.nameTable[hash];while(current){var next=current.name_next;if(mounts.indexOf(current.mount)!==-1){FS.destroyNode(current)}current=next}});node.mounted=null;var idx=node.mount.mounts.indexOf(mount);assert(idx!==-1);node.mount.mounts.splice(idx,1)},lookup:function(parent,name){return parent.node_ops.lookup(parent,name)},mknod:function(path,mode,dev){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);if(!name||name==="."||name===".."){throw new FS.ErrnoError(22)}var err=FS.mayCreate(parent,name);if(err){throw new FS.ErrnoError(err)}if(!parent.node_ops.mknod){throw new FS.ErrnoError(1)}return parent.node_ops.mknod(parent,name,mode,dev)},create:function(path,mode){mode=mode!==undefined?mode:438;mode&=4095;mode|=32768;return FS.mknod(path,mode,0)},mkdir:function(path,mode){mode=mode!==undefined?mode:511;mode&=511|512;mode|=16384;return FS.mknod(path,mode,0)},mkdirTree:function(path,mode){var dirs=path.split("/");var d="";for(var i=0;i<dirs.length;++i){if(!dirs[i])continue;d+="/"+dirs[i];try{FS.mkdir(d,mode)}catch(e){if(e.errno!=17)throw e}}},mkdev:function(path,mode,dev){if(typeof dev==="undefined"){dev=mode;mode=438}mode|=8192;return FS.mknod(path,mode,dev)},symlink:function(oldpath,newpath){if(!PATH.resolve(oldpath)){throw new FS.ErrnoError(2)}var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(2)}var newname=PATH.basename(newpath);var err=FS.mayCreate(parent,newname);if(err){throw new FS.ErrnoError(err)}if(!parent.node_ops.symlink){throw new FS.ErrnoError(1)}return parent.node_ops.symlink(parent,newname,oldpath)},rename:function(old_path,new_path){var old_dirname=PATH.dirname(old_path);var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);var lookup,old_dir,new_dir;try{lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node}catch(e){throw new FS.ErrnoError(16)}if(!old_dir||!new_dir)throw new FS.ErrnoError(2);if(old_dir.mount!==new_dir.mount){throw new FS.ErrnoError(18)}var old_node=FS.lookupNode(old_dir,old_name);var relative=PATH.relative(old_path,new_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(22)}relative=PATH.relative(new_path,old_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(39)}var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(old_node===new_node){return}var isdir=FS.isDir(old_node.mode);var err=FS.mayDelete(old_dir,old_name,isdir);if(err){throw new FS.ErrnoError(err)}err=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(err){throw new FS.ErrnoError(err)}if(!old_dir.node_ops.rename){throw new FS.ErrnoError(1)}if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node)){throw new FS.ErrnoError(16)}if(new_dir!==old_dir){err=FS.nodePermissions(old_dir,"w");if(err){throw new FS.ErrnoError(err)}}try{if(FS.trackingDelegate["willMovePath"]){FS.trackingDelegate["willMovePath"](old_path,new_path)}}catch(e){console.log("FS.trackingDelegate['willMovePath']('"+old_path+"', '"+new_path+"') threw an exception: "+e.message)}FS.hashRemoveNode(old_node);try{old_dir.node_ops.rename(old_node,new_dir,new_name)}catch(e){throw e}finally{FS.hashAddNode(old_node)}try{if(FS.trackingDelegate["onMovePath"])FS.trackingDelegate["onMovePath"](old_path,new_path)}catch(e){console.log("FS.trackingDelegate['onMovePath']('"+old_path+"', '"+new_path+"') threw an exception: "+e.message)}},rmdir:function(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var err=FS.mayDelete(parent,name,true);if(err){throw new FS.ErrnoError(err)}if(!parent.node_ops.rmdir){throw new FS.ErrnoError(1)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(16)}try{if(FS.trackingDelegate["willDeletePath"]){FS.trackingDelegate["willDeletePath"](path)}}catch(e){console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: "+e.message)}parent.node_ops.rmdir(parent,name);FS.destroyNode(node);try{if(FS.trackingDelegate["onDeletePath"])FS.trackingDelegate["onDeletePath"](path)}catch(e){console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: "+e.message)}},readdir:function(path){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node.node_ops.readdir){throw new FS.ErrnoError(20)}return node.node_ops.readdir(node)},unlink:function(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var err=FS.mayDelete(parent,name,false);if(err){throw new FS.ErrnoError(err)}if(!parent.node_ops.unlink){throw new FS.ErrnoError(1)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(16)}try{if(FS.trackingDelegate["willDeletePath"]){FS.trackingDelegate["willDeletePath"](path)}}catch(e){console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: "+e.message)}parent.node_ops.unlink(parent,name);FS.destroyNode(node);try{if(FS.trackingDelegate["onDeletePath"])FS.trackingDelegate["onDeletePath"](path)}catch(e){console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: "+e.message)}},readlink:function(path){var lookup=FS.lookupPath(path);var link=lookup.node;if(!link){throw new FS.ErrnoError(2)}if(!link.node_ops.readlink){throw new FS.ErrnoError(22)}return PATH.resolve(FS.getPath(link.parent),link.node_ops.readlink(link))},stat:function(path,dontFollow){var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;if(!node){throw new FS.ErrnoError(2)}if(!node.node_ops.getattr){throw new FS.ErrnoError(1)}return node.node_ops.getattr(node)},lstat:function(path){return FS.stat(path,true)},chmod:function(path,mode,dontFollow){var node;if(typeof path==="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(1)}node.node_ops.setattr(node,{mode:mode&4095|node.mode&~4095,timestamp:Date.now()})},lchmod:function(path,mode){FS.chmod(path,mode,true)},fchmod:function(fd,mode){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(9)}FS.chmod(stream.node,mode)},chown:function(path,uid,gid,dontFollow){var node;if(typeof path==="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(1)}node.node_ops.setattr(node,{timestamp:Date.now()})},lchown:function(path,uid,gid){FS.chown(path,uid,gid,true)},fchown:function(fd,uid,gid){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(9)}FS.chown(stream.node,uid,gid)},truncate:function(path,len){if(len<0){throw new FS.ErrnoError(22)}var node;if(typeof path==="string"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(1)}if(FS.isDir(node.mode)){throw new FS.ErrnoError(21)}if(!FS.isFile(node.mode)){throw new FS.ErrnoError(22)}var err=FS.nodePermissions(node,"w");if(err){throw new FS.ErrnoError(err)}node.node_ops.setattr(node,{size:len,timestamp:Date.now()})},ftruncate:function(fd,len){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(9)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(22)}FS.truncate(stream.node,len)},utime:function(path,atime,mtime){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;node.node_ops.setattr(node,{timestamp:Math.max(atime,mtime)})},open:function(path,flags,mode,fd_start,fd_end){if(path===""){throw new FS.ErrnoError(2)}flags=typeof flags==="string"?FS.modeStringToFlags(flags):flags;mode=typeof mode==="undefined"?438:mode;if(flags&64){mode=mode&4095|32768}else{mode=0}var node;if(typeof path==="object"){node=path}else{path=PATH.normalize(path);try{var lookup=FS.lookupPath(path,{follow:!(flags&131072)});node=lookup.node}catch(e){}}var created=false;if(flags&64){if(node){if(flags&128){throw new FS.ErrnoError(17)}}else{node=FS.mknod(path,mode,0);created=true}}if(!node){throw new FS.ErrnoError(2)}if(FS.isChrdev(node.mode)){flags&=~512}if(flags&65536&&!FS.isDir(node.mode)){throw new FS.ErrnoError(20)}if(!created){var err=FS.mayOpen(node,flags);if(err){throw new FS.ErrnoError(err)}}if(flags&512){FS.truncate(node,0)}flags&=~(128|512);var stream=FS.createStream({node:node,path:FS.getPath(node),flags:flags,seekable:true,position:0,stream_ops:node.stream_ops,ungotten:[],error:false},fd_start,fd_end);if(stream.stream_ops.open){stream.stream_ops.open(stream)}if(Module["logReadFiles"]&&!(flags&1)){if(!FS.readFiles)FS.readFiles={};if(!(path in FS.readFiles)){FS.readFiles[path]=1;console.log("FS.trackingDelegate error on read file: "+path)}}try{if(FS.trackingDelegate["onOpenFile"]){var trackingFlags=0;if((flags&2097155)!==1){trackingFlags|=FS.tracking.openFlags.READ}if((flags&2097155)!==0){trackingFlags|=FS.tracking.openFlags.WRITE}FS.trackingDelegate["onOpenFile"](path,trackingFlags)}}catch(e){console.log("FS.trackingDelegate['onOpenFile']('"+path+"', flags) threw an exception: "+e.message)}return stream},close:function(stream){if(FS.isClosed(stream)){throw new FS.ErrnoError(9)}if(stream.getdents)stream.getdents=null;try{if(stream.stream_ops.close){stream.stream_ops.close(stream)}}catch(e){throw e}finally{FS.closeStream(stream.fd)}stream.fd=null},isClosed:function(stream){return stream.fd===null},llseek:function(stream,offset,whence){if(FS.isClosed(stream)){throw new FS.ErrnoError(9)}if(!stream.seekable||!stream.stream_ops.llseek){throw new FS.ErrnoError(29)}if(whence!=0&&whence!=1&&whence!=2){throw new FS.ErrnoError(22)}stream.position=stream.stream_ops.llseek(stream,offset,whence);stream.ungotten=[];return stream.position},read:function(stream,buffer,offset,length,position){if(length<0||position<0){throw new FS.ErrnoError(22)}if(FS.isClosed(stream)){throw new FS.ErrnoError(9)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(9)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(21)}if(!stream.stream_ops.read){throw new FS.ErrnoError(22)}var seeking=typeof position!=="undefined";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(29)}var bytesRead=stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead},write:function(stream,buffer,offset,length,position,canOwn){if(length<0||position<0){throw new FS.ErrnoError(22)}if(FS.isClosed(stream)){throw new FS.ErrnoError(9)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(9)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(21)}if(!stream.stream_ops.write){throw new FS.ErrnoError(22)}if(stream.flags&1024){FS.llseek(stream,0,2)}var seeking=typeof position!=="undefined";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(29)}var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;try{if(stream.path&&FS.trackingDelegate["onWriteToFile"])FS.trackingDelegate["onWriteToFile"](stream.path)}catch(e){console.log("FS.trackingDelegate['onWriteToFile']('"+stream.path+"') threw an exception: "+e.message)}return bytesWritten},allocate:function(stream,offset,length){if(FS.isClosed(stream)){throw new FS.ErrnoError(9)}if(offset<0||length<=0){throw new FS.ErrnoError(22)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(9)}if(!FS.isFile(stream.node.mode)&&!FS.isDir(stream.node.mode)){throw new FS.ErrnoError(19)}if(!stream.stream_ops.allocate){throw new FS.ErrnoError(95)}stream.stream_ops.allocate(stream,offset,length)},mmap:function(stream,buffer,offset,length,position,prot,flags){if((stream.flags&2097155)===1){throw new FS.ErrnoError(13)}if(!stream.stream_ops.mmap){throw new FS.ErrnoError(19)}return stream.stream_ops.mmap(stream,buffer,offset,length,position,prot,flags)},msync:function(stream,buffer,offset,length,mmapFlags){if(!stream||!stream.stream_ops.msync){return 0}return stream.stream_ops.msync(stream,buffer,offset,length,mmapFlags)},munmap:function(stream){return 0},ioctl:function(stream,cmd,arg){if(!stream.stream_ops.ioctl){throw new FS.ErrnoError(25)}return stream.stream_ops.ioctl(stream,cmd,arg)},readFile:function(path,opts){opts=opts||{};opts.flags=opts.flags||"r";opts.encoding=opts.encoding||"binary";if(opts.encoding!=="utf8"&&opts.encoding!=="binary"){throw new Error('Invalid encoding type "'+opts.encoding+'"')}var ret;var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding==="utf8"){ret=UTF8ArrayToString(buf,0)}else if(opts.encoding==="binary"){ret=buf}FS.close(stream);return ret},writeFile:function(path,data,opts){opts=opts||{};opts.flags=opts.flags||"w";var stream=FS.open(path,opts.flags,opts.mode);if(typeof data==="string"){var buf=new Uint8Array(lengthBytesUTF8(data)+1);var actualNumBytes=stringToUTF8Array(data,buf,0,buf.length);FS.write(stream,buf,0,actualNumBytes,undefined,opts.canOwn)}else if(ArrayBuffer.isView(data)){FS.write(stream,data,0,data.byteLength,undefined,opts.canOwn)}else{throw new Error("Unsupported data type")}FS.close(stream)},cwd:function(){return FS.currentPath},chdir:function(path){var lookup=FS.lookupPath(path,{follow:true});if(lookup.node===null){throw new FS.ErrnoError(2)}if(!FS.isDir(lookup.node.mode)){throw new FS.ErrnoError(20)}var err=FS.nodePermissions(lookup.node,"x");if(err){throw new FS.ErrnoError(err)}FS.currentPath=lookup.path},createDefaultDirectories:function(){FS.mkdir("/tmp");FS.mkdir("/home");FS.mkdir("/home/web_user")},createDefaultDevices:function(){FS.mkdir("/dev");FS.registerDevice(FS.makedev(1,3),{read:function(){return 0},write:function(stream,buffer,offset,length,pos){return length}});FS.mkdev("/dev/null",FS.makedev(1,3));TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev("/dev/tty",FS.makedev(5,0));FS.mkdev("/dev/tty1",FS.makedev(6,0));var random_device;if(typeof crypto==="object"&&typeof crypto["getRandomValues"]==="function"){var randomBuffer=new Uint8Array(1);random_device=function(){crypto.getRandomValues(randomBuffer);return randomBuffer[0]}}else if(ENVIRONMENT_IS_NODE){try{var crypto_module=__webpack_require__(9);random_device=function(){return crypto_module["randomBytes"](1)[0]}}catch(e){}}else{}if(!random_device){random_device=function(){abort("no cryptographic support found for random_device. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: function(array) { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };")}}FS.createDevice("/dev","random",random_device);FS.createDevice("/dev","urandom",random_device);FS.mkdir("/dev/shm");FS.mkdir("/dev/shm/tmp")},createSpecialDirectories:function(){FS.mkdir("/proc");FS.mkdir("/proc/self");FS.mkdir("/proc/self/fd");FS.mount({mount:function(){var node=FS.createNode("/proc/self","fd",16384|511,73);node.node_ops={lookup:function(parent,name){var fd=+name;var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(9);var ret={parent:null,mount:{mountpoint:"fake"},node_ops:{readlink:function(){return stream.path}}};ret.parent=ret;return ret}};return node}},{},"/proc/self/fd")},createStandardStreams:function(){if(Module["stdin"]){FS.createDevice("/dev","stdin",Module["stdin"])}else{FS.symlink("/dev/tty","/dev/stdin")}if(Module["stdout"]){FS.createDevice("/dev","stdout",null,Module["stdout"])}else{FS.symlink("/dev/tty","/dev/stdout")}if(Module["stderr"]){FS.createDevice("/dev","stderr",null,Module["stderr"])}else{FS.symlink("/dev/tty1","/dev/stderr")}var stdin=FS.open("/dev/stdin","r");var stdout=FS.open("/dev/stdout","w");var stderr=FS.open("/dev/stderr","w");assert(stdin.fd===0,"invalid handle for stdin ("+stdin.fd+")");assert(stdout.fd===1,"invalid handle for stdout ("+stdout.fd+")");assert(stderr.fd===2,"invalid handle for stderr ("+stderr.fd+")")},ensureErrnoError:function(){if(FS.ErrnoError)return;FS.ErrnoError=function ErrnoError(errno,node){this.node=node;this.setErrno=function(errno){this.errno=errno;for(var key in ERRNO_CODES){if(ERRNO_CODES[key]===errno){this.code=key;break}}};this.setErrno(errno);this.message=ERRNO_MESSAGES[errno];if(this.stack)Object.defineProperty(this,"stack",{value:(new Error).stack,writable:true});if(this.stack)this.stack=demangleAll(this.stack)};FS.ErrnoError.prototype=new Error;FS.ErrnoError.prototype.constructor=FS.ErrnoError;[2].forEach(function(code){FS.genericErrors[code]=new FS.ErrnoError(code);FS.genericErrors[code].stack="<generic error, no stack>"})},staticInit:function(){FS.ensureErrnoError();FS.nameTable=new Array(4096);FS.mount(MEMFS,{},"/");FS.createDefaultDirectories();FS.createDefaultDevices();FS.createSpecialDirectories();FS.filesystems={"MEMFS":MEMFS,"NODEFS":NODEFS}},init:function(input,output,error){assert(!FS.init.initialized,"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)");FS.init.initialized=true;FS.ensureErrnoError();Module["stdin"]=input||Module["stdin"];Module["stdout"]=output||Module["stdout"];Module["stderr"]=error||Module["stderr"];FS.createStandardStreams()},quit:function(){FS.init.initialized=false;var fflush=Module["_fflush"];if(fflush)fflush(0);for(var i=0;i<FS.streams.length;i++){var stream=FS.streams[i];if(!stream){continue}FS.close(stream)}},getMode:function(canRead,canWrite){var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode},joinPath:function(parts,forceRelative){var path=PATH.join.apply(null,parts);if(forceRelative&&path[0]=="/")path=path.substr(1);return path},absolutePath:function(relative,base){return PATH.resolve(base,relative)},standardizePath:function(path){return PATH.normalize(path)},findObject:function(path,dontResolveLastLink){var ret=FS.analyzePath(path,dontResolveLastLink);if(ret.exists){return ret.object}else{___setErrNo(ret.error);return null}},analyzePath:function(path,dontResolveLastLink){try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path==="/"}catch(e){ret.error=e.errno}return ret},createFolder:function(parent,name,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(canRead,canWrite);return FS.mkdir(path,mode)},createPath:function(parent,path,canRead,canWrite){parent=typeof parent==="string"?parent:FS.getPath(parent);var parts=path.split("/").reverse();while(parts.length){var part=parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current)}catch(e){}parent=current}return current},createFile:function(parent,name,properties,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(canRead,canWrite);return FS.create(path,mode)},createDataFile:function(parent,name,data,canRead,canWrite,canOwn){var path=name?PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name):parent;var mode=FS.getMode(canRead,canWrite);var node=FS.create(path,mode);if(data){if(typeof data==="string"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr}FS.chmod(node,mode|146);var stream=FS.open(node,"w");FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode)}return node},createDevice:function(parent,name,input,output){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(!!input,!!output);if(!FS.createDevice.major)FS.createDevice.major=64;var dev=FS.makedev(FS.createDevice.major++,0);FS.registerDevice(dev,{open:function(stream){stream.seekable=false},close:function(stream){if(output&&output.buffer&&output.buffer.length){output(10)}},read:function(stream,buffer,offset,length,pos){var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input()}catch(e){throw new FS.ErrnoError(5)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(11)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.timestamp=Date.now()}return bytesRead},write:function(stream,buffer,offset,length,pos){for(var i=0;i<length;i++){try{output(buffer[offset+i])}catch(e){throw new FS.ErrnoError(5)}}if(length){stream.node.timestamp=Date.now()}return i}});return FS.mkdev(path,mode,dev)},createLink:function(parent,name,target,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);return FS.symlink(target,path)},forceLoadFile:function(obj){if(obj.isDevice||obj.isFolder||obj.link||obj.contents)return true;var success=true;if(typeof XMLHttpRequest!=="undefined"){throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.")}else if(Module["read"]){try{obj.contents=intArrayFromString(Module["read"](obj.url),true);obj.usedBytes=obj.contents.length}catch(e){success=false}}else{throw new Error("Cannot load without read() or XMLHttpRequest.")}if(!success)___setErrNo(5);return success},createLazyFile:function(parent,name,url,canRead,canWrite){function LazyUint8Array(){this.lengthKnown=false;this.chunks=[]}LazyUint8Array.prototype.get=function LazyUint8Array_get(idx){if(idx>this.length-1||idx<0){return undefined}var chunkOffset=idx%this.chunkSize;var chunkNum=idx/this.chunkSize|0;return this.getter(chunkNum)[chunkOffset]};LazyUint8Array.prototype.setDataGetter=function LazyUint8Array_setDataGetter(getter){this.getter=getter};LazyUint8Array.prototype.cacheLength=function LazyUint8Array_cacheLength(){var xhr=new XMLHttpRequest;xhr.open("HEAD",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);var datalength=Number(xhr.getResponseHeader("Content-length"));var header;var hasByteServing=(header=xhr.getResponseHeader("Accept-Ranges"))&&header==="bytes";var usesGzip=(header=xhr.getResponseHeader("Content-Encoding"))&&header==="gzip";var chunkSize=1024*1024;if(!hasByteServing)chunkSize=datalength;var doXHR=function(from,to){if(from>to)throw new Error("invalid range ("+from+", "+to+") or no bytes requested!");if(to>datalength-1)throw new Error("only "+datalength+" bytes available! programmer error!");var xhr=new XMLHttpRequest;xhr.open("GET",url,false);if(datalength!==chunkSize)xhr.setRequestHeader("Range","bytes="+from+"-"+to);if(typeof Uint8Array!="undefined")xhr.responseType="arraybuffer";if(xhr.overrideMimeType){xhr.overrideMimeType("text/plain; charset=x-user-defined")}xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);if(xhr.response!==undefined){return new Uint8Array(xhr.response||[])}else{return intArrayFromString(xhr.responseText||"",true)}};var lazyArray=this;lazyArray.setDataGetter(function(chunkNum){var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;end=Math.min(end,datalength-1);if(typeof lazyArray.chunks[chunkNum]==="undefined"){lazyArray.chunks[chunkNum]=doXHR(start,end)}if(typeof lazyArray.chunks[chunkNum]==="undefined")throw new Error("doXHR failed!");return lazyArray.chunks[chunkNum]});if(usesGzip||!datalength){chunkSize=datalength=1;datalength=this.getter(0).length;chunkSize=datalength;console.log("LazyFiles on gzip forces download of the whole file when length is accessed")}this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true};if(typeof XMLHttpRequest!=="undefined"){if(!ENVIRONMENT_IS_WORKER)throw"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";var lazyArray=new LazyUint8Array;Object.defineProperties(lazyArray,{length:{get:function(){if(!this.lengthKnown){this.cacheLength()}return this._length}},chunkSize:{get:function(){if(!this.lengthKnown){this.cacheLength()}return this._chunkSize}}});var properties={isDevice:false,contents:lazyArray}}else{var properties={isDevice:false,url:url}}var node=FS.createFile(parent,name,properties,canRead,canWrite);if(properties.contents){node.contents=properties.contents}else if(properties.url){node.contents=null;node.url=properties.url}Object.defineProperties(node,{usedBytes:{get:function(){return this.contents.length}}});var stream_ops={};var keys=Object.keys(node.stream_ops);keys.forEach(function(key){var fn=node.stream_ops[key];stream_ops[key]=function forceLoadLazyFile(){if(!FS.forceLoadFile(node)){throw new FS.ErrnoError(5)}return fn.apply(null,arguments)}});stream_ops.read=function stream_ops_read(stream,buffer,offset,length,position){if(!FS.forceLoadFile(node)){throw new FS.ErrnoError(5)}var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);assert(size>=0);if(contents.slice){for(var i=0;i<size;i++){buffer[offset+i]=contents[position+i]}}else{for(var i=0;i<size;i++){buffer[offset+i]=contents.get(position+i)}}return size};node.stream_ops=stream_ops;return node},createPreloadedFile:function(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn,preFinish){Browser.init();var fullname=name?PATH.resolve(PATH.join2(parent,name)):parent;var dep=getUniqueRunDependency("cp "+fullname);function processData(byteArray){function finish(byteArray){if(preFinish)preFinish();if(!dontCreateFile){FS.createDataFile(parent,name,byteArray,canRead,canWrite,canOwn)}if(onload)onload();removeRunDependency(dep)}var handled=false;Module["preloadPlugins"].forEach(function(plugin){if(handled)return;if(plugin["canHandle"](fullname)){plugin["handle"](byteArray,fullname,finish,function(){if(onerror)onerror();removeRunDependency(dep)});handled=true}});if(!handled)finish(byteArray)}addRunDependency(dep);if(typeof url=="string"){Browser.asyncLoad(url,function(byteArray){processData(byteArray)},onerror)}else{processData(url)}},indexedDB:function(){return window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB},DB_NAME:function(){return"EM_FS_"+window.location.pathname},DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:function(paths,onload,onerror){onload=onload||function(){};onerror=onerror||function(){};var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION)}catch(e){return onerror(e)}openRequest.onupgradeneeded=function openRequest_onupgradeneeded(){console.log("creating db");var db=openRequest.result;db.createObjectStore(FS.DB_STORE_NAME)};openRequest.onsuccess=function openRequest_onsuccess(){var db=openRequest.result;var transaction=db.transaction([FS.DB_STORE_NAME],"readwrite");var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror()}paths.forEach(function(path){var putRequest=files.put(FS.analyzePath(path).object.contents,path);putRequest.onsuccess=function putRequest_onsuccess(){ok++;if(ok+fail==total)finish()};putRequest.onerror=function putRequest_onerror(){fail++;if(ok+fail==total)finish()}});transaction.onerror=onerror};openRequest.onerror=onerror},loadFilesFromDB:function(paths,onload,onerror){onload=onload||function(){};onerror=onerror||function(){};var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION)}catch(e){return onerror(e)}openRequest.onupgradeneeded=onerror;openRequest.onsuccess=function openRequest_onsuccess(){var db=openRequest.result;try{var transaction=db.transaction([FS.DB_STORE_NAME],"readonly")}catch(e){onerror(e);return}var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror()}paths.forEach(function(path){var getRequest=files.get(path);getRequest.onsuccess=function getRequest_onsuccess(){if(FS.analyzePath(path).exists){FS.unlink(path)}FS.createDataFile(PATH.dirname(path),PATH.basename(path),getRequest.result,true,true,true);ok++;if(ok+fail==total)finish()};getRequest.onerror=function getRequest_onerror(){fail++;if(ok+fail==total)finish()}});transaction.onerror=onerror};openRequest.onerror=onerror}};var SYSCALLS={DEFAULT_POLLMASK:5,mappings:{},umask:511,calculateAt:function(dirfd,path){if(path[0]!=="/"){var dir;if(dirfd===-100){dir=FS.cwd()}else{var dirstream=FS.getStream(dirfd);if(!dirstream)throw new FS.ErrnoError(ERRNO_CODES.EBADF);dir=dirstream.path}path=PATH.join2(dir,path)}return path},doStat:function(func,path,buf){try{var stat=func(path)}catch(e){if(e&&e.node&&PATH.normalize(path)!==PATH.normalize(FS.getPath(e.node))){return-ERRNO_CODES.ENOTDIR}throw e}SAFE_HEAP_STORE(buf|0,stat.dev|0,4);SAFE_HEAP_STORE(buf+4|0,0|0,4);SAFE_HEAP_STORE(buf+8|0,stat.ino|0,4);SAFE_HEAP_STORE(buf+12|0,stat.mode|0,4);SAFE_HEAP_STORE(buf+16|0,stat.nlink|0,4);SAFE_HEAP_STORE(buf+20|0,stat.uid|0,4);SAFE_HEAP_STORE(buf+24|0,stat.gid|0,4);SAFE_HEAP_STORE(buf+28|0,stat.rdev|0,4);SAFE_HEAP_STORE(buf+32|0,0|0,4);SAFE_HEAP_STORE(buf+36|0,stat.size|0,4);SAFE_HEAP_STORE(buf+40|0,4096|0,4);SAFE_HEAP_STORE(buf+44|0,stat.blocks|0,4);SAFE_HEAP_STORE(buf+48|0,stat.atime.getTime()/1e3|0|0,4);SAFE_HEAP_STORE(buf+52|0,0|0,4);SAFE_HEAP_STORE(buf+56|0,stat.mtime.getTime()/1e3|0|0,4);SAFE_HEAP_STORE(buf+60|0,0|0,4);SAFE_HEAP_STORE(buf+64|0,stat.ctime.getTime()/1e3|0|0,4);SAFE_HEAP_STORE(buf+68|0,0|0,4);SAFE_HEAP_STORE(buf+72|0,stat.ino|0,4);return 0},doMsync:function(addr,stream,len,flags){var buffer=new Uint8Array(HEAPU8.subarray(addr,addr+len));FS.msync(stream,buffer,0,len,flags)},doMkdir:function(path,mode){path=PATH.normalize(path);if(path[path.length-1]==="/")path=path.substr(0,path.length-1);FS.mkdir(path,mode,0);return 0},doMknod:function(path,mode,dev){switch(mode&61440){case 32768:case 8192:case 24576:case 4096:case 49152:break;default:return-ERRNO_CODES.EINVAL}FS.mknod(path,mode,dev);return 0},doReadlink:function(path,buf,bufsize){if(bufsize<=0)return-ERRNO_CODES.EINVAL;var ret=FS.readlink(path);var len=Math.min(bufsize,lengthBytesUTF8(ret));var endChar=HEAP8[buf+len];stringToUTF8(ret,buf,bufsize+1);HEAP8[buf+len]=endChar;return len},doAccess:function(path,amode){if(amode&~7){return-ERRNO_CODES.EINVAL}var node;var lookup=FS.lookupPath(path,{follow:true});node=lookup.node;var perms="";if(amode&4)perms+="r";if(amode&2)perms+="w";if(amode&1)perms+="x";if(perms&&FS.nodePermissions(node,perms)){return-ERRNO_CODES.EACCES}return 0},doDup:function(path,flags,suggestFD){var suggest=FS.getStream(suggestFD);if(suggest)FS.close(suggest);return FS.open(path,flags,0,suggestFD,suggestFD).fd},doReadv:function(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=SAFE_HEAP_LOAD(iov+i*8|0,4,0)|0;var len=SAFE_HEAP_LOAD(iov+(i*8+4)|0,4,0)|0;var curr=FS.read(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len)break}return ret},doWritev:function(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=SAFE_HEAP_LOAD(iov+i*8|0,4,0)|0;var len=SAFE_HEAP_LOAD(iov+(i*8+4)|0,4,0)|0;var curr=FS.write(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr}return ret},varargs:0,get:function(varargs){SYSCALLS.varargs+=4;var ret=SAFE_HEAP_LOAD(SYSCALLS.varargs-4|0,4,0)|0;return ret},getStr:function(){var ret=UTF8ToString(SYSCALLS.get());return ret},getStreamFromFD:function(){var stream=FS.getStream(SYSCALLS.get());if(!stream)throw new FS.ErrnoError(ERRNO_CODES.EBADF);return stream},getSocketFromFD:function(){var socket=SOCKFS.getSocket(SYSCALLS.get());if(!socket)throw new FS.ErrnoError(ERRNO_CODES.EBADF);return socket},getSocketAddress:function(allowNull){var addrp=SYSCALLS.get(),addrlen=SYSCALLS.get();if(allowNull&&addrp===0)return null;var info=__read_sockaddr(addrp,addrlen);if(info.errno)throw new FS.ErrnoError(info.errno);info.addr=DNS.lookup_addr(info.addr)||info.addr;return info},get64:function(){var low=SYSCALLS.get(),high=SYSCALLS.get();if(low>=0)assert(high===0);else assert(high===-1);return low},getZero:function(){assert(SYSCALLS.get()===0)}};function ___syscall10(which,varargs){SYSCALLS.varargs=varargs;try{var path=SYSCALLS.getStr();FS.unlink(path);return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall140(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),offset_high=SYSCALLS.get(),offset_low=SYSCALLS.get(),result=SYSCALLS.get(),whence=SYSCALLS.get();var offset=offset_low;FS.llseek(stream,offset,whence);SAFE_HEAP_STORE(result|0,stream.position|0,4);if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall145(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),iov=SYSCALLS.get(),iovcnt=SYSCALLS.get();return SYSCALLS.doReadv(stream,iov,iovcnt)}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall146(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),iov=SYSCALLS.get(),iovcnt=SYSCALLS.get();return SYSCALLS.doWritev(stream,iov,iovcnt)}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall15(which,varargs){SYSCALLS.varargs=varargs;try{var path=SYSCALLS.getStr(),mode=SYSCALLS.get();FS.chmod(path,mode);return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall195(which,varargs){SYSCALLS.varargs=varargs;try{var path=SYSCALLS.getStr(),buf=SYSCALLS.get();return SYSCALLS.doStat(FS.stat,path,buf)}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall197(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),buf=SYSCALLS.get();return SYSCALLS.doStat(FS.stat,stream.path,buf)}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall221(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),cmd=SYSCALLS.get();switch(cmd){case 0:{var arg=SYSCALLS.get();if(arg<0){return-ERRNO_CODES.EINVAL}var newStream;newStream=FS.open(stream.path,stream.flags,0,arg);return newStream.fd}case 1:case 2:return 0;case 3:return stream.flags;case 4:{var arg=SYSCALLS.get();stream.flags|=arg;return 0}case 12:{var arg=SYSCALLS.get();var offset=0;SAFE_HEAP_STORE(arg+offset|0,2|0,2);return 0}case 13:case 14:return 0;case 16:case 8:return-ERRNO_CODES.EINVAL;case 9:___setErrNo(ERRNO_CODES.EINVAL);return-1;default:{return-ERRNO_CODES.EINVAL}}}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall38(which,varargs){SYSCALLS.varargs=varargs;try{var old_path=SYSCALLS.getStr(),new_path=SYSCALLS.getStr();FS.rename(old_path,new_path);return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall40(which,varargs){SYSCALLS.varargs=varargs;try{var path=SYSCALLS.getStr();FS.rmdir(path);return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall5(which,varargs){SYSCALLS.varargs=varargs;try{var pathname=SYSCALLS.getStr(),flags=SYSCALLS.get(),mode=SYSCALLS.get();var stream=FS.open(pathname,flags,mode);return stream.fd}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall54(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),op=SYSCALLS.get();switch(op){case 21509:case 21505:{if(!stream.tty)return-ERRNO_CODES.ENOTTY;return 0}case 21510:case 21511:case 21512:case 21506:case 21507:case 21508:{if(!stream.tty)return-ERRNO_CODES.ENOTTY;return 0}case 21519:{if(!stream.tty)return-ERRNO_CODES.ENOTTY;var argp=SYSCALLS.get();SAFE_HEAP_STORE(argp|0,0|0,4);return 0}case 21520:{if(!stream.tty)return-ERRNO_CODES.ENOTTY;return-ERRNO_CODES.EINVAL}case 21531:{var argp=SYSCALLS.get();return FS.ioctl(stream,op,argp)}case 21523:{if(!stream.tty)return-ERRNO_CODES.ENOTTY;return 0}case 21524:{if(!stream.tty)return-ERRNO_CODES.ENOTTY;return 0}default:abort("bad ioctl syscall "+op)}}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall6(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD();FS.close(stream);return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall60(which,varargs){SYSCALLS.varargs=varargs;try{var mask=SYSCALLS.get();var old=SYSCALLS.umask;SYSCALLS.umask=mask;return old}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___unlock(){}function _emscripten_get_heap_size(){return HEAP8.length}function abortOnCannotGrowMemory(requestedSize){abort("Cannot enlarge memory arrays to size "+requestedSize+" bytes (OOM). Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value "+HEAP8.length+", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ")}function emscripten_realloc_buffer(size){var PAGE_MULTIPLE=65536;size=alignUp(size,PAGE_MULTIPLE);var oldSize=buffer.byteLength;try{var result=wasmMemory.grow((size-oldSize)/65536);if(result!==(-1|0)){return buffer=wasmMemory.buffer}else{return null}}catch(e){console.error("emscripten_realloc_buffer: Attempted to grow from "+oldSize+" bytes to "+size+" bytes, but got error: "+e);return null}}function _emscripten_resize_heap(requestedSize){var oldSize=_emscripten_get_heap_size();assert(requestedSize>oldSize);var PAGE_MULTIPLE=65536;var LIMIT=2147483648-PAGE_MULTIPLE;if(requestedSize>LIMIT){err("Cannot enlarge memory, asked to go up to "+requestedSize+" bytes, but the limit is "+LIMIT+" bytes!");return false}var MIN_TOTAL_MEMORY=16777216;var newSize=Math.max(oldSize,MIN_TOTAL_MEMORY);while(newSize<requestedSize){if(newSize<=536870912){newSize=alignUp(2*newSize,PAGE_MULTIPLE)}else{newSize=Math.min(alignUp((3*newSize+2147483648)/4,PAGE_MULTIPLE),LIMIT);if(newSize===oldSize){warnOnce("Cannot ask for more memory since we reached the practical limit in browsers (which is just below 2GB), so the request would have failed. Requesting only "+HEAP8.length)}}}var start=Date.now();var replacement=emscripten_realloc_buffer(newSize);if(!replacement||replacement.byteLength!=newSize){err("Failed to grow the heap from "+oldSize+" bytes to "+newSize+" bytes, not enough memory!");if(replacement){err("Expected to get back a buffer of size "+newSize+" bytes, but instead got back a buffer of size "+replacement.byteLength)}return false}updateGlobalBufferViews();return true}var ___tm_current=22560;var ___tm_timezone=(stringToUTF8("GMT",22608,4),22608);function _gmtime_r(time,tmPtr){var date=new Date((SAFE_HEAP_LOAD(time|0,4,0)|0)*1e3);SAFE_HEAP_STORE(tmPtr|0,date.getUTCSeconds()|0,4);SAFE_HEAP_STORE(tmPtr+4|0,date.getUTCMinutes()|0,4);SAFE_HEAP_STORE(tmPtr+8|0,date.getUTCHours()|0,4);SAFE_HEAP_STORE(tmPtr+12|0,date.getUTCDate()|0,4);SAFE_HEAP_STORE(tmPtr+16|0,date.getUTCMonth()|0,4);SAFE_HEAP_STORE(tmPtr+20|0,date.getUTCFullYear()-1900|0,4);SAFE_HEAP_STORE(tmPtr+24|0,date.getUTCDay()|0,4);SAFE_HEAP_STORE(tmPtr+36|0,0|0,4);SAFE_HEAP_STORE(tmPtr+32|0,0|0,4);var start=Date.UTC(date.getUTCFullYear(),0,1,0,0,0,0);var yday=(date.getTime()-start)/(1e3*60*60*24)|0;SAFE_HEAP_STORE(tmPtr+28|0,yday|0,4);SAFE_HEAP_STORE(tmPtr+40|0,___tm_timezone|0,4);return tmPtr}function _gmtime(time){return _gmtime_r(time,___tm_current)}function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest)}function _tzset(){if(_tzset.called)return;_tzset.called=true;SAFE_HEAP_STORE(__get_timezone()|0,(new Date).getTimezoneOffset()*60|0,4);var winter=new Date(2e3,0,1);var summer=new Date(2e3,6,1);SAFE_HEAP_STORE(__get_daylight()|0,Number(winter.getTimezoneOffset()!=summer.getTimezoneOffset())|0,4);function extractZone(date){var match=date.toTimeString().match(/\(([A-Za-z ]+)\)$/);return match?match[1]:"GMT"}var winterName=extractZone(winter);var summerName=extractZone(summer);var winterNamePtr=allocate(intArrayFromString(winterName),"i8",ALLOC_NORMAL);var summerNamePtr=allocate(intArrayFromString(summerName),"i8",ALLOC_NORMAL);if(summer.getTimezoneOffset()<winter.getTimezoneOffset()){SAFE_HEAP_STORE(__get_tzname()|0,winterNamePtr|0,4);SAFE_HEAP_STORE(__get_tzname()+4|0,summerNamePtr|0,4)}else{SAFE_HEAP_STORE(__get_tzname()|0,summerNamePtr|0,4);SAFE_HEAP_STORE(__get_tzname()+4|0,winterNamePtr|0,4)}}function _mktime(tmPtr){_tzset();var date=new Date((SAFE_HEAP_LOAD(tmPtr+20|0,4,0)|0)+1900,SAFE_HEAP_LOAD(tmPtr+16|0,4,0)|0,SAFE_HEAP_LOAD(tmPtr+12|0,4,0)|0,SAFE_HEAP_LOAD(tmPtr+8|0,4,0)|0,SAFE_HEAP_LOAD(tmPtr+4|0,4,0)|0,SAFE_HEAP_LOAD(tmPtr|0,4,0)|0,0);var dst=SAFE_HEAP_LOAD(tmPtr+32|0,4,0)|0;var guessedOffset=date.getTimezoneOffset();var start=new Date(date.getFullYear(),0,1);var summerOffset=new Date(2e3,6,1).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dstOffset=Math.min(winterOffset,summerOffset);if(dst<0){SAFE_HEAP_STORE(tmPtr+32|0,Number(summerOffset!=winterOffset&&dstOffset==guessedOffset)|0,4)}else if(dst>0!=(dstOffset==guessedOffset)){var nonDstOffset=Math.max(winterOffset,summerOffset);var trueOffset=dst>0?dstOffset:nonDstOffset;date.setTime(date.getTime()+(trueOffset-guessedOffset)*6e4)}SAFE_HEAP_STORE(tmPtr+24|0,date.getDay()|0,4);var yday=(date.getTime()-start.getTime())/(1e3*60*60*24)|0;SAFE_HEAP_STORE(tmPtr+28|0,yday|0,4);return date.getTime()/1e3|0}function _time(ptr){var ret=Date.now()/1e3|0;if(ptr){SAFE_HEAP_STORE(ptr|0,ret|0,4)}return ret}if(ENVIRONMENT_IS_NODE){_emscripten_get_now=function _emscripten_get_now_actual(){var t=process["hrtime"]();return t[0]*1e3+t[1]/1e6}}else if(typeof dateNow!=="undefined"){_emscripten_get_now=dateNow}else if(typeof performance==="object"&&performance&&typeof performance["now"]==="function"){_emscripten_get_now=function(){return performance["now"]()}}else{_emscripten_get_now=Date.now}FS.staticInit();if(ENVIRONMENT_IS_NODE){var fs=frozenFs;var NODEJS_PATH=__webpack_require__(8);NODEFS.staticInit()}if(ENVIRONMENT_IS_NODE){var _wrapNodeError=function(func){return function(){try{return func.apply(this,arguments)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}};var VFS=Object.assign({},FS);for(var _key in NODERAWFS)FS[_key]=_wrapNodeError(NODERAWFS[_key])}else{throw new Error("NODERAWFS is currently only supported on Node.js environment.")}function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}var decodeBase64=typeof atob==="function"?atob:function(input){var keyStr="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";var output="";var chr1,chr2,chr3;var enc1,enc2,enc3,enc4;var i=0;input=input.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{enc1=keyStr.indexOf(input.charAt(i++));enc2=keyStr.indexOf(input.charAt(i++));enc3=keyStr.indexOf(input.charAt(i++));enc4=keyStr.indexOf(input.charAt(i++));chr1=enc1<<2|enc2>>4;chr2=(enc2&15)<<4|enc3>>2;chr3=(enc3&3)<<6|enc4;output=output+String.fromCharCode(chr1);if(enc3!==64){output=output+String.fromCharCode(chr2)}if(enc4!==64){output=output+String.fromCharCode(chr3)}}while(i<input.length);return output};function intArrayFromBase64(s){if(typeof ENVIRONMENT_IS_NODE==="boolean"&&ENVIRONMENT_IS_NODE){var buf;try{buf=Buffer.from(s,"base64")}catch(_){buf=new Buffer(s,"base64")}return new Uint8Array(buf.buffer,buf.byteOffset,buf.byteLength)}try{var decoded=decodeBase64(s);var bytes=new Uint8Array(decoded.length);for(var i=0;i<decoded.length;++i){bytes[i]=decoded.charCodeAt(i)}return bytes}catch(_){throw new Error("Converting base64 string to bytes failed.")}}function tryParseAsDataURI(filename){if(!isDataURI(filename)){return}return intArrayFromBase64(filename.slice(dataURIPrefix.length))}function nullFunc_ii(x){err("Invalid function pointer called with signature 'ii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");err("Build with ASSERTIONS=2 for more info.");abort(x)}function nullFunc_iii(x){err("Invalid function pointer called with signature 'iii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");err("Build with ASSERTIONS=2 for more info.");abort(x)}function nullFunc_iiii(x){err("Invalid function pointer called with signature 'iiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");err("Build with ASSERTIONS=2 for more info.");abort(x)}function nullFunc_iiiiii(x){err("Invalid function pointer called with signature 'iiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");err("Build with ASSERTIONS=2 for more info.");abort(x)}function nullFunc_iiij(x){err("Invalid function pointer called with signature 'iiij'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");err("Build with ASSERTIONS=2 for more info.");abort(x)}function nullFunc_jiiiji(x){err("Invalid function pointer called with signature 'jiiiji'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");err("Build with ASSERTIONS=2 for more info.");abort(x)}function nullFunc_jiiji(x){err("Invalid function pointer called with signature 'jiiji'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");err("Build with ASSERTIONS=2 for more info.");abort(x)}function nullFunc_vi(x){err("Invalid function pointer called with signature 'vi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");err("Build with ASSERTIONS=2 for more info.");abort(x)}function nullFunc_vidi(x){err("Invalid function pointer called with signature 'vidi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");err("Build with ASSERTIONS=2 for more info.");abort(x)}function nullFunc_vii(x){err("Invalid function pointer called with signature 'vii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");err("Build with ASSERTIONS=2 for more info.");abort(x)}var asmGlobalArg={};var asmLibraryArg={"e":setTempRet0,"b":abortStackOverflow,"c":segfault,"d":alignfault,"C":nullFunc_ii,"u":nullFunc_iii,"t":nullFunc_iiii,"s":nullFunc_iiiiii,"r":nullFunc_iiij,"q":nullFunc_jiiiji,"p":nullFunc_jiiji,"O":nullFunc_vi,"N":nullFunc_vidi,"M":nullFunc_vii,"L":___buildEnvironment,"K":___clock_gettime,"i":___lock,"o":___setErrNo,"J":___syscall10,"I":___syscall140,"H":___syscall145,"n":___syscall146,"G":___syscall15,"m":___syscall195,"F":___syscall197,"f":___syscall221,"E":___syscall38,"D":___syscall40,"l":___syscall5,"k":___syscall54,"h":___syscall6,"B":___syscall60,"g":___unlock,"A":_emscripten_get_heap_size,"z":_emscripten_memcpy_big,"y":_emscripten_resize_heap,"x":_gmtime,"w":_mktime,"j":_time,"v":abortOnCannotGrowMemory,"a":DYNAMICTOP_PTR};var asm=Module["asm"](asmGlobalArg,asmLibraryArg,buffer);var real____emscripten_environ_constructor=asm["P"];asm["P"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real____emscripten_environ_constructor.apply(null,arguments)};var real____errno_location=asm["Q"];asm["Q"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real____errno_location.apply(null,arguments)};var real___get_daylight=asm["R"];asm["R"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real___get_daylight.apply(null,arguments)};var real___get_timezone=asm["S"];asm["S"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real___get_timezone.apply(null,arguments)};var real___get_tzname=asm["T"];asm["T"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real___get_tzname.apply(null,arguments)};var real__fflush=asm["U"];asm["U"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__fflush.apply(null,arguments)};var real__free=asm["V"];asm["V"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__free.apply(null,arguments)};var real__llvm_bswap_i32=asm["W"];asm["W"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__llvm_bswap_i32.apply(null,arguments)};var real__malloc=asm["X"];asm["X"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__malloc.apply(null,arguments)};var real__sbrk=asm["Y"];asm["Y"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__sbrk.apply(null,arguments)};var real__zip_close=asm["Z"];asm["Z"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_close.apply(null,arguments)};var real__zip_dir_add=asm["_"];asm["_"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_dir_add.apply(null,arguments)};var real__zip_discard=asm["$"];asm["$"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_discard.apply(null,arguments)};var real__zip_error_init_with_code=asm["aa"];asm["aa"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_error_init_with_code.apply(null,arguments)};var real__zip_error_strerror=asm["ba"];asm["ba"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_error_strerror.apply(null,arguments)};var real__zip_fclose=asm["ca"];asm["ca"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_fclose.apply(null,arguments)};var real__zip_file_add=asm["da"];asm["da"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_file_add.apply(null,arguments)};var real__zip_file_get_error=asm["ea"];asm["ea"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_file_get_error.apply(null,arguments)};var real__zip_file_get_external_attributes=asm["fa"];asm["fa"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_file_get_external_attributes.apply(null,arguments)};var real__zip_file_set_external_attributes=asm["ga"];asm["ga"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_file_set_external_attributes.apply(null,arguments)};var real__zip_file_set_mtime=asm["ha"];asm["ha"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_file_set_mtime.apply(null,arguments)};var real__zip_fopen=asm["ia"];asm["ia"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_fopen.apply(null,arguments)};var real__zip_fopen_index=asm["ja"];asm["ja"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_fopen_index.apply(null,arguments)};var real__zip_fread=asm["ka"];asm["ka"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_fread.apply(null,arguments)};var real__zip_get_error=asm["la"];asm["la"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_get_error.apply(null,arguments)};var real__zip_get_name=asm["ma"];asm["ma"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_get_name.apply(null,arguments)};var real__zip_get_num_entries=asm["na"];asm["na"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_get_num_entries.apply(null,arguments)};var real__zip_name_locate=asm["oa"];asm["oa"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_name_locate.apply(null,arguments)};var real__zip_open=asm["pa"];asm["pa"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_open.apply(null,arguments)};var real__zip_open_from_source=asm["qa"];asm["qa"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_open_from_source.apply(null,arguments)};var real__zip_source_buffer=asm["ra"];asm["ra"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_source_buffer.apply(null,arguments)};var real__zip_source_buffer_create=asm["sa"];asm["sa"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_source_buffer_create.apply(null,arguments)};var real__zip_source_free=asm["ta"];asm["ta"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_source_free.apply(null,arguments)};var real__zip_stat=asm["ua"];asm["ua"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_stat.apply(null,arguments)};var real__zip_stat_index=asm["va"];asm["va"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_stat_index.apply(null,arguments)};var real__zipstruct_error=asm["wa"];asm["wa"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zipstruct_error.apply(null,arguments)};var real__zipstruct_errorS=asm["xa"];asm["xa"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zipstruct_errorS.apply(null,arguments)};var real__zipstruct_stat=asm["ya"];asm["ya"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zipstruct_stat.apply(null,arguments)};var real__zipstruct_statS=asm["za"];asm["za"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zipstruct_statS.apply(null,arguments)};var real__zipstruct_stat_index=asm["Aa"];asm["Aa"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zipstruct_stat_index.apply(null,arguments)};var real__zipstruct_stat_mtime=asm["Ba"];asm["Ba"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zipstruct_stat_mtime.apply(null,arguments)};var real__zipstruct_stat_name=asm["Ca"];asm["Ca"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zipstruct_stat_name.apply(null,arguments)};var real__zipstruct_stat_size=asm["Da"];asm["Da"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zipstruct_stat_size.apply(null,arguments)};var real_establishStackSpace=asm["Fa"];asm["Fa"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real_establishStackSpace.apply(null,arguments)};var real_stackAlloc=asm["Ga"];asm["Ga"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real_stackAlloc.apply(null,arguments)};var real_stackRestore=asm["Ha"];asm["Ha"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real_stackRestore.apply(null,arguments)};var real_stackSave=asm["Ia"];asm["Ia"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real_stackSave.apply(null,arguments)};var ___emscripten_environ_constructor=Module["___emscripten_environ_constructor"]=asm["P"];var ___errno_location=Module["___errno_location"]=asm["Q"];var __get_daylight=Module["__get_daylight"]=asm["R"];var __get_timezone=Module["__get_timezone"]=asm["S"];var __get_tzname=Module["__get_tzname"]=asm["T"];var _fflush=Module["_fflush"]=asm["U"];var _free=Module["_free"]=asm["V"];var _llvm_bswap_i32=Module["_llvm_bswap_i32"]=asm["W"];var _malloc=Module["_malloc"]=asm["X"];var _sbrk=Module["_sbrk"]=asm["Y"];var _zip_close=Module["_zip_close"]=asm["Z"];var _zip_dir_add=Module["_zip_dir_add"]=asm["_"];var _zip_discard=Module["_zip_discard"]=asm["$"];var _zip_error_init_with_code=Module["_zip_error_init_with_code"]=asm["aa"];var _zip_error_strerror=Module["_zip_error_strerror"]=asm["ba"];var _zip_fclose=Module["_zip_fclose"]=asm["ca"];var _zip_file_add=Module["_zip_file_add"]=asm["da"];var _zip_file_get_error=Module["_zip_file_get_error"]=asm["ea"];var _zip_file_get_external_attributes=Module["_zip_file_get_external_attributes"]=asm["fa"];var _zip_file_set_external_attributes=Module["_zip_file_set_external_attributes"]=asm["ga"];var _zip_file_set_mtime=Module["_zip_file_set_mtime"]=asm["ha"];var _zip_fopen=Module["_zip_fopen"]=asm["ia"];var _zip_fopen_index=Module["_zip_fopen_index"]=asm["ja"];var _zip_fread=Module["_zip_fread"]=asm["ka"];var _zip_get_error=Module["_zip_get_error"]=asm["la"];var _zip_get_name=Module["_zip_get_name"]=asm["ma"];var _zip_get_num_entries=Module["_zip_get_num_entries"]=asm["na"];var _zip_name_locate=Module["_zip_name_locate"]=asm["oa"];var _zip_open=Module["_zip_open"]=asm["pa"];var _zip_open_from_source=Module["_zip_open_from_source"]=asm["qa"];var _zip_source_buffer=Module["_zip_source_buffer"]=asm["ra"];var _zip_source_buffer_create=Module["_zip_source_buffer_create"]=asm["sa"];var _zip_source_free=Module["_zip_source_free"]=asm["ta"];var _zip_stat=Module["_zip_stat"]=asm["ua"];var _zip_stat_index=Module["_zip_stat_index"]=asm["va"];var _zipstruct_error=Module["_zipstruct_error"]=asm["wa"];var _zipstruct_errorS=Module["_zipstruct_errorS"]=asm["xa"];var _zipstruct_stat=Module["_zipstruct_stat"]=asm["ya"];var _zipstruct_statS=Module["_zipstruct_statS"]=asm["za"];var _zipstruct_stat_index=Module["_zipstruct_stat_index"]=asm["Aa"];var _zipstruct_stat_mtime=Module["_zipstruct_stat_mtime"]=asm["Ba"];var _zipstruct_stat_name=Module["_zipstruct_stat_name"]=asm["Ca"];var _zipstruct_stat_size=Module["_zipstruct_stat_size"]=asm["Da"];var establishStackSpace=Module["establishStackSpace"]=asm["Fa"];var stackAlloc=Module["stackAlloc"]=asm["Ga"];var stackRestore=Module["stackRestore"]=asm["Ha"];var stackSave=Module["stackSave"]=asm["Ia"];var dynCall_vi=Module["dynCall_vi"]=asm["Ea"];Module["asm"]=asm;if(!Module["intArrayFromString"])Module["intArrayFromString"]=function(){abort("'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["intArrayToString"])Module["intArrayToString"]=function(){abort("'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["ccall"])Module["ccall"]=function(){abort("'ccall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};Module["cwrap"]=cwrap;if(!Module["setValue"])Module["setValue"]=function(){abort("'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};Module["getValue"]=getValue;if(!Module["allocate"])Module["allocate"]=function(){abort("'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["getMemory"])Module["getMemory"]=function(){abort("'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")};if(!Module["AsciiToString"])Module["AsciiToString"]=function(){abort("'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["stringToAscii"])Module["stringToAscii"]=function(){abort("'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["UTF8ArrayToString"])Module["UTF8ArrayToString"]=function(){abort("'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["UTF8ToString"])Module["UTF8ToString"]=function(){abort("'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["stringToUTF8Array"])Module["stringToUTF8Array"]=function(){abort("'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["stringToUTF8"])Module["stringToUTF8"]=function(){abort("'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["lengthBytesUTF8"])Module["lengthBytesUTF8"]=function(){abort("'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["UTF16ToString"])Module["UTF16ToString"]=function(){abort("'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["stringToUTF16"])Module["stringToUTF16"]=function(){abort("'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["lengthBytesUTF16"])Module["lengthBytesUTF16"]=function(){abort("'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["UTF32ToString"])Module["UTF32ToString"]=function(){abort("'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["stringToUTF32"])Module["stringToUTF32"]=function(){abort("'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["lengthBytesUTF32"])Module["lengthBytesUTF32"]=function(){abort("'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["allocateUTF8"])Module["allocateUTF8"]=function(){abort("'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["stackTrace"])Module["stackTrace"]=function(){abort("'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["addOnPreRun"])Module["addOnPreRun"]=function(){abort("'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["addOnInit"])Module["addOnInit"]=function(){abort("'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["addOnPreMain"])Module["addOnPreMain"]=function(){abort("'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["addOnExit"])Module["addOnExit"]=function(){abort("'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["addOnPostRun"])Module["addOnPostRun"]=function(){abort("'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["writeStringToMemory"])Module["writeStringToMemory"]=function(){abort("'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["writeArrayToMemory"])Module["writeArrayToMemory"]=function(){abort("'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["writeAsciiToMemory"])Module["writeAsciiToMemory"]=function(){abort("'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["addRunDependency"])Module["addRunDependency"]=function(){abort("'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")};if(!Module["removeRunDependency"])Module["removeRunDependency"]=function(){abort("'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")};if(!Module["ENV"])Module["ENV"]=function(){abort("'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["FS"])Module["FS"]=function(){abort("'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["FS_createFolder"])Module["FS_createFolder"]=function(){abort("'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")};if(!Module["FS_createPath"])Module["FS_createPath"]=function(){abort("'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")};if(!Module["FS_createDataFile"])Module["FS_createDataFile"]=function(){abort("'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")};if(!Module["FS_createPreloadedFile"])Module["FS_createPreloadedFile"]=function(){abort("'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")};if(!Module["FS_createLazyFile"])Module["FS_createLazyFile"]=function(){abort("'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")};if(!Module["FS_createLink"])Module["FS_createLink"]=function(){abort("'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")};if(!Module["FS_createDevice"])Module["FS_createDevice"]=function(){abort("'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")};if(!Module["FS_unlink"])Module["FS_unlink"]=function(){abort("'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")};if(!Module["GL"])Module["GL"]=function(){abort("'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["dynamicAlloc"])Module["dynamicAlloc"]=function(){abort("'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["warnOnce"])Module["warnOnce"]=function(){abort("'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["loadDynamicLibrary"])Module["loadDynamicLibrary"]=function(){abort("'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["loadWebAssemblyModule"])Module["loadWebAssemblyModule"]=function(){abort("'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["getLEB"])Module["getLEB"]=function(){abort("'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["getFunctionTables"])Module["getFunctionTables"]=function(){abort("'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["alignFunctionTables"])Module["alignFunctionTables"]=function(){abort("'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["registerFunctions"])Module["registerFunctions"]=function(){abort("'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["addFunction"])Module["addFunction"]=function(){abort("'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["removeFunction"])Module["removeFunction"]=function(){abort("'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["getFuncWrapper"])Module["getFuncWrapper"]=function(){abort("'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["prettyPrint"])Module["prettyPrint"]=function(){abort("'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["makeBigInt"])Module["makeBigInt"]=function(){abort("'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["dynCall"])Module["dynCall"]=function(){abort("'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["getCompilerSetting"])Module["getCompilerSetting"]=function(){abort("'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["stackSave"])Module["stackSave"]=function(){abort("'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["stackRestore"])Module["stackRestore"]=function(){abort("'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["stackAlloc"])Module["stackAlloc"]=function(){abort("'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["establishStackSpace"])Module["establishStackSpace"]=function(){abort("'establishStackSpace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["print"])Module["print"]=function(){abort("'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["printErr"])Module["printErr"]=function(){abort("'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["getTempRet0"])Module["getTempRet0"]=function(){abort("'getTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["setTempRet0"])Module["setTempRet0"]=function(){abort("'setTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["Pointer_stringify"])Module["Pointer_stringify"]=function(){abort("'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["intArrayFromBase64"])Module["intArrayFromBase64"]=function(){abort("'intArrayFromBase64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["tryParseAsDataURI"])Module["tryParseAsDataURI"]=function(){abort("'tryParseAsDataURI' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["ALLOC_NORMAL"])Object.defineProperty(Module,"ALLOC_NORMAL",{get:function(){abort("'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}});if(!Module["ALLOC_STACK"])Object.defineProperty(Module,"ALLOC_STACK",{get:function(){abort("'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}});if(!Module["ALLOC_DYNAMIC"])Object.defineProperty(Module,"ALLOC_DYNAMIC",{get:function(){abort("'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}});if(!Module["ALLOC_NONE"])Object.defineProperty(Module,"ALLOC_NONE",{get:function(){abort("'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}});function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status}ExitStatus.prototype=new Error;ExitStatus.prototype.constructor=ExitStatus;dependenciesFulfilled=function runCaller(){if(!Module["calledRun"])run();if(!Module["calledRun"])dependenciesFulfilled=runCaller};function run(args){args=args||Module["arguments"];if(runDependencies>0){return}writeStackCookie();preRun();if(runDependencies>0)return;if(Module["calledRun"])return;function doRun(){if(Module["calledRun"])return;Module["calledRun"]=true;if(ABORT)return;ensureInitRuntime();preMain();if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();assert(!Module["_main"],'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("")},1);doRun()},1)}else{doRun()}checkStackCookie()}Module["run"]=run;var abortDecorators=[];function abort(what){if(Module["onAbort"]){Module["onAbort"](what)}if(what!==undefined){out(what);err(what);what=JSON.stringify(what)}else{what=""}ABORT=true;EXITSTATUS=1;var extra="";var output="abort("+what+") at "+stackTrace()+extra;if(abortDecorators){abortDecorators.forEach(function(decorator){output=decorator(output,what)})}throw output}Module["abort"]=abort;if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}Module["noExitRuntime"]=true;run();


  /***/ }),
  /* 24 */
  /***/ (function(module, exports) {

  module.exports = require("stream");

  /***/ }),
  /* 25 */
  /***/ (function(module, exports) {

  module.exports = require("util");

  /***/ }),
  /* 26 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const fs_1 = __webpack_require__(7);
  const FakeFS_1 = __webpack_require__(12);
  const NodeFS_1 = __webpack_require__(11);
  const ZipFS_1 = __webpack_require__(21);
  const path_1 = __webpack_require__(13);
  const ZIP_FD = 0x80000000;
  class ZipOpenFS extends FakeFS_1.BasePortableFakeFS {
      constructor({ baseFs = new NodeFS_1.NodeFS(), filter = null, useCache = true } = {}) {
          super();
          this.fdMap = new Map();
          this.nextFd = 3;
          this.isZip = new Set();
          this.notZip = new Set();
          this.baseFs = baseFs;
          this.zipInstances = useCache ? new Map() : null;
          this.filter = filter;
          this.isZip = new Set();
          this.notZip = new Set();
      }
      static open(fn) {
          const zipOpenFs = new ZipOpenFS();
          try {
              return fn(zipOpenFs);
          }
          finally {
              zipOpenFs.saveAndClose();
          }
      }
      static async openPromise(fn) {
          const zipOpenFs = new ZipOpenFS();
          try {
              return await fn(zipOpenFs);
          }
          finally {
              zipOpenFs.saveAndClose();
          }
      }
      getRealPath() {
          return this.baseFs.getRealPath();
      }
      saveAndClose() {
          if (this.zipInstances) {
              for (const [path, zipFs] of this.zipInstances.entries()) {
                  zipFs.saveAndClose();
                  this.zipInstances.delete(path);
              }
          }
      }
      discardAndClose() {
          if (this.zipInstances) {
              for (const [path, zipFs] of this.zipInstances.entries()) {
                  zipFs.discardAndClose();
                  this.zipInstances.delete(path);
              }
          }
      }
      remapFd(zipFs, fd) {
          const remappedFd = this.nextFd++ | ZIP_FD;
          this.fdMap.set(remappedFd, [zipFs, fd]);
          return remappedFd;
      }
      async openPromise(p, flags, mode) {
          return await this.makeCallPromise(p, async () => {
              return await this.baseFs.openPromise(p, flags, mode);
          }, async (zipFs, { subPath }) => {
              return this.remapFd(zipFs, await zipFs.openPromise(subPath, flags, mode));
          });
      }
      openSync(p, flags, mode) {
          return this.makeCallSync(p, () => {
              return this.baseFs.openSync(p, flags, mode);
          }, (zipFs, { subPath }) => {
              return this.remapFd(zipFs, zipFs.openSync(subPath, flags, mode));
          });
      }
      async readPromise(fd, buffer, offset, length, position) {
          if ((fd & ZIP_FD) === 0)
              return await this.baseFs.readPromise(fd, buffer, offset, length, position);
          const entry = this.fdMap.get(fd);
          if (typeof entry === `undefined`)
              throw Object.assign(new Error(`EBADF: bad file descriptor, read`), { code: `EBADF` });
          const [zipFs, realFd] = entry;
          return await zipFs.readPromise(realFd, buffer, offset, length, position);
      }
      readSync(fd, buffer, offset, length, position) {
          if ((fd & ZIP_FD) === 0)
              return this.baseFs.readSync(fd, buffer, offset, length, position);
          const entry = this.fdMap.get(fd);
          if (typeof entry === `undefined`)
              throw Object.assign(new Error(`EBADF: bad file descriptor, read`), { code: `EBADF` });
          const [zipFs, realFd] = entry;
          return zipFs.readSync(realFd, buffer, offset, length, position);
      }
      async writePromise(fd, buffer, offset, length, position) {
          if ((fd & ZIP_FD) === 0) {
              if (typeof buffer === `string`) {
                  return await this.baseFs.writePromise(fd, buffer, offset);
              }
              else {
                  return await this.baseFs.writePromise(fd, buffer, offset, length, position);
              }
          }
          const entry = this.fdMap.get(fd);
          if (typeof entry === `undefined`)
              throw Object.assign(new Error(`EBADF: bad file descriptor, write`), { code: `EBADF` });
          const [zipFs, realFd] = entry;
          if (typeof buffer === `string`) {
              return await zipFs.writePromise(realFd, buffer, offset);
          }
          else {
              return await zipFs.writePromise(realFd, buffer, offset, length, position);
          }
      }
      writeSync(fd, buffer, offset, length, position) {
          if ((fd & ZIP_FD) === 0) {
              if (typeof buffer === `string`) {
                  return this.baseFs.writeSync(fd, buffer, offset);
              }
              else {
                  return this.baseFs.writeSync(fd, buffer, offset, length, position);
              }
          }
          const entry = this.fdMap.get(fd);
          if (typeof entry === `undefined`)
              throw Object.assign(new Error(`EBADF: bad file descriptor, write`), { code: `EBADF` });
          const [zipFs, realFd] = entry;
          if (typeof buffer === `string`) {
              return zipFs.writeSync(realFd, buffer, offset);
          }
          else {
              return zipFs.writeSync(realFd, buffer, offset, length, position);
          }
      }
      async closePromise(fd) {
          if ((fd & ZIP_FD) === 0)
              return await this.baseFs.closePromise(fd);
          const entry = this.fdMap.get(fd);
          if (typeof entry === `undefined`)
              throw Object.assign(new Error(`EBADF: bad file descriptor, close`), { code: `EBADF` });
          this.fdMap.delete(fd);
          const [zipFs, realFd] = entry;
          return await zipFs.closePromise(realFd);
      }
      closeSync(fd) {
          if ((fd & ZIP_FD) === 0)
              return this.baseFs.closeSync(fd);
          const entry = this.fdMap.get(fd);
          if (typeof entry === `undefined`)
              throw Object.assign(new Error(`EBADF: bad file descriptor, close`), { code: `EBADF` });
          this.fdMap.delete(fd);
          const [zipFs, realFd] = entry;
          return zipFs.closeSync(realFd);
      }
      createReadStream(p, opts) {
          if (p === null)
              return this.baseFs.createReadStream(p, opts);
          return this.makeCallSync(p, () => {
              return this.baseFs.createReadStream(p, opts);
          }, (zipFs, { subPath }) => {
              return zipFs.createReadStream(subPath, opts);
          });
      }
      createWriteStream(p, opts) {
          if (p === null)
              return this.baseFs.createWriteStream(p, opts);
          return this.makeCallSync(p, () => {
              return this.baseFs.createWriteStream(p, opts);
          }, (zipFs, { subPath }) => {
              return zipFs.createWriteStream(subPath, opts);
          });
      }
      async realpathPromise(p) {
          return await this.makeCallPromise(p, async () => {
              return await this.baseFs.realpathPromise(p);
          }, async (zipFs, { archivePath, subPath }) => {
              return this.pathUtils.resolve(await this.baseFs.realpathPromise(archivePath), this.pathUtils.relative(path_1.PortablePath.root, await zipFs.realpathPromise(subPath)));
          });
      }
      realpathSync(p) {
          return this.makeCallSync(p, () => {
              return this.baseFs.realpathSync(p);
          }, (zipFs, { archivePath, subPath }) => {
              return this.pathUtils.resolve(this.baseFs.realpathSync(archivePath), this.pathUtils.relative(path_1.PortablePath.root, zipFs.realpathSync(subPath)));
          });
      }
      async existsPromise(p) {
          return await this.makeCallPromise(p, async () => {
              return await this.baseFs.existsPromise(p);
          }, async (zipFs, { subPath }) => {
              return await zipFs.existsPromise(subPath);
          });
      }
      existsSync(p) {
          return this.makeCallSync(p, () => {
              return this.baseFs.existsSync(p);
          }, (zipFs, { subPath }) => {
              return zipFs.existsSync(subPath);
          });
      }
      async accessPromise(p, mode) {
          return await this.makeCallPromise(p, async () => {
              return await this.baseFs.accessPromise(p, mode);
          }, async (zipFs, { subPath }) => {
              return await zipFs.accessPromise(subPath, mode);
          });
      }
      accessSync(p, mode) {
          return this.makeCallSync(p, () => {
              return this.baseFs.accessSync(p, mode);
          }, (zipFs, { subPath }) => {
              return zipFs.accessSync(subPath, mode);
          });
      }
      async statPromise(p) {
          return await this.makeCallPromise(p, async () => {
              return await this.baseFs.statPromise(p);
          }, async (zipFs, { subPath }) => {
              return await zipFs.statPromise(subPath);
          });
      }
      statSync(p) {
          return this.makeCallSync(p, () => {
              return this.baseFs.statSync(p);
          }, (zipFs, { subPath }) => {
              return zipFs.statSync(subPath);
          });
      }
      async lstatPromise(p) {
          return await this.makeCallPromise(p, async () => {
              return await this.baseFs.lstatPromise(p);
          }, async (zipFs, { subPath }) => {
              return await zipFs.lstatPromise(subPath);
          });
      }
      lstatSync(p) {
          return this.makeCallSync(p, () => {
              return this.baseFs.lstatSync(p);
          }, (zipFs, { subPath }) => {
              return zipFs.lstatSync(subPath);
          });
      }
      async chmodPromise(p, mask) {
          return await this.makeCallPromise(p, async () => {
              return await this.baseFs.chmodPromise(p, mask);
          }, async (zipFs, { subPath }) => {
              return await zipFs.chmodPromise(subPath, mask);
          });
      }
      chmodSync(p, mask) {
          return this.makeCallSync(p, () => {
              return this.baseFs.chmodSync(p, mask);
          }, (zipFs, { subPath }) => {
              return zipFs.chmodSync(subPath, mask);
          });
      }
      async renamePromise(oldP, newP) {
          return await this.makeCallPromise(oldP, async () => {
              return await this.makeCallPromise(newP, async () => {
                  return await this.baseFs.renamePromise(oldP, newP);
              }, async () => {
                  throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), { code: `EEXDEV` });
              });
          }, async (zipFsO, { subPath: subPathO }) => {
              return await this.makeCallPromise(newP, async () => {
                  throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), { code: `EEXDEV` });
              }, async (zipFsN, { subPath: subPathN }) => {
                  if (zipFsO !== zipFsN) {
                      throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), { code: `EEXDEV` });
                  }
                  else {
                      return await zipFsO.renamePromise(subPathO, subPathN);
                  }
              });
          });
      }
      renameSync(oldP, newP) {
          return this.makeCallSync(oldP, () => {
              return this.makeCallSync(newP, () => {
                  return this.baseFs.renameSync(oldP, newP);
              }, async () => {
                  throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), { code: `EEXDEV` });
              });
          }, (zipFsO, { subPath: subPathO }) => {
              return this.makeCallSync(newP, () => {
                  throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), { code: `EEXDEV` });
              }, (zipFsN, { subPath: subPathN }) => {
                  if (zipFsO !== zipFsN) {
                      throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), { code: `EEXDEV` });
                  }
                  else {
                      return zipFsO.renameSync(subPathO, subPathN);
                  }
              });
          });
      }
      async copyFilePromise(sourceP, destP, flags = 0) {
          const fallback = async (sourceFs, sourceP, destFs, destP) => {
              if ((flags & fs_1.constants.COPYFILE_FICLONE_FORCE) !== 0)
                  throw Object.assign(new Error(`EXDEV: cross-device clone not permitted, copyfile '${sourceP}' -> ${destP}'`), { code: `EXDEV` });
              if ((flags & fs_1.constants.COPYFILE_EXCL) && await this.existsPromise(sourceP))
                  throw Object.assign(new Error(`EEXIST: file already exists, copyfile '${sourceP}' -> '${destP}'`), { code: `EEXIST` });
              let content;
              try {
                  content = await sourceFs.readFilePromise(sourceP);
              }
              catch (error) {
                  throw Object.assign(new Error(`EINVAL: invalid argument, copyfile '${sourceP}' -> '${destP}'`), { code: `EINVAL` });
              }
              await destFs.writeFilePromise(destP, content);
          };
          return await this.makeCallPromise(sourceP, async () => {
              return await this.makeCallPromise(destP, async () => {
                  return await this.baseFs.copyFilePromise(sourceP, destP, flags);
              }, async (zipFsD, { subPath: subPathD }) => {
                  return await fallback(this.baseFs, sourceP, zipFsD, subPathD);
              });
          }, async (zipFsS, { subPath: subPathS }) => {
              return await this.makeCallPromise(destP, async () => {
                  return await fallback(zipFsS, subPathS, this.baseFs, destP);
              }, async (zipFsD, { subPath: subPathD }) => {
                  if (zipFsS !== zipFsD) {
                      return await fallback(zipFsS, subPathS, zipFsD, subPathD);
                  }
                  else {
                      return await zipFsS.copyFilePromise(subPathS, subPathD, flags);
                  }
              });
          });
      }
      copyFileSync(sourceP, destP, flags = 0) {
          const fallback = (sourceFs, sourceP, destFs, destP) => {
              if ((flags & fs_1.constants.COPYFILE_FICLONE_FORCE) !== 0)
                  throw Object.assign(new Error(`EXDEV: cross-device clone not permitted, copyfile '${sourceP}' -> ${destP}'`), { code: `EXDEV` });
              if ((flags & fs_1.constants.COPYFILE_EXCL) && this.existsSync(sourceP))
                  throw Object.assign(new Error(`EEXIST: file already exists, copyfile '${sourceP}' -> '${destP}'`), { code: `EEXIST` });
              let content;
              try {
                  content = sourceFs.readFileSync(sourceP);
              }
              catch (error) {
                  throw Object.assign(new Error(`EINVAL: invalid argument, copyfile '${sourceP}' -> '${destP}'`), { code: `EINVAL` });
              }
              destFs.writeFileSync(destP, content);
          };
          return this.makeCallSync(sourceP, () => {
              return this.makeCallSync(destP, () => {
                  return this.baseFs.copyFileSync(sourceP, destP, flags);
              }, (zipFsD, { subPath: subPathD }) => {
                  return fallback(this.baseFs, sourceP, zipFsD, subPathD);
              });
          }, (zipFsS, { subPath: subPathS }) => {
              return this.makeCallSync(destP, () => {
                  return fallback(zipFsS, subPathS, this.baseFs, destP);
              }, (zipFsD, { subPath: subPathD }) => {
                  if (zipFsS !== zipFsD) {
                      return fallback(zipFsS, subPathS, zipFsD, subPathD);
                  }
                  else {
                      return zipFsS.copyFileSync(subPathS, subPathD, flags);
                  }
              });
          });
      }
      async appendFilePromise(p, content, opts) {
          return await this.makeCallPromise(p, async () => {
              return await this.baseFs.appendFilePromise(p, content, opts);
          }, async (zipFs, { subPath }) => {
              return await zipFs.appendFilePromise(subPath, content, opts);
          });
      }
      appendFileSync(p, content, opts) {
          return this.makeCallSync(p, () => {
              return this.baseFs.appendFileSync(p, content, opts);
          }, (zipFs, { subPath }) => {
              return zipFs.appendFileSync(subPath, content, opts);
          });
      }
      async writeFilePromise(p, content, opts) {
          return await this.makeCallPromise(p, async () => {
              return await this.baseFs.writeFilePromise(p, content, opts);
          }, async (zipFs, { subPath }) => {
              return await zipFs.writeFilePromise(subPath, content, opts);
          });
      }
      writeFileSync(p, content, opts) {
          return this.makeCallSync(p, () => {
              return this.baseFs.writeFileSync(p, content, opts);
          }, (zipFs, { subPath }) => {
              return zipFs.writeFileSync(subPath, content, opts);
          });
      }
      async unlinkPromise(p) {
          return await this.makeCallPromise(p, async () => {
              return await this.baseFs.unlinkPromise(p);
          }, async (zipFs, { subPath }) => {
              return await zipFs.unlinkPromise(subPath);
          });
      }
      unlinkSync(p) {
          return this.makeCallSync(p, () => {
              return this.baseFs.unlinkSync(p);
          }, (zipFs, { subPath }) => {
              return zipFs.unlinkSync(subPath);
          });
      }
      async utimesPromise(p, atime, mtime) {
          return await this.makeCallPromise(p, async () => {
              return await this.baseFs.utimesPromise(p, atime, mtime);
          }, async (zipFs, { subPath }) => {
              return await zipFs.utimesPromise(subPath, atime, mtime);
          });
      }
      utimesSync(p, atime, mtime) {
          return this.makeCallSync(p, () => {
              return this.baseFs.utimesSync(p, atime, mtime);
          }, (zipFs, { subPath }) => {
              return zipFs.utimesSync(subPath, atime, mtime);
          });
      }
      async mkdirPromise(p) {
          return await this.makeCallPromise(p, async () => {
              return await this.baseFs.mkdirPromise(p);
          }, async (zipFs, { subPath }) => {
              return await zipFs.mkdirPromise(subPath);
          });
      }
      mkdirSync(p) {
          return this.makeCallSync(p, () => {
              return this.baseFs.mkdirSync(p);
          }, (zipFs, { subPath }) => {
              return zipFs.mkdirSync(subPath);
          });
      }
      async rmdirPromise(p) {
          return await this.makeCallPromise(p, async () => {
              return await this.baseFs.rmdirPromise(p);
          }, async (zipFs, { subPath }) => {
              return await zipFs.rmdirPromise(subPath);
          });
      }
      rmdirSync(p) {
          return this.makeCallSync(p, () => {
              return this.baseFs.rmdirSync(p);
          }, (zipFs, { subPath }) => {
              return zipFs.rmdirSync(subPath);
          });
      }
      async symlinkPromise(target, p) {
          return await this.makeCallPromise(p, async () => {
              return await this.baseFs.symlinkPromise(target, p);
          }, async (zipFs, { subPath }) => {
              return await zipFs.symlinkPromise(target, subPath);
          });
      }
      symlinkSync(target, p) {
          return this.makeCallSync(p, () => {
              return this.baseFs.symlinkSync(target, p);
          }, (zipFs, { subPath }) => {
              return zipFs.symlinkSync(target, subPath);
          });
      }
      async readFilePromise(p, encoding) {
          return this.makeCallPromise(p, async () => {
              // This weird switch is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
              switch (encoding) {
                  case `utf8`:
                      return await this.baseFs.readFilePromise(p, encoding);
                  default:
                      return await this.baseFs.readFilePromise(p, encoding);
              }
          }, async (zipFs, { subPath }) => {
              return await zipFs.readFilePromise(subPath, encoding);
          });
      }
      readFileSync(p, encoding) {
          return this.makeCallSync(p, () => {
              // This weird switch is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
              switch (encoding) {
                  case `utf8`:
                      return this.baseFs.readFileSync(p, encoding);
                  default:
                      return this.baseFs.readFileSync(p, encoding);
              }
          }, (zipFs, { subPath }) => {
              return zipFs.readFileSync(subPath, encoding);
          });
      }
      async readdirPromise(p) {
          return await this.makeCallPromise(p, async () => {
              return await this.baseFs.readdirPromise(p);
          }, async (zipFs, { subPath }) => {
              return await zipFs.readdirPromise(subPath);
          }, {
              requireSubpath: false,
          });
      }
      readdirSync(p) {
          return this.makeCallSync(p, () => {
              return this.baseFs.readdirSync(p);
          }, (zipFs, { subPath }) => {
              return zipFs.readdirSync(subPath);
          }, {
              requireSubpath: false,
          });
      }
      async readlinkPromise(p) {
          return await this.makeCallPromise(p, async () => {
              return await this.baseFs.readlinkPromise(p);
          }, async (zipFs, { subPath }) => {
              return await zipFs.readlinkPromise(subPath);
          });
      }
      readlinkSync(p) {
          return this.makeCallSync(p, () => {
              return this.baseFs.readlinkSync(p);
          }, (zipFs, { subPath }) => {
              return zipFs.readlinkSync(subPath);
          });
      }
      watch(p, a, b) {
          return this.makeCallSync(p, () => {
              return this.baseFs.watch(p,
              // @ts-ignore
              a, b);
          }, (zipFs, { subPath }) => {
              return zipFs.watch(subPath,
              // @ts-ignore
              a, b);
          });
      }
      async makeCallPromise(p, discard, accept, { requireSubpath = true } = {}) {
          if (typeof p !== `string`)
              return await discard();
          const normalizedP = this.pathUtils.normalize(this.pathUtils.resolve(path_1.PortablePath.root, p));
          const zipInfo = this.findZip(normalizedP);
          if (!zipInfo)
              return await discard();
          if (requireSubpath && zipInfo.subPath === `/`)
              return await discard();
          return await this.getZipPromise(zipInfo.archivePath, async (zipFs) => await accept(zipFs, zipInfo));
      }
      makeCallSync(p, discard, accept, { requireSubpath = true } = {}) {
          if (typeof p !== `string`)
              return discard();
          const normalizedP = this.pathUtils.normalize(this.pathUtils.resolve(path_1.PortablePath.root, p));
          const zipInfo = this.findZip(normalizedP);
          if (!zipInfo)
              return discard();
          if (requireSubpath && zipInfo.subPath === `/`)
              return discard();
          return this.getZipSync(zipInfo.archivePath, zipFs => accept(zipFs, zipInfo));
      }
      findZip(p) {
          if (this.filter && !this.filter.test(p))
              return null;
          const parts = p.split(/\//g);
          for (let t = 2; t <= parts.length; ++t) {
              const archivePath = parts.slice(0, t).join(`/`);
              if (this.notZip.has(archivePath))
                  continue;
              if (this.isZip.has(archivePath))
                  return { archivePath, subPath: this.pathUtils.resolve(path_1.PortablePath.root, parts.slice(t).join(`/`)) };
              let realArchivePath = archivePath;
              let stat;
              while (true) {
                  try {
                      stat = this.baseFs.lstatSync(realArchivePath);
                  }
                  catch (error) {
                      return null;
                  }
                  if (stat.isSymbolicLink()) {
                      realArchivePath = this.pathUtils.resolve(this.pathUtils.dirname(realArchivePath), this.baseFs.readlinkSync(realArchivePath));
                  }
                  else {
                      break;
                  }
              }
              const isZip = stat.isFile() && this.pathUtils.extname(realArchivePath) === `.zip`;
              if (isZip) {
                  this.isZip.add(archivePath);
                  return { archivePath, subPath: this.pathUtils.resolve(path_1.PortablePath.root, parts.slice(t).join(`/`)) };
              }
              else {
                  this.notZip.add(archivePath);
                  if (stat.isFile()) {
                      return null;
                  }
              }
          }
          return null;
      }
      async getZipPromise(p, accept) {
          if (this.zipInstances) {
              let zipFs = this.zipInstances.get(p);
              if (!zipFs)
                  this.zipInstances.set(p, zipFs = new ZipFS_1.ZipFS(p, { baseFs: this.baseFs, stats: await this.baseFs.statPromise(p) }));
              return await accept(zipFs);
          }
          else {
              const zipFs = new ZipFS_1.ZipFS(p, { baseFs: this.baseFs, stats: await this.baseFs.statPromise(p) });
              try {
                  return await accept(zipFs);
              }
              finally {
                  zipFs.saveAndClose();
              }
          }
      }
      getZipSync(p, accept) {
          if (this.zipInstances) {
              let zipFs = this.zipInstances.get(p);
              if (!zipFs)
                  this.zipInstances.set(p, zipFs = new ZipFS_1.ZipFS(p, { baseFs: this.baseFs }));
              return accept(zipFs);
          }
          else {
              const zipFs = new ZipFS_1.ZipFS(p, { baseFs: this.baseFs });
              try {
                  return accept(zipFs);
              }
              finally {
                  zipFs.saveAndClose();
              }
          }
      }
  }
  exports.ZipOpenFS = ZipOpenFS;


  /***/ }),
  /* 27 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const cp = __webpack_require__(28);
  const parse = __webpack_require__(29);
  const enoent = __webpack_require__(42);

  function spawn(command, args, options) {
      // Parse the arguments
      const parsed = parse(command, args, options);

      // Spawn the child process
      const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);

      // Hook into child process "exit" event to emit an error if the command
      // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
      enoent.hookChildProcess(spawned, parsed);

      return spawned;
  }

  function spawnSync(command, args, options) {
      // Parse the arguments
      const parsed = parse(command, args, options);

      // Spawn the child process
      const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);

      // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
      result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);

      return result;
  }

  module.exports = spawn;
  module.exports.spawn = spawn;
  module.exports.sync = spawnSync;

  module.exports._parse = parse;
  module.exports._enoent = enoent;


  /***/ }),
  /* 28 */
  /***/ (function(module, exports) {

  module.exports = require("child_process");

  /***/ }),
  /* 29 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const path = __webpack_require__(8);
  const niceTry = __webpack_require__(30);
  const resolveCommand = __webpack_require__(31);
  const escape = __webpack_require__(37);
  const readShebang = __webpack_require__(38);
  const semver = __webpack_require__(41);

  const isWin = process.platform === 'win32';
  const isExecutableRegExp = /\.(?:com|exe)$/i;
  const isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;

  // `options.shell` is supported in Node ^4.8.0, ^5.7.0 and >= 6.0.0
  const supportsShellOption = niceTry(() => semver.satisfies(process.version, '^4.8.0 || ^5.7.0 || >= 6.0.0', true)) || false;

  function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);

      const shebang = parsed.file && readShebang(parsed.file);

      if (shebang) {
          parsed.args.unshift(parsed.file);
          parsed.command = shebang;

          return resolveCommand(parsed);
      }

      return parsed.file;
  }

  function parseNonShell(parsed) {
      if (!isWin) {
          return parsed;
      }

      // Detect & add support for shebangs
      const commandFile = detectShebang(parsed);

      // We don't need a shell if the command filename is an executable
      const needsShell = !isExecutableRegExp.test(commandFile);

      // If a shell is required, use cmd.exe and take care of escaping everything correctly
      // Note that `forceShell` is an hidden option used only in tests
      if (parsed.options.forceShell || needsShell) {
          // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`
          // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument
          // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,
          // we need to double escape them
          const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);

          // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\bar)
          // This is necessary otherwise it will always fail with ENOENT in those cases
          parsed.command = path.normalize(parsed.command);

          // Escape command & arguments
          parsed.command = escape.command(parsed.command);
          parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));

          const shellCommand = [parsed.command].concat(parsed.args).join(' ');

          parsed.args = ['/d', '/s', '/c', `"${shellCommand}"`];
          parsed.command = process.env.comspec || 'cmd.exe';
          parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped
      }

      return parsed;
  }

  function parseShell(parsed) {
      // If node supports the shell option, there's no need to mimic its behavior
      if (supportsShellOption) {
          return parsed;
      }

      // Mimic node shell option
      // See https://github.com/nodejs/node/blob/b9f6a2dc059a1062776133f3d4fd848c4da7d150/lib/child_process.js#L335
      const shellCommand = [parsed.command].concat(parsed.args).join(' ');

      if (isWin) {
          parsed.command = typeof parsed.options.shell === 'string' ? parsed.options.shell : process.env.comspec || 'cmd.exe';
          parsed.args = ['/d', '/s', '/c', `"${shellCommand}"`];
          parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped
      } else {
          if (typeof parsed.options.shell === 'string') {
              parsed.command = parsed.options.shell;
          } else if (process.platform === 'android') {
              parsed.command = '/system/bin/sh';
          } else {
              parsed.command = '/bin/sh';
          }

          parsed.args = ['-c', shellCommand];
      }

      return parsed;
  }

  function parse(command, args, options) {
      // Normalize arguments, similar to nodejs
      if (args && !Array.isArray(args)) {
          options = args;
          args = null;
      }

      args = args ? args.slice(0) : []; // Clone array to avoid changing the original
      options = Object.assign({}, options); // Clone object to avoid changing the original

      // Build our parsed object
      const parsed = {
          command,
          args,
          options,
          file: undefined,
          original: {
              command,
              args,
          },
      };

      // Delegate further parsing to shell or non-shell
      return options.shell ? parseShell(parsed) : parseNonShell(parsed);
  }

  module.exports = parse;


  /***/ }),
  /* 30 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  /**
   * Tries to execute a function and discards any error that occurs.
   * @param {Function} fn - Function that might or might not throw an error.
   * @returns {?*} Return-value of the function when no error occurred.
   */
  module.exports = function(fn) {

  	try { return fn() } catch (e) {}

  }

  /***/ }),
  /* 31 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const path = __webpack_require__(8);
  const which = __webpack_require__(32);
  const pathKey = __webpack_require__(36)();

  function resolveCommandAttempt(parsed, withoutPathExt) {
      const cwd = process.cwd();
      const hasCustomCwd = parsed.options.cwd != null;

      // If a custom `cwd` was specified, we need to change the process cwd
      // because `which` will do stat calls but does not support a custom cwd
      if (hasCustomCwd) {
          try {
              process.chdir(parsed.options.cwd);
          } catch (err) {
              /* Empty */
          }
      }

      let resolved;

      try {
          resolved = which.sync(parsed.command, {
              path: (parsed.options.env || process.env)[pathKey],
              pathExt: withoutPathExt ? path.delimiter : undefined,
          });
      } catch (e) {
          /* Empty */
      } finally {
          process.chdir(cwd);
      }

      // If we successfully resolved, ensure that an absolute path is returned
      // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it
      if (resolved) {
          resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);
      }

      return resolved;
  }

  function resolveCommand(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
  }

  module.exports = resolveCommand;


  /***/ }),
  /* 32 */
  /***/ (function(module, exports, __webpack_require__) {

  module.exports = which
  which.sync = whichSync

  var isWindows = process.platform === 'win32' ||
      process.env.OSTYPE === 'cygwin' ||
      process.env.OSTYPE === 'msys'

  var path = __webpack_require__(8)
  var COLON = isWindows ? ';' : ':'
  var isexe = __webpack_require__(33)

  function getNotFoundError (cmd) {
    var er = new Error('not found: ' + cmd)
    er.code = 'ENOENT'

    return er
  }

  function getPathInfo (cmd, opt) {
    var colon = opt.colon || COLON
    var pathEnv = opt.path || process.env.PATH || ''
    var pathExt = ['']

    pathEnv = pathEnv.split(colon)

    var pathExtExe = ''
    if (isWindows) {
      pathEnv.unshift(process.cwd())
      pathExtExe = (opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM')
      pathExt = pathExtExe.split(colon)


      // Always test the cmd itself first.  isexe will check to make sure
      // it's found in the pathExt set.
      if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')
        pathExt.unshift('')
    }

    // If it has a slash, then we don't bother searching the pathenv.
    // just check the file itself, and that's it.
    if (cmd.match(/\//) || isWindows && cmd.match(/\\/))
      pathEnv = ['']

    return {
      env: pathEnv,
      ext: pathExt,
      extExe: pathExtExe
    }
  }

  function which (cmd, opt, cb) {
    if (typeof opt === 'function') {
      cb = opt
      opt = {}
    }

    var info = getPathInfo(cmd, opt)
    var pathEnv = info.env
    var pathExt = info.ext
    var pathExtExe = info.extExe
    var found = []

    ;(function F (i, l) {
      if (i === l) {
        if (opt.all && found.length)
          return cb(null, found)
        else
          return cb(getNotFoundError(cmd))
      }

      var pathPart = pathEnv[i]
      if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
        pathPart = pathPart.slice(1, -1)

      var p = path.join(pathPart, cmd)
      if (!pathPart && (/^\.[\\\/]/).test(cmd)) {
        p = cmd.slice(0, 2) + p
      }
      ;(function E (ii, ll) {
        if (ii === ll) return F(i + 1, l)
        var ext = pathExt[ii]
        isexe(p + ext, { pathExt: pathExtExe }, function (er, is) {
          if (!er && is) {
            if (opt.all)
              found.push(p + ext)
            else
              return cb(null, p + ext)
          }
          return E(ii + 1, ll)
        })
      })(0, pathExt.length)
    })(0, pathEnv.length)
  }

  function whichSync (cmd, opt) {
    opt = opt || {}

    var info = getPathInfo(cmd, opt)
    var pathEnv = info.env
    var pathExt = info.ext
    var pathExtExe = info.extExe
    var found = []

    for (var i = 0, l = pathEnv.length; i < l; i ++) {
      var pathPart = pathEnv[i]
      if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
        pathPart = pathPart.slice(1, -1)

      var p = path.join(pathPart, cmd)
      if (!pathPart && /^\.[\\\/]/.test(cmd)) {
        p = cmd.slice(0, 2) + p
      }
      for (var j = 0, ll = pathExt.length; j < ll; j ++) {
        var cur = p + pathExt[j]
        var is
        try {
          is = isexe.sync(cur, { pathExt: pathExtExe })
          if (is) {
            if (opt.all)
              found.push(cur)
            else
              return cur
          }
        } catch (ex) {}
      }
    }

    if (opt.all && found.length)
      return found

    if (opt.nothrow)
      return null

    throw getNotFoundError(cmd)
  }


  /***/ }),
  /* 33 */
  /***/ (function(module, exports, __webpack_require__) {

  var fs = __webpack_require__(7)
  var core
  if (process.platform === 'win32' || global.TESTING_WINDOWS) {
    core = __webpack_require__(34)
  } else {
    core = __webpack_require__(35)
  }

  module.exports = isexe
  isexe.sync = sync

  function isexe (path, options, cb) {
    if (typeof options === 'function') {
      cb = options
      options = {}
    }

    if (!cb) {
      if (typeof Promise !== 'function') {
        throw new TypeError('callback not provided')
      }

      return new Promise(function (resolve, reject) {
        isexe(path, options || {}, function (er, is) {
          if (er) {
            reject(er)
          } else {
            resolve(is)
          }
        })
      })
    }

    core(path, options || {}, function (er, is) {
      // ignore EACCES because that just means we aren't allowed to run it
      if (er) {
        if (er.code === 'EACCES' || options && options.ignoreErrors) {
          er = null
          is = false
        }
      }
      cb(er, is)
    })
  }

  function sync (path, options) {
    // my kingdom for a filtered catch
    try {
      return core.sync(path, options || {})
    } catch (er) {
      if (options && options.ignoreErrors || er.code === 'EACCES') {
        return false
      } else {
        throw er
      }
    }
  }


  /***/ }),
  /* 34 */
  /***/ (function(module, exports, __webpack_require__) {

  module.exports = isexe
  isexe.sync = sync

  var fs = __webpack_require__(7)

  function checkPathExt (path, options) {
    var pathext = options.pathExt !== undefined ?
      options.pathExt : process.env.PATHEXT

    if (!pathext) {
      return true
    }

    pathext = pathext.split(';')
    if (pathext.indexOf('') !== -1) {
      return true
    }
    for (var i = 0; i < pathext.length; i++) {
      var p = pathext[i].toLowerCase()
      if (p && path.substr(-p.length).toLowerCase() === p) {
        return true
      }
    }
    return false
  }

  function checkStat (stat, path, options) {
    if (!stat.isSymbolicLink() && !stat.isFile()) {
      return false
    }
    return checkPathExt(path, options)
  }

  function isexe (path, options, cb) {
    fs.stat(path, function (er, stat) {
      cb(er, er ? false : checkStat(stat, path, options))
    })
  }

  function sync (path, options) {
    return checkStat(fs.statSync(path), path, options)
  }


  /***/ }),
  /* 35 */
  /***/ (function(module, exports, __webpack_require__) {

  module.exports = isexe
  isexe.sync = sync

  var fs = __webpack_require__(7)

  function isexe (path, options, cb) {
    fs.stat(path, function (er, stat) {
      cb(er, er ? false : checkStat(stat, options))
    })
  }

  function sync (path, options) {
    return checkStat(fs.statSync(path), options)
  }

  function checkStat (stat, options) {
    return stat.isFile() && checkMode(stat, options)
  }

  function checkMode (stat, options) {
    var mod = stat.mode
    var uid = stat.uid
    var gid = stat.gid

    var myUid = options.uid !== undefined ?
      options.uid : process.getuid && process.getuid()
    var myGid = options.gid !== undefined ?
      options.gid : process.getgid && process.getgid()

    var u = parseInt('100', 8)
    var g = parseInt('010', 8)
    var o = parseInt('001', 8)
    var ug = u | g

    var ret = (mod & o) ||
      (mod & g) && gid === myGid ||
      (mod & u) && uid === myUid ||
      (mod & ug) && myUid === 0

    return ret
  }


  /***/ }),
  /* 36 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  module.exports = opts => {
  	opts = opts || {};

  	const env = opts.env || process.env;
  	const platform = opts.platform || process.platform;

  	if (platform !== 'win32') {
  		return 'PATH';
  	}

  	return Object.keys(env).find(x => x.toUpperCase() === 'PATH') || 'Path';
  };


  /***/ }),
  /* 37 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  // See http://www.robvanderwoude.com/escapechars.php
  const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;

  function escapeCommand(arg) {
      // Escape meta chars
      arg = arg.replace(metaCharsRegExp, '^$1');

      return arg;
  }

  function escapeArgument(arg, doubleEscapeMetaChars) {
      // Convert to string
      arg = `${arg}`;

      // Algorithm below is based on https://qntm.org/cmd

      // Sequence of backslashes followed by a double quote:
      // double up all the backslashes and escape the double quote
      arg = arg.replace(/(\\*)"/g, '$1$1\\"');

      // Sequence of backslashes followed by the end of the string
      // (which will become a double quote later):
      // double up all the backslashes
      arg = arg.replace(/(\\*)$/, '$1$1');

      // All other backslashes occur literally

      // Quote the whole thing:
      arg = `"${arg}"`;

      // Escape meta chars
      arg = arg.replace(metaCharsRegExp, '^$1');

      // Double escape meta chars if necessary
      if (doubleEscapeMetaChars) {
          arg = arg.replace(metaCharsRegExp, '^$1');
      }

      return arg;
  }

  module.exports.command = escapeCommand;
  module.exports.argument = escapeArgument;


  /***/ }),
  /* 38 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const fs = __webpack_require__(7);
  const shebangCommand = __webpack_require__(39);

  function readShebang(command) {
      // Read the first 150 bytes from the file
      const size = 150;
      let buffer;

      if (Buffer.alloc) {
          // Node.js v4.5+ / v5.10+
          buffer = Buffer.alloc(size);
      } else {
          // Old Node.js API
          buffer = new Buffer(size);
          buffer.fill(0); // zero-fill
      }

      let fd;

      try {
          fd = fs.openSync(command, 'r');
          fs.readSync(fd, buffer, 0, size, 0);
          fs.closeSync(fd);
      } catch (e) { /* Empty */ }

      // Attempt to extract shebang (null is returned if not a shebang)
      return shebangCommand(buffer.toString());
  }

  module.exports = readShebang;


  /***/ }),
  /* 39 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var shebangRegex = __webpack_require__(40);

  module.exports = function (str) {
  	var match = str.match(shebangRegex);

  	if (!match) {
  		return null;
  	}

  	var arr = match[0].replace(/#! ?/, '').split(' ');
  	var bin = arr[0].split('/').pop();
  	var arg = arr[1];

  	return (bin === 'env' ?
  		arg :
  		bin + (arg ? ' ' + arg : '')
  	);
  };


  /***/ }),
  /* 40 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  module.exports = /^#!.*/;


  /***/ }),
  /* 41 */
  /***/ (function(module, exports) {

  exports = module.exports = SemVer

  var debug
  /* istanbul ignore next */
  if (typeof process === 'object' &&
      process.env &&
      process.env.NODE_DEBUG &&
      /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug = function () {
      var args = Array.prototype.slice.call(arguments, 0)
      args.unshift('SEMVER')
      console.log.apply(console, args)
    }
  } else {
    debug = function () {}
  }

  // Note: this is the semver.org version of the spec that it implements
  // Not necessarily the package version of this code.
  exports.SEMVER_SPEC_VERSION = '2.0.0'

  var MAX_LENGTH = 256
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
    /* istanbul ignore next */ 9007199254740991

  // Max safe segment length for coercion.
  var MAX_SAFE_COMPONENT_LENGTH = 16

  // The actual regexps go on exports.re
  var re = exports.re = []
  var src = exports.src = []
  var R = 0

  // The following Regular Expressions can be used for tokenizing,
  // validating, and parsing SemVer version strings.

  // ## Numeric Identifier
  // A single `0`, or a non-zero digit followed by zero or more digits.

  var NUMERICIDENTIFIER = R++
  src[NUMERICIDENTIFIER] = '0|[1-9]\\d*'
  var NUMERICIDENTIFIERLOOSE = R++
  src[NUMERICIDENTIFIERLOOSE] = '[0-9]+'

  // ## Non-numeric Identifier
  // Zero or more digits, followed by a letter or hyphen, and then zero or
  // more letters, digits, or hyphens.

  var NONNUMERICIDENTIFIER = R++
  src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

  // ## Main Version
  // Three dot-separated numeric identifiers.

  var MAINVERSION = R++
  src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                     '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                     '(' + src[NUMERICIDENTIFIER] + ')'

  var MAINVERSIONLOOSE = R++
  src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                          '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                          '(' + src[NUMERICIDENTIFIERLOOSE] + ')'

  // ## Pre-release Version Identifier
  // A numeric identifier, or a non-numeric identifier.

  var PRERELEASEIDENTIFIER = R++
  src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                              '|' + src[NONNUMERICIDENTIFIER] + ')'

  var PRERELEASEIDENTIFIERLOOSE = R++
  src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                   '|' + src[NONNUMERICIDENTIFIER] + ')'

  // ## Pre-release Version
  // Hyphen, followed by one or more dot-separated pre-release version
  // identifiers.

  var PRERELEASE = R++
  src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                    '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))'

  var PRERELEASELOOSE = R++
  src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                         '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'

  // ## Build Metadata Identifier
  // Any combination of digits, letters, or hyphens.

  var BUILDIDENTIFIER = R++
  src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

  // ## Build Metadata
  // Plus sign, followed by one or more period-separated build metadata
  // identifiers.

  var BUILD = R++
  src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
               '(?:\\.' + src[BUILDIDENTIFIER] + ')*))'

  // ## Full Version String
  // A main version, followed optionally by a pre-release version and
  // build metadata.

  // Note that the only major, minor, patch, and pre-release sections of
  // the version string are capturing groups.  The build metadata is not a
  // capturing group, because it should not ever be used in version
  // comparison.

  var FULL = R++
  var FULLPLAIN = 'v?' + src[MAINVERSION] +
                  src[PRERELEASE] + '?' +
                  src[BUILD] + '?'

  src[FULL] = '^' + FULLPLAIN + '$'

  // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
  // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
  // common in the npm registry.
  var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                   src[PRERELEASELOOSE] + '?' +
                   src[BUILD] + '?'

  var LOOSE = R++
  src[LOOSE] = '^' + LOOSEPLAIN + '$'

  var GTLT = R++
  src[GTLT] = '((?:<|>)?=?)'

  // Something like "2.*" or "1.2.x".
  // Note that "x.x" is a valid xRange identifer, meaning "any version"
  // Only the first item is strictly required.
  var XRANGEIDENTIFIERLOOSE = R++
  src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
  var XRANGEIDENTIFIER = R++
  src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*'

  var XRANGEPLAIN = R++
  src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                     '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                     '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                     '(?:' + src[PRERELEASE] + ')?' +
                     src[BUILD] + '?' +
                     ')?)?'

  var XRANGEPLAINLOOSE = R++
  src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                          '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                          '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                          '(?:' + src[PRERELEASELOOSE] + ')?' +
                          src[BUILD] + '?' +
                          ')?)?'

  var XRANGE = R++
  src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$'
  var XRANGELOOSE = R++
  src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'

  // Coercion.
  // Extract anything that could conceivably be a part of a valid semver
  var COERCE = R++
  src[COERCE] = '(?:^|[^\\d])' +
                '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
                '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
                '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
                '(?:$|[^\\d])'

  // Tilde ranges.
  // Meaning is "reasonably at or greater than"
  var LONETILDE = R++
  src[LONETILDE] = '(?:~>?)'

  var TILDETRIM = R++
  src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+'
  re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')
  var tildeTrimReplace = '$1~'

  var TILDE = R++
  src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'
  var TILDELOOSE = R++
  src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'

  // Caret ranges.
  // Meaning is "at least and backwards compatible with"
  var LONECARET = R++
  src[LONECARET] = '(?:\\^)'

  var CARETTRIM = R++
  src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+'
  re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')
  var caretTrimReplace = '$1^'

  var CARET = R++
  src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'
  var CARETLOOSE = R++
  src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'

  // A simple gt/lt/eq thing, or just "" to indicate "any version"
  var COMPARATORLOOSE = R++
  src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$'
  var COMPARATOR = R++
  src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'

  // An expression to strip any whitespace between the gtlt and the thing
  // it modifies, so that `> 1.2.3` ==> `>1.2.3`
  var COMPARATORTRIM = R++
  src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                        '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'

  // this one has to use the /g flag
  re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')
  var comparatorTrimReplace = '$1$2$3'

  // Something like `1.2.3 - 1.2.4`
  // Note that these all use the loose form, because they'll be
  // checked against either the strict or loose comparator form
  // later.
  var HYPHENRANGE = R++
  src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                     '\\s+-\\s+' +
                     '(' + src[XRANGEPLAIN] + ')' +
                     '\\s*$'

  var HYPHENRANGELOOSE = R++
  src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                          '\\s+-\\s+' +
                          '(' + src[XRANGEPLAINLOOSE] + ')' +
                          '\\s*$'

  // Star ranges basically just allow anything at all.
  var STAR = R++
  src[STAR] = '(<|>)?=?\\s*\\*'

  // Compile to actual regexp objects.
  // All are flag-free, unless they were created above with a flag.
  for (var i = 0; i < R; i++) {
    debug(i, src[i])
    if (!re[i]) {
      re[i] = new RegExp(src[i])
    }
  }

  exports.parse = parse
  function parse (version, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    if (version instanceof SemVer) {
      return version
    }

    if (typeof version !== 'string') {
      return null
    }

    if (version.length > MAX_LENGTH) {
      return null
    }

    var r = options.loose ? re[LOOSE] : re[FULL]
    if (!r.test(version)) {
      return null
    }

    try {
      return new SemVer(version, options)
    } catch (er) {
      return null
    }
  }

  exports.valid = valid
  function valid (version, options) {
    var v = parse(version, options)
    return v ? v.version : null
  }

  exports.clean = clean
  function clean (version, options) {
    var s = parse(version.trim().replace(/^[=v]+/, ''), options)
    return s ? s.version : null
  }

  exports.SemVer = SemVer

  function SemVer (version, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }
    if (version instanceof SemVer) {
      if (version.loose === options.loose) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError('Invalid Version: ' + version)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
    }

    if (!(this instanceof SemVer)) {
      return new SemVer(version, options)
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose

    var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL])

    if (!m) {
      throw new TypeError('Invalid Version: ' + version)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map(function (id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  SemVer.prototype.format = function () {
    this.version = this.major + '.' + this.minor + '.' + this.patch
    if (this.prerelease.length) {
      this.version += '-' + this.prerelease.join('.')
    }
    return this.version
  }

  SemVer.prototype.toString = function () {
    return this.version
  }

  SemVer.prototype.compare = function (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  SemVer.prototype.compareMain = function (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return compareIdentifiers(this.major, other.major) ||
           compareIdentifiers(this.minor, other.minor) ||
           compareIdentifiers(this.patch, other.patch)
  }

  SemVer.prototype.comparePre = function (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    var i = 0
    do {
      var a = this.prerelease[i]
      var b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  SemVer.prototype.inc = function (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier)
        this.inc('pre', identifier)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier)
        }
        this.inc('pre', identifier)
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (this.minor !== 0 ||
            this.patch !== 0 ||
            this.prerelease.length === 0) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0]
        } else {
          var i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            this.prerelease.push(0)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0]
            }
          } else {
            this.prerelease = [identifier, 0]
          }
        }
        break

      default:
        throw new Error('invalid increment argument: ' + release)
    }
    this.format()
    this.raw = this.version
    return this
  }

  exports.inc = inc
  function inc (version, release, loose, identifier) {
    if (typeof (loose) === 'string') {
      identifier = loose
      loose = undefined
    }

    try {
      return new SemVer(version, loose).inc(release, identifier).version
    } catch (er) {
      return null
    }
  }

  exports.diff = diff
  function diff (version1, version2) {
    if (eq(version1, version2)) {
      return null
    } else {
      var v1 = parse(version1)
      var v2 = parse(version2)
      var prefix = ''
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = 'pre'
        var defaultResult = 'prerelease'
      }
      for (var key in v1) {
        if (key === 'major' || key === 'minor' || key === 'patch') {
          if (v1[key] !== v2[key]) {
            return prefix + key
          }
        }
      }
      return defaultResult // may be undefined
    }
  }

  exports.compareIdentifiers = compareIdentifiers

  var numeric = /^[0-9]+$/
  function compareIdentifiers (a, b) {
    var anum = numeric.test(a)
    var bnum = numeric.test(b)

    if (anum && bnum) {
      a = +a
      b = +b
    }

    return a === b ? 0
      : (anum && !bnum) ? -1
      : (bnum && !anum) ? 1
      : a < b ? -1
      : 1
  }

  exports.rcompareIdentifiers = rcompareIdentifiers
  function rcompareIdentifiers (a, b) {
    return compareIdentifiers(b, a)
  }

  exports.major = major
  function major (a, loose) {
    return new SemVer(a, loose).major
  }

  exports.minor = minor
  function minor (a, loose) {
    return new SemVer(a, loose).minor
  }

  exports.patch = patch
  function patch (a, loose) {
    return new SemVer(a, loose).patch
  }

  exports.compare = compare
  function compare (a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose))
  }

  exports.compareLoose = compareLoose
  function compareLoose (a, b) {
    return compare(a, b, true)
  }

  exports.rcompare = rcompare
  function rcompare (a, b, loose) {
    return compare(b, a, loose)
  }

  exports.sort = sort
  function sort (list, loose) {
    return list.sort(function (a, b) {
      return exports.compare(a, b, loose)
    })
  }

  exports.rsort = rsort
  function rsort (list, loose) {
    return list.sort(function (a, b) {
      return exports.rcompare(a, b, loose)
    })
  }

  exports.gt = gt
  function gt (a, b, loose) {
    return compare(a, b, loose) > 0
  }

  exports.lt = lt
  function lt (a, b, loose) {
    return compare(a, b, loose) < 0
  }

  exports.eq = eq
  function eq (a, b, loose) {
    return compare(a, b, loose) === 0
  }

  exports.neq = neq
  function neq (a, b, loose) {
    return compare(a, b, loose) !== 0
  }

  exports.gte = gte
  function gte (a, b, loose) {
    return compare(a, b, loose) >= 0
  }

  exports.lte = lte
  function lte (a, b, loose) {
    return compare(a, b, loose) <= 0
  }

  exports.cmp = cmp
  function cmp (a, op, b, loose) {
    switch (op) {
      case '===':
        if (typeof a === 'object')
          a = a.version
        if (typeof b === 'object')
          b = b.version
        return a === b

      case '!==':
        if (typeof a === 'object')
          a = a.version
        if (typeof b === 'object')
          b = b.version
        return a !== b

      case '':
      case '=':
      case '==':
        return eq(a, b, loose)

      case '!=':
        return neq(a, b, loose)

      case '>':
        return gt(a, b, loose)

      case '>=':
        return gte(a, b, loose)

      case '<':
        return lt(a, b, loose)

      case '<=':
        return lte(a, b, loose)

      default:
        throw new TypeError('Invalid operator: ' + op)
    }
  }

  exports.Comparator = Comparator
  function Comparator (comp, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value
      }
    }

    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options)
    }

    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    } else {
      this.value = this.operator + this.semver.version
    }

    debug('comp', this)
  }

  var ANY = {}
  Comparator.prototype.parse = function (comp) {
    var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
    var m = comp.match(r)

    if (!m) {
      throw new TypeError('Invalid comparator: ' + comp)
    }

    this.operator = m[1]
    if (this.operator === '=') {
      this.operator = ''
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    } else {
      this.semver = new SemVer(m[2], this.options.loose)
    }
  }

  Comparator.prototype.toString = function () {
    return this.value
  }

  Comparator.prototype.test = function (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY) {
      return true
    }

    if (typeof version === 'string') {
      version = new SemVer(version, this.options)
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  Comparator.prototype.intersects = function (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    var rangeTmp

    if (this.operator === '') {
      rangeTmp = new Range(comp.value, options)
      return satisfies(this.value, rangeTmp, options)
    } else if (comp.operator === '') {
      rangeTmp = new Range(this.value, options)
      return satisfies(comp.semver, rangeTmp, options)
    }

    var sameDirectionIncreasing =
      (this.operator === '>=' || this.operator === '>') &&
      (comp.operator === '>=' || comp.operator === '>')
    var sameDirectionDecreasing =
      (this.operator === '<=' || this.operator === '<') &&
      (comp.operator === '<=' || comp.operator === '<')
    var sameSemVer = this.semver.version === comp.semver.version
    var differentDirectionsInclusive =
      (this.operator === '>=' || this.operator === '<=') &&
      (comp.operator === '>=' || comp.operator === '<=')
    var oppositeDirectionsLessThan =
      cmp(this.semver, '<', comp.semver, options) &&
      ((this.operator === '>=' || this.operator === '>') &&
      (comp.operator === '<=' || comp.operator === '<'))
    var oppositeDirectionsGreaterThan =
      cmp(this.semver, '>', comp.semver, options) &&
      ((this.operator === '<=' || this.operator === '<') &&
      (comp.operator === '>=' || comp.operator === '>'))

    return sameDirectionIncreasing || sameDirectionDecreasing ||
      (sameSemVer && differentDirectionsInclusive) ||
      oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
  }

  exports.Range = Range
  function Range (range, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    if (range instanceof Range) {
      if (range.loose === !!options.loose &&
          range.includePrerelease === !!options.includePrerelease) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      return new Range(range.value, options)
    }

    if (!(this instanceof Range)) {
      return new Range(range, options)
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First, split based on boolean or ||
    this.raw = range
    this.set = range.split(/\s*\|\|\s*/).map(function (range) {
      return this.parseRange(range.trim())
    }, this).filter(function (c) {
      // throw out any that are not relevant for whatever reason
      return c.length
    })

    if (!this.set.length) {
      throw new TypeError('Invalid SemVer Range: ' + range)
    }

    this.format()
  }

  Range.prototype.format = function () {
    this.range = this.set.map(function (comps) {
      return comps.join(' ').trim()
    }).join('||').trim()
    return this.range
  }

  Range.prototype.toString = function () {
    return this.range
  }

  Range.prototype.parseRange = function (range) {
    var loose = this.options.loose
    range = range.trim()
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE]
    range = range.replace(hr, hyphenReplace)
    debug('hyphen replace', range)
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range, re[COMPARATORTRIM])

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[TILDETRIM], tildeTrimReplace)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[CARETTRIM], caretTrimReplace)

    // normalize spaces
    range = range.split(/\s+/).join(' ')

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
    var set = range.split(' ').map(function (comp) {
      return parseComparator(comp, this.options)
    }, this).join(' ').split(/\s+/)
    if (this.options.loose) {
      // in loose mode, throw out any that are not valid comparators
      set = set.filter(function (comp) {
        return !!comp.match(compRe)
      })
    }
    set = set.map(function (comp) {
      return new Comparator(comp, this.options)
    }, this)

    return set
  }

  Range.prototype.intersects = function (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some(function (thisComparators) {
      return thisComparators.every(function (thisComparator) {
        return range.set.some(function (rangeComparators) {
          return rangeComparators.every(function (rangeComparator) {
            return thisComparator.intersects(rangeComparator, options)
          })
        })
      })
    })
  }

  // Mostly just for testing and legacy API reasons
  exports.toComparators = toComparators
  function toComparators (range, options) {
    return new Range(range, options).set.map(function (comp) {
      return comp.map(function (c) {
        return c.value
      }).join(' ').trim().split(' ')
    })
  }

  // comprised of xranges, tildes, stars, and gtlt's at this point.
  // already replaced the hyphen ranges
  // turn into a set of JUST comparators.
  function parseComparator (comp, options) {
    debug('comp', comp, options)
    comp = replaceCarets(comp, options)
    debug('caret', comp)
    comp = replaceTildes(comp, options)
    debug('tildes', comp)
    comp = replaceXRanges(comp, options)
    debug('xrange', comp)
    comp = replaceStars(comp, options)
    debug('stars', comp)
    return comp
  }

  function isX (id) {
    return !id || id.toLowerCase() === 'x' || id === '*'
  }

  // ~, ~> --> * (any, kinda silly)
  // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
  // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
  // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
  // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
  // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
  function replaceTildes (comp, options) {
    return comp.trim().split(/\s+/).map(function (comp) {
      return replaceTilde(comp, options)
    }).join(' ')
  }

  function replaceTilde (comp, options) {
    var r = options.loose ? re[TILDELOOSE] : re[TILDE]
    return comp.replace(r, function (_, M, m, p, pr) {
      debug('tilde', comp, _, M, m, p, pr)
      var ret

      if (isX(M)) {
        ret = ''
      } else if (isX(m)) {
        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
      } else if (isX(p)) {
        // ~1.2 == >=1.2.0 <1.3.0
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else if (pr) {
        debug('replaceTilde pr', pr)
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + M + '.' + (+m + 1) + '.0'
      } else {
        // ~1.2.3 == >=1.2.3 <1.3.0
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + M + '.' + (+m + 1) + '.0'
      }

      debug('tilde return', ret)
      return ret
    })
  }

  // ^ --> * (any, kinda silly)
  // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
  // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
  // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
  // ^1.2.3 --> >=1.2.3 <2.0.0
  // ^1.2.0 --> >=1.2.0 <2.0.0
  function replaceCarets (comp, options) {
    return comp.trim().split(/\s+/).map(function (comp) {
      return replaceCaret(comp, options)
    }).join(' ')
  }

  function replaceCaret (comp, options) {
    debug('caret', comp, options)
    var r = options.loose ? re[CARETLOOSE] : re[CARET]
    return comp.replace(r, function (_, M, m, p, pr) {
      debug('caret', comp, _, M, m, p, pr)
      var ret

      if (isX(M)) {
        ret = ''
      } else if (isX(m)) {
        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
      } else if (isX(p)) {
        if (M === '0') {
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
        } else {
          ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
        }
      } else if (pr) {
        debug('replaceCaret pr', pr)
        if (M === '0') {
          if (m === '0') {
            ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                  ' <' + M + '.' + m + '.' + (+p + 1)
          } else {
            ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                  ' <' + M + '.' + (+m + 1) + '.0'
          }
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + (+M + 1) + '.0.0'
        }
      } else {
        debug('no pr')
        if (M === '0') {
          if (m === '0') {
            ret = '>=' + M + '.' + m + '.' + p +
                  ' <' + M + '.' + m + '.' + (+p + 1)
          } else {
            ret = '>=' + M + '.' + m + '.' + p +
                  ' <' + M + '.' + (+m + 1) + '.0'
          }
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + (+M + 1) + '.0.0'
        }
      }

      debug('caret return', ret)
      return ret
    })
  }

  function replaceXRanges (comp, options) {
    debug('replaceXRanges', comp, options)
    return comp.split(/\s+/).map(function (comp) {
      return replaceXRange(comp, options)
    }).join(' ')
  }

  function replaceXRange (comp, options) {
    comp = comp.trim()
    var r = options.loose ? re[XRANGELOOSE] : re[XRANGE]
    return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
      debug('xRange', comp, ret, gtlt, M, m, p, pr)
      var xM = isX(M)
      var xm = xM || isX(m)
      var xp = xm || isX(p)
      var anyX = xp

      if (gtlt === '=' && anyX) {
        gtlt = ''
      }

      if (xM) {
        if (gtlt === '>' || gtlt === '<') {
          // nothing is allowed
          ret = '<0.0.0'
        } else {
          // nothing is forbidden
          ret = '*'
        }
      } else if (gtlt && anyX) {
        // we know patch is an x, because we have any x at all.
        // replace X with 0
        if (xm) {
          m = 0
        }
        p = 0

        if (gtlt === '>') {
          // >1 => >=2.0.0
          // >1.2 => >=1.3.0
          // >1.2.3 => >= 1.2.4
          gtlt = '>='
          if (xm) {
            M = +M + 1
            m = 0
            p = 0
          } else {
            m = +m + 1
            p = 0
          }
        } else if (gtlt === '<=') {
          // <=0.7.x is actually <0.8.0, since any 0.7.x should
          // pass.  Similarly, <=7.x is actually <8.0.0, etc.
          gtlt = '<'
          if (xm) {
            M = +M + 1
          } else {
            m = +m + 1
          }
        }

        ret = gtlt + M + '.' + m + '.' + p
      } else if (xm) {
        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
      } else if (xp) {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      }

      debug('xRange return', ret)

      return ret
    })
  }

  // Because * is AND-ed with everything else in the comparator,
  // and '' means "any version", just remove the *s entirely.
  function replaceStars (comp, options) {
    debug('replaceStars', comp, options)
    // Looseness is ignored here.  star is always as loose as it gets!
    return comp.trim().replace(re[STAR], '')
  }

  // This function is passed to string.replace(re[HYPHENRANGE])
  // M, m, patch, prerelease, build
  // 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
  // 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
  // 1.2 - 3.4 => >=1.2.0 <3.5.0
  function hyphenReplace ($0,
    from, fM, fm, fp, fpr, fb,
    to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = ''
    } else if (isX(fm)) {
      from = '>=' + fM + '.0.0'
    } else if (isX(fp)) {
      from = '>=' + fM + '.' + fm + '.0'
    } else {
      from = '>=' + from
    }

    if (isX(tM)) {
      to = ''
    } else if (isX(tm)) {
      to = '<' + (+tM + 1) + '.0.0'
    } else if (isX(tp)) {
      to = '<' + tM + '.' + (+tm + 1) + '.0'
    } else if (tpr) {
      to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
    } else {
      to = '<=' + to
    }

    return (from + ' ' + to).trim()
  }

  // if ANY of the sets match ALL of its comparators, then pass
  Range.prototype.test = function (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      version = new SemVer(version, this.options)
    }

    for (var i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }

  function testSet (set, version, options) {
    for (var i = 0; i < set.length; i++) {
      if (!set[i].test(version)) {
        return false
      }
    }

    if (version.prerelease.length && !options.includePrerelease) {
      // Find the set of versions that are allowed to have prereleases
      // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
      // That should allow `1.2.3-pr.2` to pass.
      // However, `1.2.4-alpha.notready` should NOT be allowed,
      // even though it's within the range set by the comparators.
      for (i = 0; i < set.length; i++) {
        debug(set[i].semver)
        if (set[i].semver === ANY) {
          continue
        }

        if (set[i].semver.prerelease.length > 0) {
          var allowed = set[i].semver
          if (allowed.major === version.major &&
              allowed.minor === version.minor &&
              allowed.patch === version.patch) {
            return true
          }
        }
      }

      // Version has a -pre, but it's not one of the ones we like.
      return false
    }

    return true
  }

  exports.satisfies = satisfies
  function satisfies (version, range, options) {
    try {
      range = new Range(range, options)
    } catch (er) {
      return false
    }
    return range.test(version)
  }

  exports.maxSatisfying = maxSatisfying
  function maxSatisfying (versions, range, options) {
    var max = null
    var maxSV = null
    try {
      var rangeObj = new Range(range, options)
    } catch (er) {
      return null
    }
    versions.forEach(function (v) {
      if (rangeObj.test(v)) {
        // satisfies(v, range, options)
        if (!max || maxSV.compare(v) === -1) {
          // compare(max, v, true)
          max = v
          maxSV = new SemVer(max, options)
        }
      }
    })
    return max
  }

  exports.minSatisfying = minSatisfying
  function minSatisfying (versions, range, options) {
    var min = null
    var minSV = null
    try {
      var rangeObj = new Range(range, options)
    } catch (er) {
      return null
    }
    versions.forEach(function (v) {
      if (rangeObj.test(v)) {
        // satisfies(v, range, options)
        if (!min || minSV.compare(v) === 1) {
          // compare(min, v, true)
          min = v
          minSV = new SemVer(min, options)
        }
      }
    })
    return min
  }

  exports.minVersion = minVersion
  function minVersion (range, loose) {
    range = new Range(range, loose)

    var minver = new SemVer('0.0.0')
    if (range.test(minver)) {
      return minver
    }

    minver = new SemVer('0.0.0-0')
    if (range.test(minver)) {
      return minver
    }

    minver = null
    for (var i = 0; i < range.set.length; ++i) {
      var comparators = range.set[i]

      comparators.forEach(function (comparator) {
        // Clone to avoid manipulating the comparator's semver object.
        var compver = new SemVer(comparator.semver.version)
        switch (comparator.operator) {
          case '>':
            if (compver.prerelease.length === 0) {
              compver.patch++
            } else {
              compver.prerelease.push(0)
            }
            compver.raw = compver.format()
            /* fallthrough */
          case '':
          case '>=':
            if (!minver || gt(minver, compver)) {
              minver = compver
            }
            break
          case '<':
          case '<=':
            /* Ignore maximum versions */
            break
          /* istanbul ignore next */
          default:
            throw new Error('Unexpected operation: ' + comparator.operator)
        }
      })
    }

    if (minver && range.test(minver)) {
      return minver
    }

    return null
  }

  exports.validRange = validRange
  function validRange (range, options) {
    try {
      // Return '*' instead of '' so that truthiness works.
      // This will throw if it's invalid anyway
      return new Range(range, options).range || '*'
    } catch (er) {
      return null
    }
  }

  // Determine if version is less than all the versions possible in the range
  exports.ltr = ltr
  function ltr (version, range, options) {
    return outside(version, range, '<', options)
  }

  // Determine if version is greater than all the versions possible in the range.
  exports.gtr = gtr
  function gtr (version, range, options) {
    return outside(version, range, '>', options)
  }

  exports.outside = outside
  function outside (version, range, hilo, options) {
    version = new SemVer(version, options)
    range = new Range(range, options)

    var gtfn, ltefn, ltfn, comp, ecomp
    switch (hilo) {
      case '>':
        gtfn = gt
        ltefn = lte
        ltfn = lt
        comp = '>'
        ecomp = '>='
        break
      case '<':
        gtfn = lt
        ltefn = gte
        ltfn = gt
        comp = '<'
        ecomp = '<='
        break
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"')
    }

    // If it satisifes the range it is not outside
    if (satisfies(version, range, options)) {
      return false
    }

    // From now on, variable terms are as if we're in "gtr" mode.
    // but note that everything is flipped for the "ltr" function.

    for (var i = 0; i < range.set.length; ++i) {
      var comparators = range.set[i]

      var high = null
      var low = null

      comparators.forEach(function (comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator('>=0.0.0')
        }
        high = high || comparator
        low = low || comparator
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator
        }
      })

      // If the edge version comparator has a operator then our version
      // isn't outside it
      if (high.operator === comp || high.operator === ecomp) {
        return false
      }

      // If the lowest version comparator has an operator and our version
      // is less than it then it isn't higher than the range
      if ((!low.operator || low.operator === comp) &&
          ltefn(version, low.semver)) {
        return false
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false
      }
    }
    return true
  }

  exports.prerelease = prerelease
  function prerelease (version, options) {
    var parsed = parse(version, options)
    return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
  }

  exports.intersects = intersects
  function intersects (r1, r2, options) {
    r1 = new Range(r1, options)
    r2 = new Range(r2, options)
    return r1.intersects(r2)
  }

  exports.coerce = coerce
  function coerce (version) {
    if (version instanceof SemVer) {
      return version
    }

    if (typeof version !== 'string') {
      return null
    }

    var match = version.match(re[COERCE])

    if (match == null) {
      return null
    }

    return parse(match[1] +
      '.' + (match[2] || '0') +
      '.' + (match[3] || '0'))
  }


  /***/ }),
  /* 42 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const isWin = process.platform === 'win32';

  function notFoundError(original, syscall) {
      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
          code: 'ENOENT',
          errno: 'ENOENT',
          syscall: `${syscall} ${original.command}`,
          path: original.command,
          spawnargs: original.args,
      });
  }

  function hookChildProcess(cp, parsed) {
      if (!isWin) {
          return;
      }

      const originalEmit = cp.emit;

      cp.emit = function (name, arg1) {
          // If emitting "exit" event and exit code is 1, we need to check if
          // the command exists and emit an "error" instead
          // See https://github.com/IndigoUnited/node-cross-spawn/issues/16
          if (name === 'exit') {
              const err = verifyENOENT(arg1, parsed, 'spawn');

              if (err) {
                  return originalEmit.call(cp, 'error', err);
              }
          }

          return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params
      };
  }

  function verifyENOENT(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
          return notFoundError(parsed.original, 'spawn');
      }

      return null;
  }

  function verifyENOENTSync(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
          return notFoundError(parsed.original, 'spawnSync');
      }

      return null;
  }

  module.exports = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError,
  };


  /***/ }),
  /* 43 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const fslib_1 = __webpack_require__(5);
  const os_1 = __webpack_require__(44);
  function getDefaultGlobalFolder() {
      if (process.platform === `win32`) {
          const base = fslib_1.NodeFS.toPortablePath(process.env.LOCALAPPDATA || fslib_1.npath.join(os_1.homedir(), 'AppData', 'Local'));
          return fslib_1.ppath.resolve(base, `Yarn/Berry`);
      }
      if (process.env.XDG_DATA_HOME) {
          const base = fslib_1.NodeFS.toPortablePath(process.env.XDG_DATA_HOME);
          return fslib_1.ppath.resolve(base, `yarn/berry`);
      }
      return fslib_1.ppath.resolve(getHomeFolder(), `.yarn/berry`);
  }
  exports.getDefaultGlobalFolder = getDefaultGlobalFolder;
  function getHomeFolder() {
      return fslib_1.NodeFS.toPortablePath(os_1.homedir() || '/usr/local/share');
  }
  exports.getHomeFolder = getHomeFolder;
  function isFolderInside(target, parent) {
      const relative = fslib_1.ppath.relative(parent, target);
      return relative && !relative.startsWith('..') && !fslib_1.ppath.isAbsolute(relative);
  }
  exports.isFolderInside = isFolderInside;


  /***/ }),
  /* 44 */
  /***/ (function(module, exports) {

  module.exports = require("os");

  /***/ }),
  /* 45 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __rest = (this && this.__rest) || function (s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                  t[p[i]] = s[p[i]];
          }
      return t;
  };
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      result["default"] = mod;
      return result;
  };
  var __importDefault = (this && this.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const agentkeepalive_1 = __importStar(__webpack_require__(46));
  const got_1 = __importDefault(__webpack_require__(57));
  const micromatch_1 = __importDefault(__webpack_require__(107));
  const tunnel_1 = __importDefault(__webpack_require__(124));
  const url_1 = __webpack_require__(61);
  const cache = new Map();
  const globalHttpAgent = new agentkeepalive_1.default();
  const globalHttpsAgent = new agentkeepalive_1.HttpsAgent();
  function parseProxy(specifier) {
      const url = new url_1.URL(specifier);
      const proxy = { host: url.hostname, headers: {} };
      if (url.port)
          proxy.port = Number(url.port);
      return { proxy };
  }
  var Method;
  (function (Method) {
      Method["GET"] = "GET";
      Method["PUT"] = "PUT";
  })(Method = exports.Method || (exports.Method = {}));
  ;
  async function request(target, body, { configuration, headers, json, method = Method.GET }) {
      if (!configuration.get(`enableNetwork`))
          throw new Error(`Network access have been disabled by configuration (${method} ${target})`);
      const url = new url_1.URL(target);
      if (url.protocol === `http:` && !micromatch_1.default.isMatch(url.hostname, configuration.get(`unsafeHttpWhitelist`)))
          throw new Error(`Unsafe http requests must be explicitly whitelisted in your configuration (${url.hostname})`);
      let agent;
      const httpProxy = configuration.get(`httpProxy`);
      const httpsProxy = configuration.get(`httpsProxy`);
      if (url.protocol === `http:`)
          agent = httpProxy
              ? tunnel_1.default.httpOverHttp(parseProxy(httpProxy))
              : globalHttpAgent;
      if (url.protocol === `https:`)
          agent = httpsProxy
              ? tunnel_1.default.httpsOverHttp(parseProxy(httpsProxy))
              : globalHttpsAgent;
      const gotOptions = { agent, body, headers, json, method, encoding: null };
      let hostname;
      const makeHooks = () => ({
          beforeRequest: [
              (options) => {
                  hostname = options.hostname;
              },
          ],
          beforeRedirect: [
              (options) => {
                  if (options.headers && options.headers.authorization && options.hostname !== hostname) {
                      delete options.headers.authorization;
                  }
              },
          ],
      });
      //@ts-ignore
      const gotClient = got_1.default.extend(Object.assign({}, gotOptions, { hooks: makeHooks() }));
      const res = await gotClient(target);
      return await res.body;
  }
  async function get(target, _a) {
      var { configuration, json } = _a, rest = __rest(_a, ["configuration", "json"]);
      let entry = cache.get(target);
      if (!entry) {
          entry = request(target, null, Object.assign({ configuration }, rest));
          cache.set(target, entry);
      }
      if (json) {
          return await entry.then(buffer => JSON.parse(buffer.toString()));
      }
      else {
          return await entry;
      }
  }
  exports.get = get;
  async function put(target, body, options) {
      return await request(target, body, Object.assign({}, options, { method: Method.PUT }));
  }
  exports.put = put;


  /***/ }),
  /* 46 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  module.exports = __webpack_require__(47);
  module.exports.HttpsAgent = __webpack_require__(55);
  module.exports.constants = __webpack_require__(54);


  /***/ }),
  /* 47 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const OriginalAgent = __webpack_require__(48).Agent;
  const ms = __webpack_require__(49);
  const debug = __webpack_require__(51)('agentkeepalive');
  const deprecate = __webpack_require__(53)('agentkeepalive');
  const {
    INIT_SOCKET,
    CURRENT_ID,
    CREATE_ID,
    SOCKET_CREATED_TIME,
    SOCKET_NAME,
    SOCKET_REQUEST_COUNT,
    SOCKET_REQUEST_FINISHED_COUNT,
  } = __webpack_require__(54);

  // OriginalAgent come from
  // - https://github.com/nodejs/node/blob/v8.12.0/lib/_http_agent.js
  // - https://github.com/nodejs/node/blob/v10.12.0/lib/_http_agent.js

  class Agent extends OriginalAgent {
    constructor(options) {
      options = options || {};
      options.keepAlive = options.keepAlive !== false;
      // default is keep-alive and 15s free socket timeout
      if (options.freeSocketTimeout === undefined) {
        options.freeSocketTimeout = 15000;
      }
      // Legacy API: keepAliveTimeout should be rename to `freeSocketTimeout`
      if (options.keepAliveTimeout) {
        deprecate('options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead');
        options.freeSocketTimeout = options.keepAliveTimeout;
        delete options.keepAliveTimeout;
      }
      // Legacy API: freeSocketKeepAliveTimeout should be rename to `freeSocketTimeout`
      if (options.freeSocketKeepAliveTimeout) {
        deprecate('options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead');
        options.freeSocketTimeout = options.freeSocketKeepAliveTimeout;
        delete options.freeSocketKeepAliveTimeout;
      }

      // Sets the socket to timeout after timeout milliseconds of inactivity on the socket.
      // By default is double free socket timeout.
      if (options.timeout === undefined) {
        // make sure socket default inactivity timeout >= 30s
        options.timeout = Math.max(options.freeSocketTimeout * 2, 30000);
      }

      // support humanize format
      options.timeout = ms(options.timeout);
      options.freeSocketTimeout = ms(options.freeSocketTimeout);
      options.socketActiveTTL = options.socketActiveTTL ? ms(options.socketActiveTTL) : 0;

      super(options);

      this[CURRENT_ID] = 0;

      // create socket success counter
      this.createSocketCount = 0;
      this.createSocketCountLastCheck = 0;

      this.createSocketErrorCount = 0;
      this.createSocketErrorCountLastCheck = 0;

      this.closeSocketCount = 0;
      this.closeSocketCountLastCheck = 0;

      // socket error event count
      this.errorSocketCount = 0;
      this.errorSocketCountLastCheck = 0;

      // request finished counter
      this.requestCount = 0;
      this.requestCountLastCheck = 0;

      // including free socket timeout counter
      this.timeoutSocketCount = 0;
      this.timeoutSocketCountLastCheck = 0;
    }

    get freeSocketKeepAliveTimeout() {
      deprecate('agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead');
      return this.options.freeSocketTimeout;
    }

    get timeout() {
      deprecate('agent.timeout is deprecated, please use agent.options.timeout instead');
      return this.options.timeout;
    }

    get socketActiveTTL() {
      deprecate('agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead');
      return this.options.socketActiveTTL;
    }

    keepSocketAlive(socket) {
      const result = super.keepSocketAlive(socket);
      // should not keepAlive, do nothing
      if (!result) return result;

      let freeSocketTimeout = this.options.freeSocketTimeout;
      const socketActiveTTL = this.options.socketActiveTTL;
      if (socketActiveTTL) {
        // check socketActiveTTL
        const aliveTime = Date.now() - socket[SOCKET_CREATED_TIME];
        const diff = socketActiveTTL - aliveTime;
        // destroy it
        if (diff <= 0) {
          debug('%s(requests: %s, finished: %s) free but need to destroy by TTL, alive %sms(max %sms)',
            socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT],
            aliveTime, socketActiveTTL);
          return false;
        }

        if (freeSocketTimeout && diff < freeSocketTimeout) {
          debug('%s(requests: %s, finished: %s) free and wait for %sms TTL timeout',
            socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT],
            diff);
          freeSocketTimeout = diff;
        }
      }
      // set freeSocketTimeout
      if (freeSocketTimeout) {
        // set free keepalive timer
        // try to use socket custom freeSocketTimeout first, support headers['keep-alive']
        // https://github.com/node-modules/urllib/blob/b76053020923f4d99a1c93cf2e16e0c5ba10bacf/lib/urllib.js#L498
        const customFreeSocketTimeout = socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout;
        if (customFreeSocketTimeout && customFreeSocketTimeout < freeSocketTimeout) {
          freeSocketTimeout = customFreeSocketTimeout;
        }
        // FIXME: need to make setRequestSocket as a method on Agent class
        // then we can reset the agent.options.timeout when free socket is reused.
        socket.setTimeout(freeSocketTimeout);
      }
      return true;
    }

    // only call on addRequest
    reuseSocket(...args) {
      // reuseSocket(socket, req)
      super.reuseSocket(...args);
      const socket = args[0];
      const agentTimeout = this.options.timeout;
      if (getSocketTimeout(socket) !== agentTimeout) {
        // reset timeout before use
        socket.setTimeout(agentTimeout);
        debug('%s reset timeout to %sms', socket[SOCKET_NAME], agentTimeout);
      }
      socket[SOCKET_REQUEST_COUNT]++;
      debug('%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms',
        socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT],
        getSocketTimeout(socket));
    }

    [CREATE_ID]() {
      const id = this[CURRENT_ID]++;
      if (this[CURRENT_ID] === Number.MAX_SAFE_INTEGER) this[CURRENT_ID] = 0;
      return id;
    }

    [INIT_SOCKET](socket, options) {
      // bugfix here.
      // https on node 8, 10 won't set agent.options.timeout by default
      // TODO: need to fix on node itself
      if (options.timeout) {
        const timeout = getSocketTimeout(socket);
        if (!timeout) {
          socket.setTimeout(options.timeout);
        }
      }

      if (this.options.keepAlive) {
        // Disable Nagle's algorithm: http://blog.caustik.com/2012/04/08/scaling-node-js-to-100k-concurrent-connections/
        // https://fengmk2.com/benchmark/nagle-algorithm-delayed-ack-mock.html
        socket.setNoDelay(true);
      }
      this.createSocketCount++;
      if (this.options.socketActiveTTL) {
        socket[SOCKET_CREATED_TIME] = Date.now();
      }
      // don't show the hole '-----BEGIN CERTIFICATE----' key string
      socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${options._agentKey}]`.split('-----BEGIN', 1)[0];
      socket[SOCKET_REQUEST_COUNT] = 1;
      socket[SOCKET_REQUEST_FINISHED_COUNT] = 0;
      installListeners(this, socket, options);
    }

    createConnection(options, oncreate) {
      let called = false;
      const onNewCreate = (err, socket) => {
        if (called) return;
        called = true;

        if (err) {
          this.createSocketErrorCount++;
          return oncreate(err);
        }
        this[INIT_SOCKET](socket, options);
        oncreate(err, socket);
      };

      const newSocket = super.createConnection(options, onNewCreate);
      if (newSocket) onNewCreate(null, newSocket);
    }

    get statusChanged() {
      const changed = this.createSocketCount !== this.createSocketCountLastCheck ||
        this.createSocketErrorCount !== this.createSocketErrorCountLastCheck ||
        this.closeSocketCount !== this.closeSocketCountLastCheck ||
        this.errorSocketCount !== this.errorSocketCountLastCheck ||
        this.timeoutSocketCount !== this.timeoutSocketCountLastCheck ||
        this.requestCount !== this.requestCountLastCheck;
      if (changed) {
        this.createSocketCountLastCheck = this.createSocketCount;
        this.createSocketErrorCountLastCheck = this.createSocketErrorCount;
        this.closeSocketCountLastCheck = this.closeSocketCount;
        this.errorSocketCountLastCheck = this.errorSocketCount;
        this.timeoutSocketCountLastCheck = this.timeoutSocketCount;
        this.requestCountLastCheck = this.requestCount;
      }
      return changed;
    }

    getCurrentStatus() {
      return {
        createSocketCount: this.createSocketCount,
        createSocketErrorCount: this.createSocketErrorCount,
        closeSocketCount: this.closeSocketCount,
        errorSocketCount: this.errorSocketCount,
        timeoutSocketCount: this.timeoutSocketCount,
        requestCount: this.requestCount,
        freeSockets: inspect(this.freeSockets),
        sockets: inspect(this.sockets),
        requests: inspect(this.requests),
      };
    }
  }

  // node 8 don't has timeout attribute on socket
  // https://github.com/nodejs/node/pull/21204/files#diff-e6ef024c3775d787c38487a6309e491dR408
  function getSocketTimeout(socket) {
    return socket.timeout || socket._idleTimeout;
  }

  function installListeners(agent, socket, options) {
    debug('%s create, timeout %sms', socket[SOCKET_NAME], getSocketTimeout(socket));

    // listener socket events: close, timeout, error, free
    function onFree() {
      // create and socket.emit('free') logic
      // https://github.com/nodejs/node/blob/master/lib/_http_agent.js#L311
      // no req on the socket, it should be the new socket
      if (!socket._httpMessage && socket[SOCKET_REQUEST_COUNT] === 1) return;

      socket[SOCKET_REQUEST_FINISHED_COUNT]++;
      agent.requestCount++;
      debug('%s(requests: %s, finished: %s) free',
        socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);

      // should reuse on pedding requests?
      const name = agent.getName(options);
      if (socket.writable && agent.requests[name] && agent.requests[name].length) {
        // will be reuse on agent free listener
        socket[SOCKET_REQUEST_COUNT]++;
        debug('%s(requests: %s, finished: %s) will be reuse on agent free event',
          socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);
      }
    }
    socket.on('free', onFree);

    function onClose(isError) {
      debug('%s(requests: %s, finished: %s) close, isError: %s',
        socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], isError);
      agent.closeSocketCount++;
    }
    socket.on('close', onClose);

    // start socket timeout handler
    function onTimeout() {
      const listenerCount = socket.listeners('timeout').length;
      debug('%s(requests: %s, finished: %s) timeout after %sms, listeners %s',
        socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT],
        getSocketTimeout(socket), listenerCount);
      agent.timeoutSocketCount++;
      const name = agent.getName(options);
      if (agent.freeSockets[name] && agent.freeSockets[name].indexOf(socket) !== -1) {
        // free socket timeout, destroy quietly
        socket.destroy();
        // Remove it from freeSockets list immediately to prevent new requests
        // from being sent through this socket.
        agent.removeSocket(socket, options);
        debug('%s is free, destroy quietly', socket[SOCKET_NAME]);
      } else {
        // if there is no any request socket timeout handler,
        // agent need to handle socket timeout itself.
        //
        // custom request socket timeout handle logic must follow these rules:
        //  1. Destroy socket first
        //  2. Must emit socket 'agentRemove' event tell agent remove socket
        //     from freeSockets list immediately.
        //     Otherise you may be get 'socket hang up' error when reuse
        //     free socket and timeout happen in the same time.
        if (listenerCount === 1) {
          const error = new Error('Socket timeout');
          error.code = 'ERR_SOCKET_TIMEOUT';
          error.timeout = getSocketTimeout(socket);
          // must manually call socket.end() or socket.destroy() to end the connection.
          // https://nodejs.org/dist/latest-v10.x/docs/api/net.html#net_socket_settimeout_timeout_callback
          socket.destroy(error);
          agent.removeSocket(socket, options);
          debug('%s destroy with timeout error', socket[SOCKET_NAME]);
        }
      }
    }
    socket.on('timeout', onTimeout);

    function onError(err) {
      const listenerCount = socket.listeners('error').length;
      debug('%s(requests: %s, finished: %s) error: %s, listenerCount: %s',
        socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT],
        err, listenerCount);
      agent.errorSocketCount++;
      if (listenerCount === 1) {
        // if socket don't contain error event handler, don't catch it, emit it again
        debug('%s emit uncaught error event', socket[SOCKET_NAME]);
        socket.removeListener('error', onError);
        socket.emit('error', err);
      }
    }
    socket.on('error', onError);

    function onRemove() {
      debug('%s(requests: %s, finished: %s) agentRemove',
        socket[SOCKET_NAME],
        socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);
      // We need this function for cases like HTTP 'upgrade'
      // (defined by WebSockets) where we need to remove a socket from the
      // pool because it'll be locked up indefinitely
      socket.removeListener('close', onClose);
      socket.removeListener('error', onError);
      socket.removeListener('free', onFree);
      socket.removeListener('timeout', onTimeout);
      socket.removeListener('agentRemove', onRemove);
    }
    socket.on('agentRemove', onRemove);
  }

  module.exports = Agent;

  function inspect(obj) {
    const res = {};
    for (const key in obj) {
      res[key] = obj[key].length;
    }
    return res;
  }


  /***/ }),
  /* 48 */
  /***/ (function(module, exports) {

  module.exports = require("http");

  /***/ }),
  /* 49 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * humanize-ms - index.js
   * Copyright(c) 2014 dead_horse <dead_horse@qq.com>
   * MIT Licensed
   */



  /**
   * Module dependencies.
   */

  var util = __webpack_require__(25);
  var ms = __webpack_require__(50);

  module.exports = function (t) {
    if (typeof t === 'number') return t;
    var r = ms(t);
    if (r === undefined) {
      var err = new Error(util.format('humanize-ms(%j) result undefined', t));
      console.warn(err.stack);
    }
    return r;
  };


  /***/ }),
  /* 50 */
  /***/ (function(module, exports) {

  /**
   * Helpers.
   */

  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;

  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} [options]
   * @throws {Error} throw an error if val is not a non-empty string or a number
   * @return {String|Number}
   * @api public
   */

  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
      return parse(val);
    } else if (type === 'number' && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      'val is not a non-empty string or a valid number. val=' +
        JSON.stringify(val)
    );
  };

  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */

  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'weeks':
      case 'week':
      case 'w':
        return n * w;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
      default:
        return undefined;
    }
  }

  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
  }

  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
  }

  /**
   * Pluralization helper.
   */

  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
  }


  /***/ }),
  /* 51 */
  /***/ (function(module, exports, __webpack_require__) {

  /* eslint-env browser */

  /**
   * This is the web browser implementation of `debug()`.
   */

  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();

  /**
   * Colors.
   */

  exports.colors = [
  	'#0000CC',
  	'#0000FF',
  	'#0033CC',
  	'#0033FF',
  	'#0066CC',
  	'#0066FF',
  	'#0099CC',
  	'#0099FF',
  	'#00CC00',
  	'#00CC33',
  	'#00CC66',
  	'#00CC99',
  	'#00CCCC',
  	'#00CCFF',
  	'#3300CC',
  	'#3300FF',
  	'#3333CC',
  	'#3333FF',
  	'#3366CC',
  	'#3366FF',
  	'#3399CC',
  	'#3399FF',
  	'#33CC00',
  	'#33CC33',
  	'#33CC66',
  	'#33CC99',
  	'#33CCCC',
  	'#33CCFF',
  	'#6600CC',
  	'#6600FF',
  	'#6633CC',
  	'#6633FF',
  	'#66CC00',
  	'#66CC33',
  	'#9900CC',
  	'#9900FF',
  	'#9933CC',
  	'#9933FF',
  	'#99CC00',
  	'#99CC33',
  	'#CC0000',
  	'#CC0033',
  	'#CC0066',
  	'#CC0099',
  	'#CC00CC',
  	'#CC00FF',
  	'#CC3300',
  	'#CC3333',
  	'#CC3366',
  	'#CC3399',
  	'#CC33CC',
  	'#CC33FF',
  	'#CC6600',
  	'#CC6633',
  	'#CC9900',
  	'#CC9933',
  	'#CCCC00',
  	'#CCCC33',
  	'#FF0000',
  	'#FF0033',
  	'#FF0066',
  	'#FF0099',
  	'#FF00CC',
  	'#FF00FF',
  	'#FF3300',
  	'#FF3333',
  	'#FF3366',
  	'#FF3399',
  	'#FF33CC',
  	'#FF33FF',
  	'#FF6600',
  	'#FF6633',
  	'#FF9900',
  	'#FF9933',
  	'#FFCC00',
  	'#FFCC33'
  ];

  /**
   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
   * and the Firebug extension (any Firefox version) are known
   * to support "%c" CSS customizations.
   *
   * TODO: add a `localStorage` variable to explicitly enable/disable colors
   */

  // eslint-disable-next-line complexity
  function useColors() {
  	// NB: In an Electron preload script, document will be defined but not fully
  	// initialized. Since we know we're in Chrome, we'll just detect this case
  	// explicitly
  	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
  		return true;
  	}

  	// Internet Explorer and Edge do not support colors.
  	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
  		return false;
  	}

  	// Is webkit? http://stackoverflow.com/a/16459606/376773
  	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
  		// Is firebug? http://stackoverflow.com/a/398120/376773
  		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
  		// Is firefox >= v31?
  		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
  		// Double check webkit in userAgent just in case we are in a worker
  		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
  }

  /**
   * Colorize log arguments if enabled.
   *
   * @api public
   */

  function formatArgs(args) {
  	args[0] = (this.useColors ? '%c' : '') +
  		this.namespace +
  		(this.useColors ? ' %c' : ' ') +
  		args[0] +
  		(this.useColors ? '%c ' : ' ') +
  		'+' + module.exports.humanize(this.diff);

  	if (!this.useColors) {
  		return;
  	}

  	const c = 'color: ' + this.color;
  	args.splice(1, 0, c, 'color: inherit');

  	// The final "%c" is somewhat tricky, because there could be other
  	// arguments passed either before or after the %c, so we need to
  	// figure out the correct index to insert the CSS into
  	let index = 0;
  	let lastC = 0;
  	args[0].replace(/%[a-zA-Z%]/g, match => {
  		if (match === '%%') {
  			return;
  		}
  		index++;
  		if (match === '%c') {
  			// We only are interested in the *last* %c
  			// (the user may have provided their own)
  			lastC = index;
  		}
  	});

  	args.splice(lastC, 0, c);
  }

  /**
   * Invokes `console.log()` when available.
   * No-op when `console.log` is not a "function".
   *
   * @api public
   */
  function log(...args) {
  	// This hackery is required for IE8/9, where
  	// the `console.log` function doesn't have 'apply'
  	return typeof console === 'object' &&
  		console.log &&
  		console.log(...args);
  }

  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */
  function save(namespaces) {
  	try {
  		if (namespaces) {
  			exports.storage.setItem('debug', namespaces);
  		} else {
  			exports.storage.removeItem('debug');
  		}
  	} catch (error) {
  		// Swallow
  		// XXX (@Qix-) should we be logging these?
  	}
  }

  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */
  function load() {
  	let r;
  	try {
  		r = exports.storage.getItem('debug');
  	} catch (error) {
  		// Swallow
  		// XXX (@Qix-) should we be logging these?
  	}

  	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  	if (!r && typeof process !== 'undefined' && 'env' in process) {
  		r = process.env.DEBUG;
  	}

  	return r;
  }

  /**
   * Localstorage attempts to return the localstorage.
   *
   * This is necessary because safari throws
   * when a user disables cookies/localstorage
   * and you attempt to access it.
   *
   * @return {LocalStorage}
   * @api private
   */

  function localstorage() {
  	try {
  		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
  		// The Browser also has localStorage in the global context.
  		return localStorage;
  	} catch (error) {
  		// Swallow
  		// XXX (@Qix-) should we be logging these?
  	}
  }

  module.exports = __webpack_require__(52)(exports);

  const {formatters} = module.exports;

  /**
   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
   */

  formatters.j = function (v) {
  	try {
  		return JSON.stringify(v);
  	} catch (error) {
  		return '[UnexpectedJSONParseError]: ' + error.message;
  	}
  };


  /***/ }),
  /* 52 */
  /***/ (function(module, exports, __webpack_require__) {


  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   */

  function setup(env) {
  	createDebug.debug = createDebug;
  	createDebug.default = createDebug;
  	createDebug.coerce = coerce;
  	createDebug.disable = disable;
  	createDebug.enable = enable;
  	createDebug.enabled = enabled;
  	createDebug.humanize = __webpack_require__(50);

  	Object.keys(env).forEach(key => {
  		createDebug[key] = env[key];
  	});

  	/**
  	* Active `debug` instances.
  	*/
  	createDebug.instances = [];

  	/**
  	* The currently active debug mode names, and names to skip.
  	*/

  	createDebug.names = [];
  	createDebug.skips = [];

  	/**
  	* Map of special "%n" handling functions, for the debug "format" argument.
  	*
  	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  	*/
  	createDebug.formatters = {};

  	/**
  	* Selects a color for a debug namespace
  	* @param {String} namespace The namespace string for the for the debug instance to be colored
  	* @return {Number|String} An ANSI color code for the given namespace
  	* @api private
  	*/
  	function selectColor(namespace) {
  		let hash = 0;

  		for (let i = 0; i < namespace.length; i++) {
  			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
  			hash |= 0; // Convert to 32bit integer
  		}

  		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  	}
  	createDebug.selectColor = selectColor;

  	/**
  	* Create a debugger with the given `namespace`.
  	*
  	* @param {String} namespace
  	* @return {Function}
  	* @api public
  	*/
  	function createDebug(namespace) {
  		let prevTime;

  		function debug(...args) {
  			// Disabled?
  			if (!debug.enabled) {
  				return;
  			}

  			const self = debug;

  			// Set `diff` timestamp
  			const curr = Number(new Date());
  			const ms = curr - (prevTime || curr);
  			self.diff = ms;
  			self.prev = prevTime;
  			self.curr = curr;
  			prevTime = curr;

  			args[0] = createDebug.coerce(args[0]);

  			if (typeof args[0] !== 'string') {
  				// Anything else let's inspect with %O
  				args.unshift('%O');
  			}

  			// Apply any `formatters` transformations
  			let index = 0;
  			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
  				// If we encounter an escaped % then don't increase the array index
  				if (match === '%%') {
  					return match;
  				}
  				index++;
  				const formatter = createDebug.formatters[format];
  				if (typeof formatter === 'function') {
  					const val = args[index];
  					match = formatter.call(self, val);

  					// Now we need to remove `args[index]` since it's inlined in the `format`
  					args.splice(index, 1);
  					index--;
  				}
  				return match;
  			});

  			// Apply env-specific formatting (colors, etc.)
  			createDebug.formatArgs.call(self, args);

  			const logFn = self.log || createDebug.log;
  			logFn.apply(self, args);
  		}

  		debug.namespace = namespace;
  		debug.enabled = createDebug.enabled(namespace);
  		debug.useColors = createDebug.useColors();
  		debug.color = selectColor(namespace);
  		debug.destroy = destroy;
  		debug.extend = extend;
  		// Debug.formatArgs = formatArgs;
  		// debug.rawLog = rawLog;

  		// env-specific initialization logic for debug instances
  		if (typeof createDebug.init === 'function') {
  			createDebug.init(debug);
  		}

  		createDebug.instances.push(debug);

  		return debug;
  	}

  	function destroy() {
  		const index = createDebug.instances.indexOf(this);
  		if (index !== -1) {
  			createDebug.instances.splice(index, 1);
  			return true;
  		}
  		return false;
  	}

  	function extend(namespace, delimiter) {
  		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  		newDebug.log = this.log;
  		return newDebug;
  	}

  	/**
  	* Enables a debug mode by namespaces. This can include modes
  	* separated by a colon and wildcards.
  	*
  	* @param {String} namespaces
  	* @api public
  	*/
  	function enable(namespaces) {
  		createDebug.save(namespaces);

  		createDebug.names = [];
  		createDebug.skips = [];

  		let i;
  		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  		const len = split.length;

  		for (i = 0; i < len; i++) {
  			if (!split[i]) {
  				// ignore empty strings
  				continue;
  			}

  			namespaces = split[i].replace(/\*/g, '.*?');

  			if (namespaces[0] === '-') {
  				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
  			} else {
  				createDebug.names.push(new RegExp('^' + namespaces + '$'));
  			}
  		}

  		for (i = 0; i < createDebug.instances.length; i++) {
  			const instance = createDebug.instances[i];
  			instance.enabled = createDebug.enabled(instance.namespace);
  		}
  	}

  	/**
  	* Disable debug output.
  	*
  	* @return {String} namespaces
  	* @api public
  	*/
  	function disable() {
  		const namespaces = [
  			...createDebug.names.map(toNamespace),
  			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
  		].join(',');
  		createDebug.enable('');
  		return namespaces;
  	}

  	/**
  	* Returns true if the given mode name is enabled, false otherwise.
  	*
  	* @param {String} name
  	* @return {Boolean}
  	* @api public
  	*/
  	function enabled(name) {
  		if (name[name.length - 1] === '*') {
  			return true;
  		}

  		let i;
  		let len;

  		for (i = 0, len = createDebug.skips.length; i < len; i++) {
  			if (createDebug.skips[i].test(name)) {
  				return false;
  			}
  		}

  		for (i = 0, len = createDebug.names.length; i < len; i++) {
  			if (createDebug.names[i].test(name)) {
  				return true;
  			}
  		}

  		return false;
  	}

  	/**
  	* Convert regexp to namespace
  	*
  	* @param {RegExp} regxep
  	* @return {String} namespace
  	* @api private
  	*/
  	function toNamespace(regexp) {
  		return regexp.toString()
  			.substring(2, regexp.toString().length - 2)
  			.replace(/\.\*\?$/, '*');
  	}

  	/**
  	* Coerce `val`.
  	*
  	* @param {Mixed} val
  	* @return {Mixed}
  	* @api private
  	*/
  	function coerce(val) {
  		if (val instanceof Error) {
  			return val.stack || val.message;
  		}
  		return val;
  	}

  	createDebug.enable(createDebug.load());

  	return createDebug;
  }

  module.exports = setup;


  /***/ }),
  /* 53 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * depd
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */



  /**
   * Module exports.
   * @public
   */

  module.exports = depd

  /**
   * Create deprecate for namespace in caller.
   */

  function depd (namespace) {
    if (!namespace) {
      throw new TypeError('argument namespace is required')
    }

    function deprecate (message) {
      // no-op in browser
    }

    deprecate._file = undefined
    deprecate._ignored = true
    deprecate._namespace = namespace
    deprecate._traced = false
    deprecate._warned = Object.create(null)

    deprecate.function = wrapfunction
    deprecate.property = wrapproperty

    return deprecate
  }

  /**
   * Return a wrapped function in a deprecation message.
   *
   * This is a no-op version of the wrapper, which does nothing but call
   * validation.
   */

  function wrapfunction (fn, message) {
    if (typeof fn !== 'function') {
      throw new TypeError('argument fn must be a function')
    }

    return fn
  }

  /**
   * Wrap property in a deprecation message.
   *
   * This is a no-op version of the wrapper, which does nothing but call
   * validation.
   */

  function wrapproperty (obj, prop, message) {
    if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
      throw new TypeError('argument obj must be object')
    }

    var descriptor = Object.getOwnPropertyDescriptor(obj, prop)

    if (!descriptor) {
      throw new TypeError('must call property on owner object')
    }

    if (!descriptor.configurable) {
      throw new TypeError('property must be configurable')
    }
  }


  /***/ }),
  /* 54 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  module.exports = {
    // agent
    CURRENT_ID: Symbol('agentkeepalive#currentId'),
    CREATE_ID: Symbol('agentkeepalive#createId'),
    INIT_SOCKET: Symbol('agentkeepalive#initSocket'),
    CREATE_HTTPS_CONNECTION: Symbol('agentkeepalive#createHttpsConnection'),
    // socket
    SOCKET_CREATED_TIME: Symbol('agentkeepalive#socketCreatedTime'),
    SOCKET_NAME: Symbol('agentkeepalive#socketName'),
    SOCKET_REQUEST_COUNT: Symbol('agentkeepalive#socketRequestCount'),
    SOCKET_REQUEST_FINISHED_COUNT: Symbol('agentkeepalive#socketRequestFinishedCount'),
  };


  /***/ }),
  /* 55 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const OriginalHttpsAgent = __webpack_require__(56).Agent;
  const HttpAgent = __webpack_require__(47);
  const {
    INIT_SOCKET,
    CREATE_HTTPS_CONNECTION,
  } = __webpack_require__(54);

  class HttpsAgent extends HttpAgent {
    constructor(options) {
      super(options);

      this.defaultPort = 443;
      this.protocol = 'https:';
      this.maxCachedSessions = this.options.maxCachedSessions;
      /* istanbul ignore next */
      if (this.maxCachedSessions === undefined) {
        this.maxCachedSessions = 100;
      }

      this._sessionCache = {
        map: {},
        list: [],
      };
    }

    createConnection(options) {
      const socket = this[CREATE_HTTPS_CONNECTION](options);
      this[INIT_SOCKET](socket, options);
      return socket;
    }
  }

  // https://github.com/nodejs/node/blob/master/lib/https.js#L89
  HttpsAgent.prototype[CREATE_HTTPS_CONNECTION] = OriginalHttpsAgent.prototype.createConnection;

  [
    'getName',
    '_getSession',
    '_cacheSession',
    // https://github.com/nodejs/node/pull/4982
    '_evictSession',
  ].forEach(function(method) {
    /* istanbul ignore next */
    if (typeof OriginalHttpsAgent.prototype[method] === 'function') {
      HttpsAgent.prototype[method] = OriginalHttpsAgent.prototype[method];
    }
  });

  module.exports = HttpsAgent;


  /***/ }),
  /* 56 */
  /***/ (function(module, exports) {

  module.exports = require("https");

  /***/ }),
  /* 57 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const pkg = __webpack_require__(58);
  const create = __webpack_require__(59);

  const defaults = {
  	options: {
  		retry: {
  			retries: 2,
  			methods: [
  				'GET',
  				'PUT',
  				'HEAD',
  				'DELETE',
  				'OPTIONS',
  				'TRACE'
  			],
  			statusCodes: [
  				408,
  				413,
  				429,
  				500,
  				502,
  				503,
  				504
  			],
  			errorCodes: [
  				'ETIMEDOUT',
  				'ECONNRESET',
  				'EADDRINUSE',
  				'ECONNREFUSED',
  				'EPIPE',
  				'ENOTFOUND',
  				'ENETUNREACH',
  				'EAI_AGAIN'
  			]
  		},
  		headers: {
  			'user-agent': `${pkg.name}/${pkg.version} (https://github.com/sindresorhus/got)`
  		},
  		hooks: {
  			beforeRequest: [],
  			beforeRedirect: [],
  			beforeRetry: [],
  			afterResponse: []
  		},
  		decompress: true,
  		throwHttpErrors: true,
  		followRedirect: true,
  		stream: false,
  		form: false,
  		json: false,
  		cache: false,
  		useElectronNet: false
  	},
  	mutableDefaults: false
  };

  const got = create(defaults);

  module.exports = got;


  /***/ }),
  /* 58 */
  /***/ (function(module) {

  module.exports = JSON.parse("{\"name\":\"got\",\"version\":\"9.6.0\",\"description\":\"Simplified HTTP requests\",\"license\":\"MIT\",\"repository\":\"sindresorhus/got\",\"main\":\"source\",\"engines\":{\"node\":\">=8.6\"},\"scripts\":{\"test\":\"xo && nyc ava\",\"release\":\"np\"},\"files\":[\"source\"],\"keywords\":[\"http\",\"https\",\"get\",\"got\",\"url\",\"uri\",\"request\",\"util\",\"utility\",\"simple\",\"curl\",\"wget\",\"fetch\",\"net\",\"network\",\"electron\"],\"dependencies\":{\"@sindresorhus/is\":\"^0.14.0\",\"@szmarczak/http-timer\":\"^1.1.2\",\"cacheable-request\":\"^6.0.0\",\"decompress-response\":\"^3.3.0\",\"duplexer3\":\"^0.1.4\",\"get-stream\":\"^4.1.0\",\"lowercase-keys\":\"^1.0.1\",\"mimic-response\":\"^1.0.1\",\"p-cancelable\":\"^1.0.0\",\"to-readable-stream\":\"^1.0.0\",\"url-parse-lax\":\"^3.0.0\"},\"devDependencies\":{\"ava\":\"^1.1.0\",\"coveralls\":\"^3.0.0\",\"delay\":\"^4.1.0\",\"form-data\":\"^2.3.3\",\"get-port\":\"^4.0.0\",\"np\":\"^3.1.0\",\"nyc\":\"^13.1.0\",\"p-event\":\"^2.1.0\",\"pem\":\"^1.13.2\",\"proxyquire\":\"^2.0.1\",\"sinon\":\"^7.2.2\",\"slow-stream\":\"0.0.4\",\"tempfile\":\"^2.0.0\",\"tempy\":\"^0.2.1\",\"tough-cookie\":\"^3.0.0\",\"xo\":\"^0.24.0\"},\"ava\":{\"concurrency\":4},\"browser\":{\"decompress-response\":false,\"electron\":false}}");

  /***/ }),
  /* 59 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const errors = __webpack_require__(60);
  const asStream = __webpack_require__(64);
  const asPromise = __webpack_require__(98);
  const normalizeArguments = __webpack_require__(103);
  const merge = __webpack_require__(101);
  const deepFreeze = __webpack_require__(106);

  const getPromiseOrStream = options => options.stream ? asStream(options) : asPromise(options);

  const aliases = [
  	'get',
  	'post',
  	'put',
  	'patch',
  	'head',
  	'delete'
  ];

  const create = defaults => {
  	defaults = merge({}, defaults);
  	normalizeArguments.preNormalize(defaults.options);

  	if (!defaults.handler) {
  		// This can't be getPromiseOrStream, because when merging
  		// the chain would stop at this point and no further handlers would be called.
  		defaults.handler = (options, next) => next(options);
  	}

  	function got(url, options) {
  		try {
  			return defaults.handler(normalizeArguments(url, options, defaults), getPromiseOrStream);
  		} catch (error) {
  			if (options && options.stream) {
  				throw error;
  			} else {
  				return Promise.reject(error);
  			}
  		}
  	}

  	got.create = create;
  	got.extend = options => {
  		let mutableDefaults;
  		if (options && Reflect.has(options, 'mutableDefaults')) {
  			mutableDefaults = options.mutableDefaults;
  			delete options.mutableDefaults;
  		} else {
  			mutableDefaults = defaults.mutableDefaults;
  		}

  		return create({
  			options: merge.options(defaults.options, options),
  			handler: defaults.handler,
  			mutableDefaults
  		});
  	};

  	got.mergeInstances = (...args) => create(merge.instances(args));

  	got.stream = (url, options) => got(url, {...options, stream: true});

  	for (const method of aliases) {
  		got[method] = (url, options) => got(url, {...options, method});
  		got.stream[method] = (url, options) => got.stream(url, {...options, method});
  	}

  	Object.assign(got, {...errors, mergeOptions: merge.options});
  	Object.defineProperty(got, 'defaults', {
  		value: defaults.mutableDefaults ? defaults : deepFreeze(defaults),
  		writable: defaults.mutableDefaults,
  		configurable: defaults.mutableDefaults,
  		enumerable: true
  	});

  	return got;
  };

  module.exports = create;


  /***/ }),
  /* 60 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const urlLib = __webpack_require__(61);
  const http = __webpack_require__(48);
  const PCancelable = __webpack_require__(62);
  const is = __webpack_require__(63);

  class GotError extends Error {
  	constructor(message, error, options) {
  		super(message);
  		Error.captureStackTrace(this, this.constructor);
  		this.name = 'GotError';

  		if (!is.undefined(error.code)) {
  			this.code = error.code;
  		}

  		Object.assign(this, {
  			host: options.host,
  			hostname: options.hostname,
  			method: options.method,
  			path: options.path,
  			socketPath: options.socketPath,
  			protocol: options.protocol,
  			url: options.href,
  			gotOptions: options
  		});
  	}
  }

  module.exports.GotError = GotError;

  module.exports.CacheError = class extends GotError {
  	constructor(error, options) {
  		super(error.message, error, options);
  		this.name = 'CacheError';
  	}
  };

  module.exports.RequestError = class extends GotError {
  	constructor(error, options) {
  		super(error.message, error, options);
  		this.name = 'RequestError';
  	}
  };

  module.exports.ReadError = class extends GotError {
  	constructor(error, options) {
  		super(error.message, error, options);
  		this.name = 'ReadError';
  	}
  };

  module.exports.ParseError = class extends GotError {
  	constructor(error, statusCode, options, data) {
  		super(`${error.message} in "${urlLib.format(options)}": \n${data.slice(0, 77)}...`, error, options);
  		this.name = 'ParseError';
  		this.statusCode = statusCode;
  		this.statusMessage = http.STATUS_CODES[this.statusCode];
  	}
  };

  module.exports.HTTPError = class extends GotError {
  	constructor(response, options) {
  		const {statusCode} = response;
  		let {statusMessage} = response;

  		if (statusMessage) {
  			statusMessage = statusMessage.replace(/\r?\n/g, ' ').trim();
  		} else {
  			statusMessage = http.STATUS_CODES[statusCode];
  		}

  		super(`Response code ${statusCode} (${statusMessage})`, {}, options);
  		this.name = 'HTTPError';
  		this.statusCode = statusCode;
  		this.statusMessage = statusMessage;
  		this.headers = response.headers;
  		this.body = response.body;
  	}
  };

  module.exports.MaxRedirectsError = class extends GotError {
  	constructor(statusCode, redirectUrls, options) {
  		super('Redirected 10 times. Aborting.', {}, options);
  		this.name = 'MaxRedirectsError';
  		this.statusCode = statusCode;
  		this.statusMessage = http.STATUS_CODES[this.statusCode];
  		this.redirectUrls = redirectUrls;
  	}
  };

  module.exports.UnsupportedProtocolError = class extends GotError {
  	constructor(options) {
  		super(`Unsupported protocol "${options.protocol}"`, {}, options);
  		this.name = 'UnsupportedProtocolError';
  	}
  };

  module.exports.TimeoutError = class extends GotError {
  	constructor(error, options) {
  		super(error.message, {code: 'ETIMEDOUT'}, options);
  		this.name = 'TimeoutError';
  		this.event = error.event;
  	}
  };

  module.exports.CancelError = PCancelable.CancelError;


  /***/ }),
  /* 61 */
  /***/ (function(module, exports) {

  module.exports = require("url");

  /***/ }),
  /* 62 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  class CancelError extends Error {
  	constructor(reason) {
  		super(reason || 'Promise was canceled');
  		this.name = 'CancelError';
  	}

  	get isCanceled() {
  		return true;
  	}
  }

  class PCancelable {
  	static fn(userFn) {
  		return (...args) => {
  			return new PCancelable((resolve, reject, onCancel) => {
  				args.push(onCancel);
  				userFn(...args).then(resolve, reject);
  			});
  		};
  	}

  	constructor(executor) {
  		this._cancelHandlers = [];
  		this._isPending = true;
  		this._isCanceled = false;
  		this._rejectOnCancel = true;

  		this._promise = new Promise((resolve, reject) => {
  			this._reject = reject;

  			const onResolve = value => {
  				this._isPending = false;
  				resolve(value);
  			};

  			const onReject = error => {
  				this._isPending = false;
  				reject(error);
  			};

  			const onCancel = handler => {
  				this._cancelHandlers.push(handler);
  			};

  			Object.defineProperties(onCancel, {
  				shouldReject: {
  					get: () => this._rejectOnCancel,
  					set: bool => {
  						this._rejectOnCancel = bool;
  					}
  				}
  			});

  			return executor(onResolve, onReject, onCancel);
  		});
  	}

  	then(onFulfilled, onRejected) {
  		return this._promise.then(onFulfilled, onRejected);
  	}

  	catch(onRejected) {
  		return this._promise.catch(onRejected);
  	}

  	finally(onFinally) {
  		return this._promise.finally(onFinally);
  	}

  	cancel(reason) {
  		if (!this._isPending || this._isCanceled) {
  			return;
  		}

  		if (this._cancelHandlers.length > 0) {
  			try {
  				for (const handler of this._cancelHandlers) {
  					handler();
  				}
  			} catch (error) {
  				this._reject(error);
  			}
  		}

  		this._isCanceled = true;
  		if (this._rejectOnCancel) {
  			this._reject(new CancelError(reason));
  		}
  	}

  	get isCanceled() {
  		return this._isCanceled;
  	}
  }

  Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);

  module.exports = PCancelable;
  module.exports.default = PCancelable;

  module.exports.CancelError = CancelError;


  /***/ }),
  /* 63 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  /// <reference lib="es2016"/>
  /// <reference lib="es2017.sharedmemory"/>
  /// <reference lib="esnext.asynciterable"/>
  /// <reference lib="dom"/>
  Object.defineProperty(exports, "__esModule", { value: true });
  // TODO: Use the `URL` global when targeting Node.js 10
  // tslint:disable-next-line
  const URLGlobal = typeof URL === 'undefined' ? __webpack_require__(61).URL : URL;
  const toString = Object.prototype.toString;
  const isOfType = (type) => (value) => typeof value === type;
  const isBuffer = (input) => !is.nullOrUndefined(input) && !is.nullOrUndefined(input.constructor) && is.function_(input.constructor.isBuffer) && input.constructor.isBuffer(input);
  const getObjectType = (value) => {
      const objectName = toString.call(value).slice(8, -1);
      if (objectName) {
          return objectName;
      }
      return null;
  };
  const isObjectOfType = (type) => (value) => getObjectType(value) === type;
  function is(value) {
      switch (value) {
          case null:
              return "null" /* null */;
          case true:
          case false:
              return "boolean" /* boolean */;
          default:
      }
      switch (typeof value) {
          case 'undefined':
              return "undefined" /* undefined */;
          case 'string':
              return "string" /* string */;
          case 'number':
              return "number" /* number */;
          case 'symbol':
              return "symbol" /* symbol */;
          default:
      }
      if (is.function_(value)) {
          return "Function" /* Function */;
      }
      if (is.observable(value)) {
          return "Observable" /* Observable */;
      }
      if (Array.isArray(value)) {
          return "Array" /* Array */;
      }
      if (isBuffer(value)) {
          return "Buffer" /* Buffer */;
      }
      const tagType = getObjectType(value);
      if (tagType) {
          return tagType;
      }
      if (value instanceof String || value instanceof Boolean || value instanceof Number) {
          throw new TypeError('Please don\'t use object wrappers for primitive types');
      }
      return "Object" /* Object */;
  }
  (function (is) {
      // tslint:disable-next-line:strict-type-predicates
      const isObject = (value) => typeof value === 'object';
      // tslint:disable:variable-name
      is.undefined = isOfType('undefined');
      is.string = isOfType('string');
      is.number = isOfType('number');
      is.function_ = isOfType('function');
      // tslint:disable-next-line:strict-type-predicates
      is.null_ = (value) => value === null;
      is.class_ = (value) => is.function_(value) && value.toString().startsWith('class ');
      is.boolean = (value) => value === true || value === false;
      is.symbol = isOfType('symbol');
      // tslint:enable:variable-name
      is.numericString = (value) => is.string(value) && value.length > 0 && !Number.isNaN(Number(value));
      is.array = Array.isArray;
      is.buffer = isBuffer;
      is.nullOrUndefined = (value) => is.null_(value) || is.undefined(value);
      is.object = (value) => !is.nullOrUndefined(value) && (is.function_(value) || isObject(value));
      is.iterable = (value) => !is.nullOrUndefined(value) && is.function_(value[Symbol.iterator]);
      is.asyncIterable = (value) => !is.nullOrUndefined(value) && is.function_(value[Symbol.asyncIterator]);
      is.generator = (value) => is.iterable(value) && is.function_(value.next) && is.function_(value.throw);
      is.nativePromise = (value) => isObjectOfType("Promise" /* Promise */)(value);
      const hasPromiseAPI = (value) => !is.null_(value) &&
          isObject(value) &&
          is.function_(value.then) &&
          is.function_(value.catch);
      is.promise = (value) => is.nativePromise(value) || hasPromiseAPI(value);
      is.generatorFunction = isObjectOfType("GeneratorFunction" /* GeneratorFunction */);
      is.asyncFunction = isObjectOfType("AsyncFunction" /* AsyncFunction */);
      is.boundFunction = (value) => is.function_(value) && !value.hasOwnProperty('prototype');
      is.regExp = isObjectOfType("RegExp" /* RegExp */);
      is.date = isObjectOfType("Date" /* Date */);
      is.error = isObjectOfType("Error" /* Error */);
      is.map = (value) => isObjectOfType("Map" /* Map */)(value);
      is.set = (value) => isObjectOfType("Set" /* Set */)(value);
      is.weakMap = (value) => isObjectOfType("WeakMap" /* WeakMap */)(value);
      is.weakSet = (value) => isObjectOfType("WeakSet" /* WeakSet */)(value);
      is.int8Array = isObjectOfType("Int8Array" /* Int8Array */);
      is.uint8Array = isObjectOfType("Uint8Array" /* Uint8Array */);
      is.uint8ClampedArray = isObjectOfType("Uint8ClampedArray" /* Uint8ClampedArray */);
      is.int16Array = isObjectOfType("Int16Array" /* Int16Array */);
      is.uint16Array = isObjectOfType("Uint16Array" /* Uint16Array */);
      is.int32Array = isObjectOfType("Int32Array" /* Int32Array */);
      is.uint32Array = isObjectOfType("Uint32Array" /* Uint32Array */);
      is.float32Array = isObjectOfType("Float32Array" /* Float32Array */);
      is.float64Array = isObjectOfType("Float64Array" /* Float64Array */);
      is.arrayBuffer = isObjectOfType("ArrayBuffer" /* ArrayBuffer */);
      is.sharedArrayBuffer = isObjectOfType("SharedArrayBuffer" /* SharedArrayBuffer */);
      is.dataView = isObjectOfType("DataView" /* DataView */);
      is.directInstanceOf = (instance, klass) => Object.getPrototypeOf(instance) === klass.prototype;
      is.urlInstance = (value) => isObjectOfType("URL" /* URL */)(value);
      is.urlString = (value) => {
          if (!is.string(value)) {
              return false;
          }
          try {
              new URLGlobal(value); // tslint:disable-line no-unused-expression
              return true;
          }
          catch (_a) {
              return false;
          }
      };
      is.truthy = (value) => Boolean(value);
      is.falsy = (value) => !value;
      is.nan = (value) => Number.isNaN(value);
      const primitiveTypes = new Set([
          'undefined',
          'string',
          'number',
          'boolean',
          'symbol'
      ]);
      is.primitive = (value) => is.null_(value) || primitiveTypes.has(typeof value);
      is.integer = (value) => Number.isInteger(value);
      is.safeInteger = (value) => Number.isSafeInteger(value);
      is.plainObject = (value) => {
          // From: https://github.com/sindresorhus/is-plain-obj/blob/master/index.js
          let prototype;
          return getObjectType(value) === "Object" /* Object */ &&
              (prototype = Object.getPrototypeOf(value), prototype === null || // tslint:disable-line:ban-comma-operator
                  prototype === Object.getPrototypeOf({}));
      };
      const typedArrayTypes = new Set([
          "Int8Array" /* Int8Array */,
          "Uint8Array" /* Uint8Array */,
          "Uint8ClampedArray" /* Uint8ClampedArray */,
          "Int16Array" /* Int16Array */,
          "Uint16Array" /* Uint16Array */,
          "Int32Array" /* Int32Array */,
          "Uint32Array" /* Uint32Array */,
          "Float32Array" /* Float32Array */,
          "Float64Array" /* Float64Array */
      ]);
      is.typedArray = (value) => {
          const objectType = getObjectType(value);
          if (objectType === null) {
              return false;
          }
          return typedArrayTypes.has(objectType);
      };
      const isValidLength = (value) => is.safeInteger(value) && value > -1;
      is.arrayLike = (value) => !is.nullOrUndefined(value) && !is.function_(value) && isValidLength(value.length);
      is.inRange = (value, range) => {
          if (is.number(range)) {
              return value >= Math.min(0, range) && value <= Math.max(range, 0);
          }
          if (is.array(range) && range.length === 2) {
              return value >= Math.min(...range) && value <= Math.max(...range);
          }
          throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
      };
      const NODE_TYPE_ELEMENT = 1;
      const DOM_PROPERTIES_TO_CHECK = [
          'innerHTML',
          'ownerDocument',
          'style',
          'attributes',
          'nodeValue'
      ];
      is.domElement = (value) => is.object(value) && value.nodeType === NODE_TYPE_ELEMENT && is.string(value.nodeName) &&
          !is.plainObject(value) && DOM_PROPERTIES_TO_CHECK.every(property => property in value);
      is.observable = (value) => {
          if (!value) {
              return false;
          }
          if (value[Symbol.observable] && value === value[Symbol.observable]()) {
              return true;
          }
          if (value['@@observable'] && value === value['@@observable']()) {
              return true;
          }
          return false;
      };
      is.nodeStream = (value) => !is.nullOrUndefined(value) && isObject(value) && is.function_(value.pipe) && !is.observable(value);
      is.infinite = (value) => value === Infinity || value === -Infinity;
      const isAbsoluteMod2 = (rem) => (value) => is.integer(value) && Math.abs(value % 2) === rem;
      is.even = isAbsoluteMod2(0);
      is.odd = isAbsoluteMod2(1);
      const isWhiteSpaceString = (value) => is.string(value) && /\S/.test(value) === false;
      is.emptyArray = (value) => is.array(value) && value.length === 0;
      is.nonEmptyArray = (value) => is.array(value) && value.length > 0;
      is.emptyString = (value) => is.string(value) && value.length === 0;
      is.nonEmptyString = (value) => is.string(value) && value.length > 0;
      is.emptyStringOrWhitespace = (value) => is.emptyString(value) || isWhiteSpaceString(value);
      is.emptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length === 0;
      is.nonEmptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length > 0;
      is.emptySet = (value) => is.set(value) && value.size === 0;
      is.nonEmptySet = (value) => is.set(value) && value.size > 0;
      is.emptyMap = (value) => is.map(value) && value.size === 0;
      is.nonEmptyMap = (value) => is.map(value) && value.size > 0;
      const predicateOnArray = (method, predicate, values) => {
          if (is.function_(predicate) === false) {
              throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
          }
          if (values.length === 0) {
              throw new TypeError('Invalid number of values');
          }
          return method.call(values, predicate);
      };
      // tslint:disable variable-name
      is.any = (predicate, ...values) => predicateOnArray(Array.prototype.some, predicate, values);
      is.all = (predicate, ...values) => predicateOnArray(Array.prototype.every, predicate, values);
      // tslint:enable variable-name
  })(is || (is = {}));
  // Some few keywords are reserved, but we'll populate them for Node.js users
  // See https://github.com/Microsoft/TypeScript/issues/2536
  Object.defineProperties(is, {
      class: {
          value: is.class_
      },
      function: {
          value: is.function_
      },
      null: {
          value: is.null_
      }
  });
  exports.default = is;
  // For CommonJS default export support
  module.exports = is;
  module.exports.default = is;
  //# sourceMappingURL=index.js.map

  /***/ }),
  /* 64 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const {PassThrough} = __webpack_require__(24);
  const duplexer3 = __webpack_require__(65);
  const requestAsEventEmitter = __webpack_require__(66);
  const {HTTPError, ReadError} = __webpack_require__(60);

  module.exports = options => {
  	const input = new PassThrough();
  	const output = new PassThrough();
  	const proxy = duplexer3(input, output);
  	const piped = new Set();
  	let isFinished = false;

  	options.retry.retries = () => 0;

  	if (options.body) {
  		proxy.write = () => {
  			throw new Error('Got\'s stream is not writable when the `body` option is used');
  		};
  	}

  	const emitter = requestAsEventEmitter(options, input);

  	// Cancels the request
  	proxy._destroy = emitter.abort;

  	emitter.on('response', response => {
  		const {statusCode} = response;

  		response.on('error', error => {
  			proxy.emit('error', new ReadError(error, options));
  		});

  		if (options.throwHttpErrors && statusCode !== 304 && (statusCode < 200 || statusCode > 299)) {
  			proxy.emit('error', new HTTPError(response, options), null, response);
  			return;
  		}

  		isFinished = true;

  		response.pipe(output);

  		for (const destination of piped) {
  			if (destination.headersSent) {
  				continue;
  			}

  			for (const [key, value] of Object.entries(response.headers)) {
  				// Got gives *decompressed* data. Overriding `content-encoding` header would result in an error.
  				// It's not possible to decompress already decompressed data, is it?
  				const allowed = options.decompress ? key !== 'content-encoding' : true;
  				if (allowed) {
  					destination.setHeader(key, value);
  				}
  			}

  			destination.statusCode = response.statusCode;
  		}

  		proxy.emit('response', response);
  	});

  	[
  		'error',
  		'request',
  		'redirect',
  		'uploadProgress',
  		'downloadProgress'
  	].forEach(event => emitter.on(event, (...args) => proxy.emit(event, ...args)));

  	const pipe = proxy.pipe.bind(proxy);
  	const unpipe = proxy.unpipe.bind(proxy);
  	proxy.pipe = (destination, options) => {
  		if (isFinished) {
  			throw new Error('Failed to pipe. The response has been emitted already.');
  		}

  		const result = pipe(destination, options);

  		if (Reflect.has(destination, 'setHeader')) {
  			piped.add(destination);
  		}

  		return result;
  	};

  	proxy.unpipe = stream => {
  		piped.delete(stream);
  		return unpipe(stream);
  	};

  	return proxy;
  };


  /***/ }),
  /* 65 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var stream = __webpack_require__(24);

  function DuplexWrapper(options, writable, readable) {
    if (typeof readable === "undefined") {
      readable = writable;
      writable = options;
      options = null;
    }

    stream.Duplex.call(this, options);

    if (typeof readable.read !== "function") {
      readable = (new stream.Readable(options)).wrap(readable);
    }

    this._writable = writable;
    this._readable = readable;
    this._waiting = false;

    var self = this;

    writable.once("finish", function() {
      self.end();
    });

    this.once("finish", function() {
      writable.end();
    });

    readable.on("readable", function() {
      if (self._waiting) {
        self._waiting = false;
        self._read();
      }
    });

    readable.once("end", function() {
      self.push(null);
    });

    if (!options || typeof options.bubbleErrors === "undefined" || options.bubbleErrors) {
      writable.on("error", function(err) {
        self.emit("error", err);
      });

      readable.on("error", function(err) {
        self.emit("error", err);
      });
    }
  }

  DuplexWrapper.prototype = Object.create(stream.Duplex.prototype, {constructor: {value: DuplexWrapper}});

  DuplexWrapper.prototype._write = function _write(input, encoding, done) {
    this._writable.write(input, encoding, done);
  };

  DuplexWrapper.prototype._read = function _read() {
    var buf;
    var reads = 0;
    while ((buf = this._readable.read()) !== null) {
      this.push(buf);
      reads++;
    }
    if (reads === 0) {
      this._waiting = true;
    }
  };

  module.exports = function duplex2(options, writable, readable) {
    return new DuplexWrapper(options, writable, readable);
  };

  module.exports.DuplexWrapper = DuplexWrapper;


  /***/ }),
  /* 66 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const {URL} = __webpack_require__(61); // TODO: Use the `URL` global when targeting Node.js 10
  const util = __webpack_require__(25);
  const EventEmitter = __webpack_require__(67);
  const http = __webpack_require__(48);
  const https = __webpack_require__(56);
  const urlLib = __webpack_require__(61);
  const CacheableRequest = __webpack_require__(68);
  const toReadableStream = __webpack_require__(85);
  const is = __webpack_require__(63);
  const timer = __webpack_require__(86);
  const timedOut = __webpack_require__(88);
  const getBodySize = __webpack_require__(90);
  const getResponse = __webpack_require__(92);
  const progress = __webpack_require__(95);
  const {CacheError, UnsupportedProtocolError, MaxRedirectsError, RequestError, TimeoutError} = __webpack_require__(60);
  const urlToOptions = __webpack_require__(96);

  const getMethodRedirectCodes = new Set([300, 301, 302, 303, 304, 305, 307, 308]);
  const allMethodRedirectCodes = new Set([300, 303, 307, 308]);

  module.exports = (options, input) => {
  	const emitter = new EventEmitter();
  	const redirects = [];
  	let currentRequest;
  	let requestUrl;
  	let redirectString;
  	let uploadBodySize;
  	let retryCount = 0;
  	let shouldAbort = false;

  	const setCookie = options.cookieJar ? util.promisify(options.cookieJar.setCookie.bind(options.cookieJar)) : null;
  	const getCookieString = options.cookieJar ? util.promisify(options.cookieJar.getCookieString.bind(options.cookieJar)) : null;
  	const agents = is.object(options.agent) ? options.agent : null;

  	const emitError = async error => {
  		try {
  			for (const hook of options.hooks.beforeError) {
  				// eslint-disable-next-line no-await-in-loop
  				error = await hook(error);
  			}

  			emitter.emit('error', error);
  		} catch (error2) {
  			emitter.emit('error', error2);
  		}
  	};

  	const get = async options => {
  		const currentUrl = redirectString || requestUrl;

  		if (options.protocol !== 'http:' && options.protocol !== 'https:') {
  			throw new UnsupportedProtocolError(options);
  		}

  		decodeURI(currentUrl);

  		let fn;
  		if (is.function(options.request)) {
  			fn = {request: options.request};
  		} else {
  			fn = options.protocol === 'https:' ? https : http;
  		}

  		if (agents) {
  			const protocolName = options.protocol === 'https:' ? 'https' : 'http';
  			options.agent = agents[protocolName] || options.agent;
  		}

  		/* istanbul ignore next: electron.net is broken */
  		if (options.useElectronNet && process.versions.electron) {
  			const r = ({x: __webpack_require__(97)})['yx'.slice(1)]; // Trick webpack
  			const electron = r('electron');
  			fn = electron.net || electron.remote.net;
  		}

  		if (options.cookieJar) {
  			const cookieString = await getCookieString(currentUrl, {});

  			if (is.nonEmptyString(cookieString)) {
  				options.headers.cookie = cookieString;
  			}
  		}

  		let timings;
  		const handleResponse = async response => {
  			try {
  				/* istanbul ignore next: fixes https://github.com/electron/electron/blob/cbb460d47628a7a146adf4419ed48550a98b2923/lib/browser/api/net.js#L59-L65 */
  				if (options.useElectronNet) {
  					response = new Proxy(response, {
  						get: (target, name) => {
  							if (name === 'trailers' || name === 'rawTrailers') {
  								return [];
  							}

  							const value = target[name];
  							return is.function(value) ? value.bind(target) : value;
  						}
  					});
  				}

  				const {statusCode} = response;
  				response.url = currentUrl;
  				response.requestUrl = requestUrl;
  				response.retryCount = retryCount;
  				response.timings = timings;
  				response.redirectUrls = redirects;
  				response.request = {
  					gotOptions: options
  				};

  				const rawCookies = response.headers['set-cookie'];
  				if (options.cookieJar && rawCookies) {
  					await Promise.all(rawCookies.map(rawCookie => setCookie(rawCookie, response.url)));
  				}

  				if (options.followRedirect && 'location' in response.headers) {
  					if (allMethodRedirectCodes.has(statusCode) || (getMethodRedirectCodes.has(statusCode) && (options.method === 'GET' || options.method === 'HEAD'))) {
  						response.resume(); // We're being redirected, we don't care about the response.

  						if (statusCode === 303) {
  							// Server responded with "see other", indicating that the resource exists at another location,
  							// and the client should request it from that location via GET or HEAD.
  							options.method = 'GET';
  						}

  						if (redirects.length >= 10) {
  							throw new MaxRedirectsError(statusCode, redirects, options);
  						}

  						// Handles invalid URLs. See https://github.com/sindresorhus/got/issues/604
  						const redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();
  						const redirectURL = new URL(redirectBuffer, currentUrl);
  						redirectString = redirectURL.toString();

  						redirects.push(redirectString);

  						const redirectOptions = {
  							...options,
  							...urlToOptions(redirectURL)
  						};

  						for (const hook of options.hooks.beforeRedirect) {
  							// eslint-disable-next-line no-await-in-loop
  							await hook(redirectOptions);
  						}

  						emitter.emit('redirect', response, redirectOptions);

  						await get(redirectOptions);
  						return;
  					}
  				}

  				getResponse(response, options, emitter);
  			} catch (error) {
  				emitError(error);
  			}
  		};

  		const handleRequest = request => {
  			if (shouldAbort) {
  				request.once('error', () => {});
  				request.abort();
  				return;
  			}

  			currentRequest = request;

  			request.once('error', error => {
  				if (request.aborted) {
  					return;
  				}

  				if (error instanceof timedOut.TimeoutError) {
  					error = new TimeoutError(error, options);
  				} else {
  					error = new RequestError(error, options);
  				}

  				if (emitter.retry(error) === false) {
  					emitError(error);
  				}
  			});

  			timings = timer(request);

  			progress.upload(request, emitter, uploadBodySize);

  			if (options.gotTimeout) {
  				timedOut(request, options.gotTimeout, options);
  			}

  			emitter.emit('request', request);

  			const uploadComplete = () => {
  				request.emit('upload-complete');
  			};

  			try {
  				if (is.nodeStream(options.body)) {
  					options.body.once('end', uploadComplete);
  					options.body.pipe(request);
  					options.body = undefined;
  				} else if (options.body) {
  					request.end(options.body, uploadComplete);
  				} else if (input && (options.method === 'POST' || options.method === 'PUT' || options.method === 'PATCH')) {
  					input.once('end', uploadComplete);
  					input.pipe(request);
  				} else {
  					request.end(uploadComplete);
  				}
  			} catch (error) {
  				emitError(new RequestError(error, options));
  			}
  		};

  		if (options.cache) {
  			const cacheableRequest = new CacheableRequest(fn.request, options.cache);
  			const cacheRequest = cacheableRequest(options, handleResponse);

  			cacheRequest.once('error', error => {
  				if (error instanceof CacheableRequest.RequestError) {
  					emitError(new RequestError(error, options));
  				} else {
  					emitError(new CacheError(error, options));
  				}
  			});

  			cacheRequest.once('request', handleRequest);
  		} else {
  			// Catches errors thrown by calling fn.request(...)
  			try {
  				handleRequest(fn.request(options, handleResponse));
  			} catch (error) {
  				emitError(new RequestError(error, options));
  			}
  		}
  	};

  	emitter.retry = error => {
  		let backoff;

  		try {
  			backoff = options.retry.retries(++retryCount, error);
  		} catch (error2) {
  			emitError(error2);
  			return;
  		}

  		if (backoff) {
  			const retry = async options => {
  				try {
  					for (const hook of options.hooks.beforeRetry) {
  						// eslint-disable-next-line no-await-in-loop
  						await hook(options, error, retryCount);
  					}

  					await get(options);
  				} catch (error) {
  					emitError(error);
  				}
  			};

  			setTimeout(retry, backoff, {...options, forceRefresh: true});
  			return true;
  		}

  		return false;
  	};

  	emitter.abort = () => {
  		if (currentRequest) {
  			currentRequest.once('error', () => {});
  			currentRequest.abort();
  		} else {
  			shouldAbort = true;
  		}
  	};

  	setImmediate(async () => {
  		try {
  			// Convert buffer to stream to receive upload progress events (#322)
  			const {body} = options;
  			if (is.buffer(body)) {
  				options.body = toReadableStream(body);
  				uploadBodySize = body.length;
  			} else {
  				uploadBodySize = await getBodySize(options);
  			}

  			if (is.undefined(options.headers['content-length']) && is.undefined(options.headers['transfer-encoding'])) {
  				if ((uploadBodySize > 0 || options.method === 'PUT') && !is.null(uploadBodySize)) {
  					options.headers['content-length'] = uploadBodySize;
  				}
  			}

  			for (const hook of options.hooks.beforeRequest) {
  				// eslint-disable-next-line no-await-in-loop
  				await hook(options);
  			}

  			requestUrl = options.href || (new URL(options.path, urlLib.format(options))).toString();

  			await get(options);
  		} catch (error) {
  			emitError(error);
  		}
  	});

  	return emitter;
  };


  /***/ }),
  /* 67 */
  /***/ (function(module, exports) {

  module.exports = require("events");

  /***/ }),
  /* 68 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const EventEmitter = __webpack_require__(67);
  const urlLib = __webpack_require__(61);
  const normalizeUrl = __webpack_require__(69);
  const getStream = __webpack_require__(70);
  const CachePolicy = __webpack_require__(76);
  const Response = __webpack_require__(77);
  const lowercaseKeys = __webpack_require__(79);
  const cloneResponse = __webpack_require__(80);
  const Keyv = __webpack_require__(82);

  class CacheableRequest {
  	constructor(request, cacheAdapter) {
  		if (typeof request !== 'function') {
  			throw new TypeError('Parameter `request` must be a function');
  		}

  		this.cache = new Keyv({
  			uri: typeof cacheAdapter === 'string' && cacheAdapter,
  			store: typeof cacheAdapter !== 'string' && cacheAdapter,
  			namespace: 'cacheable-request'
  		});

  		return this.createCacheableRequest(request);
  	}

  	createCacheableRequest(request) {
  		return (opts, cb) => {
  			let url;
  			if (typeof opts === 'string') {
  				url = normalizeUrlObject(urlLib.parse(opts));
  				opts = {};
  			} else if (opts instanceof urlLib.URL) {
  				url = normalizeUrlObject(urlLib.parse(opts.toString()));
  				opts = {};
  			} else {
  				const [pathname, ...searchParts] = (opts.path || '').split('?');
  				const search = searchParts.length > 0 ?
  					`?${searchParts.join('?')}` :
  					'';
  				url = normalizeUrlObject({ ...opts, pathname, search });
  			}

  			opts = {
  				headers: {},
  				method: 'GET',
  				cache: true,
  				strictTtl: false,
  				automaticFailover: false,
  				...opts,
  				...urlObjectToRequestOptions(url)
  			};
  			opts.headers = lowercaseKeys(opts.headers);

  			const ee = new EventEmitter();
  			const normalizedUrlString = normalizeUrl(
  				urlLib.format(url),
  				{
  					stripWWW: false,
  					removeTrailingSlash: false,
  					stripAuthentication: false
  				}
  			);
  			const key = `${opts.method}:${normalizedUrlString}`;
  			let revalidate = false;
  			let madeRequest = false;

  			const makeRequest = opts => {
  				madeRequest = true;
  				let requestErrored = false;
  				let requestErrorCallback;

  				const requestErrorPromise = new Promise(resolve => {
  					requestErrorCallback = () => {
  						if (!requestErrored) {
  							requestErrored = true;
  							resolve();
  						}
  					};
  				});

  				const handler = response => {
  					if (revalidate && !opts.forceRefresh) {
  						response.status = response.statusCode;
  						const revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(opts, response);
  						if (!revalidatedPolicy.modified) {
  							const headers = revalidatedPolicy.policy.responseHeaders();
  							response = new Response(revalidate.statusCode, headers, revalidate.body, revalidate.url);
  							response.cachePolicy = revalidatedPolicy.policy;
  							response.fromCache = true;
  						}
  					}

  					if (!response.fromCache) {
  						response.cachePolicy = new CachePolicy(opts, response, opts);
  						response.fromCache = false;
  					}

  					let clonedResponse;
  					if (opts.cache && response.cachePolicy.storable()) {
  						clonedResponse = cloneResponse(response);

  						(async () => {
  							try {
  								const bodyPromise = getStream.buffer(response);

  								await Promise.race([
  									requestErrorPromise,
  									new Promise(resolve => response.once('end', resolve))
  								]);

  								if (requestErrored) {
  									return;
  								}

  								const body = await bodyPromise;

  								const value = {
  									cachePolicy: response.cachePolicy.toObject(),
  									url: response.url,
  									statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,
  									body
  								};

  								let ttl = opts.strictTtl ? response.cachePolicy.timeToLive() : undefined;
  								if (opts.maxTtl) {
  									ttl = ttl ? Math.min(ttl, opts.maxTtl) : opts.maxTtl;
  								}

  								await this.cache.set(key, value, ttl);
  							} catch (error) {
  								ee.emit('error', new CacheableRequest.CacheError(error));
  							}
  						})();
  					} else if (opts.cache && revalidate) {
  						(async () => {
  							try {
  								await this.cache.delete(key);
  							} catch (error) {
  								ee.emit('error', new CacheableRequest.CacheError(error));
  							}
  						})();
  					}

  					ee.emit('response', clonedResponse || response);
  					if (typeof cb === 'function') {
  						cb(clonedResponse || response);
  					}
  				};

  				try {
  					const req = request(opts, handler);
  					req.once('error', requestErrorCallback);
  					req.once('abort', requestErrorCallback);
  					ee.emit('request', req);
  				} catch (error) {
  					ee.emit('error', new CacheableRequest.RequestError(error));
  				}
  			};

  			(async () => {
  				const get = async opts => {
  					await Promise.resolve();

  					const cacheEntry = opts.cache ? await this.cache.get(key) : undefined;
  					if (typeof cacheEntry === 'undefined') {
  						return makeRequest(opts);
  					}

  					const policy = CachePolicy.fromObject(cacheEntry.cachePolicy);
  					if (policy.satisfiesWithoutRevalidation(opts) && !opts.forceRefresh) {
  						const headers = policy.responseHeaders();
  						const response = new Response(cacheEntry.statusCode, headers, cacheEntry.body, cacheEntry.url);
  						response.cachePolicy = policy;
  						response.fromCache = true;

  						ee.emit('response', response);
  						if (typeof cb === 'function') {
  							cb(response);
  						}
  					} else {
  						revalidate = cacheEntry;
  						opts.headers = policy.revalidationHeaders(opts);
  						makeRequest(opts);
  					}
  				};

  				const errorHandler = error => ee.emit('error', new CacheableRequest.CacheError(error));
  				this.cache.once('error', errorHandler);
  				ee.on('response', () => this.cache.removeListener('error', errorHandler));

  				try {
  					await get(opts);
  				} catch (error) {
  					if (opts.automaticFailover && !madeRequest) {
  						makeRequest(opts);
  					}

  					ee.emit('error', new CacheableRequest.CacheError(error));
  				}
  			})();

  			return ee;
  		};
  	}
  }

  function urlObjectToRequestOptions(url) {
  	const options = { ...url };
  	options.path = `${url.pathname || '/'}${url.search || ''}`;
  	delete options.pathname;
  	delete options.search;
  	return options;
  }

  function normalizeUrlObject(url) {
  	// If url was parsed by url.parse or new URL:
  	// - hostname will be set
  	// - host will be hostname[:port]
  	// - port will be set if it was explicit in the parsed string
  	// Otherwise, url was from request options:
  	// - hostname or host may be set
  	// - host shall not have port encoded
  	return {
  		protocol: url.protocol,
  		auth: url.auth,
  		hostname: url.hostname || url.host || 'localhost',
  		port: url.port,
  		pathname: url.pathname,
  		search: url.search
  	};
  }

  CacheableRequest.RequestError = class extends Error {
  	constructor(error) {
  		super(error.message);
  		this.name = 'RequestError';
  		Object.assign(this, error);
  	}
  };

  CacheableRequest.CacheError = class extends Error {
  	constructor(error) {
  		super(error.message);
  		this.name = 'CacheError';
  		Object.assign(this, error);
  	}
  };

  module.exports = CacheableRequest;


  /***/ }),
  /* 69 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  // TODO: Use the `URL` global when targeting Node.js 10
  const URLParser = typeof URL === 'undefined' ? __webpack_require__(61).URL : URL;

  const testParameter = (name, filters) => {
  	return filters.some(filter => filter instanceof RegExp ? filter.test(name) : filter === name);
  };

  const normalizeUrl = (urlString, options) => {
  	options = {
  		defaultProtocol: 'http:',
  		normalizeProtocol: true,
  		forceHttp: false,
  		forceHttps: false,
  		stripAuthentication: true,
  		stripHash: false,
  		stripWWW: true,
  		removeQueryParameters: [/^utm_\w+/i],
  		removeTrailingSlash: true,
  		removeDirectoryIndex: false,
  		sortQueryParameters: true,
  		...options
  	};

  	// TODO: Remove this at some point in the future
  	if (Reflect.has(options, 'normalizeHttps')) {
  		throw new Error('options.normalizeHttps is renamed to options.forceHttp');
  	}

  	if (Reflect.has(options, 'normalizeHttp')) {
  		throw new Error('options.normalizeHttp is renamed to options.forceHttps');
  	}

  	if (Reflect.has(options, 'stripFragment')) {
  		throw new Error('options.stripFragment is renamed to options.stripHash');
  	}

  	urlString = urlString.trim();

  	const hasRelativeProtocol = urlString.startsWith('//');
  	const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString);

  	// Prepend protocol
  	if (!isRelativeUrl) {
  		urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
  	}

  	const urlObj = new URLParser(urlString);

  	if (options.forceHttp && options.forceHttps) {
  		throw new Error('The `forceHttp` and `forceHttps` options cannot be used together');
  	}

  	if (options.forceHttp && urlObj.protocol === 'https:') {
  		urlObj.protocol = 'http:';
  	}

  	if (options.forceHttps && urlObj.protocol === 'http:') {
  		urlObj.protocol = 'https:';
  	}

  	// Remove auth
  	if (options.stripAuthentication) {
  		urlObj.username = '';
  		urlObj.password = '';
  	}

  	// Remove hash
  	if (options.stripHash) {
  		urlObj.hash = '';
  	}

  	// Remove duplicate slashes if not preceded by a protocol
  	if (urlObj.pathname) {
  		// TODO: Use the following instead when targeting Node.js 10
  		// `urlObj.pathname = urlObj.pathname.replace(/(?<!https?:)\/{2,}/g, '/');`
  		urlObj.pathname = urlObj.pathname.replace(/((?!:).|^)\/{2,}/g, (_, p1) => {
  			if (/^(?!\/)/g.test(p1)) {
  				return `${p1}/`;
  			}

  			return '/';
  		});
  	}

  	// Decode URI octets
  	if (urlObj.pathname) {
  		urlObj.pathname = decodeURI(urlObj.pathname);
  	}

  	// Remove directory index
  	if (options.removeDirectoryIndex === true) {
  		options.removeDirectoryIndex = [/^index\.[a-z]+$/];
  	}

  	if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
  		let pathComponents = urlObj.pathname.split('/');
  		const lastComponent = pathComponents[pathComponents.length - 1];

  		if (testParameter(lastComponent, options.removeDirectoryIndex)) {
  			pathComponents = pathComponents.slice(0, pathComponents.length - 1);
  			urlObj.pathname = pathComponents.slice(1).join('/') + '/';
  		}
  	}

  	if (urlObj.hostname) {
  		// Remove trailing dot
  		urlObj.hostname = urlObj.hostname.replace(/\.$/, '');

  		// Remove `www.`
  		if (options.stripWWW && /^www\.([a-z\-\d]{2,63})\.([a-z.]{2,5})$/.test(urlObj.hostname)) {
  			// Each label should be max 63 at length (min: 2).
  			// The extension should be max 5 at length (min: 2).
  			// Source: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names
  			urlObj.hostname = urlObj.hostname.replace(/^www\./, '');
  		}
  	}

  	// Remove query unwanted parameters
  	if (Array.isArray(options.removeQueryParameters)) {
  		for (const key of [...urlObj.searchParams.keys()]) {
  			if (testParameter(key, options.removeQueryParameters)) {
  				urlObj.searchParams.delete(key);
  			}
  		}
  	}

  	// Sort query parameters
  	if (options.sortQueryParameters) {
  		urlObj.searchParams.sort();
  	}

  	if (options.removeTrailingSlash) {
  		urlObj.pathname = urlObj.pathname.replace(/\/$/, '');
  	}

  	// Take advantage of many of the Node `url` normalizations
  	urlString = urlObj.toString();

  	// Remove ending `/`
  	if ((options.removeTrailingSlash || urlObj.pathname === '/') && urlObj.hash === '') {
  		urlString = urlString.replace(/\/$/, '');
  	}

  	// Restore relative protocol, if applicable
  	if (hasRelativeProtocol && !options.normalizeProtocol) {
  		urlString = urlString.replace(/^http:\/\//, '//');
  	}

  	// Remove http/https
  	if (options.stripProtocol) {
  		urlString = urlString.replace(/^(?:https?:)?\/\//, '');
  	}

  	return urlString;
  };

  module.exports = normalizeUrl;
  // TODO: Remove this for the next major release
  module.exports.default = normalizeUrl;


  /***/ }),
  /* 70 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const pump = __webpack_require__(71);
  const bufferStream = __webpack_require__(75);

  class MaxBufferError extends Error {
  	constructor() {
  		super('maxBuffer exceeded');
  		this.name = 'MaxBufferError';
  	}
  }

  async function getStream(inputStream, options) {
  	if (!inputStream) {
  		return Promise.reject(new Error('Expected a stream'));
  	}

  	options = {
  		maxBuffer: Infinity,
  		...options
  	};

  	const {maxBuffer} = options;

  	let stream;
  	await new Promise((resolve, reject) => {
  		const rejectPromise = error => {
  			if (error) { // A null check
  				error.bufferedData = stream.getBufferedValue();
  			}

  			reject(error);
  		};

  		stream = pump(inputStream, bufferStream(options), error => {
  			if (error) {
  				rejectPromise(error);
  				return;
  			}

  			resolve();
  		});

  		stream.on('data', () => {
  			if (stream.getBufferedLength() > maxBuffer) {
  				rejectPromise(new MaxBufferError());
  			}
  		});
  	});

  	return stream.getBufferedValue();
  }

  module.exports = getStream;
  // TODO: Remove this for the next major release
  module.exports.default = getStream;
  module.exports.buffer = (stream, options) => getStream(stream, {...options, encoding: 'buffer'});
  module.exports.array = (stream, options) => getStream(stream, {...options, array: true});
  module.exports.MaxBufferError = MaxBufferError;


  /***/ }),
  /* 71 */
  /***/ (function(module, exports, __webpack_require__) {

  var once = __webpack_require__(72)
  var eos = __webpack_require__(74)
  var fs = __webpack_require__(7) // we only need fs to get the ReadStream and WriteStream prototypes

  var noop = function () {}
  var ancient = /^v?\.0/.test(process.version)

  var isFn = function (fn) {
    return typeof fn === 'function'
  }

  var isFS = function (stream) {
    if (!ancient) return false // newer node version do not need to care about fs is a special way
    if (!fs) return false // browser
    return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)
  }

  var isRequest = function (stream) {
    return stream.setHeader && isFn(stream.abort)
  }

  var destroyer = function (stream, reading, writing, callback) {
    callback = once(callback)

    var closed = false
    stream.on('close', function () {
      closed = true
    })

    eos(stream, {readable: reading, writable: writing}, function (err) {
      if (err) return callback(err)
      closed = true
      callback()
    })

    var destroyed = false
    return function (err) {
      if (closed) return
      if (destroyed) return
      destroyed = true

      if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks
      if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

      if (isFn(stream.destroy)) return stream.destroy()

      callback(err || new Error('stream was destroyed'))
    }
  }

  var call = function (fn) {
    fn()
  }

  var pipe = function (from, to) {
    return from.pipe(to)
  }

  var pump = function () {
    var streams = Array.prototype.slice.call(arguments)
    var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop

    if (Array.isArray(streams[0])) streams = streams[0]
    if (streams.length < 2) throw new Error('pump requires two streams per minimum')

    var error
    var destroys = streams.map(function (stream, i) {
      var reading = i < streams.length - 1
      var writing = i > 0
      return destroyer(stream, reading, writing, function (err) {
        if (!error) error = err
        if (err) destroys.forEach(call)
        if (reading) return
        destroys.forEach(call)
        callback(error)
      })
    })

    return streams.reduce(pipe)
  }

  module.exports = pump


  /***/ }),
  /* 72 */
  /***/ (function(module, exports, __webpack_require__) {

  var wrappy = __webpack_require__(73)
  module.exports = wrappy(once)

  once.proto = once(function () {
    Object.defineProperty(Function.prototype, 'once', {
      value: function () {
        return once(this)
      },
      configurable: true
    })
  })

  function once (fn) {
    var f = function () {
      if (f.called) return f.value
      f.called = true
      return f.value = fn.apply(this, arguments)
    }
    f.called = false
    return f
  }


  /***/ }),
  /* 73 */
  /***/ (function(module, exports) {

  // Returns a wrapper function that returns a wrapped callback
  // The wrapper function should do some stuff, and return a
  // presumably different callback function.
  // This makes sure that own properties are retained, so that
  // decorations and such are not lost along the way.
  module.exports = wrappy
  function wrappy (fn, cb) {
    if (fn && cb) return wrappy(fn)(cb)

    if (typeof fn !== 'function')
      throw new TypeError('need wrapper function')

    Object.keys(fn).forEach(function (k) {
      wrapper[k] = fn[k]
    })

    return wrapper

    function wrapper() {
      var args = new Array(arguments.length)
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i]
      }
      var ret = fn.apply(this, args)
      var cb = args[args.length-1]
      if (typeof ret === 'function' && ret !== cb) {
        Object.keys(cb).forEach(function (k) {
          ret[k] = cb[k]
        })
      }
      return ret
    }
  }


  /***/ }),
  /* 74 */
  /***/ (function(module, exports, __webpack_require__) {

  var once = __webpack_require__(72);

  var noop = function() {};

  var isRequest = function(stream) {
  	return stream.setHeader && typeof stream.abort === 'function';
  };

  var isChildProcess = function(stream) {
  	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
  };

  var eos = function(stream, opts, callback) {
  	if (typeof opts === 'function') return eos(stream, null, opts);
  	if (!opts) opts = {};

  	callback = once(callback || noop);

  	var ws = stream._writableState;
  	var rs = stream._readableState;
  	var readable = opts.readable || (opts.readable !== false && stream.readable);
  	var writable = opts.writable || (opts.writable !== false && stream.writable);

  	var onlegacyfinish = function() {
  		if (!stream.writable) onfinish();
  	};

  	var onfinish = function() {
  		writable = false;
  		if (!readable) callback();
  	};

  	var onend = function() {
  		readable = false;
  		if (!writable) callback();
  	};

  	var onexit = function(exitCode) {
  		callback(exitCode ? new Error('exited with error code: ' + exitCode) : null);
  	};

  	var onclose = function() {
  		if (readable && !(rs && rs.ended)) return callback(new Error('premature close'));
  		if (writable && !(ws && ws.ended)) return callback(new Error('premature close'));
  	};

  	var onrequest = function() {
  		stream.req.on('finish', onfinish);
  	};

  	if (isRequest(stream)) {
  		stream.on('complete', onfinish);
  		stream.on('abort', onclose);
  		if (stream.req) onrequest();
  		else stream.on('request', onrequest);
  	} else if (writable && !ws) { // legacy streams
  		stream.on('end', onlegacyfinish);
  		stream.on('close', onlegacyfinish);
  	}

  	if (isChildProcess(stream)) stream.on('exit', onexit);

  	stream.on('end', onend);
  	stream.on('finish', onfinish);
  	if (opts.error !== false) stream.on('error', callback);
  	stream.on('close', onclose);

  	return function() {
  		stream.removeListener('complete', onfinish);
  		stream.removeListener('abort', onclose);
  		stream.removeListener('request', onrequest);
  		if (stream.req) stream.req.removeListener('finish', onfinish);
  		stream.removeListener('end', onlegacyfinish);
  		stream.removeListener('close', onlegacyfinish);
  		stream.removeListener('finish', onfinish);
  		stream.removeListener('exit', onexit);
  		stream.removeListener('end', onend);
  		stream.removeListener('error', callback);
  		stream.removeListener('close', onclose);
  	};
  };

  module.exports = eos;

  /***/ }),
  /* 75 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const {PassThrough: PassThroughStream} = __webpack_require__(24);

  module.exports = options => {
  	options = {...options};

  	const {array} = options;
  	let {encoding} = options;
  	const isBuffer = encoding === 'buffer';
  	let objectMode = false;

  	if (array) {
  		objectMode = !(encoding || isBuffer);
  	} else {
  		encoding = encoding || 'utf8';
  	}

  	if (isBuffer) {
  		encoding = null;
  	}

  	const stream = new PassThroughStream({objectMode});

  	if (encoding) {
  		stream.setEncoding(encoding);
  	}

  	let length = 0;
  	const chunks = [];

  	stream.on('data', chunk => {
  		chunks.push(chunk);

  		if (objectMode) {
  			length = chunks.length;
  		} else {
  			length += chunk.length;
  		}
  	});

  	stream.getBufferedValue = () => {
  		if (array) {
  			return chunks;
  		}

  		return isBuffer ? Buffer.concat(chunks, length) : chunks.join('');
  	};

  	stream.getBufferedLength = () => length;

  	return stream;
  };


  /***/ }),
  /* 76 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  // rfc7231 6.1
  const statusCodeCacheableByDefault = [
      200,
      203,
      204,
      206,
      300,
      301,
      404,
      405,
      410,
      414,
      501,
  ];

  // This implementation does not understand partial responses (206)
  const understoodStatuses = [
      200,
      203,
      204,
      300,
      301,
      302,
      303,
      307,
      308,
      404,
      405,
      410,
      414,
      501,
  ];

  const hopByHopHeaders = {
      date: true, // included, because we add Age update Date
      connection: true,
      'keep-alive': true,
      'proxy-authenticate': true,
      'proxy-authorization': true,
      te: true,
      trailer: true,
      'transfer-encoding': true,
      upgrade: true,
  };
  const excludedFromRevalidationUpdate = {
      // Since the old body is reused, it doesn't make sense to change properties of the body
      'content-length': true,
      'content-encoding': true,
      'transfer-encoding': true,
      'content-range': true,
  };

  function parseCacheControl(header) {
      const cc = {};
      if (!header) return cc;

      // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),
      // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale
      const parts = header.trim().split(/\s*,\s*/); // TODO: lame parsing
      for (const part of parts) {
          const [k, v] = part.split(/\s*=\s*/, 2);
          cc[k] = v === undefined ? true : v.replace(/^"|"$/g, ''); // TODO: lame unquoting
      }

      return cc;
  }

  function formatCacheControl(cc) {
      let parts = [];
      for (const k in cc) {
          const v = cc[k];
          parts.push(v === true ? k : k + '=' + v);
      }
      if (!parts.length) {
          return undefined;
      }
      return parts.join(', ');
  }

  module.exports = class CachePolicy {
      constructor(
          req,
          res,
          {
              shared,
              cacheHeuristic,
              immutableMinTimeToLive,
              ignoreCargoCult,
              trustServerDate,
              _fromObject,
          } = {}
      ) {
          if (_fromObject) {
              this._fromObject(_fromObject);
              return;
          }

          if (!res || !res.headers) {
              throw Error('Response headers missing');
          }
          this._assertRequestHasHeaders(req);

          this._responseTime = this.now();
          this._isShared = shared !== false;
          this._trustServerDate =
              undefined !== trustServerDate ? trustServerDate : true;
          this._cacheHeuristic =
              undefined !== cacheHeuristic ? cacheHeuristic : 0.1; // 10% matches IE
          this._immutableMinTtl =
              undefined !== immutableMinTimeToLive
                  ? immutableMinTimeToLive
                  : 24 * 3600 * 1000;

          this._status = 'status' in res ? res.status : 200;
          this._resHeaders = res.headers;
          this._rescc = parseCacheControl(res.headers['cache-control']);
          this._method = 'method' in req ? req.method : 'GET';
          this._url = req.url;
          this._host = req.headers.host;
          this._noAuthorization = !req.headers.authorization;
          this._reqHeaders = res.headers.vary ? req.headers : null; // Don't keep all request headers if they won't be used
          this._reqcc = parseCacheControl(req.headers['cache-control']);

          // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,
          // so there's no point stricly adhering to the blindly copy&pasted directives.
          if (
              ignoreCargoCult &&
              'pre-check' in this._rescc &&
              'post-check' in this._rescc
          ) {
              delete this._rescc['pre-check'];
              delete this._rescc['post-check'];
              delete this._rescc['no-cache'];
              delete this._rescc['no-store'];
              delete this._rescc['must-revalidate'];
              this._resHeaders = Object.assign({}, this._resHeaders, {
                  'cache-control': formatCacheControl(this._rescc),
              });
              delete this._resHeaders.expires;
              delete this._resHeaders.pragma;
          }

          // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive
          // as having the same effect as if "Cache-Control: no-cache" were present (see Section 5.2.1).
          if (
              res.headers['cache-control'] == null &&
              /no-cache/.test(res.headers.pragma)
          ) {
              this._rescc['no-cache'] = true;
          }
      }

      now() {
          return Date.now();
      }

      storable() {
          // The "no-store" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.
          return !!(
              !this._reqcc['no-store'] &&
              // A cache MUST NOT store a response to any request, unless:
              // The request method is understood by the cache and defined as being cacheable, and
              ('GET' === this._method ||
                  'HEAD' === this._method ||
                  ('POST' === this._method && this._hasExplicitExpiration())) &&
              // the response status code is understood by the cache, and
              understoodStatuses.indexOf(this._status) !== -1 &&
              // the "no-store" cache directive does not appear in request or response header fields, and
              !this._rescc['no-store'] &&
              // the "private" response directive does not appear in the response, if the cache is shared, and
              (!this._isShared || !this._rescc.private) &&
              // the Authorization header field does not appear in the request, if the cache is shared,
              (!this._isShared ||
                  this._noAuthorization ||
                  this._allowsStoringAuthenticated()) &&
              // the response either:
              // contains an Expires header field, or
              (this._resHeaders.expires ||
                  // contains a max-age response directive, or
                  // contains a s-maxage response directive and the cache is shared, or
                  // contains a public response directive.
                  this._rescc.public ||
                  this._rescc['max-age'] ||
                  this._rescc['s-maxage'] ||
                  // has a status code that is defined as cacheable by default
                  statusCodeCacheableByDefault.indexOf(this._status) !== -1)
          );
      }

      _hasExplicitExpiration() {
          // 4.2.1 Calculating Freshness Lifetime
          return (
              (this._isShared && this._rescc['s-maxage']) ||
              this._rescc['max-age'] ||
              this._resHeaders.expires
          );
      }

      _assertRequestHasHeaders(req) {
          if (!req || !req.headers) {
              throw Error('Request headers missing');
          }
      }

      satisfiesWithoutRevalidation(req) {
          this._assertRequestHasHeaders(req);

          // When presented with a request, a cache MUST NOT reuse a stored response, unless:
          // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,
          // unless the stored response is successfully validated (Section 4.3), and
          const requestCC = parseCacheControl(req.headers['cache-control']);
          if (requestCC['no-cache'] || /no-cache/.test(req.headers.pragma)) {
              return false;
          }

          if (requestCC['max-age'] && this.age() > requestCC['max-age']) {
              return false;
          }

          if (
              requestCC['min-fresh'] &&
              this.timeToLive() < 1000 * requestCC['min-fresh']
          ) {
              return false;
          }

          // the stored response is either:
          // fresh, or allowed to be served stale
          if (this.stale()) {
              const allowsStale =
                  requestCC['max-stale'] &&
                  !this._rescc['must-revalidate'] &&
                  (true === requestCC['max-stale'] ||
                      requestCC['max-stale'] > this.age() - this.maxAge());
              if (!allowsStale) {
                  return false;
              }
          }

          return this._requestMatches(req, false);
      }

      _requestMatches(req, allowHeadMethod) {
          // The presented effective request URI and that of the stored response match, and
          return (
              (!this._url || this._url === req.url) &&
              this._host === req.headers.host &&
              // the request method associated with the stored response allows it to be used for the presented request, and
              (!req.method ||
                  this._method === req.method ||
                  (allowHeadMethod && 'HEAD' === req.method)) &&
              // selecting header fields nominated by the stored response (if any) match those presented, and
              this._varyMatches(req)
          );
      }

      _allowsStoringAuthenticated() {
          //  following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.
          return (
              this._rescc['must-revalidate'] ||
              this._rescc.public ||
              this._rescc['s-maxage']
          );
      }

      _varyMatches(req) {
          if (!this._resHeaders.vary) {
              return true;
          }

          // A Vary header field-value of "*" always fails to match
          if (this._resHeaders.vary === '*') {
              return false;
          }

          const fields = this._resHeaders.vary
              .trim()
              .toLowerCase()
              .split(/\s*,\s*/);
          for (const name of fields) {
              if (req.headers[name] !== this._reqHeaders[name]) return false;
          }
          return true;
      }

      _copyWithoutHopByHopHeaders(inHeaders) {
          const headers = {};
          for (const name in inHeaders) {
              if (hopByHopHeaders[name]) continue;
              headers[name] = inHeaders[name];
          }
          // 9.1.  Connection
          if (inHeaders.connection) {
              const tokens = inHeaders.connection.trim().split(/\s*,\s*/);
              for (const name of tokens) {
                  delete headers[name];
              }
          }
          if (headers.warning) {
              const warnings = headers.warning.split(/,/).filter(warning => {
                  return !/^\s*1[0-9][0-9]/.test(warning);
              });
              if (!warnings.length) {
                  delete headers.warning;
              } else {
                  headers.warning = warnings.join(',').trim();
              }
          }
          return headers;
      }

      responseHeaders() {
          const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);
          const age = this.age();

          // A cache SHOULD generate 113 warning if it heuristically chose a freshness
          // lifetime greater than 24 hours and the response's age is greater than 24 hours.
          if (
              age > 3600 * 24 &&
              !this._hasExplicitExpiration() &&
              this.maxAge() > 3600 * 24
          ) {
              headers.warning =
                  (headers.warning ? `${headers.warning}, ` : '') +
                  '113 - "rfc7234 5.5.4"';
          }
          headers.age = `${Math.round(age)}`;
          headers.date = new Date(this.now()).toUTCString();
          return headers;
      }

      /**
       * Value of the Date response header or current time if Date was demed invalid
       * @return timestamp
       */
      date() {
          if (this._trustServerDate) {
              return this._serverDate();
          }
          return this._responseTime;
      }

      _serverDate() {
          const dateValue = Date.parse(this._resHeaders.date);
          if (isFinite(dateValue)) {
              const maxClockDrift = 8 * 3600 * 1000;
              const clockDrift = Math.abs(this._responseTime - dateValue);
              if (clockDrift < maxClockDrift) {
                  return dateValue;
              }
          }
          return this._responseTime;
      }

      /**
       * Value of the Age header, in seconds, updated for the current time.
       * May be fractional.
       *
       * @return Number
       */
      age() {
          let age = Math.max(0, (this._responseTime - this.date()) / 1000);
          if (this._resHeaders.age) {
              let ageValue = this._ageValue();
              if (ageValue > age) age = ageValue;
          }

          const residentTime = (this.now() - this._responseTime) / 1000;
          return age + residentTime;
      }

      _ageValue() {
          const ageValue = parseInt(this._resHeaders.age);
          return isFinite(ageValue) ? ageValue : 0;
      }

      /**
       * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.
       *
       * For an up-to-date value, see `timeToLive()`.
       *
       * @return Number
       */
      maxAge() {
          if (!this.storable() || this._rescc['no-cache']) {
              return 0;
          }

          // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default
          // so this implementation requires explicit opt-in via public header
          if (
              this._isShared &&
              (this._resHeaders['set-cookie'] &&
                  !this._rescc.public &&
                  !this._rescc.immutable)
          ) {
              return 0;
          }

          if (this._resHeaders.vary === '*') {
              return 0;
          }

          if (this._isShared) {
              if (this._rescc['proxy-revalidate']) {
                  return 0;
              }
              // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.
              if (this._rescc['s-maxage']) {
                  return parseInt(this._rescc['s-maxage'], 10);
              }
          }

          // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.
          if (this._rescc['max-age']) {
              return parseInt(this._rescc['max-age'], 10);
          }

          const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;

          const dateValue = this._serverDate();
          if (this._resHeaders.expires) {
              const expires = Date.parse(this._resHeaders.expires);
              // A cache recipient MUST interpret invalid date formats, especially the value "0", as representing a time in the past (i.e., "already expired").
              if (Number.isNaN(expires) || expires < dateValue) {
                  return 0;
              }
              return Math.max(defaultMinTtl, (expires - dateValue) / 1000);
          }

          if (this._resHeaders['last-modified']) {
              const lastModified = Date.parse(this._resHeaders['last-modified']);
              if (isFinite(lastModified) && dateValue > lastModified) {
                  return Math.max(
                      defaultMinTtl,
                      ((dateValue - lastModified) / 1000) * this._cacheHeuristic
                  );
              }
          }

          return defaultMinTtl;
      }

      timeToLive() {
          return Math.max(0, this.maxAge() - this.age()) * 1000;
      }

      stale() {
          return this.maxAge() <= this.age();
      }

      static fromObject(obj) {
          return new this(undefined, undefined, { _fromObject: obj });
      }

      _fromObject(obj) {
          if (this._responseTime) throw Error('Reinitialized');
          if (!obj || obj.v !== 1) throw Error('Invalid serialization');

          this._responseTime = obj.t;
          this._isShared = obj.sh;
          this._cacheHeuristic = obj.ch;
          this._immutableMinTtl =
              obj.imm !== undefined ? obj.imm : 24 * 3600 * 1000;
          this._status = obj.st;
          this._resHeaders = obj.resh;
          this._rescc = obj.rescc;
          this._method = obj.m;
          this._url = obj.u;
          this._host = obj.h;
          this._noAuthorization = obj.a;
          this._reqHeaders = obj.reqh;
          this._reqcc = obj.reqcc;
      }

      toObject() {
          return {
              v: 1,
              t: this._responseTime,
              sh: this._isShared,
              ch: this._cacheHeuristic,
              imm: this._immutableMinTtl,
              st: this._status,
              resh: this._resHeaders,
              rescc: this._rescc,
              m: this._method,
              u: this._url,
              h: this._host,
              a: this._noAuthorization,
              reqh: this._reqHeaders,
              reqcc: this._reqcc,
          };
      }

      /**
       * Headers for sending to the origin server to revalidate stale response.
       * Allows server to return 304 to allow reuse of the previous response.
       *
       * Hop by hop headers are always stripped.
       * Revalidation headers may be added or removed, depending on request.
       */
      revalidationHeaders(incomingReq) {
          this._assertRequestHasHeaders(incomingReq);
          const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);

          // This implementation does not understand range requests
          delete headers['if-range'];

          if (!this._requestMatches(incomingReq, true) || !this.storable()) {
              // revalidation allowed via HEAD
              // not for the same resource, or wasn't allowed to be cached anyway
              delete headers['if-none-match'];
              delete headers['if-modified-since'];
              return headers;
          }

          /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */
          if (this._resHeaders.etag) {
              headers['if-none-match'] = headers['if-none-match']
                  ? `${headers['if-none-match']}, ${this._resHeaders.etag}`
                  : this._resHeaders.etag;
          }

          // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.
          const forbidsWeakValidators =
              headers['accept-ranges'] ||
              headers['if-match'] ||
              headers['if-unmodified-since'] ||
              (this._method && this._method != 'GET');

          /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.
          Note: This implementation does not understand partial responses (206) */
          if (forbidsWeakValidators) {
              delete headers['if-modified-since'];

              if (headers['if-none-match']) {
                  const etags = headers['if-none-match']
                      .split(/,/)
                      .filter(etag => {
                          return !/^\s*W\//.test(etag);
                      });
                  if (!etags.length) {
                      delete headers['if-none-match'];
                  } else {
                      headers['if-none-match'] = etags.join(',').trim();
                  }
              }
          } else if (
              this._resHeaders['last-modified'] &&
              !headers['if-modified-since']
          ) {
              headers['if-modified-since'] = this._resHeaders['last-modified'];
          }

          return headers;
      }

      /**
       * Creates new CachePolicy with information combined from the previews response,
       * and the new revalidation response.
       *
       * Returns {policy, modified} where modified is a boolean indicating
       * whether the response body has been modified, and old cached body can't be used.
       *
       * @return {Object} {policy: CachePolicy, modified: Boolean}
       */
      revalidatedPolicy(request, response) {
          this._assertRequestHasHeaders(request);
          if (!response || !response.headers) {
              throw Error('Response headers missing');
          }

          // These aren't going to be supported exactly, since one CachePolicy object
          // doesn't know about all the other cached objects.
          let matches = false;
          if (response.status !== undefined && response.status != 304) {
              matches = false;
          } else if (
              response.headers.etag &&
              !/^\s*W\//.test(response.headers.etag)
          ) {
              // "All of the stored responses with the same strong validator are selected.
              // If none of the stored responses contain the same strong validator,
              // then the cache MUST NOT use the new response to update any stored responses."
              matches =
                  this._resHeaders.etag &&
                  this._resHeaders.etag.replace(/^\s*W\//, '') ===
                      response.headers.etag;
          } else if (this._resHeaders.etag && response.headers.etag) {
              // "If the new response contains a weak validator and that validator corresponds
              // to one of the cache's stored responses,
              // then the most recent of those matching stored responses is selected for update."
              matches =
                  this._resHeaders.etag.replace(/^\s*W\//, '') ===
                  response.headers.etag.replace(/^\s*W\//, '');
          } else if (this._resHeaders['last-modified']) {
              matches =
                  this._resHeaders['last-modified'] ===
                  response.headers['last-modified'];
          } else {
              // If the new response does not include any form of validator (such as in the case where
              // a client generates an If-Modified-Since request from a source other than the Last-Modified
              // response header field), and there is only one stored response, and that stored response also
              // lacks a validator, then that stored response is selected for update.
              if (
                  !this._resHeaders.etag &&
                  !this._resHeaders['last-modified'] &&
                  !response.headers.etag &&
                  !response.headers['last-modified']
              ) {
                  matches = true;
              }
          }

          if (!matches) {
              return {
                  policy: new this.constructor(request, response),
                  // Client receiving 304 without body, even if it's invalid/mismatched has no option
                  // but to reuse a cached body. We don't have a good way to tell clients to do
                  // error recovery in such case.
                  modified: response.status != 304,
                  matches: false,
              };
          }

          // use other header fields provided in the 304 (Not Modified) response to replace all instances
          // of the corresponding header fields in the stored response.
          const headers = {};
          for (const k in this._resHeaders) {
              headers[k] =
                  k in response.headers && !excludedFromRevalidationUpdate[k]
                      ? response.headers[k]
                      : this._resHeaders[k];
          }

          const newResponse = Object.assign({}, response, {
              status: this._status,
              method: this._method,
              headers,
          });
          return {
              policy: new this.constructor(request, newResponse, {
                  shared: this._isShared,
                  cacheHeuristic: this._cacheHeuristic,
                  immutableMinTimeToLive: this._immutableMinTtl,
                  trustServerDate: this._trustServerDate,
              }),
              modified: false,
              matches: true,
          };
      }
  };


  /***/ }),
  /* 77 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const Readable = __webpack_require__(24).Readable;
  const lowercaseKeys = __webpack_require__(78);

  class Response extends Readable {
  	constructor(statusCode, headers, body, url) {
  		if (typeof statusCode !== 'number') {
  			throw new TypeError('Argument `statusCode` should be a number');
  		}
  		if (typeof headers !== 'object') {
  			throw new TypeError('Argument `headers` should be an object');
  		}
  		if (!(body instanceof Buffer)) {
  			throw new TypeError('Argument `body` should be a buffer');
  		}
  		if (typeof url !== 'string') {
  			throw new TypeError('Argument `url` should be a string');
  		}

  		super();
  		this.statusCode = statusCode;
  		this.headers = lowercaseKeys(headers);
  		this.body = body;
  		this.url = url;
  	}

  	_read() {
  		this.push(this.body);
  		this.push(null);
  	}
  }

  module.exports = Response;


  /***/ }),
  /* 78 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  module.exports = function (obj) {
  	var ret = {};
  	var keys = Object.keys(Object(obj));

  	for (var i = 0; i < keys.length; i++) {
  		ret[keys[i].toLowerCase()] = obj[keys[i]];
  	}

  	return ret;
  };


  /***/ }),
  /* 79 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  module.exports = object => {
  	const result = {};

  	for (const [key, value] of Object.entries(object)) {
  		result[key.toLowerCase()] = value;
  	}

  	return result;
  };


  /***/ }),
  /* 80 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const PassThrough = __webpack_require__(24).PassThrough;
  const mimicResponse = __webpack_require__(81);

  const cloneResponse = response => {
  	if (!(response && response.pipe)) {
  		throw new TypeError('Parameter `response` must be a response stream.');
  	}

  	const clone = new PassThrough();
  	mimicResponse(response, clone);

  	return response.pipe(clone);
  };

  module.exports = cloneResponse;


  /***/ }),
  /* 81 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  // We define these manually to ensure they're always copied
  // even if they would move up the prototype chain
  // https://nodejs.org/api/http.html#http_class_http_incomingmessage
  const knownProps = [
  	'destroy',
  	'setTimeout',
  	'socket',
  	'headers',
  	'trailers',
  	'rawHeaders',
  	'statusCode',
  	'httpVersion',
  	'httpVersionMinor',
  	'httpVersionMajor',
  	'rawTrailers',
  	'statusMessage'
  ];

  module.exports = (fromStream, toStream) => {
  	const fromProps = new Set(Object.keys(fromStream).concat(knownProps));

  	for (const prop of fromProps) {
  		// Don't overwrite existing properties
  		if (prop in toStream) {
  			continue;
  		}

  		toStream[prop] = typeof fromStream[prop] === 'function' ? fromStream[prop].bind(fromStream) : fromStream[prop];
  	}
  };


  /***/ }),
  /* 82 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const EventEmitter = __webpack_require__(67);
  const JSONB = __webpack_require__(83);

  const loadStore = opts => {
  	const adapters = {
  		redis: '@keyv/redis',
  		mongodb: '@keyv/mongo',
  		mongo: '@keyv/mongo',
  		sqlite: '@keyv/sqlite',
  		postgresql: '@keyv/postgres',
  		postgres: '@keyv/postgres',
  		mysql: '@keyv/mysql'
  	};
  	if (opts.adapter || opts.uri) {
  		const adapter = opts.adapter || /^[^:]*/.exec(opts.uri)[0];
  		return new (__webpack_require__(84)(adapters[adapter]))(opts);
  	}
  	return new Map();
  };

  class Keyv extends EventEmitter {
  	constructor(uri, opts) {
  		super();
  		this.opts = Object.assign(
  			{
  				namespace: 'keyv',
  				serialize: JSONB.stringify,
  				deserialize: JSONB.parse
  			},
  			(typeof uri === 'string') ? { uri } : uri,
  			opts
  		);

  		if (!this.opts.store) {
  			const adapterOpts = Object.assign({}, this.opts);
  			this.opts.store = loadStore(adapterOpts);
  		}

  		if (typeof this.opts.store.on === 'function') {
  			this.opts.store.on('error', err => this.emit('error', err));
  		}

  		this.opts.store.namespace = this.opts.namespace;
  	}

  	_getKeyPrefix(key) {
  		return `${this.opts.namespace}:${key}`;
  	}

  	get(key) {
  		key = this._getKeyPrefix(key);
  		const store = this.opts.store;
  		return Promise.resolve()
  			.then(() => store.get(key))
  			.then(data => {
  				data = (typeof data === 'string') ? this.opts.deserialize(data) : data;
  				if (data === undefined) {
  					return undefined;
  				}
  				if (typeof data.expires === 'number' && Date.now() > data.expires) {
  					this.delete(key);
  					return undefined;
  				}
  				return data.value;
  			});
  	}

  	set(key, value, ttl) {
  		key = this._getKeyPrefix(key);
  		if (typeof ttl === 'undefined') {
  			ttl = this.opts.ttl;
  		}
  		if (ttl === 0) {
  			ttl = undefined;
  		}
  		const store = this.opts.store;

  		return Promise.resolve()
  			.then(() => {
  				const expires = (typeof ttl === 'number') ? (Date.now() + ttl) : null;
  				value = { value, expires };
  				return store.set(key, this.opts.serialize(value), ttl);
  			})
  			.then(() => true);
  	}

  	delete(key) {
  		key = this._getKeyPrefix(key);
  		const store = this.opts.store;
  		return Promise.resolve()
  			.then(() => store.delete(key));
  	}

  	clear() {
  		const store = this.opts.store;
  		return Promise.resolve()
  			.then(() => store.clear());
  	}
  }

  module.exports = Keyv;


  /***/ }),
  /* 83 */
  /***/ (function(module, exports) {

  //TODO: handle reviver/dehydrate function like normal
  //and handle indentation, like normal.
  //if anyone needs this... please send pull request.

  exports.stringify = function stringify (o) {
    if('undefined' == typeof o) return o

    if(o && Buffer.isBuffer(o))
      return JSON.stringify(':base64:' + o.toString('base64'))

    if(o && o.toJSON)
      o =  o.toJSON()

    if(o && 'object' === typeof o) {
      var s = ''
      var array = Array.isArray(o)
      s = array ? '[' : '{'
      var first = true

      for(var k in o) {
        var ignore = 'function' == typeof o[k] || (!array && 'undefined' === typeof o[k])
        if(Object.hasOwnProperty.call(o, k) && !ignore) {
          if(!first)
            s += ','
          first = false
          if (array) {
            if(o[k] == undefined)
              s += 'null'
            else
              s += stringify(o[k])
          } else if (o[k] !== void(0)) {
            s += stringify(k) + ':' + stringify(o[k])
          }
        }
      }

      s += array ? ']' : '}'

      return s
    } else if ('string' === typeof o) {
      return JSON.stringify(/^:/.test(o) ? ':' + o : o)
    } else if ('undefined' === typeof o) {
      return 'null';
    } else
      return JSON.stringify(o)
  }

  exports.parse = function (s) {
    return JSON.parse(s, function (key, value) {
      if('string' === typeof value) {
        if(/^:base64:/.test(value))
          return new Buffer(value.substring(8), 'base64')
        else
          return /^:/.test(value) ? value.substring(1) : value
      }
      return value
    })
  }


  /***/ }),
  /* 84 */
  /***/ (function(module, exports) {

  function webpackEmptyContext(req) {
  	var e = new Error("Cannot find module '" + req + "'");
  	e.code = 'MODULE_NOT_FOUND';
  	throw e;
  }
  webpackEmptyContext.keys = function() { return []; };
  webpackEmptyContext.resolve = webpackEmptyContext;
  module.exports = webpackEmptyContext;
  webpackEmptyContext.id = 84;

  /***/ }),
  /* 85 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const {Readable} = __webpack_require__(24);

  module.exports = input => (
  	new Readable({
  		read() {
  			this.push(input);
  			this.push(null);
  		}
  	})
  );


  /***/ }),
  /* 86 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const deferToConnect = __webpack_require__(87);

  module.exports = request => {
  	const timings = {
  		start: Date.now(),
  		socket: null,
  		lookup: null,
  		connect: null,
  		upload: null,
  		response: null,
  		end: null,
  		error: null,
  		phases: {
  			wait: null,
  			dns: null,
  			tcp: null,
  			request: null,
  			firstByte: null,
  			download: null,
  			total: null
  		}
  	};

  	const handleError = origin => {
  		const emit = origin.emit.bind(origin);
  		origin.emit = (event, ...args) => {
  			// Catches the `error` event
  			if (event === 'error') {
  				timings.error = Date.now();
  				timings.phases.total = timings.error - timings.start;

  				origin.emit = emit;
  			}

  			// Saves the original behavior
  			return emit(event, ...args);
  		};
  	};

  	let uploadFinished = false;
  	const onUpload = () => {
  		timings.upload = Date.now();
  		timings.phases.request = timings.upload - timings.connect;
  	};

  	handleError(request);

  	request.once('socket', socket => {
  		timings.socket = Date.now();
  		timings.phases.wait = timings.socket - timings.start;

  		const lookupListener = () => {
  			timings.lookup = Date.now();
  			timings.phases.dns = timings.lookup - timings.socket;
  		};

  		socket.once('lookup', lookupListener);

  		deferToConnect(socket, () => {
  			timings.connect = Date.now();

  			if (timings.lookup === null) {
  				socket.removeListener('lookup', lookupListener);
  				timings.lookup = timings.connect;
  				timings.phases.dns = timings.lookup - timings.socket;
  			}

  			timings.phases.tcp = timings.connect - timings.lookup;

  			if (uploadFinished && !timings.upload) {
  				onUpload();
  			}
  		});
  	});

  	request.once('finish', () => {
  		uploadFinished = true;

  		if (timings.connect) {
  			onUpload();
  		}
  	});

  	request.once('response', response => {
  		timings.response = Date.now();
  		timings.phases.firstByte = timings.response - timings.upload;

  		handleError(response);

  		response.once('end', () => {
  			timings.end = Date.now();
  			timings.phases.download = timings.end - timings.response;
  			timings.phases.total = timings.end - timings.start;
  		});
  	});

  	return timings;
  };


  /***/ }),
  /* 87 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  
  
  module.exports = (socket, callback) => {
  	if (socket.writable && !socket.connecting) {
  		callback();
  	} else {
  		socket.once('connect', callback);
  	}
  };


  /***/ }),
  /* 88 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const net = __webpack_require__(89);

  class TimeoutError extends Error {
  	constructor(threshold, event) {
  		super(`Timeout awaiting '${event}' for ${threshold}ms`);
  		this.name = 'TimeoutError';
  		this.code = 'ETIMEDOUT';
  		this.event = event;
  	}
  }

  const reentry = Symbol('reentry');

  const noop = () => {};

  module.exports = (request, delays, options) => {
  	/* istanbul ignore next: this makes sure timed-out isn't called twice */
  	if (request[reentry]) {
  		return;
  	}

  	request[reentry] = true;

  	let stopNewTimeouts = false;

  	const addTimeout = (delay, callback, ...args) => {
  		// An error had been thrown before. Going further would result in uncaught errors.
  		// See https://github.com/sindresorhus/got/issues/631#issuecomment-435675051
  		if (stopNewTimeouts) {
  			return noop;
  		}

  		// Event loop order is timers, poll, immediates.
  		// The timed event may emit during the current tick poll phase, so
  		// defer calling the handler until the poll phase completes.
  		let immediate;
  		const timeout = setTimeout(() => {
  			immediate = setImmediate(callback, delay, ...args);
  			/* istanbul ignore next: added in node v9.7.0 */
  			if (immediate.unref) {
  				immediate.unref();
  			}
  		}, delay);

  		/* istanbul ignore next: in order to support electron renderer */
  		if (timeout.unref) {
  			timeout.unref();
  		}

  		const cancel = () => {
  			clearTimeout(timeout);
  			clearImmediate(immediate);
  		};

  		cancelers.push(cancel);

  		return cancel;
  	};

  	const {host, hostname} = options;
  	const timeoutHandler = (delay, event) => {
  		request.emit('error', new TimeoutError(delay, event));
  		request.once('error', () => {}); // Ignore the `socket hung up` error made by request.abort()

  		request.abort();
  	};

  	const cancelers = [];
  	const cancelTimeouts = () => {
  		stopNewTimeouts = true;
  		cancelers.forEach(cancelTimeout => cancelTimeout());
  	};

  	request.once('error', cancelTimeouts);
  	request.once('response', response => {
  		response.once('end', cancelTimeouts);
  	});

  	if (delays.request !== undefined) {
  		addTimeout(delays.request, timeoutHandler, 'request');
  	}

  	if (delays.socket !== undefined) {
  		const socketTimeoutHandler = () => {
  			timeoutHandler(delays.socket, 'socket');
  		};

  		request.setTimeout(delays.socket, socketTimeoutHandler);

  		// `request.setTimeout(0)` causes a memory leak.
  		// We can just remove the listener and forget about the timer - it's unreffed.
  		// See https://github.com/sindresorhus/got/issues/690
  		cancelers.push(() => request.removeListener('timeout', socketTimeoutHandler));
  	}

  	if (delays.lookup !== undefined && !request.socketPath && !net.isIP(hostname || host)) {
  		request.once('socket', socket => {
  			/* istanbul ignore next: hard to test */
  			if (socket.connecting) {
  				const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');
  				socket.once('lookup', cancelTimeout);
  			}
  		});
  	}

  	if (delays.connect !== undefined) {
  		request.once('socket', socket => {
  			/* istanbul ignore next: hard to test */
  			if (socket.connecting) {
  				const timeConnect = () => addTimeout(delays.connect, timeoutHandler, 'connect');

  				if (request.socketPath || net.isIP(hostname || host)) {
  					socket.once('connect', timeConnect());
  				} else {
  					socket.once('lookup', error => {
  						if (error === null) {
  							socket.once('connect', timeConnect());
  						}
  					});
  				}
  			}
  		});
  	}

  	if (delays.secureConnect !== undefined && options.protocol === 'https:') {
  		request.once('socket', socket => {
  			/* istanbul ignore next: hard to test */
  			if (socket.connecting) {
  				socket.once('connect', () => {
  					const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');
  					socket.once('secureConnect', cancelTimeout);
  				});
  			}
  		});
  	}

  	if (delays.send !== undefined) {
  		request.once('socket', socket => {
  			const timeRequest = () => addTimeout(delays.send, timeoutHandler, 'send');
  			/* istanbul ignore next: hard to test */
  			if (socket.connecting) {
  				socket.once('connect', () => {
  					request.once('upload-complete', timeRequest());
  				});
  			} else {
  				request.once('upload-complete', timeRequest());
  			}
  		});
  	}

  	if (delays.response !== undefined) {
  		request.once('upload-complete', () => {
  			const cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');
  			request.once('response', cancelTimeout);
  		});
  	}
  };

  module.exports.TimeoutError = TimeoutError;


  /***/ }),
  /* 89 */
  /***/ (function(module, exports) {

  module.exports = require("net");

  /***/ }),
  /* 90 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const fs = __webpack_require__(7);
  const util = __webpack_require__(25);
  const is = __webpack_require__(63);
  const isFormData = __webpack_require__(91);

  module.exports = async options => {
  	const {body} = options;

  	if (options.headers['content-length']) {
  		return Number(options.headers['content-length']);
  	}

  	if (!body && !options.stream) {
  		return 0;
  	}

  	if (is.string(body)) {
  		return Buffer.byteLength(body);
  	}

  	if (isFormData(body)) {
  		return util.promisify(body.getLength.bind(body))();
  	}

  	if (body instanceof fs.ReadStream) {
  		const {size} = await util.promisify(fs.stat)(body.path);
  		return size;
  	}

  	return null;
  };


  /***/ }),
  /* 91 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const is = __webpack_require__(63);

  module.exports = body => is.nodeStream(body) && is.function(body.getBoundary);


  /***/ }),
  /* 92 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const decompressResponse = __webpack_require__(93);
  const is = __webpack_require__(63);
  const mimicResponse = __webpack_require__(81);
  const progress = __webpack_require__(95);

  module.exports = (response, options, emitter) => {
  	const downloadBodySize = Number(response.headers['content-length']) || null;

  	const progressStream = progress.download(response, emitter, downloadBodySize);

  	mimicResponse(response, progressStream);

  	const newResponse = options.decompress === true &&
  		is.function(decompressResponse) &&
  		options.method !== 'HEAD' ? decompressResponse(progressStream) : progressStream;

  	if (!options.decompress && ['gzip', 'deflate'].includes(response.headers['content-encoding'])) {
  		options.encoding = null;
  	}

  	emitter.emit('response', newResponse);

  	emitter.emit('downloadProgress', {
  		percent: 0,
  		transferred: 0,
  		total: downloadBodySize
  	});

  	response.pipe(progressStream);
  };


  /***/ }),
  /* 93 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const PassThrough = __webpack_require__(24).PassThrough;
  const zlib = __webpack_require__(94);
  const mimicResponse = __webpack_require__(81);

  module.exports = response => {
  	// TODO: Use Array#includes when targeting Node.js 6
  	if (['gzip', 'deflate'].indexOf(response.headers['content-encoding']) === -1) {
  		return response;
  	}

  	const unzip = zlib.createUnzip();
  	const stream = new PassThrough();

  	mimicResponse(response, stream);

  	unzip.on('error', err => {
  		if (err.code === 'Z_BUF_ERROR') {
  			stream.end();
  			return;
  		}

  		stream.emit('error', err);
  	});

  	response.pipe(unzip).pipe(stream);

  	return stream;
  };


  /***/ }),
  /* 94 */
  /***/ (function(module, exports) {

  module.exports = require("zlib");

  /***/ }),
  /* 95 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const {Transform} = __webpack_require__(24);

  module.exports = {
  	download(response, emitter, downloadBodySize) {
  		let downloaded = 0;

  		return new Transform({
  			transform(chunk, encoding, callback) {
  				downloaded += chunk.length;

  				const percent = downloadBodySize ? downloaded / downloadBodySize : 0;

  				// Let `flush()` be responsible for emitting the last event
  				if (percent < 1) {
  					emitter.emit('downloadProgress', {
  						percent,
  						transferred: downloaded,
  						total: downloadBodySize
  					});
  				}

  				callback(null, chunk);
  			},

  			flush(callback) {
  				emitter.emit('downloadProgress', {
  					percent: 1,
  					transferred: downloaded,
  					total: downloadBodySize
  				});

  				callback();
  			}
  		});
  	},

  	upload(request, emitter, uploadBodySize) {
  		const uploadEventFrequency = 150;
  		let uploaded = 0;
  		let progressInterval;

  		emitter.emit('uploadProgress', {
  			percent: 0,
  			transferred: 0,
  			total: uploadBodySize
  		});

  		request.once('error', () => {
  			clearInterval(progressInterval);
  		});

  		request.once('response', () => {
  			clearInterval(progressInterval);

  			emitter.emit('uploadProgress', {
  				percent: 1,
  				transferred: uploaded,
  				total: uploadBodySize
  			});
  		});

  		request.once('socket', socket => {
  			const onSocketConnect = () => {
  				progressInterval = setInterval(() => {
  					const lastUploaded = uploaded;
  					/* istanbul ignore next: see #490 (occurs randomly!) */
  					const headersSize = request._header ? Buffer.byteLength(request._header) : 0;
  					uploaded = socket.bytesWritten - headersSize;

  					// Don't emit events with unchanged progress and
  					// prevent last event from being emitted, because
  					// it's emitted when `response` is emitted
  					if (uploaded === lastUploaded || uploaded === uploadBodySize) {
  						return;
  					}

  					emitter.emit('uploadProgress', {
  						percent: uploadBodySize ? uploaded / uploadBodySize : 0,
  						transferred: uploaded,
  						total: uploadBodySize
  					});
  				}, uploadEventFrequency);
  			};

  			/* istanbul ignore next: hard to test */
  			if (socket.connecting) {
  				socket.once('connect', onSocketConnect);
  			} else if (socket.writable) {
  				// The socket is being reused from pool,
  				// so the connect event will not be emitted
  				onSocketConnect();
  			}
  		});
  	}
  };


  /***/ }),
  /* 96 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const is = __webpack_require__(63);

  module.exports = url => {
  	const options = {
  		protocol: url.protocol,
  		hostname: url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,
  		hash: url.hash,
  		search: url.search,
  		pathname: url.pathname,
  		href: url.href
  	};

  	if (is.string(url.port) && url.port.length > 0) {
  		options.port = Number(url.port);
  	}

  	if (url.username || url.password) {
  		options.auth = `${url.username}:${url.password}`;
  	}

  	options.path = is.null(url.search) ? url.pathname : `${url.pathname}${url.search}`;

  	return options;
  };


  /***/ }),
  /* 97 */
  /***/ (function(module, exports) {

  function webpackEmptyContext(req) {
  	var e = new Error("Cannot find module '" + req + "'");
  	e.code = 'MODULE_NOT_FOUND';
  	throw e;
  }
  webpackEmptyContext.keys = function() { return []; };
  webpackEmptyContext.resolve = webpackEmptyContext;
  module.exports = webpackEmptyContext;
  webpackEmptyContext.id = 97;

  /***/ }),
  /* 98 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const EventEmitter = __webpack_require__(67);
  const getStream = __webpack_require__(99);
  const is = __webpack_require__(63);
  const PCancelable = __webpack_require__(62);
  const requestAsEventEmitter = __webpack_require__(66);
  const {HTTPError, ParseError, ReadError} = __webpack_require__(60);
  const {options: mergeOptions} = __webpack_require__(101);
  const {reNormalize} = __webpack_require__(103);

  const asPromise = options => {
  	const proxy = new EventEmitter();

  	const promise = new PCancelable((resolve, reject, onCancel) => {
  		const emitter = requestAsEventEmitter(options);

  		onCancel(emitter.abort);

  		emitter.on('response', async response => {
  			proxy.emit('response', response);

  			const stream = is.null(options.encoding) ? getStream.buffer(response) : getStream(response, options);

  			let data;
  			try {
  				data = await stream;
  			} catch (error) {
  				reject(new ReadError(error, options));
  				return;
  			}

  			const limitStatusCode = options.followRedirect ? 299 : 399;

  			response.body = data;

  			try {
  				for (const [index, hook] of Object.entries(options.hooks.afterResponse)) {
  					// eslint-disable-next-line no-await-in-loop
  					response = await hook(response, updatedOptions => {
  						updatedOptions = reNormalize(mergeOptions(options, {
  							...updatedOptions,
  							retry: 0,
  							throwHttpErrors: false
  						}));

  						// Remove any further hooks for that request, because we we'll call them anyway.
  						// The loop continues. We don't want duplicates (asPromise recursion).
  						updatedOptions.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);

  						return asPromise(updatedOptions);
  					});
  				}
  			} catch (error) {
  				reject(error);
  				return;
  			}

  			const {statusCode} = response;

  			if (options.json && response.body) {
  				try {
  					response.body = JSON.parse(response.body);
  				} catch (error) {
  					if (statusCode >= 200 && statusCode < 300) {
  						const parseError = new ParseError(error, statusCode, options, data);
  						Object.defineProperty(parseError, 'response', {value: response});
  						reject(parseError);
  						return;
  					}
  				}
  			}

  			if (statusCode !== 304 && (statusCode < 200 || statusCode > limitStatusCode)) {
  				const error = new HTTPError(response, options);
  				Object.defineProperty(error, 'response', {value: response});
  				if (emitter.retry(error) === false) {
  					if (options.throwHttpErrors) {
  						reject(error);
  						return;
  					}

  					resolve(response);
  				}

  				return;
  			}

  			resolve(response);
  		});

  		emitter.once('error', reject);
  		[
  			'request',
  			'redirect',
  			'uploadProgress',
  			'downloadProgress'
  		].forEach(event => emitter.on(event, (...args) => proxy.emit(event, ...args)));
  	});

  	promise.on = (name, fn) => {
  		proxy.on(name, fn);
  		return promise;
  	};

  	return promise;
  };

  module.exports = asPromise;


  /***/ }),
  /* 99 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const pump = __webpack_require__(71);
  const bufferStream = __webpack_require__(100);

  class MaxBufferError extends Error {
  	constructor() {
  		super('maxBuffer exceeded');
  		this.name = 'MaxBufferError';
  	}
  }

  function getStream(inputStream, options) {
  	if (!inputStream) {
  		return Promise.reject(new Error('Expected a stream'));
  	}

  	options = Object.assign({maxBuffer: Infinity}, options);

  	const {maxBuffer} = options;

  	let stream;
  	return new Promise((resolve, reject) => {
  		const rejectPromise = error => {
  			if (error) { // A null check
  				error.bufferedData = stream.getBufferedValue();
  			}
  			reject(error);
  		};

  		stream = pump(inputStream, bufferStream(options), error => {
  			if (error) {
  				rejectPromise(error);
  				return;
  			}

  			resolve();
  		});

  		stream.on('data', () => {
  			if (stream.getBufferedLength() > maxBuffer) {
  				rejectPromise(new MaxBufferError());
  			}
  		});
  	}).then(() => stream.getBufferedValue());
  }

  module.exports = getStream;
  module.exports.buffer = (stream, options) => getStream(stream, Object.assign({}, options, {encoding: 'buffer'}));
  module.exports.array = (stream, options) => getStream(stream, Object.assign({}, options, {array: true}));
  module.exports.MaxBufferError = MaxBufferError;


  /***/ }),
  /* 100 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const {PassThrough} = __webpack_require__(24);

  module.exports = options => {
  	options = Object.assign({}, options);

  	const {array} = options;
  	let {encoding} = options;
  	const buffer = encoding === 'buffer';
  	let objectMode = false;

  	if (array) {
  		objectMode = !(encoding || buffer);
  	} else {
  		encoding = encoding || 'utf8';
  	}

  	if (buffer) {
  		encoding = null;
  	}

  	let len = 0;
  	const ret = [];
  	const stream = new PassThrough({objectMode});

  	if (encoding) {
  		stream.setEncoding(encoding);
  	}

  	stream.on('data', chunk => {
  		ret.push(chunk);

  		if (objectMode) {
  			len = ret.length;
  		} else {
  			len += chunk.length;
  		}
  	});

  	stream.getBufferedValue = () => {
  		if (array) {
  			return ret;
  		}

  		return buffer ? Buffer.concat(ret, len) : ret.join('');
  	};

  	stream.getBufferedLength = () => len;

  	return stream;
  };


  /***/ }),
  /* 101 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const {URL} = __webpack_require__(61);
  const is = __webpack_require__(63);
  const knownHookEvents = __webpack_require__(102);

  const merge = (target, ...sources) => {
  	for (const source of sources) {
  		for (const [key, sourceValue] of Object.entries(source)) {
  			if (is.undefined(sourceValue)) {
  				continue;
  			}

  			const targetValue = target[key];
  			if (is.urlInstance(targetValue) && (is.urlInstance(sourceValue) || is.string(sourceValue))) {
  				target[key] = new URL(sourceValue, targetValue);
  			} else if (is.plainObject(sourceValue)) {
  				if (is.plainObject(targetValue)) {
  					target[key] = merge({}, targetValue, sourceValue);
  				} else {
  					target[key] = merge({}, sourceValue);
  				}
  			} else if (is.array(sourceValue)) {
  				target[key] = merge([], sourceValue);
  			} else {
  				target[key] = sourceValue;
  			}
  		}
  	}

  	return target;
  };

  const mergeOptions = (...sources) => {
  	sources = sources.map(source => source || {});
  	const merged = merge({}, ...sources);

  	const hooks = {};
  	for (const hook of knownHookEvents) {
  		hooks[hook] = [];
  	}

  	for (const source of sources) {
  		if (source.hooks) {
  			for (const hook of knownHookEvents) {
  				hooks[hook] = hooks[hook].concat(source.hooks[hook]);
  			}
  		}
  	}

  	merged.hooks = hooks;

  	return merged;
  };

  const mergeInstances = (instances, methods) => {
  	const handlers = instances.map(instance => instance.defaults.handler);
  	const size = instances.length - 1;

  	return {
  		methods,
  		options: mergeOptions(...instances.map(instance => instance.defaults.options)),
  		handler: (options, next) => {
  			let iteration = -1;
  			const iterate = options => handlers[++iteration](options, iteration === size ? next : iterate);

  			return iterate(options);
  		}
  	};
  };

  module.exports = merge;
  module.exports.options = mergeOptions;
  module.exports.instances = mergeInstances;


  /***/ }),
  /* 102 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  module.exports = [
  	'beforeError',
  	'init',
  	'beforeRequest',
  	'beforeRedirect',
  	'beforeRetry',
  	'afterResponse'
  ];


  /***/ }),
  /* 103 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const {URL, URLSearchParams} = __webpack_require__(61); // TODO: Use the `URL` global when targeting Node.js 10
  const urlLib = __webpack_require__(61);
  const is = __webpack_require__(63);
  const urlParseLax = __webpack_require__(104);
  const lowercaseKeys = __webpack_require__(78);
  const urlToOptions = __webpack_require__(96);
  const isFormData = __webpack_require__(91);
  const merge = __webpack_require__(101);
  const knownHookEvents = __webpack_require__(102);

  const retryAfterStatusCodes = new Set([413, 429, 503]);

  // `preNormalize` handles static options (e.g. headers).
  // For example, when you create a custom instance and make a request
  // with no static changes, they won't be normalized again.
  //
  // `normalize` operates on dynamic options - they cannot be saved.
  // For example, `body` is everytime different per request.
  // When it's done normalizing the new options, it performs merge()
  // on the prenormalized options and the normalized ones.

  const preNormalize = (options, defaults) => {
  	if (is.nullOrUndefined(options.headers)) {
  		options.headers = {};
  	} else {
  		options.headers = lowercaseKeys(options.headers);
  	}

  	if (options.baseUrl && !options.baseUrl.toString().endsWith('/')) {
  		options.baseUrl += '/';
  	}

  	if (options.stream) {
  		options.json = false;
  	}

  	if (is.nullOrUndefined(options.hooks)) {
  		options.hooks = {};
  	} else if (!is.object(options.hooks)) {
  		throw new TypeError(`Parameter \`hooks\` must be an object, not ${is(options.hooks)}`);
  	}

  	for (const event of knownHookEvents) {
  		if (is.nullOrUndefined(options.hooks[event])) {
  			if (defaults) {
  				options.hooks[event] = [...defaults.hooks[event]];
  			} else {
  				options.hooks[event] = [];
  			}
  		}
  	}

  	if (is.number(options.timeout)) {
  		options.gotTimeout = {request: options.timeout};
  	} else if (is.object(options.timeout)) {
  		options.gotTimeout = options.timeout;
  	}

  	delete options.timeout;

  	const {retry} = options;
  	options.retry = {
  		retries: 0,
  		methods: [],
  		statusCodes: [],
  		errorCodes: []
  	};

  	if (is.nonEmptyObject(defaults) && retry !== false) {
  		options.retry = {...defaults.retry};
  	}

  	if (retry !== false) {
  		if (is.number(retry)) {
  			options.retry.retries = retry;
  		} else {
  			options.retry = {...options.retry, ...retry};
  		}
  	}

  	if (options.gotTimeout) {
  		options.retry.maxRetryAfter = Math.min(...[options.gotTimeout.request, options.gotTimeout.connection].filter(n => !is.nullOrUndefined(n)));
  	}

  	if (is.array(options.retry.methods)) {
  		options.retry.methods = new Set(options.retry.methods.map(method => method.toUpperCase()));
  	}

  	if (is.array(options.retry.statusCodes)) {
  		options.retry.statusCodes = new Set(options.retry.statusCodes);
  	}

  	if (is.array(options.retry.errorCodes)) {
  		options.retry.errorCodes = new Set(options.retry.errorCodes);
  	}

  	return options;
  };

  const normalize = (url, options, defaults) => {
  	if (is.plainObject(url)) {
  		options = {...url, ...options};
  		url = options.url || {};
  		delete options.url;
  	}

  	if (defaults) {
  		options = merge({}, defaults.options, options ? preNormalize(options, defaults.options) : {});
  	} else {
  		options = merge({}, preNormalize(options));
  	}

  	if (!is.string(url) && !is.object(url)) {
  		throw new TypeError(`Parameter \`url\` must be a string or object, not ${is(url)}`);
  	}

  	if (is.string(url)) {
  		if (options.baseUrl) {
  			if (url.toString().startsWith('/')) {
  				url = url.toString().slice(1);
  			}

  			url = urlToOptions(new URL(url, options.baseUrl));
  		} else {
  			url = url.replace(/^unix:/, 'http://$&');
  			url = urlParseLax(url);
  		}
  	} else if (is(url) === 'URL') {
  		url = urlToOptions(url);
  	}

  	// Override both null/undefined with default protocol
  	options = merge({path: ''}, url, {protocol: url.protocol || 'https:'}, options);

  	for (const hook of options.hooks.init) {
  		const called = hook(options);

  		if (is.promise(called)) {
  			throw new TypeError('The `init` hook must be a synchronous function');
  		}
  	}

  	const {baseUrl} = options;
  	Object.defineProperty(options, 'baseUrl', {
  		set: () => {
  			throw new Error('Failed to set baseUrl. Options are normalized already.');
  		},
  		get: () => baseUrl
  	});

  	const {query} = options;
  	if (is.nonEmptyString(query) || is.nonEmptyObject(query) || query instanceof URLSearchParams) {
  		if (!is.string(query)) {
  			options.query = (new URLSearchParams(query)).toString();
  		}

  		options.path = `${options.path.split('?')[0]}?${options.query}`;
  		delete options.query;
  	}

  	if (options.hostname === 'unix') {
  		const matches = /(.+?):(.+)/.exec(options.path);

  		if (matches) {
  			const [, socketPath, path] = matches;
  			options = {
  				...options,
  				socketPath,
  				path,
  				host: null
  			};
  		}
  	}

  	const {headers} = options;
  	for (const [key, value] of Object.entries(headers)) {
  		if (is.nullOrUndefined(value)) {
  			delete headers[key];
  		}
  	}

  	if (options.json && is.undefined(headers.accept)) {
  		headers.accept = 'application/json';
  	}

  	if (options.decompress && is.undefined(headers['accept-encoding'])) {
  		headers['accept-encoding'] = 'gzip, deflate';
  	}

  	const {body} = options;
  	if (is.nullOrUndefined(body)) {
  		options.method = options.method ? options.method.toUpperCase() : 'GET';
  	} else {
  		const isObject = is.object(body) && !is.buffer(body) && !is.nodeStream(body);
  		if (!is.nodeStream(body) && !is.string(body) && !is.buffer(body) && !(options.form || options.json)) {
  			throw new TypeError('The `body` option must be a stream.Readable, string or Buffer');
  		}

  		if (options.json && !(isObject || is.array(body))) {
  			throw new TypeError('The `body` option must be an Object or Array when the `json` option is used');
  		}

  		if (options.form && !isObject) {
  			throw new TypeError('The `body` option must be an Object when the `form` option is used');
  		}

  		if (isFormData(body)) {
  			// Special case for https://github.com/form-data/form-data
  			headers['content-type'] = headers['content-type'] || `multipart/form-data; boundary=${body.getBoundary()}`;
  		} else if (options.form) {
  			headers['content-type'] = headers['content-type'] || 'application/x-www-form-urlencoded';
  			options.body = (new URLSearchParams(body)).toString();
  		} else if (options.json) {
  			headers['content-type'] = headers['content-type'] || 'application/json';
  			options.body = JSON.stringify(body);
  		}

  		options.method = options.method ? options.method.toUpperCase() : 'POST';
  	}

  	if (!is.function(options.retry.retries)) {
  		const {retries} = options.retry;

  		options.retry.retries = (iteration, error) => {
  			if (iteration > retries) {
  				return 0;
  			}

  			if ((!error || !options.retry.errorCodes.has(error.code)) && (!options.retry.methods.has(error.method) || !options.retry.statusCodes.has(error.statusCode))) {
  				return 0;
  			}

  			if (Reflect.has(error, 'headers') && Reflect.has(error.headers, 'retry-after') && retryAfterStatusCodes.has(error.statusCode)) {
  				let after = Number(error.headers['retry-after']);
  				if (is.nan(after)) {
  					after = Date.parse(error.headers['retry-after']) - Date.now();
  				} else {
  					after *= 1000;
  				}

  				if (after > options.retry.maxRetryAfter) {
  					return 0;
  				}

  				return after;
  			}

  			if (error.statusCode === 413) {
  				return 0;
  			}

  			const noise = Math.random() * 100;
  			return ((2 ** (iteration - 1)) * 1000) + noise;
  		};
  	}

  	return options;
  };

  const reNormalize = options => normalize(urlLib.format(options), options);

  module.exports = normalize;
  module.exports.preNormalize = preNormalize;
  module.exports.reNormalize = reNormalize;


  /***/ }),
  /* 104 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const url = __webpack_require__(61);
  const prependHttp = __webpack_require__(105);

  module.exports = (input, options) => {
  	if (typeof input !== 'string') {
  		throw new TypeError(`Expected \`url\` to be of type \`string\`, got \`${typeof input}\` instead.`);
  	}

  	const finalUrl = prependHttp(input, Object.assign({https: true}, options));
  	return url.parse(finalUrl);
  };


  /***/ }),
  /* 105 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  module.exports = (url, opts) => {
  	if (typeof url !== 'string') {
  		throw new TypeError(`Expected \`url\` to be of type \`string\`, got \`${typeof url}\``);
  	}

  	url = url.trim();
  	opts = Object.assign({https: false}, opts);

  	if (/^\.*\/|^(?!localhost)\w+:/.test(url)) {
  		return url;
  	}

  	return url.replace(/^(?!(?:\w+:)?\/\/)/, opts.https ? 'https://' : 'http://');
  };


  /***/ }),
  /* 106 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const is = __webpack_require__(63);

  module.exports = function deepFreeze(object) {
  	for (const [key, value] of Object.entries(object)) {
  		if (is.plainObject(value) || is.array(value)) {
  			deepFreeze(object[key]);
  		}
  	}

  	return Object.freeze(object);
  };


  /***/ }),
  /* 107 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const util = __webpack_require__(25);
  const braces = __webpack_require__(108);
  const picomatch = __webpack_require__(118);
  const utils = __webpack_require__(121);
  const isEmptyString = val => typeof val === 'string' && (val === '' || val === './');

  /**
   * Returns an array of strings that match one or more glob patterns.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm(list, patterns[, options]);
   *
   * console.log(mm(['a.js', 'a.txt'], ['*.js']));
   * //=> [ 'a.js' ]
   * ```
   * @param {String|Array<string>} list List of strings to match.
   * @param {String|Array<string>} patterns One or more glob patterns to use for matching.
   * @param {Object} options See available [options](#options)
   * @return {Array} Returns an array of matches
   * @summary false
   * @api public
   */

  const micromatch = (list, patterns, options) => {
    patterns = [].concat(patterns);
    list = [].concat(list);

    let omit = new Set();
    let keep = new Set();
    let items = new Set();
    let negatives = 0;

    let onResult = state => {
      items.add(state.output);
      if (options && options.onResult) {
        options.onResult(state);
      }
    };

    for (let i = 0; i < patterns.length; i++) {
      let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
      let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
      if (negated) negatives++;

      for (let item of list) {
        let matched = isMatch(item, true);

        let match = negated ? !matched.isMatch : matched.isMatch;
        if (!match) continue;

        if (negated) {
          omit.add(matched.output);
        } else {
          omit.delete(matched.output);
          keep.add(matched.output);
        }
      }
    }

    let result = negatives === patterns.length ? [...items] : [...keep];
    let matches = result.filter(item => !omit.has(item));

    if (options && matches.length === 0) {
      if (options.failglob === true) {
        throw new Error(`No matches found for "${patterns.join(', ')}"`);
      }

      if (options.nonull === true || options.nullglob === true) {
        return options.unescape ? patterns.map(p => p.replace(/\\/g, '')) : patterns;
      }
    }

    return matches;
  };

  /**
   * Backwards compatibility
   */

  micromatch.match = micromatch;

  /**
   * Returns a matcher function from the given glob `pattern` and `options`.
   * The returned function takes a string to match as its only argument and returns
   * true if the string is a match.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.matcher(pattern[, options]);
   *
   * const isMatch = mm.matcher('*.!(*a)');
   * console.log(isMatch('a.a')); //=> false
   * console.log(isMatch('a.b')); //=> true
   * ```
   * @param {String} `pattern` Glob pattern
   * @param {Object} `options`
   * @return {Function} Returns a matcher function.
   * @api public
   */

  micromatch.matcher = (pattern, options) => picomatch(pattern, options);

  /**
   * Returns true if **any** of the given glob `patterns` match the specified `string`.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.isMatch(string, patterns[, options]);
   *
   * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true
   * console.log(mm.isMatch('a.a', 'b.*')); //=> false
   * ```
   * @param {String} str The string to test.
   * @param {String|Array} patterns One or more glob patterns to use for matching.
   * @param {Object} [options] See available [options](#options).
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */

  micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

  /**
   * Backwards compatibility
   */

  micromatch.any = micromatch.isMatch;

  /**
   * Returns a list of strings that _**do not match any**_ of the given `patterns`.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.not(list, patterns[, options]);
   *
   * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
   * //=> ['b.b', 'c.c']
   * ```
   * @param {Array} `list` Array of strings to match.
   * @param {String|Array} `patterns` One or more glob pattern to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Array} Returns an array of strings that **do not match** the given patterns.
   * @api public
   */

  micromatch.not = (list, patterns, options = {}) => {
    patterns = [].concat(patterns).map(String);
    let result = new Set();
    let items = [];

    let onResult = state => {
      if (options.onResult) options.onResult(state);
      items.push(state.output);
    };

    let matches = micromatch(list, patterns, { ...options, onResult });

    for (let item of items) {
      if (!matches.includes(item)) {
        result.add(item);
      }
    }
    return [...result];
  };

  /**
   * Returns true if the given `string` contains the given pattern. Similar
   * to [.isMatch](#isMatch) but the pattern can match any part of the string.
   *
   * ```js
   * var mm = require('micromatch');
   * // mm.contains(string, pattern[, options]);
   *
   * console.log(mm.contains('aa/bb/cc', '*b'));
   * //=> true
   * console.log(mm.contains('aa/bb/cc', '*d'));
   * //=> false
   * ```
   * @param {String} `str` The string to match.
   * @param {String|Array} `patterns` Glob pattern to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if the patter matches any part of `str`.
   * @api public
   */

  micromatch.contains = (str, pattern, options) => {
    if (typeof str !== 'string') {
      throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
    }

    if (Array.isArray(pattern)) {
      return pattern.some(p => micromatch.contains(str, p, options));
    }

    if (typeof pattern === 'string') {
      if (isEmptyString(str) || isEmptyString(pattern)) {
        return false;
      }

      if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {
        return true;
      }
    }

    return micromatch.isMatch(str, pattern, { ...options, contains: true });
  };

  /**
   * Filter the keys of the given object with the given `glob` pattern
   * and `options`. Does not attempt to match nested keys. If you need this feature,
   * use [glob-object][] instead.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.matchKeys(object, patterns[, options]);
   *
   * const obj = { aa: 'a', ab: 'b', ac: 'c' };
   * console.log(mm.matchKeys(obj, '*b'));
   * //=> { ab: 'b' }
   * ```
   * @param {Object} `object` The object with keys to filter.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Object} Returns an object with only keys that match the given patterns.
   * @api public
   */

  micromatch.matchKeys = (obj, patterns, options) => {
    if (!utils.isObject(obj)) {
      throw new TypeError('Expected the first argument to be an object');
    }
    let keys = micromatch(Object.keys(obj), patterns, options);
    let res = {};
    for (let key of keys) res[key] = obj[key];
    return res;
  };

  /**
   * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.some(list, patterns[, options]);
   *
   * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
   * // true
   * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
   * // false
   * ```
   * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */

  micromatch.some = (list, patterns, options) => {
    let items = [].concat(list);

    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch(String(pattern), options);
      if (items.some(item => isMatch(item))) {
        return true;
      }
    }
    return false;
  };

  /**
   * Returns true if every string in the given `list` matches
   * any of the given glob `patterns`.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.every(list, patterns[, options]);
   *
   * console.log(mm.every('foo.js', ['foo.js']));
   * // true
   * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
   * // true
   * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
   * // false
   * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
   * // false
   * ```
   * @param {String|Array} `list` The string or array of strings to test.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */

  micromatch.every = (list, patterns, options) => {
    let items = [].concat(list);

    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch(String(pattern), options);
      if (!items.every(item => isMatch(item))) {
        return false;
      }
    }
    return true;
  };

  /**
   * Returns true if **all** of the given `patterns` match
   * the specified string.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.all(string, patterns[, options]);
   *
   * console.log(mm.all('foo.js', ['foo.js']));
   * // true
   *
   * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
   * // false
   *
   * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
   * // true
   *
   * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
   * // true
   * ```
   * @param {String|Array} `str` The string to test.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */

  micromatch.all = (str, patterns, options) => {
    if (typeof str !== 'string') {
      throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
    }

    return [].concat(patterns).every(p => picomatch(p, options)(str));
  };

  /**
   * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.capture(pattern, string[, options]);
   *
   * console.log(mm.capture('test/*.js', 'test/foo.js'));
   * //=> ['foo']
   * console.log(mm.capture('test/*.js', 'foo/bar.css'));
   * //=> null
   * ```
   * @param {String} `glob` Glob pattern to use for matching.
   * @param {String} `input` String to match
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns an array of captures if the input matches the glob pattern, otherwise `null`.
   * @api public
   */

  micromatch.capture = (glob, input, options) => {
    let posix = utils.isWindows(options);
    let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
    let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);

    if (match) {
      return match.slice(1).map(v => v === void 0 ? '' : v);
    }
  };

  /**
   * Create a regular expression from the given glob `pattern`.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.makeRe(pattern[, options]);
   *
   * console.log(mm.makeRe('*.js'));
   * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
   * ```
   * @param {String} `pattern` A glob pattern to convert to regex.
   * @param {Object} `options`
   * @return {RegExp} Returns a regex created from the given pattern.
   * @api public
   */

  micromatch.makeRe = (...args) => picomatch.makeRe(...args);

  /**
   * Scan a glob pattern to separate the pattern into segments. Used
   * by the [split](#split) method.
   *
   * ```js
   * const mm = require('micromatch');
   * const state = mm.scan(pattern[, options]);
   * ```
   * @param {String} `pattern`
   * @param {Object} `options`
   * @return {Object} Returns an object with
   * @api public
   */

  micromatch.scan = (...args) => picomatch.scan(...args);

  /**
   * Parse a glob pattern to create the source string for a regular
   * expression.
   *
   * ```js
   * const mm = require('micromatch');
   * const state = mm(pattern[, options]);
   * ```
   * @param {String} `glob`
   * @param {Object} `options`
   * @return {Object} Returns an object with useful properties and output to be used as regex source string.
   * @api public
   */

  micromatch.parse = (patterns, options) => {
    let res = [];
    for (let pattern of [].concat(patterns || [])) {
      for (let str of braces(String(pattern), options)) {
        res.push(picomatch.parse(str, options));
      }
    }
    return res;
  };

  /**
   * Process the given brace `pattern`.
   *
   * ```js
   * const { braces } = require('micromatch');
   * console.log(braces('foo/{a,b,c}/bar'));
   * //=> [ 'foo/(a|b|c)/bar' ]
   *
   * console.log(braces('foo/{a,b,c}/bar', { expand: true }));
   * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]
   * ```
   * @param {String} `pattern` String with brace pattern to process.
   * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
   * @return {Array}
   * @api public
   */

  micromatch.braces = (pattern, options) => {
    if (typeof pattern !== 'string') throw new TypeError('Expected a string');
    if ((options && options.nobrace === true) || !/\{.*\}/.test(pattern)) {
      return [pattern];
    }
    return braces(pattern, options);
  };

  /**
   * Expand braces
   */

  micromatch.braceExpand = (pattern, options) => {
    if (typeof pattern !== 'string') throw new TypeError('Expected a string');
    return micromatch.braces(pattern, { ...options, expand: true });
  };

  /**
   * Expose micromatch
   */

  module.exports = micromatch;


  /***/ }),
  /* 108 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const stringify = __webpack_require__(109);
  const compile = __webpack_require__(111);
  const expand = __webpack_require__(115);
  const parse = __webpack_require__(116);

  /**
   * Expand the given pattern or create a regex-compatible string.
   *
   * ```js
   * const braces = require('braces');
   * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
   * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
   * ```
   * @param {String} `str`
   * @param {Object} `options`
   * @return {String}
   * @api public
   */

  const braces = (input, options = {}) => {
    let output = [];

    if (Array.isArray(input)) {
      for (let pattern of input) {
        let result = braces.create(pattern, options);
        if (Array.isArray(result)) {
          output.push(...result);
        } else {
          output.push(result);
        }
      }
    } else {
      output = [].concat(braces.create(input, options));
    }

    if (options && options.expand === true && options.nodupes === true) {
      output = [...new Set(output)];
    }
    return output;
  };

  /**
   * Parse the given `str` with the given `options`.
   *
   * ```js
   * // braces.parse(pattern, [, options]);
   * const ast = braces.parse('a/{b,c}/d');
   * console.log(ast);
   * ```
   * @param {String} pattern Brace pattern to parse
   * @param {Object} options
   * @return {Object} Returns an AST
   * @api public
   */

  braces.parse = (input, options = {}) => parse(input, options);

  /**
   * Creates a braces string from an AST, or an AST node.
   *
   * ```js
   * const braces = require('braces');
   * let ast = braces.parse('foo/{a,b}/bar');
   * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
   * ```
   * @param {String} `input` Brace pattern or AST.
   * @param {Object} `options`
   * @return {Array} Returns an array of expanded values.
   * @api public
   */

  braces.stringify = (input, options = {}) => {
    if (typeof input === 'string') {
      return stringify(braces.parse(input, options), options);
    }
    return stringify(input, options);
  };

  /**
   * Compiles a brace pattern into a regex-compatible, optimized string.
   * This method is called by the main [braces](#braces) function by default.
   *
   * ```js
   * const braces = require('braces');
   * console.log(braces.compile('a/{b,c}/d'));
   * //=> ['a/(b|c)/d']
   * ```
   * @param {String} `input` Brace pattern or AST.
   * @param {Object} `options`
   * @return {Array} Returns an array of expanded values.
   * @api public
   */

  braces.compile = (input, options = {}) => {
    if (typeof input === 'string') {
      input = braces.parse(input, options);
    }
    return compile(input, options);
  };

  /**
   * Expands a brace pattern into an array. This method is called by the
   * main [braces](#braces) function when `options.expand` is true. Before
   * using this method it's recommended that you read the [performance notes](#performance))
   * and advantages of using [.compile](#compile) instead.
   *
   * ```js
   * const braces = require('braces');
   * console.log(braces.expand('a/{b,c}/d'));
   * //=> ['a/b/d', 'a/c/d'];
   * ```
   * @param {String} `pattern` Brace pattern
   * @param {Object} `options`
   * @return {Array} Returns an array of expanded values.
   * @api public
   */

  braces.expand = (input, options = {}) => {
    if (typeof input === 'string') {
      input = braces.parse(input, options);
    }

    let result = expand(input, options);

    // filter out empty strings if specified
    if (options.noempty === true) {
      result = result.filter(Boolean);
    }

    // filter out duplicates if specified
    if (options.nodupes === true) {
      result = [...new Set(result)];
    }

    return result;
  };

  /**
   * Processes a brace pattern and returns either an expanded array
   * (if `options.expand` is true), a highly optimized regex-compatible string.
   * This method is called by the main [braces](#braces) function.
   *
   * ```js
   * const braces = require('braces');
   * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
   * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
   * ```
   * @param {String} `pattern` Brace pattern
   * @param {Object} `options`
   * @return {Array} Returns an array of expanded values.
   * @api public
   */

  braces.create = (input, options = {}) => {
    if (input === '' || input.length < 3) {
      return [input];
    }

   return options.expand !== true
      ? braces.compile(input, options)
      : braces.expand(input, options);
  };

  /**
   * Expose "braces"
   */

  module.exports = braces;


  /***/ }),
  /* 109 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const utils = __webpack_require__(110);

  module.exports = (ast, options = {}) => {
    let stringify = (node, parent = {}) => {
      let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
      let invalidNode = node.invalid === true && options.escapeInvalid === true;
      let output = '';

      if (node.value) {
        if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
          return '\\' + node.value;
        }
        return node.value;
      }

      if (node.value) {
        return node.value;
      }

      if (node.nodes) {
        for (let child of node.nodes) {
          output += stringify(child);
        }
      }
      return output;
    };

    return stringify(ast);
  };



  /***/ }),
  /* 110 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  exports.isInteger = num => {
    if (typeof num === 'number') {
      return Number.isInteger(num);
    }
    if (typeof num === 'string' && num.trim() !== '') {
      return Number.isInteger(Number(num));
    }
    return false;
  };

  /**
   * Find a node of the given type
   */

  exports.find = (node, type) => node.nodes.find(node => node.type === type);

  /**
   * Find a node of the given type
   */

  exports.exceedsLimit = (min, max, step = 1, limit) => {
    if (limit === false) return false;
    if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
    return ((Number(max) - Number(min)) / Number(step)) >= limit;
  };

  /**
   * Escape the given node with '\\' before node.value
   */

  exports.escapeNode = (block, n = 0, type) => {
    let node = block.nodes[n];
    if (!node) return;

    if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {
      if (node.escaped !== true) {
        node.value = '\\' + node.value;
        node.escaped = true;
      }
    }
  };

  /**
   * Returns true if the given brace node should be enclosed in literal braces
   */

  exports.encloseBrace = node => {
    if (node.type !== 'brace') return false;
    if ((node.commas >> 0 + node.ranges >> 0) === 0) {
      node.invalid = true;
      return true;
    }
    return false;
  };

  /**
   * Returns true if a brace node is invalid.
   */

  exports.isInvalidBrace = block => {
    if (block.type !== 'brace') return false;
    if (block.invalid === true || block.dollar) return true;
    if ((block.commas >> 0 + block.ranges >> 0) === 0) {
      block.invalid = true;
      return true;
    }
    if (block.open !== true || block.close !== true) {
      block.invalid = true;
      return true;
    }
    return false;
  };

  /**
   * Returns true if a node is an open or close node
   */

  exports.isOpenOrClose = node => {
    if (node.type === 'open' || node.type === 'close') {
      return true;
    }
    return node.open === true || node.close === true;
  };

  /**
   * Reduce an array of text nodes.
   */

  exports.reduce = nodes => nodes.reduce((acc, node) => {
    if (node.type === 'text') acc.push(node.value);
    if (node.type === 'range') node.type = 'text';
    return acc;
  }, []);

  /**
   * Flatten an array
   */

  exports.flatten = (...args) => {
    const result = [];
    const flat = arr => {
      for (let i = 0; i < arr.length; i++) {
        let ele = arr[i];
        Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
      }
      return result;
    };
    flat(args);
    return result;
  };


  /***/ }),
  /* 111 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const fill = __webpack_require__(112);
  const utils = __webpack_require__(110);

  const compile = (ast, options = {}) => {
    let walk = (node, parent = {}) => {
      let invalidBlock = utils.isInvalidBrace(parent);
      let invalidNode = node.invalid === true && options.escapeInvalid === true;
      let invalid = invalidBlock === true || invalidNode === true;
      let prefix = options.escapeInvalid === true ? '\\' : '';
      let output = '';

      if (node.isOpen === true) {
        return prefix + node.value;
      }
      if (node.isClose === true) {
        return prefix + node.value;
      }

      if (node.type === 'open') {
        return invalid ? (prefix + node.value) : '(';
      }

      if (node.type === 'close') {
        return invalid ? (prefix + node.value) : ')';
      }

      if (node.type === 'comma') {
        return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');
      }

      if (node.value) {
        return node.value;
      }

      if (node.nodes && node.ranges > 0) {
        let args = utils.reduce(node.nodes);
        let range = fill(...args, { ...options, wrap: false, toRegex: true });

        if (range.length !== 0) {
          return args.length > 1 && range.length > 1 ? `(${range})` : range;
        }
      }

      if (node.nodes) {
        for (let child of node.nodes) {
          output += walk(child, node);
        }
      }
      return output;
    };

    return walk(ast);
  };

  module.exports = compile;


  /***/ }),
  /* 112 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   */



  const util = __webpack_require__(25);
  const toRegexRange = __webpack_require__(113);

  const isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);

  const transform = toNumber => {
    return value => toNumber === true ? Number(value) : String(value);
  };

  const isValidValue = value => {
    return typeof value === 'number' || (typeof value === 'string' && value !== '');
  };

  const isNumber = num => Number.isInteger(+num);

  const zeros = input => {
    let value = `${input}`;
    let index = -1;
    if (value[0] === '-') value = value.slice(1);
    if (value === '0') return false;
    while (value[++index] === '0');
    return index > 0;
  };

  const stringify = (start, end, options) => {
    if (typeof start === 'string' || typeof end === 'string') {
      return true;
    }
    return options.stringify === true;
  };

  const pad = (input, maxLength, toNumber) => {
    if (maxLength > 0) {
      let dash = input[0] === '-' ? '-' : '';
      if (dash) input = input.slice(1);
      input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));
    }
    if (toNumber === false) {
      return String(input);
    }
    return input;
  };

  const toMaxLen = (input, maxLength) => {
    let negative = input[0] === '-' ? '-' : '';
    if (negative) {
      input = input.slice(1);
      maxLength--;
    }
    while (input.length < maxLength) input = '0' + input;
    return negative ? ('-' + input) : input;
  };

  const toSequence = (parts, options) => {
    parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);

    let prefix = options.capture ? '' : '?:';
    let positives = '';
    let negatives = '';
    let result;

    if (parts.positives.length) {
      positives = parts.positives.join('|');
    }

    if (parts.negatives.length) {
      negatives = `-(${prefix}${parts.negatives.join('|')})`;
    }

    if (positives && negatives) {
      result = `${positives}|${negatives}`;
    } else {
      result = positives || negatives;
    }

    if (options.wrap) {
      return `(${prefix}${result})`;
    }

    return result;
  };

  const toRange = (a, b, isNumbers, options) => {
    if (isNumbers) {
      return toRegexRange(a, b, { wrap: false, ...options });
    }

    let start = String.fromCharCode(a);
    if (a === b) return start;

    let stop = String.fromCharCode(b);
    return `[${start}-${stop}]`;
  };

  const toRegex = (start, end, options) => {
    if (Array.isArray(start)) {
      let wrap = options.wrap === true;
      let prefix = options.capture ? '' : '?:';
      return wrap ? `(${prefix}${start.join('|')})` : start.join('|');
    }
    return toRegexRange(start, end, options);
  };

  const rangeError = (...args) => {
    return new RangeError('Invalid range arguments: ' + util.inspect(...args));
  };

  const invalidRange = (start, end, options) => {
    if (options.strictRanges === true) throw rangeError([start, end]);
    return [];
  };

  const invalidStep = (step, options) => {
    if (options.strictRanges === true) {
      throw new TypeError(`Expected step "${step}" to be a number`);
    }
    return [];
  };

  const fillNumbers = (start, end, step = 1, options = {}) => {
    let a = Number(start);
    let b = Number(end);

    if (!Number.isInteger(a) || !Number.isInteger(b)) {
      if (options.strictRanges === true) throw rangeError([start, end]);
      return [];
    }

    // fix negative zero
    if (a === 0) a = 0;
    if (b === 0) b = 0;

    let descending = a > b;
    let startString = String(start);
    let endString = String(end);
    let stepString = String(step);
    step = Math.max(Math.abs(step), 1);

    let padded = zeros(startString) || zeros(endString) || zeros(stepString);
    let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
    let toNumber = padded === false && stringify(start, end, options) === false;
    let format = options.transform || transform(toNumber);

    if (options.toRegex && step === 1) {
      return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
    }

    let parts = { negatives: [], positives: [] };
    let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));
    let range = [];
    let index = 0;

    while (descending ? a >= b : a <= b) {
      if (options.toRegex === true && step > 1) {
        push(a);
      } else {
        range.push(pad(format(a, index), maxLen, toNumber));
      }
      a = descending ? a - step : a + step;
      index++;
    }

    if (options.toRegex === true) {
      return step > 1
        ? toSequence(parts, options)
        : toRegex(range, null, { wrap: false, ...options });
    }

    return range;
  };

  const fillLetters = (start, end, step = 1, options = {}) => {
    if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {
      return invalidRange(start, end, options);
    }


    let format = options.transform || (val => String.fromCharCode(val));
    let a = `${start}`.charCodeAt(0);
    let b = `${end}`.charCodeAt(0);

    let descending = a > b;
    let min = Math.min(a, b);
    let max = Math.max(a, b);

    if (options.toRegex && step === 1) {
      return toRange(min, max, false, options);
    }

    let range = [];
    let index = 0;

    while (descending ? a >= b : a <= b) {
      range.push(format(a, index));
      a = descending ? a - step : a + step;
      index++;
    }

    if (options.toRegex === true) {
      return toRegex(range, null, { wrap: false, options });
    }

    return range;
  };

  const fill = (start, end, step, options = {}) => {
    if (end == null && isValidValue(start)) {
      return [start];
    }

    if (!isValidValue(start) || !isValidValue(end)) {
      return invalidRange(start, end, options);
    }

    if (typeof step === 'function') {
      return fill(start, end, 1, { transform: step });
    }

    if (isObject(step)) {
      return fill(start, end, 0, step);
    }

    let opts = { ...options };
    if (opts.capture === true) opts.wrap = true;
    step = step || opts.step || 1;

    if (!isNumber(step)) {
      if (step != null && !isObject(step)) return invalidStep(step, opts);
      return fill(start, end, 1, step);
    }

    if (isNumber(start) && isNumber(end)) {
      return fillNumbers(start, end, step, opts);
    }

    return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
  };

  module.exports = fill;


  /***/ }),
  /* 113 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   */



  const isNumber = __webpack_require__(114);

  const toRegexRange = (min, max, options) => {
    if (isNumber(min) === false) {
      throw new TypeError('toRegexRange: expected the first argument to be a number');
    }

    if (max === void 0 || min === max) {
      return String(min);
    }

    if (isNumber(max) === false) {
      throw new TypeError('toRegexRange: expected the second argument to be a number.');
    }

    let opts = { relaxZeros: true, ...options };
    if (typeof opts.strictZeros === 'boolean') {
      opts.relaxZeros = opts.strictZeros === false;
    }

    let relax = String(opts.relaxZeros);
    let shorthand = String(opts.shorthand);
    let capture = String(opts.capture);
    let wrap = String(opts.wrap);
    let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;

    if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
      return toRegexRange.cache[cacheKey].result;
    }

    let a = Math.min(min, max);
    let b = Math.max(min, max);

    if (Math.abs(a - b) === 1) {
      let result = min + '|' + max;
      if (opts.capture) {
        return `(${result})`;
      }
      if (opts.wrap === false) {
        return result;
      }
      return `(?:${result})`;
    }

    let isPadded = hasPadding(min) || hasPadding(max);
    let state = { min, max, a, b };
    let positives = [];
    let negatives = [];

    if (isPadded) {
      state.isPadded = isPadded;
      state.maxLen = String(state.max).length;
    }

    if (a < 0) {
      let newMin = b < 0 ? Math.abs(b) : 1;
      negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
      a = state.a = 0;
    }

    if (b >= 0) {
      positives = splitToPatterns(a, b, state, opts);
    }

    state.negatives = negatives;
    state.positives = positives;
    state.result = collatePatterns(negatives, positives, opts);

    if (opts.capture === true) {
      state.result = `(${state.result})`;
    } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {
      state.result = `(?:${state.result})`;
    }

    toRegexRange.cache[cacheKey] = state;
    return state.result;
  };

  function collatePatterns(neg, pos, options) {
    let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];
    let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];
    let intersected = filterPatterns(neg, pos, '-?', true, options) || [];
    let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
    return subpatterns.join('|');
  }

  function splitToRanges(min, max) {
    let nines = 1;
    let zeros = 1;

    let stop = countNines(min, nines);
    let stops = new Set([max]);

    while (min <= stop && stop <= max) {
      stops.add(stop);
      nines += 1;
      stop = countNines(min, nines);
    }

    stop = countZeros(max + 1, zeros) - 1;

    while (min < stop && stop <= max) {
      stops.add(stop);
      zeros += 1;
      stop = countZeros(max + 1, zeros) - 1;
    }

    stops = [...stops];
    stops.sort(compare);
    return stops;
  }

  /**
   * Convert a range to a regex pattern
   * @param {Number} `start`
   * @param {Number} `stop`
   * @return {String}
   */

  function rangeToPattern(start, stop, options) {
    if (start === stop) {
      return { pattern: start, count: [], digits: 0 };
    }

    let zipped = zip(start, stop);
    let digits = zipped.length;
    let pattern = '';
    let count = 0;

    for (let i = 0; i < digits; i++) {
      let [startDigit, stopDigit] = zipped[i];

      if (startDigit === stopDigit) {
        pattern += startDigit;

      } else if (startDigit !== '0' || stopDigit !== '9') {
        pattern += toCharacterClass(startDigit, stopDigit, options);

      } else {
        count++;
      }
    }

    if (count) {
      pattern += options.shorthand === true ? '\\d' : '[0-9]';
    }

    return { pattern, count: [count], digits };
  }

  function splitToPatterns(min, max, tok, options) {
    let ranges = splitToRanges(min, max);
    let tokens = [];
    let start = min;
    let prev;

    for (let i = 0; i < ranges.length; i++) {
      let max = ranges[i];
      let obj = rangeToPattern(String(start), String(max), options);
      let zeros = '';

      if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
        if (prev.count.length > 1) {
          prev.count.pop();
        }

        prev.count.push(obj.count[0]);
        prev.string = prev.pattern + toQuantifier(prev.count);
        start = max + 1;
        continue;
      }

      if (tok.isPadded) {
        zeros = padZeros(max, tok, options);
      }

      obj.string = zeros + obj.pattern + toQuantifier(obj.count);
      tokens.push(obj);
      start = max + 1;
      prev = obj;
    }

    return tokens;
  }

  function filterPatterns(arr, comparison, prefix, intersection, options) {
    let result = [];

    for (let ele of arr) {
      let { string } = ele;

      // only push if _both_ are negative...
      if (!intersection && !contains(comparison, 'string', string)) {
        result.push(prefix + string);
      }

      // or _both_ are positive
      if (intersection && contains(comparison, 'string', string)) {
        result.push(prefix + string);
      }
    }
    return result;
  }

  /**
   * Zip strings
   */

  function zip(a, b) {
    let arr = [];
    for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
    return arr;
  }

  function compare(a, b) {
    return a > b ? 1 : b > a ? -1 : 0;
  }

  function contains(arr, key, val) {
    return arr.some(ele => ele[key] === val);
  }

  function countNines(min, len) {
    return Number(String(min).slice(0, -len) + '9'.repeat(len));
  }

  function countZeros(integer, zeros) {
    return integer - (integer % Math.pow(10, zeros));
  }

  function toQuantifier(digits) {
    let [start = 0, stop = ''] = digits;
    if (stop || start > 1) {
      return `{${start + (stop ? ',' + stop : '')}}`;
    }
    return '';
  }

  function toCharacterClass(a, b, options) {
    return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;
  }

  function hasPadding(str) {
    return /^-?(0+)\d/.test(str);
  }

  function padZeros(value, tok, options) {
    if (!tok.isPadded) {
      return value;
    }

    let diff = Math.abs(tok.maxLen - String(value).length);
    let relax = options.relaxZeros !== false;

    switch (diff) {
      case 0:
        return '';
      case 1:
        return relax ? '0?' : '0';
      case 2:
        return relax ? '0{0,2}' : '00';
      default: {
        return relax ? `0{0,${diff}}` : `0{${diff}}`;
      }
    }
  }

  /**
   * Cache
   */

  toRegexRange.cache = {};
  toRegexRange.clearCache = () => (toRegexRange.cache = {});

  /**
   * Expose `toRegexRange`
   */

  module.exports = toRegexRange;


  /***/ }),
  /* 114 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   */



  module.exports = function(num) {
    if (typeof num === 'number') {
      return num - num === 0;
    }
    if (typeof num === 'string' && num.trim() !== '') {
      return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
    }
    return false;
  };


  /***/ }),
  /* 115 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const fill = __webpack_require__(112);
  const stringify = __webpack_require__(109);
  const utils = __webpack_require__(110);

  const append = (queue = '', stash = '', enclose = false) => {
    let result = [];

    queue = [].concat(queue);
    stash = [].concat(stash);

    if (!stash.length) return queue;
    if (!queue.length) {
      return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;
    }

    for (let item of queue) {
      if (Array.isArray(item)) {
        for (let value of item) {
          result.push(append(value, stash, enclose));
        }
      } else {
        for (let ele of stash) {
          if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;
          result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));
        }
      }
    }
    return utils.flatten(result);
  };

  const expand = (ast, options = {}) => {
    let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;

    let walk = (node, parent = {}) => {
      node.queue = [];

      let p = parent;
      let q = parent.queue;

      while (p.type !== 'brace' && p.type !== 'root' && p.parent) {
        p = p.parent;
        q = p.queue;
      }

      if (node.invalid || node.dollar) {
        q.push(append(q.pop(), stringify(node, options)));
        return;
      }

      if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {
        q.push(append(q.pop(), ['{}']));
        return;
      }

      if (node.nodes && node.ranges > 0) {
        let args = utils.reduce(node.nodes);

        if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
          throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
        }

        let range = fill(...args, options);
        if (range.length === 0) {
          range = stringify(node, options);
        }

        q.push(append(q.pop(), range));
        node.nodes = [];
        return;
      }

      let enclose = utils.encloseBrace(node);
      let queue = node.queue;
      let block = node;

      while (block.type !== 'brace' && block.type !== 'root' && block.parent) {
        block = block.parent;
        queue = block.queue;
      }

      for (let i = 0; i < node.nodes.length; i++) {
        let child = node.nodes[i];

        if (child.type === 'comma' && node.type === 'brace') {
          if (i === 1) queue.push('');
          queue.push('');
          continue;
        }

        if (child.type === 'close') {
          q.push(append(q.pop(), queue, enclose));
          continue;
        }

        if (child.value && child.type !== 'open') {
          queue.push(append(queue.pop(), child.value));
          continue;
        }

        if (child.nodes) {
          walk(child, node);
        }
      }

      return queue;
    };

    return utils.flatten(walk(ast));
  };

  module.exports = expand;


  /***/ }),
  /* 116 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const stringify = __webpack_require__(109);

  /**
   * Constants
   */

  const {
    MAX_LENGTH,
    CHAR_BACKSLASH, /* \ */
    CHAR_BACKTICK, /* ` */
    CHAR_COMMA, /* , */
    CHAR_DOT, /* . */
    CHAR_LEFT_PARENTHESES, /* ( */
    CHAR_RIGHT_PARENTHESES, /* ) */
    CHAR_LEFT_CURLY_BRACE, /* { */
    CHAR_RIGHT_CURLY_BRACE, /* } */
    CHAR_LEFT_SQUARE_BRACKET, /* [ */
    CHAR_RIGHT_SQUARE_BRACKET, /* ] */
    CHAR_DOUBLE_QUOTE, /* " */
    CHAR_SINGLE_QUOTE, /* ' */
    CHAR_NO_BREAK_SPACE,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE
  } = __webpack_require__(117);

  /**
   * parse
   */

  const parse = (input, options = {}) => {
    if (typeof input !== 'string') {
      throw new TypeError('Expected a string');
    }

    let opts = options || {};
    let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    if (input.length > max) {
      throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
    }

    let ast = { type: 'root', input, nodes: [] };
    let stack = [ast];
    let block = ast;
    let prev = ast;
    let brackets = 0;
    let length = input.length;
    let index = 0;
    let depth = 0;
    let value;
    let memo = {};

    /**
     * Helpers
     */

    const advance = () => input[index++];
    const push = node => {
      if (node.type === 'text' && prev.type === 'dot') {
        prev.type = 'text';
      }

      if (prev && prev.type === 'text' && node.type === 'text') {
        prev.value += node.value;
        return;
      }

      block.nodes.push(node);
      node.parent = block;
      node.prev = prev;
      prev = node;
      return node;
    };

    push({ type: 'bos' });

    while (index < length) {
      block = stack[stack.length - 1];
      value = advance();

      /**
       * Invalid chars
       */

      if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
        continue;
      }

      /**
       * Escaped chars
       */

      if (value === CHAR_BACKSLASH) {
        push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });
        continue;
      }

      /**
       * Right square bracket (literal): ']'
       */

      if (value === CHAR_RIGHT_SQUARE_BRACKET) {
        push({ type: 'text', value: '\\' + value });
        continue;
      }

      /**
       * Left square bracket: '['
       */

      if (value === CHAR_LEFT_SQUARE_BRACKET) {
        brackets++;

        let closed = true;
        let next;

        while (index < length && (next = advance())) {
          value += next;

          if (next === CHAR_LEFT_SQUARE_BRACKET) {
            brackets++;
            continue;
          }

          if (next === CHAR_BACKSLASH) {
            value += advance();
            continue;
          }

          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            brackets--;

            if (brackets === 0) {
              break;
            }
          }
        }

        push({ type: 'text', value });
        continue;
      }

      /**
       * Parentheses
       */

      if (value === CHAR_LEFT_PARENTHESES) {
        block = push({ type: 'paren', nodes: [] });
        stack.push(block);
        push({ type: 'text', value });
        continue;
      }

      if (value === CHAR_RIGHT_PARENTHESES) {
        if (block.type !== 'paren') {
          push({ type: 'text', value });
          continue;
        }
        block = stack.pop();
        push({ type: 'text', value });
        block = stack[stack.length - 1];
        continue;
      }

      /**
       * Quotes: '|"|`
       */

      if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
        let open = value;
        let next;

        if (options.keepQuotes !== true) {
          value = '';
        }

        while (index < length && (next = advance())) {
          if (next === CHAR_BACKSLASH) {
            value += next + advance();
            continue;
          }

          if (next === open) {
            if (options.keepQuotes === true) value += next;
            break;
          }

          value += next;
        }

        push({ type: 'text', value });
        continue;
      }

      /**
       * Left curly brace: '{'
       */

      if (value === CHAR_LEFT_CURLY_BRACE) {
        depth++;

        let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;
        let brace = {
          type: 'brace',
          open: true,
          close: false,
          dollar,
          depth,
          commas: 0,
          ranges: 0,
          nodes: []
        };

        block = push(brace);
        stack.push(block);
        push({ type: 'open', value });
        continue;
      }

      /**
       * Right curly brace: '}'
       */

      if (value === CHAR_RIGHT_CURLY_BRACE) {
        if (block.type !== 'brace') {
          push({ type: 'text', value });
          continue;
        }

        let type = 'close';
        block = stack.pop();
        block.close = true;

        push({ type, value });
        depth--;

        block = stack[stack.length - 1];
        continue;
      }

      /**
       * Comma: ','
       */

      if (value === CHAR_COMMA && depth > 0) {
        if (block.ranges > 0) {
          block.ranges = 0;
          let open = block.nodes.shift();
          block.nodes = [open, { type: 'text', value: stringify(block) }];
        }

        push({ type: 'comma', value });
        block.commas++;
        continue;
      }

      /**
       * Dot: '.'
       */

      if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
        let siblings = block.nodes;

        if (depth === 0 || siblings.length === 0) {
          push({ type: 'text', value });
          continue;
        }

        if (prev.type === 'dot') {
          block.range = [];
          prev.value += value;
          prev.type = 'range';

          if (block.nodes.length !== 3 && block.nodes.length !== 5) {
            block.invalid = true;
            block.ranges = 0;
            prev.type = 'text';
            continue;
          }

          block.ranges++;
          block.args = [];
          continue;
        }

        if (prev.type === 'range') {
          siblings.pop();

          let before = siblings[siblings.length - 1];
          before.value += prev.value + value;
          prev = before;
          block.ranges--;
          continue;
        }

        push({ type: 'dot', value });
        continue;
      }

      /**
       * Text
       */

      push({ type: 'text', value });
    }

    // Mark imbalanced braces and brackets as invalid
    do {
      block = stack.pop();

      if (block.type !== 'root') {
        block.nodes.forEach(node => {
          if (!node.nodes) {
            if (node.type === 'open') node.isOpen = true;
            if (node.type === 'close') node.isClose = true;
            if (!node.nodes) node.type = 'text';
            node.invalid = true;
          }
        });

        // get the location of the block on parent.nodes (block's siblings)
        let parent = stack[stack.length - 1];
        let index = parent.nodes.indexOf(block);
        // replace the (invalid) block with it's nodes
        parent.nodes.splice(index, 1, ...block.nodes);
      }
    } while (stack.length > 0);

    push({ type: 'eos' });
    return ast;
  };

  module.exports = parse;


  /***/ }),
  /* 117 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  module.exports = {
    MAX_LENGTH: 1024 * 64,

    // Digits
    CHAR_0: '0', /* 0 */
    CHAR_9: '9', /* 9 */

    // Alphabet chars.
    CHAR_UPPERCASE_A: 'A', /* A */
    CHAR_LOWERCASE_A: 'a', /* a */
    CHAR_UPPERCASE_Z: 'Z', /* Z */
    CHAR_LOWERCASE_Z: 'z', /* z */

    CHAR_LEFT_PARENTHESES: '(', /* ( */
    CHAR_RIGHT_PARENTHESES: ')', /* ) */

    CHAR_ASTERISK: '*', /* * */

    // Non-alphabetic chars.
    CHAR_AMPERSAND: '&', /* & */
    CHAR_AT: '@', /* @ */
    CHAR_BACKSLASH: '\\', /* \ */
    CHAR_BACKTICK: '`', /* ` */
    CHAR_CARRIAGE_RETURN: '\r', /* \r */
    CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */
    CHAR_COLON: ':', /* : */
    CHAR_COMMA: ',', /* , */
    CHAR_DOLLAR: '$', /* . */
    CHAR_DOT: '.', /* . */
    CHAR_DOUBLE_QUOTE: '"', /* " */
    CHAR_EQUAL: '=', /* = */
    CHAR_EXCLAMATION_MARK: '!', /* ! */
    CHAR_FORM_FEED: '\f', /* \f */
    CHAR_FORWARD_SLASH: '/', /* / */
    CHAR_HASH: '#', /* # */
    CHAR_HYPHEN_MINUS: '-', /* - */
    CHAR_LEFT_ANGLE_BRACKET: '<', /* < */
    CHAR_LEFT_CURLY_BRACE: '{', /* { */
    CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */
    CHAR_LINE_FEED: '\n', /* \n */
    CHAR_NO_BREAK_SPACE: '\u00A0', /* \u00A0 */
    CHAR_PERCENT: '%', /* % */
    CHAR_PLUS: '+', /* + */
    CHAR_QUESTION_MARK: '?', /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */
    CHAR_RIGHT_CURLY_BRACE: '}', /* } */
    CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */
    CHAR_SEMICOLON: ';', /* ; */
    CHAR_SINGLE_QUOTE: '\'', /* ' */
    CHAR_SPACE: ' ', /*   */
    CHAR_TAB: '\t', /* \t */
    CHAR_UNDERSCORE: '_', /* _ */
    CHAR_VERTICAL_LINE: '|', /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\uFEFF' /* \uFEFF */
  };


  /***/ }),
  /* 118 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  module.exports = __webpack_require__(119);


  /***/ }),
  /* 119 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const path = __webpack_require__(8);
  const scan = __webpack_require__(120);
  const parse = __webpack_require__(123);
  const utils = __webpack_require__(121);

  /**
   * Creates a matcher function from one or more glob patterns. The
   * returned function takes a string to match as its first argument,
   * and returns true if the string is a match. The returned matcher
   * function also takes a boolean as the second argument that, when true,
   * returns an object with additional information.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch(glob[, options]);
   *
   * const isMatch = picomatch('*.!(*a)');
   * console.log(isMatch('a.a')); //=> false
   * console.log(isMatch('a.b')); //=> true
   * ```
   * @name picomatch
   * @param {String|Array} `globs` One or more glob patterns.
   * @param {Object=} `options`
   * @return {Function=} Returns a matcher function.
   * @api public
   */

  const picomatch = (glob, options, returnState = false) => {
    if (Array.isArray(glob)) {
      let fns = glob.map(input => picomatch(input, options, returnState));
      return str => {
        for (let isMatch of fns) {
          let state = isMatch(str);
          if (state) return state;
        }
        return false;
      };
    }

    if (typeof glob !== 'string' || glob === '') {
      throw new TypeError('Expected pattern to be a non-empty string');
    }

    let opts = options || {};
    let posix = utils.isWindows(options);
    let regex = picomatch.makeRe(glob, options, false, true);
    let state = regex.state;
    delete regex.state;

    let isIgnored = () => false;
    if (opts.ignore) {
      let ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
      isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
    }

    const matcher = (input, returnObject = false) => {
      let { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
      let result = { glob, state, regex, posix, input, output, match, isMatch };

      if (typeof opts.onResult === 'function') {
        opts.onResult(result);
      }

      if (isMatch === false) {
        result.isMatch = false;
        return returnObject ? result : false;
      }

      if (isIgnored(input)) {
        if (typeof opts.onIgnore === 'function') {
          opts.onIgnore(result);
        }
        result.isMatch = false;
        return returnObject ? result : false;
      }

      if (typeof opts.onMatch === 'function') {
        opts.onMatch(result);
      }
      return returnObject ? result : true;
    };

    if (returnState) {
      matcher.state = state;
    }

    return matcher;
  };

  /**
   * Test `input` with the given `regex`. This is used by the main
   * `picomatch()` function to test the input string.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.test(input, regex[, options]);
   *
   * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
   * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
   * ```
   * @param {String} `input` String to test.
   * @param {RegExp} `regex`
   * @return {Object} Returns an object with matching info.
   * @api public
   */

  picomatch.test = (input, regex, options, { glob, posix } = {}) => {
    if (typeof input !== 'string') {
      throw new TypeError('Expected input to be a string');
    }

    if (input === '') {
      return { isMatch: false, output: '' };
    }

    let opts = options || {};
    let format = opts.format || (posix ? utils.toPosixSlashes : null);
    let match = input === glob;
    let output = (match && format) ? format(input) : input;

    if (match === false) {
      output = format ? format(input) : input;
      match = output === glob;
    }

    if (match === false || opts.capture === true) {
      if (opts.matchBase === true || opts.basename === true) {
        match = picomatch.matchBase(input, regex, options, posix);
      } else {
        match = regex.exec(output);
      }
    }

    return { isMatch: !!match, match, output };
  };

  /**
   * Match the basename of a filepath.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.matchBase(input, glob[, options]);
   * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
   * ```
   * @param {String} `input` String to test.
   * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
   * @return {Boolean}
   * @api public
   */

  picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
    let regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
    return regex.test(path.basename(input));
  };

  /**
   * Returns true if **any** of the given glob `patterns` match the specified `string`.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.isMatch(string, patterns[, options]);
   *
   * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
   * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
   * ```
   * @param {String|Array} str The string to test.
   * @param {String|Array} patterns One or more glob patterns to use for matching.
   * @param {Object} [options] See available [options](#options).
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */

  picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

  /**
   * Parse a glob pattern to create the source string for a regular
   * expression.
   *
   * ```js
   * const picomatch = require('picomatch');
   * const result = picomatch.parse(glob[, options]);
   * ```
   * @param {String} `glob`
   * @param {Object} `options`
   * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
   * @api public
   */

  picomatch.parse = (glob, options) => parse(glob, options);

  /**
   * Scan a glob pattern to separate the pattern into segments.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.scan(input[, options]);
   *
   * const result = picomatch.scan('!./foo/*.js');
   * console.log(result);
   * // { prefix: '!./',
   * //   input: '!./foo/*.js',
   * //   base: 'foo',
   * //   glob: '*.js',
   * //   negated: true,
   * //   isGlob: true }
   * ```
   * @param {String} `input` Glob pattern to scan.
   * @param {Object} `options`
   * @return {Object} Returns an object with
   * @api public
   */

  picomatch.scan = (input, options) => scan(input, options);

  /**
   * Create a regular expression from a glob pattern.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.makeRe(input[, options]);
   *
   * console.log(picomatch.makeRe('*.js'));
   * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
   * ```
   * @param {String} `input` A glob pattern to convert to regex.
   * @param {Object} `options`
   * @return {RegExp} Returns a regex created from the given pattern.
   * @api public
   */

  picomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {
    if (!input || typeof input !== 'string') {
      throw new TypeError('Expected a non-empty string');
    }

    let opts = options || {};
    let prepend = opts.contains ? '' : '^';
    let append = opts.contains ? '' : '$';
    let state = { negated: false, fastpaths: true };
    let prefix = '';
    let output;

    if (input.startsWith('./')) {
      input = input.slice(2);
      prefix = state.prefix = './';
    }

    if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
      output = parse.fastpaths(input, options);
    }

    if (output === void 0) {
      state = picomatch.parse(input, options);
      state.prefix = prefix + (state.prefix || '');
      output = state.output;
    }

    if (returnOutput === true) {
      return output;
    }

    let source = `${prepend}(?:${output})${append}`;
    if (state && state.negated === true) {
      source = `^(?!${source}).*$`;
    }

    let regex = picomatch.toRegex(source, options);
    if (returnState === true) {
      regex.state = state;
    }

    return regex;
  };

  /**
   * Create a regular expression from the given regex source string.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.toRegex(source[, options]);
   *
   * const { output } = picomatch.parse('*.js');
   * console.log(picomatch.toRegex(output));
   * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
   * ```
   * @param {String} `source` Regular expression source string.
   * @param {Object} `options`
   * @return {RegExp}
   * @api public
   */

  picomatch.toRegex = (source, options) => {
    try {
      let opts = options || {};
      return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
    } catch (err) {
      if (options && options.debug === true) throw err;
      return /$^/;
    }
  };

  /**
   * Picomatch constants.
   * @return {Object}
   */

  picomatch.constants = __webpack_require__(122);

  /**
   * Expose "picomatch"
   */

  module.exports = picomatch;


  /***/ }),
  /* 120 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const utils = __webpack_require__(121);

  const {
    CHAR_ASTERISK,             /* * */
    CHAR_AT,                   /* @ */
    CHAR_BACKWARD_SLASH,       /* \ */
    CHAR_COMMA,                /* , */
    CHAR_DOT,                  /* . */
    CHAR_EXCLAMATION_MARK,     /* ! */
    CHAR_FORWARD_SLASH,        /* / */
    CHAR_LEFT_CURLY_BRACE,     /* { */
    CHAR_LEFT_PARENTHESES,     /* ( */
    CHAR_LEFT_SQUARE_BRACKET,  /* [ */
    CHAR_PLUS,                 /* + */
    CHAR_QUESTION_MARK,        /* ? */
    CHAR_RIGHT_CURLY_BRACE,    /* } */
    CHAR_RIGHT_PARENTHESES,    /* ) */
    CHAR_RIGHT_SQUARE_BRACKET /* ] */
  } = __webpack_require__(122);

  const isPathSeparator = code => {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
  };

  /**
   * Quickly scans a glob pattern and returns an object with a handful of
   * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
   * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).
   *
   * ```js
   * const pm = require('picomatch');
   * console.log(pm.scan('foo/bar/*.js'));
   * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
   * ```
   * @param {String} `str`
   * @param {Object} `options`
   * @return {Object} Returns an object with tokens and regex source string.
   * @api public
   */

  module.exports = (input, options) => {
    let opts = options || {};
    let length = input.length - 1;
    let index = -1;
    let start = 0;
    let lastIndex = 0;
    let isGlob = false;
    let backslashes = false;
    let negated = false;
    let braces = 0;
    let prev;
    let code;

    let braceEscaped = false;

    let eos = () => index >= length;
    let advance = () => {
      prev = code;
      return input.charCodeAt(++index);
    };

    while (index < length) {
      code = advance();
      let next;

      if (code === CHAR_BACKWARD_SLASH) {
        backslashes = true;
        next = advance();

        if (next === CHAR_LEFT_CURLY_BRACE) {
          braceEscaped = true;
        }
        continue;
      }

      if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
        braces++;

        while (!eos() && (next = advance())) {
          if (next === CHAR_BACKWARD_SLASH) {
            backslashes = true;
            next = advance();
            continue;
          }

          if (next === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            continue;
          }

          if (!braceEscaped && next === CHAR_DOT && (next = advance()) === CHAR_DOT) {
            isGlob = true;
            break;
          }

          if (!braceEscaped && next === CHAR_COMMA) {
            isGlob = true;
            break;
          }

          if (next === CHAR_RIGHT_CURLY_BRACE) {
            braces--;
            if (braces === 0) {
              braceEscaped = false;
              break;
            }
          }
        }
      }

      if (code === CHAR_FORWARD_SLASH) {
        if (prev === CHAR_DOT && index === (start + 1)) {
          start += 2;
          continue;
        }

        lastIndex = index + 1;
        continue;
      }

      if (code === CHAR_ASTERISK) {
        isGlob = true;
        break;
      }

      if (code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK) {
        isGlob = true;
        break;
      }

      if (code === CHAR_LEFT_SQUARE_BRACKET) {
        while (!eos() && (next = advance())) {
          if (next === CHAR_BACKWARD_SLASH) {
            backslashes = true;
            next = advance();
            continue;
          }

          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            isGlob = true;
            break;
          }
        }
      }

      let isExtglobChar = code === CHAR_PLUS
        || code === CHAR_AT
        || code === CHAR_EXCLAMATION_MARK;

      if (isExtglobChar && input.charCodeAt(index + 1) === CHAR_LEFT_PARENTHESES) {
        isGlob = true;
        break;
      }

      if (code === CHAR_EXCLAMATION_MARK && index === start) {
        negated = true;
        start++;
        continue;
      }

      if (code === CHAR_LEFT_PARENTHESES) {
        while (!eos() && (next = advance())) {
          if (next === CHAR_BACKWARD_SLASH) {
            backslashes = true;
            next = advance();
            continue;
          }

          if (next === CHAR_RIGHT_PARENTHESES) {
            isGlob = true;
            break;
          }
        }
      }

      if (isGlob) {
        break;
      }
    }

    let prefix = '';
    let orig = input;
    let base = input;
    let glob = '';

    if (start > 0) {
      prefix = input.slice(0, start);
      input = input.slice(start);
      lastIndex -= start;
    }

    if (base && isGlob === true && lastIndex > 0) {
      base = input.slice(0, lastIndex);
      glob = input.slice(lastIndex);
    } else if (isGlob === true) {
      base = '';
      glob = input;
    } else {
      base = input;
    }

    if (base && base !== '' && base !== '/' && base !== input) {
      if (isPathSeparator(base.charCodeAt(base.length - 1))) {
        base = base.slice(0, -1);
      }
    }

    if (opts.unescape === true) {
      if (glob) glob = utils.removeBackslashes(glob);

      if (base && backslashes === true) {
        base = utils.removeBackslashes(base);
      }
    }

    return { prefix, input: orig, base, glob, negated, isGlob };
  };


  /***/ }),
  /* 121 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const path = __webpack_require__(8);
  const win32 = process.platform === 'win32';
  const {
    REGEX_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_GLOBAL,
    REGEX_REMOVE_BACKSLASH
  } = __webpack_require__(122);

  exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
  exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
  exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
  exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
  exports.toPosixSlashes = str => str.replace(/\\/g, '/');

  exports.removeBackslashes = str => {
    return str.replace(REGEX_REMOVE_BACKSLASH, match => {
      return match === '\\' ? '' : match;
    });
  }

  exports.supportsLookbehinds = () => {
    let segs = process.version.slice(1).split('.');
    if (segs.length === 3 && +segs[0] >= 9 || (+segs[0] === 8 && +segs[1] >= 10)) {
      return true;
    }
    return false;
  };

  exports.isWindows = options => {
    if (options && typeof options.windows === 'boolean') {
      return options.windows;
    }
    return win32 === true || path.sep === '\\';
  };

  exports.escapeLast = (input, char, lastIdx) => {
    let idx = input.lastIndexOf(char, lastIdx);
    if (idx === -1) return input;
    if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
    return input.slice(0, idx) + '\\' + input.slice(idx);
  };


  /***/ }),
  /* 122 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const path = __webpack_require__(8);
  const WIN_SLASH = '\\\\/';
  const WIN_NO_SLASH = `[^${WIN_SLASH}]`;

  /**
   * Posix glob regex
   */

  const DOT_LITERAL = '\\.';
  const PLUS_LITERAL = '\\+';
  const QMARK_LITERAL = '\\?';
  const SLASH_LITERAL = '\\/';
  const ONE_CHAR = '(?=.)';
  const QMARK = '[^/]';
  const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
  const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
  const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
  const NO_DOT = `(?!${DOT_LITERAL})`;
  const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
  const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
  const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
  const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
  const STAR = `${QMARK}*?`;

  const POSIX_CHARS = {
    DOT_LITERAL,
    PLUS_LITERAL,
    QMARK_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    QMARK,
    END_ANCHOR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  };

  /**
   * Windows glob regex
   */

  const WINDOWS_CHARS = {
    ...POSIX_CHARS,

    SLASH_LITERAL: `[${WIN_SLASH}]`,
    QMARK: WIN_NO_SLASH,
    STAR: `${WIN_NO_SLASH}*?`,
    DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
    NO_DOT: `(?!${DOT_LITERAL})`,
    NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
    NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
    START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
    END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
  };

  /**
   * POSIX Bracket Regex
   */

  const POSIX_REGEX_SOURCE = {
    alnum: 'a-zA-Z0-9',
    alpha: 'a-zA-Z',
    ascii: '\\x00-\\x7F',
    blank: ' \\t',
    cntrl: '\\x00-\\x1F\\x7F',
    digit: '0-9',
    graph: '\\x21-\\x7E',
    lower: 'a-z',
    print: '\\x20-\\x7E ',
    punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
    space: ' \\t\\r\\n\\v\\f',
    upper: 'A-Z',
    word: 'A-Za-z0-9_',
    xdigit: 'A-Fa-f0-9'
  };

  module.exports = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE,

    // regular expressions
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHAR: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,

    // Replace globs with equivalent patterns to reduce parsing time.
    REPLACEMENTS: {
      '***': '*',
      '**/**': '**',
      '**/**/**': '**'
    },

    // Digits
    CHAR_0: 48, /* 0 */
    CHAR_9: 57, /* 9 */

    // Alphabet chars.
    CHAR_UPPERCASE_A: 65, /* A */
    CHAR_LOWERCASE_A: 97, /* a */
    CHAR_UPPERCASE_Z: 90, /* Z */
    CHAR_LOWERCASE_Z: 122, /* z */

    CHAR_LEFT_PARENTHESES: 40, /* ( */
    CHAR_RIGHT_PARENTHESES: 41, /* ) */

    CHAR_ASTERISK: 42, /* * */

    // Non-alphabetic chars.
    CHAR_AMPERSAND: 38, /* & */
    CHAR_AT: 64, /* @ */
    CHAR_BACKWARD_SLASH: 92, /* \ */
    CHAR_CARRIAGE_RETURN: 13, /* \r */
    CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */
    CHAR_COLON: 58, /* : */
    CHAR_COMMA: 44, /* , */
    CHAR_DOT: 46, /* . */
    CHAR_DOUBLE_QUOTE: 34, /* " */
    CHAR_EQUAL: 61, /* = */
    CHAR_EXCLAMATION_MARK: 33, /* ! */
    CHAR_FORM_FEED: 12, /* \f */
    CHAR_FORWARD_SLASH: 47, /* / */
    CHAR_GRAVE_ACCENT: 96, /* ` */
    CHAR_HASH: 35, /* # */
    CHAR_HYPHEN_MINUS: 45, /* - */
    CHAR_LEFT_ANGLE_BRACKET: 60, /* < */
    CHAR_LEFT_CURLY_BRACE: 123, /* { */
    CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */
    CHAR_LINE_FEED: 10, /* \n */
    CHAR_NO_BREAK_SPACE: 160, /* \u00A0 */
    CHAR_PERCENT: 37, /* % */
    CHAR_PLUS: 43, /* + */
    CHAR_QUESTION_MARK: 63, /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */
    CHAR_RIGHT_CURLY_BRACE: 125, /* } */
    CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */
    CHAR_SEMICOLON: 59, /* ; */
    CHAR_SINGLE_QUOTE: 39, /* ' */
    CHAR_SPACE: 32, /*   */
    CHAR_TAB: 9, /* \t */
    CHAR_UNDERSCORE: 95, /* _ */
    CHAR_VERTICAL_LINE: 124, /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \uFEFF */

    SEP: path.sep,

    /**
     * Create EXTGLOB_CHARS
     */

    extglobChars(chars) {
      return {
        '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },
        '?': { type: 'qmark', open: '(?:', close: ')?' },
        '+': { type: 'plus', open: '(?:', close: ')+' },
        '*': { type: 'star', open: '(?:', close: ')*' },
        '@': { type: 'at', open: '(?:', close: ')' }
      };
    },

    /**
     * Create GLOB_CHARS
     */

    globChars(win32) {
      return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
    }
  };


  /***/ }),
  /* 123 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const utils = __webpack_require__(121);
  const constants = __webpack_require__(122);

  /**
   * Constants
   */

  const {
    MAX_LENGTH,
    POSIX_REGEX_SOURCE,
    REGEX_NON_SPECIAL_CHAR,
    REGEX_SPECIAL_CHARS_BACKREF,
    REPLACEMENTS
  } = constants;

  /**
   * Helpers
   */

  const expandRange = (args, options) => {
    if (typeof options.expandRange === 'function') {
      return options.expandRange(...args, options);
    }

    args.sort();
    let value = `[${args.join('-')}]`;

    try {
      /* eslint-disable no-new */
      new RegExp(value);
    } catch (ex) {
      return args.map(v => utils.escapeRegex(v)).join('..');
    }

    return value;
  };

  const negate = state => {
    let count = 1;

    while (state.peek() === '!' && (state.peek(2) !== '(' || state.peek(3) === '?')) {
      state.advance();
      state.start++;
      count++;
    }

    if (count % 2 === 0) {
      return false;
    }

    state.negated = true;
    state.start++;
    return true;
  };

  /**
   * Create the message for a syntax error
   */

  const syntaxError = (type, char) => {
    return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
  };

  /**
   * Parse the given input string.
   * @param {String} input
   * @param {Object} options
   * @return {Object}
   */

  const parse = (input, options) => {
    if (typeof input !== 'string') {
      throw new TypeError('Expected a string');
    }

    input = REPLACEMENTS[input] || input;

    let opts = { ...options };
    let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    let len = input.length;
    if (len > max) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    }

    let bos = { type: 'bos', value: '', output: opts.prepend || '' };
    let tokens = [bos];

    let capture = opts.capture ? '' : '?:';
    let win32 = utils.isWindows(options);

    // create constants based on platform, for windows or posix
    const PLATFORM_CHARS = constants.globChars(win32);
    const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);

    const {
      DOT_LITERAL,
      PLUS_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    } = PLATFORM_CHARS;

    const globstar = (opts) => {
      return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };

    let nodot = opts.dot ? '' : NO_DOT;
    let star = opts.bash === true ? globstar(opts) : STAR;
    let qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;

    if (opts.capture) {
      star = `(${star})`;
    }

    // minimatch options support
    if (typeof opts.noext === 'boolean') {
      opts.noextglob = opts.noext;
    }

    let state = {
      index: -1,
      start: 0,
      consumed: '',
      output: '',
      backtrack: false,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      tokens
    };

    let extglobs = [];
    let stack = [];
    let prev = bos;
    let value;

    /**
     * Tokenizing helpers
     */

    const eos = () => state.index === len - 1;
    const peek = state.peek = (n = 1) => input[state.index + n];
    const advance = state.advance = () => input[++state.index];
    const append = token => {
      state.output += token.output != null ? token.output : token.value;
      state.consumed += token.value || '';
    };

    const increment = type => {
      state[type]++;
      stack.push(type);
    };

    const decrement = type => {
      state[type]--;
      stack.pop();
    };

    /**
     * Push tokens onto the tokens array. This helper speeds up
     * tokenizing by 1) helping us avoid backtracking as much as possible,
     * and 2) helping us avoid creating extra tokens when consecutive
     * characters are plain text. This improves performance and simplifies
     * lookbehinds.
     */

    const push = tok => {
      if (prev.type === 'globstar') {
        let isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
        let isExtglob = extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');
        if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = 'star';
          prev.value = '*';
          prev.output = star;
          state.output += prev.output;
        }
      }

      if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {
        extglobs[extglobs.length - 1].inner += tok.value;
      }

      if (tok.value || tok.output) append(tok);
      if (prev && prev.type === 'text' && tok.type === 'text') {
        prev.value += tok.value;
        return;
      }

      tok.prev = prev;
      tokens.push(tok);
      prev = tok;
    };

    const extglobOpen = (type, value) => {
      let token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };

      token.prev = prev;
      token.parens = state.parens;
      token.output = state.output;
      let output = (opts.capture ? '(' : '') + token.open;

      push({ type, value, output: state.output ? '' : ONE_CHAR });
      push({ type: 'paren', extglob: true, value: advance(), output });
      increment('parens');
      extglobs.push(token);
    };

    const extglobClose = token => {
      let output = token.close + (opts.capture ? ')' : '');

      if (token.type === 'negate') {
        let extglobStar = star;

        if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
          extglobStar = globstar(opts);
        }

        if (extglobStar !== star || eos() || /^\)+$/.test(input.slice(state.index + 1))) {
          output = token.close = ')$))' + extglobStar;
        }

        if (token.prev.type === 'bos' && eos()) {
          state.negatedExtglob = true;
        }
      }

      push({ type: 'paren', extglob: true, value, output });
      decrement('parens');
    };

    if (opts.fastpaths !== false && !/(^[*!]|[/{[()\]}"])/.test(input)) {
      let backslashes = false;

      let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
        if (first === '\\') {
          backslashes = true;
          return m;
        }

        if (first === '?') {
          if (esc) {
            return esc + first + (rest ? QMARK.repeat(rest.length) : '');
          }
          if (index === 0) {
            return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
          }
          return QMARK.repeat(chars.length);
        }

        if (first === '.') {
          return DOT_LITERAL.repeat(chars.length);
        }

        if (first === '*') {
          if (esc) {
            return esc + first + (rest ? star : '');
          }
          return star;
        }
        return esc ? m : '\\' + m;
      });

      if (backslashes === true) {
        if (opts.unescape === true) {
          output = output.replace(/\\/g, '');
        } else {
          output = output.replace(/\\+/g, m => {
            return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
          });
        }
      }

      state.output = output;
      return state;
    }

    /**
     * Tokenize input until we reach end-of-string
     */

    while (!eos()) {
      value = advance();

      if (value === '\u0000') {
        continue;
      }

      /**
       * Escaped characters
       */

      if (value === '\\') {
        let next = peek();

        if (next === '/' && opts.bash !== true) {
          continue;
        }

        if (next === '.' || next === ';') {
          continue;
        }

        if (!next) {
          value += '\\';
          push({ type: 'text', value });
          continue;
        }

        // collapse slashes to reduce potential for exploits
        let match = /^\\+/.exec(input.slice(state.index + 1));
        let slashes = 0;

        if (match && match[0].length > 2) {
          slashes = match[0].length;
          state.index += slashes;
          if (slashes % 2 !== 0) {
            value += '\\';
          }
        }

        if (opts.unescape === true) {
          value = advance() || '';
        } else {
          value += advance() || '';
        }

        if (state.brackets === 0) {
          push({ type: 'text', value });
          continue;
        }
      }

      /**
       * If we're inside a regex character class, continue
       * until we reach the closing bracket.
       */

      if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
        if (opts.posix !== false && value === ':') {
          let inner = prev.value.slice(1);
          if (inner.includes('[')) {
            prev.posix = true;

            if (inner.includes(':')) {
              let idx = prev.value.lastIndexOf('[');
              let pre = prev.value.slice(0, idx);
              let rest = prev.value.slice(idx + 2);
              let posix = POSIX_REGEX_SOURCE[rest];
              if (posix) {
                prev.value = pre + posix;
                state.backtrack = true;
                advance();

                if (!bos.output && tokens.indexOf(prev) === 1) {
                  bos.output = ONE_CHAR;
                }
                continue;
              }
            }
          }
        }

        if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
          value = '\\' + value;
        }

        if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
          value = '\\' + value;
        }

        if (opts.posix === true && value === '!' && prev.value === '[') {
          value = '^';
        }

        prev.value += value;
        append({ value });
        continue;
      }

      /**
       * If we're inside a quoted string, continue
       * until we reach the closing double quote.
       */

      if (state.quotes === 1 && value !== '"') {
        value = utils.escapeRegex(value);
        prev.value += value;
        append({ value });
        continue;
      }

      /**
       * Double quotes
       */

      if (value === '"') {
        state.quotes = state.quotes === 1 ? 0 : 1;
        if (opts.keepQuotes === true) {
          push({ type: 'text', value });
        }
        continue;
      }

      /**
       * Parentheses
       */

      if (value === '(') {
        push({ type: 'paren', value });
        increment('parens');
        continue;
      }

      if (value === ')') {
        if (state.parens === 0 && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('opening', '('));
        }

        let extglob = extglobs[extglobs.length - 1];
        if (extglob && state.parens === extglob.parens + 1) {
          extglobClose(extglobs.pop());
          continue;
        }

        push({ type: 'paren', value, output: state.parens ? ')' : '\\)' });
        decrement('parens');
        continue;
      }

      /**
       * Brackets
       */

      if (value === '[') {
        if (opts.nobracket === true || !input.slice(state.index + 1).includes(']')) {
          if (opts.nobracket !== true && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError('closing', ']'));
          }

          value = '\\' + value;
        } else {
          increment('brackets');
        }

        push({ type: 'bracket', value });
        continue;
      }

      if (value === ']') {
        if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
          push({ type: 'text', value, output: '\\' + value });
          continue;
        }

        if (state.brackets === 0) {
          if (opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError('opening', '['));
          }

          push({ type: 'text', value, output: '\\' + value });
          continue;
        }

        decrement('brackets');

        let prevValue = prev.value.slice(1);
        if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
          value = '/' + value;
        }

        prev.value += value;
        append({ value });

        // when literal brackets are explicitly disabled
        // assume we should match with a regex character class
        if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
          continue;
        }

        let escaped = utils.escapeRegex(prev.value);
        state.output = state.output.slice(0, -prev.value.length);

        // when literal brackets are explicitly enabled
        // assume we should escape the brackets to match literal characters
        if (opts.literalBrackets === true) {
          state.output += escaped;
          prev.value = escaped;
          continue;
        }

        // when the user specifies nothing, try to match both
        prev.value = `(${capture}${escaped}|${prev.value})`;
        state.output += prev.value;
        continue;
      }

      /**
       * Braces
       */

      if (value === '{' && opts.nobrace !== true) {
        push({ type: 'brace', value, output: '(' });
        increment('braces');
        continue;
      }

      if (value === '}') {
        if (opts.nobrace === true || state.braces === 0) {
          push({ type: 'text', value, output: '\\' + value });
          continue;
        }

        let output = ')';

        if (state.dots === true) {
          let arr = tokens.slice();
          let range = [];

          for (let i = arr.length - 1; i >= 0; i--) {
            tokens.pop();
            if (arr[i].type === 'brace') {
              break;
            }
            if (arr[i].type !== 'dots') {
              range.unshift(arr[i].value);
            }
          }

          output = expandRange(range, opts);
          state.backtrack = true;
        }

        push({ type: 'brace', value, output });
        decrement('braces');
        continue;
      }

      /**
       * Pipes
       */

      if (value === '|') {
        if (extglobs.length > 0) {
          extglobs[extglobs.length - 1].conditions++;
        }
        push({ type: 'text', value });
        continue;
      }

      /**
       * Commas
       */

      if (value === ',') {
        let output = value;

        if (state.braces > 0 && stack[stack.length - 1] === 'braces') {
          output = '|';
        }

        push({ type: 'comma', value, output });
        continue;
      }

      /**
       * Slashes
       */

      if (value === '/') {
        // if the beginning of the glob is "./", advance the start
        // to the current index, and don't add the "./" characters
        // to the state. This greatly simplifies lookbehinds when
        // checking for BOS characters like "!" and "." (not "./")
        if (prev.type === 'dot' && state.index === 1) {
          state.start = state.index + 1;
          state.consumed = '';
          state.output = '';
          tokens.pop();
          prev = bos; // reset "prev" to the first token
          continue;
        }

        push({ type: 'slash', value, output: SLASH_LITERAL });
        continue;
      }

      /**
       * Dots
       */

      if (value === '.') {
        if (state.braces > 0 && prev.type === 'dot') {
          if (prev.value === '.') prev.output = DOT_LITERAL;
          prev.type = 'dots';
          prev.output += value;
          prev.value += value;
          state.dots = true;
          continue;
        }

        push({ type: 'dot', value, output: DOT_LITERAL });
        continue;
      }

      /**
       * Question marks
       */

      if (value === '?') {
        if (prev && prev.type === 'paren') {
          let next = peek();
          let output = value;

          if (next === '<' && !utils.supportsLookbehinds()) {
            throw new Error('Node.js v10 or higher is required for regex lookbehinds');
          }

          if (prev.value === '(' && !/[!=<:]/.test(next) || (next === '<' && !/[!=]/.test(peek(2)))) {
            output = '\\' + value;
          }

          push({ type: 'text', value, output });
          continue;
        }

        if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
          extglobOpen('qmark', value);
          continue;
        }

        if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
          push({ type: 'qmark', value, output: QMARK_NO_DOT });
          continue;
        }

        push({ type: 'qmark', value, output: QMARK });
        continue;
      }

      /**
       * Exclamation
       */

      if (value === '!') {
        if (opts.noextglob !== true && peek() === '(') {
          if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
            extglobOpen('negate', value);
            continue;
          }
        }

        if (opts.nonegate !== true && state.index === 0) {
          negate(state);
          continue;
        }
      }

      /**
       * Plus
       */

      if (value === '+') {
        if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
          extglobOpen('plus', value);
          continue;
        }

        if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) {
          let output = prev.extglob === true ? '\\' + value : value;
          push({ type: 'plus', value, output });
          continue;
        }

        // use regex behavior inside parens
        if (state.parens > 0 && opts.regex !== false) {
          push({ type: 'plus', value });
          continue;
        }

        push({ type: 'plus', value: PLUS_LITERAL });
        continue;
      }

      /**
       * Plain text
       */

      if (value === '@') {
        if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
          push({ type: 'at', value, output: '' });
          continue;
        }

        push({ type: 'text', value });
        continue;
      }

      /**
       * Plain text
       */

      if (value !== '*') {
        if (value === '$' || value === '^') {
          value = '\\' + value;
        }

        let match = REGEX_NON_SPECIAL_CHAR.exec(input.slice(state.index + 1));
        if (match) {
          value += match[0];
          state.index += match[0].length;
        }

        push({ type: 'text', value });
        continue;
      }

      /**
       * Stars
       */

      if (prev && (prev.type === 'globstar' || prev.star === true)) {
        prev.type = 'star';
        prev.star = true;
        prev.value += value;
        prev.output = star;
        state.backtrack = true;
        state.consumed += value;
        continue;
      }

      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('star', value);
        continue;
      }

      if (prev.type === 'star') {
        if (opts.noglobstar === true) {
          state.consumed += value;
          continue;
        }

        let prior = prev.prev;
        let before = prior.prev;
        let isStart = prior.type === 'slash' || prior.type === 'bos';
        let afterStar = before && (before.type === 'star' || before.type === 'globstar');

        if (opts.bash === true && (!isStart || (!eos() && peek() !== '/'))) {
          push({ type: 'star', value, output: '' });
          continue;
        }

        let isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
        let isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
        if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
          push({ type: 'star', value, output: '' });
          continue;
        }

        // strip consecutive `/**/`
        while (input.slice(state.index + 1, state.index + 4) === '/**') {
          let after = input[state.index + 4];
          if (after && after !== '/') {
            break;
          }
          state.consumed += '/**';
          state.index += 3;
        }

        if (prior.type === 'bos' && eos()) {
          prev.type = 'globstar';
          prev.value += value;
          prev.output = globstar(opts);
          state.output = prev.output;
          state.consumed += value;
          continue;
        }

        if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = '(?:' + prior.output;

          prev.type = 'globstar';
          prev.output = globstar(opts) + '|$)';
          prev.value += value;

          state.output += prior.output + prev.output;
          state.consumed += value;
          continue;
        }

        let next = peek();
        if (prior.type === 'slash' && prior.prev.type !== 'bos' && next === '/') {
          let end = peek(2) !== void 0 ? '|$' : '';

          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = '(?:' + prior.output;

          prev.type = 'globstar';
          prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
          prev.value += value;

          state.output += prior.output + prev.output;
          state.consumed += value + advance();

          push({ type: 'slash', value, output: '' });
          continue;
        }

        if (prior.type === 'bos' && next === '/') {
          prev.type = 'globstar';
          prev.value += value;
          prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
          state.output = prev.output;
          state.consumed += value + advance();
          push({ type: 'slash', value, output: '' });
          continue;
        }

        // remove single star from output
        state.output = state.output.slice(0, -prev.output.length);

        // reset previous token to globstar
        prev.type = 'globstar';
        prev.output = globstar(opts);
        prev.value += value;

        // reset output with globstar
        state.output += prev.output;
        state.consumed += value;
        continue;
      }

      let token = { type: 'star', value, output: star };

      if (opts.bash === true) {
        token.output = '.*?';
        if (prev.type === 'bos' || prev.type === 'slash') {
          token.output = nodot + token.output;
        }
        push(token);
        continue;
      }

      if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
        token.output = value;
        push(token);
        continue;
      }

      if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
        if (prev.type === 'dot') {
          state.output += NO_DOT_SLASH;
          prev.output += NO_DOT_SLASH;

        } else if (opts.dot === true) {
          state.output += NO_DOTS_SLASH;
          prev.output += NO_DOTS_SLASH;

        } else {
          state.output += nodot;
          prev.output += nodot;
        }

        if (peek() !== '*') {
          state.output += ONE_CHAR;
          prev.output += ONE_CHAR;
        }
      }

      push(token);
    }

    while (state.brackets > 0) {
      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
      state.output = utils.escapeLast(state.output, '[');
      decrement('brackets');
    }

    while (state.parens > 0) {
      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
      state.output = utils.escapeLast(state.output, '(');
      decrement('parens');
    }

    while (state.braces > 0) {
      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
      state.output = utils.escapeLast(state.output, '{');
      decrement('braces');
    }

    if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
      push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });
    }

    // rebuild the output if we had to backtrack at any point
    if (state.backtrack === true) {
      state.output = '';

      for (let token of state.tokens) {
        state.output += token.output != null ? token.output : token.value;

        if (token.suffix) {
          state.output += token.suffix;
        }
      }
    }

    return state;
  };

  /**
   * Fast paths for creating regular expressions for common glob patterns.
   * This can significantly speed up processing and has very little downside
   * impact when none of the fast paths match.
   */

  parse.fastpaths = (input, options) => {
    let opts = { ...options };
    let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    let len = input.length;
    if (len > max) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    }

    input = REPLACEMENTS[input] || input;
    let win32 = utils.isWindows(options);

    // create constants based on platform, for windows or posix
    const {
      DOT_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOTS_SLASH,
      STAR,
      START_ANCHOR
    } = constants.globChars(win32);

    let capture = opts.capture ? '' : '?:';
    let star = opts.bash === true ? '.*?' : STAR;
    let nodot = opts.dot ? NO_DOTS : NO_DOT;
    let slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;

    if (opts.capture) {
      star = `(${star})`;
    }

    const globstar = (opts) => {
      return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };

    const create = str => {
      switch (str) {
        case '*':
          return `${nodot}${ONE_CHAR}${star}`;

        case '.*':
          return `${DOT_LITERAL}${ONE_CHAR}${star}`;

        case '*.*':
          return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

        case '*/*':
          return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

        case '**':
          return nodot + globstar(opts);

        case '**/*':
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

        case '**/*.*':
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

        case '**/.*':
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

        default: {
          let match = /^(.*?)\.(\w+)$/.exec(str);
          if (!match) return;

          let source = create(match[1], options);
          if (!source) return;

          return source + DOT_LITERAL + match[2];
        }
      }
    };

    let output = create(input);
    if (output && opts.strictSlashes !== true) {
      output += `${SLASH_LITERAL}?`;
    }

    return output;
  };

  module.exports = parse;


  /***/ }),
  /* 124 */
  /***/ (function(module, exports, __webpack_require__) {

  module.exports = __webpack_require__(125);


  /***/ }),
  /* 125 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var net = __webpack_require__(89);
  var tls = __webpack_require__(126);
  var http = __webpack_require__(48);
  var https = __webpack_require__(56);
  var events = __webpack_require__(67);
  var assert = __webpack_require__(127);
  var util = __webpack_require__(25);


  exports.httpOverHttp = httpOverHttp;
  exports.httpsOverHttp = httpsOverHttp;
  exports.httpOverHttps = httpOverHttps;
  exports.httpsOverHttps = httpsOverHttps;


  function httpOverHttp(options) {
    var agent = new TunnelingAgent(options);
    agent.request = http.request;
    return agent;
  }

  function httpsOverHttp(options) {
    var agent = new TunnelingAgent(options);
    agent.request = http.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
  }

  function httpOverHttps(options) {
    var agent = new TunnelingAgent(options);
    agent.request = https.request;
    return agent;
  }

  function httpsOverHttps(options) {
    var agent = new TunnelingAgent(options);
    agent.request = https.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
  }


  function TunnelingAgent(options) {
    var self = this;
    self.options = options || {};
    self.proxyOptions = self.options.proxy || {};
    self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
    self.requests = [];
    self.sockets = [];

    self.on('free', function onFree(socket, host, port, localAddress) {
      var options = toOptions(host, port, localAddress);
      for (var i = 0, len = self.requests.length; i < len; ++i) {
        var pending = self.requests[i];
        if (pending.host === options.host && pending.port === options.port) {
          // Detect the request to connect same origin server,
          // reuse the connection.
          self.requests.splice(i, 1);
          pending.request.onSocket(socket);
          return;
        }
      }
      socket.destroy();
      self.removeSocket(socket);
    });
  }
  util.inherits(TunnelingAgent, events.EventEmitter);

  TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
    var self = this;
    var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

    if (self.sockets.length >= this.maxSockets) {
      // We are over limit so we'll add it to the queue.
      self.requests.push(options);
      return;
    }

    // If we are under maxSockets create a new one.
    self.createSocket(options, function(socket) {
      socket.on('free', onFree);
      socket.on('close', onCloseOrRemove);
      socket.on('agentRemove', onCloseOrRemove);
      req.onSocket(socket);

      function onFree() {
        self.emit('free', socket, options);
      }

      function onCloseOrRemove(err) {
        self.removeSocket(socket);
        socket.removeListener('free', onFree);
        socket.removeListener('close', onCloseOrRemove);
        socket.removeListener('agentRemove', onCloseOrRemove);
      }
    });
  };

  TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
    var self = this;
    var placeholder = {};
    self.sockets.push(placeholder);

    var connectOptions = mergeOptions({}, self.proxyOptions, {
      method: 'CONNECT',
      path: options.host + ':' + options.port,
      agent: false,
      headers: {
        host: options.host + ':' + options.port
      }
    });
    if (options.localAddress) {
      connectOptions.localAddress = options.localAddress;
    }
    if (connectOptions.proxyAuth) {
      connectOptions.headers = connectOptions.headers || {};
      connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
          new Buffer(connectOptions.proxyAuth).toString('base64');
    }

    debug('making CONNECT request');
    var connectReq = self.request(connectOptions);
    connectReq.useChunkedEncodingByDefault = false; // for v0.6
    connectReq.once('response', onResponse); // for v0.6
    connectReq.once('upgrade', onUpgrade);   // for v0.6
    connectReq.once('connect', onConnect);   // for v0.7 or later
    connectReq.once('error', onError);
    connectReq.end();

    function onResponse(res) {
      // Very hacky. This is necessary to avoid http-parser leaks.
      res.upgrade = true;
    }

    function onUpgrade(res, socket, head) {
      // Hacky.
      process.nextTick(function() {
        onConnect(res, socket, head);
      });
    }

    function onConnect(res, socket, head) {
      connectReq.removeAllListeners();
      socket.removeAllListeners();

      if (res.statusCode !== 200) {
        debug('tunneling socket could not be established, statusCode=%d',
          res.statusCode);
        socket.destroy();
        var error = new Error('tunneling socket could not be established, ' +
          'statusCode=' + res.statusCode);
        error.code = 'ECONNRESET';
        options.request.emit('error', error);
        self.removeSocket(placeholder);
        return;
      }
      if (head.length > 0) {
        debug('got illegal response body from proxy');
        socket.destroy();
        var error = new Error('got illegal response body from proxy');
        error.code = 'ECONNRESET';
        options.request.emit('error', error);
        self.removeSocket(placeholder);
        return;
      }
      debug('tunneling connection has established');
      self.sockets[self.sockets.indexOf(placeholder)] = socket;
      return cb(socket);
    }

    function onError(cause) {
      connectReq.removeAllListeners();

      debug('tunneling socket could not be established, cause=%s\n',
            cause.message, cause.stack);
      var error = new Error('tunneling socket could not be established, ' +
                            'cause=' + cause.message);
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
    }
  };

  TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
    var pos = this.sockets.indexOf(socket)
    if (pos === -1) {
      return;
    }
    this.sockets.splice(pos, 1);

    var pending = this.requests.shift();
    if (pending) {
      // If we have pending requests and a socket gets closed a new one
      // needs to be created to take over in the pool for the one that closed.
      this.createSocket(pending, function(socket) {
        pending.request.onSocket(socket);
      });
    }
  };

  function createSecureSocket(options, cb) {
    var self = this;
    TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
      var hostHeader = options.request.getHeader('host');
      var tlsOptions = mergeOptions({}, self.options, {
        socket: socket,
        servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
      });

      // 0 is dummy port for v0.6
      var secureSocket = tls.connect(0, tlsOptions);
      self.sockets[self.sockets.indexOf(socket)] = secureSocket;
      cb(secureSocket);
    });
  }


  function toOptions(host, port, localAddress) {
    if (typeof host === 'string') { // since v0.10
      return {
        host: host,
        port: port,
        localAddress: localAddress
      };
    }
    return host; // for v0.11 or later
  }

  function mergeOptions(target) {
    for (var i = 1, len = arguments.length; i < len; ++i) {
      var overrides = arguments[i];
      if (typeof overrides === 'object') {
        var keys = Object.keys(overrides);
        for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
          var k = keys[j];
          if (overrides[k] !== undefined) {
            target[k] = overrides[k];
          }
        }
      }
    }
    return target;
  }


  var debug;
  if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments);
      if (typeof args[0] === 'string') {
        args[0] = 'TUNNEL: ' + args[0];
      } else {
        args.unshift('TUNNEL:');
      }
      console.error.apply(console, args);
    }
  } else {
    debug = function() {};
  }
  exports.debug = debug; // for test


  /***/ }),
  /* 126 */
  /***/ (function(module, exports) {

  module.exports = require("tls");

  /***/ }),
  /* 127 */
  /***/ (function(module, exports) {

  module.exports = require("assert");

  /***/ }),
  /* 128 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const stream_1 = __webpack_require__(24);
  // Executes a chunk of code and calls a cleanup function once it returns (even
  // if it throws an exception)
  async function releaseAfterUseAsync(fn, cleanup) {
      if (!cleanup)
          return await fn();
      try {
          return await fn();
      }
      finally {
          await cleanup();
      }
  }
  exports.releaseAfterUseAsync = releaseAfterUseAsync;
  // Executes a chunk of code but slightly modify its exception message if it
  // throws something
  async function prettifyAsyncErrors(fn, update) {
      try {
          return await fn();
      }
      catch (error) {
          error.message = update(error.message);
          throw error;
      }
  }
  exports.prettifyAsyncErrors = prettifyAsyncErrors;
  // Same thing but synchronous
  function prettifySyncErrors(fn, update) {
      try {
          return fn();
      }
      catch (error) {
          error.message = update(error.message);
          throw error;
      }
  }
  exports.prettifySyncErrors = prettifySyncErrors;
  // Converts a Node stream into a Buffer instance
  async function bufferStream(stream) {
      return await new Promise((resolve, reject) => {
          const chunks = [];
          stream.on(`error`, error => {
              reject(error);
          });
          stream.on(`data`, chunk => {
              chunks.push(chunk);
          });
          stream.on(`end`, () => {
              resolve(Buffer.concat(chunks));
          });
      });
  }
  exports.bufferStream = bufferStream;
  // A stream implementation that buffers a stream to send it all at once
  class BufferStream extends stream_1.Transform {
      constructor() {
          super(...arguments);
          this.chunks = [];
      }
      _transform(chunk, encoding, cb) {
          if (encoding !== `buffer` || !Buffer.isBuffer(chunk))
              throw new Error(`Assertion failed: BufferStream only accept buffers`);
          this.chunks.push(chunk);
          cb(null, null);
      }
      _flush(cb) {
          cb(null, Buffer.concat(this.chunks));
      }
  }
  exports.BufferStream = BufferStream;
  // A stream implementation that prints a message if nothing was output
  class DefaultStream extends stream_1.Transform {
      constructor(ifEmpty = Buffer.alloc(0)) {
          super();
          this.active = true;
          this.ifEmpty = ifEmpty;
      }
      _transform(chunk, encoding, cb) {
          if (encoding !== `buffer` || !Buffer.isBuffer(chunk))
              throw new Error(`Assertion failed: DefaultStream only accept buffers`);
          this.active = false;
          cb(null, chunk);
      }
      _flush(cb) {
          if (this.active && this.ifEmpty.length > 0) {
              cb(null, this.ifEmpty);
          }
      }
  }
  exports.DefaultStream = DefaultStream;
  // Webpack has this annoying tendency to replace dynamic requires by a stub
  // code that simply throws when called. It's all fine and dandy in the context
  // of a web application, but is quite annoying when working with Node projects!
  function dynamicRequire(path) {
      // @ts-ignore
      if (typeof require !== 'undefined') {
          // @ts-ignore
          return require(path);
      }
      else {
          return __webpack_require__(129)(path);
      }
  }
  exports.dynamicRequire = dynamicRequire;
  // This function transforms an iterable into an array and sorts it according to
  // the mapper functions provided as parameter. The mappers are expected to take
  // each element from the iterable and generate a string from it, that will then
  // be used to compare the entries.
  //
  // Using sortMap is more efficient than kinda reimplementing the logic in a sort
  // predicate because sortMap caches the result of the mappers in such a way that
  // they are guaranteed to be executed exactly once for each element.
  function sortMap(values, mappers) {
      const asArray = Array.from(values);
      if (!Array.isArray(mappers))
          mappers = [mappers];
      const stringified = [];
      for (const mapper of mappers)
          stringified.push(asArray.map(value => mapper(value)));
      const indices = asArray.map((_, index) => index);
      indices.sort((a, b) => {
          for (const layer of stringified) {
              const comparison = layer[a] < layer[b] ? -1 : layer[a] > layer[b] ? +1 : 0;
              if (comparison !== 0) {
                  return comparison;
              }
          }
          return 0;
      });
      return indices.map(index => {
          return asArray[index];
      });
  }
  exports.sortMap = sortMap;


  /***/ }),
  /* 129 */
  /***/ (function(module, exports) {

  function webpackEmptyContext(req) {
  	var e = new Error("Cannot find module '" + req + "'");
  	e.code = 'MODULE_NOT_FOUND';
  	throw e;
  }
  webpackEmptyContext.keys = function() { return []; };
  webpackEmptyContext.resolve = webpackEmptyContext;
  module.exports = webpackEmptyContext;
  webpackEmptyContext.id = 129;

  /***/ }),
  /* 130 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      result["default"] = mod;
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const fslib_1 = __webpack_require__(5);
  const fslib_2 = __webpack_require__(5);
  const shell_1 = __webpack_require__(131);
  const stream_1 = __webpack_require__(24);
  const tmp_1 = __webpack_require__(6);
  const Manifest_1 = __webpack_require__(172);
  const StreamReport_1 = __webpack_require__(176);
  const execUtils = __importStar(__webpack_require__(4));
  const structUtils = __importStar(__webpack_require__(173));
  async function makePathWrapper(location, name, argv0, args = []) {
      if (process.platform === `win32`) {
          await fslib_2.xfs.writeFilePromise(fslib_2.ppath.format({ dir: location, name, ext: '.cmd' }), `@"${argv0}" ${args.join(` `)} %*\n`);
      }
      else {
          await fslib_2.xfs.writeFilePromise(fslib_2.ppath.join(location, name), `#!/bin/sh\nexec "${argv0}" ${args.map(arg => `'${arg.replace(/'/g, `'"'"'`)}'`).join(` `)} "$@"\n`);
          await fslib_2.xfs.chmodPromise(fslib_2.ppath.join(location, name), 0o755);
      }
  }
  async function makeScriptEnv(project, lifecycleScript) {
      const scriptEnv = {};
      for (const [key, value] of Object.entries(process.env))
          if (typeof value !== `undefined`)
              scriptEnv[key.toLowerCase() !== `path` ? key : `PATH`] = value;
      const nativeBinFolder = tmp_1.dirSync().name;
      const binFolder = fslib_1.NodeFS.toPortablePath(nativeBinFolder);
      // We expose the base folder in the environment so that we can later add the
      // binaries for the dependencies of the active package
      scriptEnv.BERRY_BIN_FOLDER = nativeBinFolder;
      // Register some binaries that must be made available in all subprocesses
      // spawned by Yarn (we thus ensure that they always use the right version)
      await makePathWrapper(binFolder, fslib_2.toFilename(`run`), process.execPath, [process.argv[1], `run`]);
      await makePathWrapper(binFolder, fslib_2.toFilename(`yarn`), process.execPath, [process.argv[1]]);
      await makePathWrapper(binFolder, fslib_2.toFilename(`yarnpkg`), process.execPath, [process.argv[1]]);
      await makePathWrapper(binFolder, fslib_2.toFilename(`node`), process.execPath);
      await makePathWrapper(binFolder, fslib_2.toFilename(`node-gyp`), process.execPath, [process.argv[1], `run`, `--top-level`, `node-gyp`]);
      scriptEnv.PATH = scriptEnv.PATH
          ? `${nativeBinFolder}${fslib_2.npath.delimiter}${scriptEnv.PATH}`
          : `${nativeBinFolder}`;
      scriptEnv.npm_execpath = `${nativeBinFolder}${fslib_2.npath.sep}yarn`;
      scriptEnv.npm_node_execpath = `${nativeBinFolder}${fslib_2.npath.sep}node`;
      scriptEnv.npm_config_user_agent = `yarn/? npm/? node/${process.versions.node} ${process.platform} ${process.arch}`;
      if (lifecycleScript)
          scriptEnv.npm_lifecycle_event = lifecycleScript;
      await project.configuration.triggerHook(hook => hook.setupScriptEnvironment, project, scriptEnv, async (name, argv0, args) => {
          return await makePathWrapper(binFolder, fslib_2.toFilename(name), argv0, args);
      });
      return scriptEnv;
  }
  exports.makeScriptEnv = makeScriptEnv;
  async function hasPackageScript(locator, scriptName, { project }) {
      const pkg = project.storedPackages.get(locator.locatorHash);
      if (!pkg)
          throw new Error(`Package for ${structUtils.prettyLocator(project.configuration, locator)} not found in the project`);
      return await fslib_1.ZipOpenFS.openPromise(async (zipOpenFs) => {
          const configuration = project.configuration;
          const linkers = project.configuration.getLinkers();
          const linkerOptions = { project, report: new StreamReport_1.StreamReport({ stdout: new stream_1.PassThrough(), configuration }) };
          const linker = linkers.find(linker => linker.supportsPackage(pkg, linkerOptions));
          if (!linker)
              throw new Error(`The package ${structUtils.prettyLocator(project.configuration, pkg)} isn't supported by any of the available linkers`);
          const packageLocation = await linker.findPackageLocation(pkg, linkerOptions);
          const packageFs = new fslib_1.CwdFS(packageLocation, { baseFs: zipOpenFs });
          const manifest = await Manifest_1.Manifest.find(fslib_1.PortablePath.dot, { baseFs: packageFs });
          return manifest.scripts.has(scriptName);
      });
  }
  exports.hasPackageScript = hasPackageScript;
  async function executePackageScript(locator, scriptName, args, { cwd, project, stdin, stdout, stderr }) {
      const { manifest, binFolder, env, cwd: realCwd } = await initializePackageEnvironment(locator, { project, cwd, lifecycleScript: scriptName });
      const script = manifest.scripts.get(scriptName);
      if (!script)
          return;
      const realExecutor = async () => {
          return await shell_1.execute(script, args, { cwd: realCwd, env, stdin, stdout, stderr });
      };
      const executor = await project.configuration.reduceHook(hooks => {
          return hooks.wrapScriptExecution;
      }, realExecutor, project, locator, scriptName, {
          script, args, cwd: realCwd, env, stdin, stdout, stderr,
      });
      try {
          return await executor();
      }
      finally {
          await fslib_2.xfs.removePromise(binFolder);
      }
  }
  exports.executePackageScript = executePackageScript;
  async function executePackageShellcode(locator, command, args, { cwd, project, stdin, stdout, stderr }) {
      const { binFolder, env, cwd: realCwd } = await initializePackageEnvironment(locator, { project, cwd });
      try {
          return await shell_1.execute(command, args, { cwd: realCwd, env, stdin, stdout, stderr });
      }
      finally {
          await fslib_2.xfs.removePromise(binFolder);
      }
  }
  exports.executePackageShellcode = executePackageShellcode;
  async function initializePackageEnvironment(locator, { project, cwd, lifecycleScript }) {
      const pkg = project.storedPackages.get(locator.locatorHash);
      if (!pkg)
          throw new Error(`Package for ${structUtils.prettyLocator(project.configuration, locator)} not found in the project`);
      return await fslib_1.ZipOpenFS.openPromise(async (zipOpenFs) => {
          const configuration = project.configuration;
          const linkers = project.configuration.getLinkers();
          const linkerOptions = { project, report: new StreamReport_1.StreamReport({ stdout: new stream_1.PassThrough(), configuration }) };
          const linker = linkers.find(linker => linker.supportsPackage(pkg, linkerOptions));
          if (!linker)
              throw new Error(`The package ${structUtils.prettyLocator(project.configuration, pkg)} isn't supported by any of the available linkers`);
          const env = await makeScriptEnv(project, lifecycleScript);
          const binFolder = fslib_1.NodeFS.toPortablePath(env.BERRY_BIN_FOLDER);
          for (const [binaryName, [, binaryPath]] of await getPackageAccessibleBinaries(locator, { project }))
              await makePathWrapper(binFolder, fslib_2.toFilename(binaryName), process.execPath, [binaryPath]);
          const packageLocation = await linker.findPackageLocation(pkg, linkerOptions);
          const packageFs = new fslib_1.CwdFS(packageLocation, { baseFs: zipOpenFs });
          const manifest = await Manifest_1.Manifest.find(fslib_1.PortablePath.dot, { baseFs: packageFs });
          if (typeof cwd === `undefined`)
              cwd = packageLocation;
          return { manifest, binFolder, env, cwd };
      });
  }
  async function executeWorkspaceScript(workspace, scriptName, args, { cwd, stdin, stdout, stderr }) {
      return await executePackageScript(workspace.anchoredLocator, scriptName, args, { cwd, project: workspace.project, stdin, stdout, stderr });
  }
  exports.executeWorkspaceScript = executeWorkspaceScript;
  async function hasWorkspaceScript(workspace, scriptName) {
      return await hasPackageScript(workspace.anchoredLocator, scriptName, { project: workspace.project });
  }
  exports.hasWorkspaceScript = hasWorkspaceScript;
  /**
   * Return the binaries that can be accessed by the specified package
   *
   * @param locator The queried package
   * @param project The project owning the package
   */
  async function getPackageAccessibleBinaries(locator, { project }) {
      const configuration = project.configuration;
      const binaries = new Map();
      const pkg = project.storedPackages.get(locator.locatorHash);
      if (!pkg)
          throw new Error(`Package for ${structUtils.prettyLocator(configuration, locator)} not found in the project`);
      const stdout = new stream_1.Writable();
      const linkers = configuration.getLinkers();
      const linkerOptions = { project, report: new StreamReport_1.StreamReport({ configuration, stdout }) };
      const visibleLocators = new Set([locator.locatorHash]);
      for (const descriptor of pkg.dependencies.values()) {
          const resolution = project.storedResolutions.get(descriptor.descriptorHash);
          if (!resolution)
              throw new Error(`Assertion failed: The resolution (${structUtils.prettyDescriptor(configuration, descriptor)}) should have been registered`);
          visibleLocators.add(resolution);
      }
      for (const locatorHash of visibleLocators) {
          const dependency = project.storedPackages.get(locatorHash);
          if (!dependency)
              throw new Error(`Assertion failed: The package (${locatorHash}) should have been registered`);
          if (dependency.bin.size === 0)
              continue;
          const linker = linkers.find(linker => linker.supportsPackage(dependency, linkerOptions));
          if (!linker)
              continue;
          const packageLocation = await linker.findPackageLocation(dependency, linkerOptions);
          for (const [name, target] of dependency.bin) {
              binaries.set(name, [dependency, fslib_1.NodeFS.fromPortablePath(fslib_2.ppath.resolve(packageLocation, target))]);
          }
      }
      return binaries;
  }
  exports.getPackageAccessibleBinaries = getPackageAccessibleBinaries;
  /**
   * Return the binaries that can be accessed by the specified workspace
   *
   * @param workspace The queried workspace
   */
  async function getWorkspaceAccessibleBinaries(workspace) {
      return await getPackageAccessibleBinaries(workspace.anchoredLocator, { project: workspace.project });
  }
  exports.getWorkspaceAccessibleBinaries = getWorkspaceAccessibleBinaries;
  /**
   * Execute a binary from the specified package.
   *
   * Note that "binary" in this sense means "a Javascript file". Actual native
   * binaries cannot be executed this way, because we use Node in order to
   * transparently read from the archives.
   *
   * @param locator The queried package
   * @param binaryName The name of the binary file to execute
   * @param args The arguments to pass to the file
   */
  async function executePackageAccessibleBinary(locator, binaryName, args, { cwd, project, stdin, stdout, stderr }) {
      const packageAccessibleBinaries = await getPackageAccessibleBinaries(locator, { project });
      const binary = packageAccessibleBinaries.get(binaryName);
      if (!binary)
          throw new Error(`Binary not found (${binaryName}) for ${structUtils.prettyLocator(project.configuration, locator)}`);
      const [, binaryPath] = binary;
      const env = await makeScriptEnv(project);
      for (const [binaryName, [, binaryPath]] of packageAccessibleBinaries)
          await makePathWrapper(env.BERRY_BIN_FOLDER, fslib_2.toFilename(binaryName), process.execPath, [binaryPath]);
      let result;
      try {
          result = await execUtils.pipevp(process.execPath, [binaryPath, ...args], { cwd, env, stdin, stdout, stderr });
      }
      finally {
          await fslib_2.xfs.removePromise(env.BERRY_BIN_FOLDER);
      }
      return result.code;
  }
  exports.executePackageAccessibleBinary = executePackageAccessibleBinary;
  /**
   * Execute a binary from the specified workspace
   *
   * @param workspace The queried package
   * @param binaryName The name of the binary file to execute
   * @param args The arguments to pass to the file
   */
  async function executeWorkspaceAccessibleBinary(workspace, binaryName, args, { cwd, stdin, stdout, stderr }) {
      return await executePackageAccessibleBinary(workspace.anchoredLocator, binaryName, args, { project: workspace.project, cwd, stdin, stdout, stderr });
  }
  exports.executeWorkspaceAccessibleBinary = executeWorkspaceAccessibleBinary;


  /***/ }),
  /* 131 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const fslib_1 = __webpack_require__(5);
  const parsers_1 = __webpack_require__(132);
  const stream_1 = __webpack_require__(24);
  const pipe_1 = __webpack_require__(171);
  const pipe_2 = __webpack_require__(171);
  function cloneState(state, mergeWith = {}) {
      const newState = Object.assign({}, state, mergeWith);
      newState.environment = Object.assign({}, state.environment, mergeWith.environment);
      newState.variables = Object.assign({}, state.variables, mergeWith.variables);
      return newState;
  }
  const BUILTINS = new Map([
      [`cd`, async ([target, ...rest], opts, state) => {
              const resolvedTarget = fslib_1.ppath.resolve(state.cwd, fslib_1.NodeFS.toPortablePath(target));
              const stat = await fslib_1.xfs.statPromise(resolvedTarget);
              if (!stat.isDirectory()) {
                  state.stderr.write(`cd: not a directory\n`);
                  return 1;
              }
              else {
                  state.cwd = resolvedTarget;
                  return 0;
              }
          }],
      [`pwd`, async (args, opts, state) => {
              state.stdout.write(`${fslib_1.NodeFS.fromPortablePath(state.cwd)}\n`);
              return 0;
          }],
      [`true`, async (args, opts, state) => {
              return 0;
          }],
      [`false`, async (args, opts, state) => {
              return 1;
          }],
      [`exit`, async ([code, ...rest], opts, state) => {
              return state.exitCode = parseInt(code, 10);
          }],
      [`echo`, async (args, opts, state) => {
              state.stdout.write(`${args.join(` `)}\n`);
              return 0;
          }],
      [`setredirects`, async (args, opts, state) => {
              let stdin = state.stdin;
              let stdout = state.stdout;
              let stderr = state.stderr;
              const inputs = [];
              const outputs = [];
              let t = 0;
              while (args[t] !== `--`) {
                  const type = args[t++];
                  const count = Number(args[t++]);
                  const last = t + count;
                  for (let u = t; u < last; ++t, ++u) {
                      switch (type) {
                          case `<`:
                              {
                                  inputs.push(() => {
                                      return fslib_1.xfs.createReadStream(fslib_1.ppath.resolve(state.cwd, fslib_1.NodeFS.toPortablePath(args[u])));
                                  });
                              }
                              break;
                          case `<<<`:
                              {
                                  inputs.push(() => {
                                      const input = new stream_1.PassThrough();
                                      process.nextTick(() => {
                                          input.write(`${args[u]}\n`);
                                          input.end();
                                      });
                                      return input;
                                  });
                              }
                              break;
                          case `>`:
                              {
                                  outputs.push(fslib_1.xfs.createWriteStream(fslib_1.ppath.resolve(state.cwd, fslib_1.NodeFS.toPortablePath(args[u]))));
                              }
                              break;
                          case `>>`:
                              {
                                  outputs.push(fslib_1.xfs.createWriteStream(fslib_1.ppath.resolve(state.cwd, fslib_1.NodeFS.toPortablePath(args[u])), { flags: `a` }));
                              }
                              break;
                      }
                  }
              }
              if (inputs.length > 0) {
                  const pipe = new stream_1.PassThrough();
                  stdin = pipe;
                  const bindInput = (n) => {
                      if (n === inputs.length) {
                          pipe.end();
                      }
                      else {
                          const input = inputs[n]();
                          input.pipe(pipe, { end: false });
                          input.on(`end`, () => {
                              bindInput(n + 1);
                          });
                      }
                  };
                  bindInput(0);
              }
              if (outputs.length > 0) {
                  const pipe = new stream_1.PassThrough();
                  stdout = pipe;
                  for (const output of outputs) {
                      pipe.pipe(output);
                  }
              }
              const exitCode = await pipe_1.start(makeCommandAction(args.slice(t + 1), opts, state), {
                  stdin: new pipe_1.ProtectedStream(stdin),
                  stdout: new pipe_1.ProtectedStream(stdout),
                  stderr: new pipe_1.ProtectedStream(stderr),
              }).run();
              // Close all the outputs (since the shell never closes the output stream)
              await Promise.all(outputs.map(output => {
                  output.end();
                  // Wait until the output got flushed to the disk
                  return new Promise(resolve => {
                      output.on(`close`, () => {
                          resolve();
                      });
                  });
              }));
              return exitCode;
          }],
  ]);
  async function executeBufferedSubshell(ast, opts, state) {
      const chunks = [];
      const stdout = new stream_1.PassThrough();
      stdout.on(`data`, chunk => chunks.push(chunk));
      await executeShellLine(ast, opts, cloneState(state, { stdout }));
      return Buffer.concat(chunks).toString().replace(/[\r\n]+$/, ``);
  }
  async function applyEnvVariables(environmentSegments, opts, state) {
      const envPromises = environmentSegments.map(async (envSegment) => {
          const interpolatedArgs = await interpolateArguments(envSegment.args, opts, state);
          return {
              name: envSegment.name,
              value: interpolatedArgs.join(` `),
          };
      });
      const interpolatedEnvs = await Promise.all(envPromises);
      return interpolatedEnvs.reduce((envs, env) => {
          envs[env.name] = env.value;
          return envs;
      }, {});
  }
  async function interpolateArguments(commandArgs, opts, state) {
      const redirections = new Map();
      const interpolated = [];
      let interpolatedSegments = [];
      const split = (raw) => {
          return raw.match(/[^ \r\n\t]+/g) || [];
      };
      const push = (segment) => {
          interpolatedSegments.push(segment);
      };
      const close = () => {
          if (interpolatedSegments.length > 0)
              interpolated.push(interpolatedSegments.join(``));
          interpolatedSegments = [];
      };
      const pushAndClose = (segment) => {
          push(segment);
          close();
      };
      const redirect = (type, target) => {
          let targets = redirections.get(type);
          if (typeof targets === `undefined`)
              redirections.set(type, targets = []);
          targets.push(target);
      };
      for (const commandArg of commandArgs) {
          switch (commandArg.type) {
              case `redirection`:
                  {
                      const interpolatedArgs = await interpolateArguments(commandArg.args, opts, state);
                      for (const interpolatedArg of interpolatedArgs) {
                          redirect(commandArg.subtype, interpolatedArg);
                      }
                  }
                  break;
              case `argument`:
                  {
                      for (const segment of commandArg.segments) {
                          switch (segment.type) {
                              case `text`:
                                  {
                                      push(segment.text);
                                  }
                                  break;
                              case `shell`:
                                  {
                                      const raw = await executeBufferedSubshell(segment.shell, opts, state);
                                      if (segment.quoted) {
                                          push(raw);
                                      }
                                      else {
                                          for (const part of split(raw)) {
                                              pushAndClose(part);
                                          }
                                      }
                                  }
                                  break;
                              case `variable`:
                                  {
                                      switch (segment.name) {
                                          case `#`:
                                              {
                                                  push(String(opts.args.length));
                                              }
                                              break;
                                          case `@`:
                                              {
                                                  if (segment.quoted) {
                                                      for (const raw of opts.args) {
                                                          pushAndClose(raw);
                                                      }
                                                  }
                                                  else {
                                                      for (const raw of opts.args) {
                                                          for (const part of split(raw)) {
                                                              pushAndClose(part);
                                                          }
                                                      }
                                                  }
                                              }
                                              break;
                                          case `*`:
                                              {
                                                  const raw = opts.args.join(` `);
                                                  if (segment.quoted) {
                                                      push(raw);
                                                  }
                                                  else {
                                                      for (const part of split(raw)) {
                                                          pushAndClose(part);
                                                      }
                                                  }
                                              }
                                              break;
                                          default:
                                              {
                                                  const argIndex = parseInt(segment.name, 10);
                                                  if (Number.isFinite(argIndex)) {
                                                      if (!(argIndex >= 0 && argIndex < opts.args.length)) {
                                                          throw new Error(`Unbound argument #${argIndex}`);
                                                      }
                                                      else {
                                                          push(opts.args[argIndex]);
                                                      }
                                                  }
                                                  else {
                                                      if (Object.prototype.hasOwnProperty.call(state.variables, segment.name)) {
                                                          push(state.variables[segment.name]);
                                                      }
                                                      else if (Object.prototype.hasOwnProperty.call(state.environment, segment.name)) {
                                                          push(state.environment[segment.name]);
                                                      }
                                                      else if (segment.defaultValue) {
                                                          push((await interpolateArguments(segment.defaultValue, opts, state)).join(` `));
                                                      }
                                                      else {
                                                          throw new Error(`Unbound variable "${segment.name}"`);
                                                      }
                                                  }
                                              }
                                              break;
                                      }
                                  }
                                  break;
                          }
                      }
                  }
                  break;
          }
          close();
      }
      if (redirections.size > 0) {
          const redirectionArgs = [];
          for (const [subtype, targets] of redirections.entries())
              redirectionArgs.splice(redirectionArgs.length, 0, subtype, String(targets.length), ...targets);
          interpolated.splice(0, 0, `setredirects`, ...redirectionArgs, `--`);
      }
      return interpolated;
  }
  /**
   * Executes a command chain. A command chain is a list of commands linked
   * together thanks to the use of either of the `|` or `|&` operators:
   *
   * $ cat hello | grep world | grep -v foobar
   */
  function makeCommandAction(args, opts, state) {
      if (!opts.builtins.has(args[0]))
          args = [`command`, ...args];
      const [name, ...rest] = args;
      if (name === `command`) {
          return pipe_2.makeProcess(rest[0], rest.slice(1), opts, {
              cwd: fslib_1.NodeFS.fromPortablePath(state.cwd),
              env: state.environment,
          });
      }
      const builtin = opts.builtins.get(name);
      if (typeof builtin === `undefined`)
          throw new Error(`Assertion failed: A builtin should exist for "${name}"`);
      return pipe_2.makeBuiltin(async ({ stdin, stdout, stderr }) => {
          state.stdin = stdin;
          state.stdout = stdout;
          state.stderr = stderr;
          return await builtin(rest, opts, state);
      });
  }
  function makeSubshellAction(ast, opts, state) {
      return (stdio) => {
          const stdin = new stream_1.PassThrough();
          const promise = executeShellLine(ast, opts, cloneState(state, { stdin }));
          return { stdin, promise };
      };
  }
  async function executeCommandChain(node, opts, state) {
      let current = node;
      let pipeType = null;
      let execution = null;
      while (current) {
          // Only the final segment is allowed to modify the shell state; all the
          // other ones are isolated
          const activeState = current.then
              ? Object.assign({}, state) : state;
          let action;
          switch (current.type) {
              case `command`:
                  {
                      const args = await interpolateArguments(current.args, opts, state);
                      const environment = await applyEnvVariables(current.envs, opts, state);
                      action = current.envs.length
                          ? makeCommandAction(args, opts, cloneState(activeState, { environment }))
                          : makeCommandAction(args, opts, activeState);
                  }
                  break;
              case `subshell`:
                  {
                      // We don't interpolate the subshell because it will be recursively
                      // interpolated within its own context
                      action = makeSubshellAction(current.subshell, opts, activeState);
                  }
                  break;
              case `envs`:
                  {
                      const environment = await applyEnvVariables(current.envs, opts, state);
                      activeState.environment = Object.assign({}, activeState.environment, environment);
                      action = makeCommandAction([`true`], opts, activeState);
                  }
                  break;
          }
          if (typeof action === `undefined`)
              throw new Error(`Assertion failed: An action should have been generated`);
          if (pipeType === null) {
              // If we're processing the left-most segment of the command, we start a
              // new execution pipeline
              execution = pipe_1.start(action, {
                  stdin: new pipe_1.ProtectedStream(activeState.stdin),
                  stdout: new pipe_1.ProtectedStream(activeState.stdout),
                  stderr: new pipe_1.ProtectedStream(activeState.stderr),
              });
          }
          else {
              if (execution === null)
                  throw new Error(`The execution pipeline should have been setup`);
              // Otherwise, depending on the exaxct pipe type, we either pipe stdout
              // only or stdout and stderr
              switch (pipeType) {
                  case `|`:
                      {
                          execution = execution.pipeTo(action);
                      }
                      break;
                  case `|&`:
                      {
                          execution = execution.pipeTo(action);
                      }
                      break;
              }
          }
          if (current.then) {
              pipeType = current.then.type;
              current = current.then.chain;
          }
          else {
              current = null;
          }
      }
      if (execution === null)
          throw new Error(`Assertion failed: The execution pipeline should have been setup`);
      return await execution.run();
  }
  /**
   * Execute a command line. A command line is a list of command shells linked
   * together thanks to the use of either of the `||` or `&&` operators.
   */
  async function executeCommandLine(node, opts, state) {
      if (!node.then)
          return await executeCommandChain(node.chain, opts, state);
      const code = await executeCommandChain(node.chain, opts, state);
      // If the execution aborted (usually through "exit"), we must bailout
      if (state.exitCode !== null)
          return state.exitCode;
      // We must update $?, which always contains the exit code from
      // the right-most command
      state.variables[`?`] = String(code);
      switch (node.then.type) {
          case `&&`:
              {
                  if (code === 0) {
                      return await executeCommandLine(node.then.line, opts, state);
                  }
                  else {
                      return code;
                  }
              }
              break;
          case `||`:
              {
                  if (code !== 0) {
                      return await executeCommandLine(node.then.line, opts, state);
                  }
                  else {
                      return code;
                  }
              }
              break;
          default:
              {
                  throw new Error(`Unsupported command type: "${node.then.type}"`);
              }
              break;
      }
  }
  async function executeShellLine(node, opts, state) {
      let rightMostExitCode = 0;
      for (const command of node) {
          rightMostExitCode = await executeCommandLine(command, opts, state);
          // If the execution aborted (usually through "exit"), we must bailout
          if (state.exitCode !== null)
              return state.exitCode;
          // We must update $?, which always contains the exit code from
          // the right-most command
          state.variables[`?`] = String(rightMostExitCode);
      }
      return rightMostExitCode;
  }
  function locateArgsVariableInSegment(segment) {
      switch (segment.type) {
          case `variable`:
              {
                  return segment.name === `@` || segment.name === `#` || segment.name === `*` || Number.isFinite(parseInt(segment.name, 10)) || (!!segment.defaultValue && segment.defaultValue.some(arg => locateArgsVariableInArgument(arg)));
              }
              break;
          case `shell`:
              {
                  return locateArgsVariable(segment.shell);
              }
              break;
          default:
              {
                  return false;
              }
              break;
      }
  }
  function locateArgsVariableInArgument(arg) {
      switch (arg.type) {
          case `redirection`:
              {
                  return arg.args.some(arg => locateArgsVariableInArgument(arg));
              }
              break;
          case `argument`:
              {
                  return arg.segments.some(segment => locateArgsVariableInSegment(segment));
              }
              break;
      }
  }
  function locateArgsVariable(node) {
      return node.some(command => {
          while (command) {
              let chain = command.chain;
              while (chain) {
                  let hasArgs;
                  switch (chain.type) {
                      case `subshell`:
                          {
                              hasArgs = locateArgsVariable(chain.subshell);
                          }
                          break;
                      case `command`:
                          {
                              hasArgs = chain.envs.some(env => env.args.some(arg => {
                                  return locateArgsVariableInArgument(arg);
                              })) || chain.args.some(arg => {
                                  return locateArgsVariableInArgument(arg);
                              });
                          }
                          break;
                  }
                  if (hasArgs)
                      return true;
                  if (!chain.then)
                      break;
                  chain = chain.then.chain;
              }
              if (!command.then)
                  break;
              command = command.then.line;
          }
          return false;
      });
  }
  async function execute(command, args = [], { builtins = {}, cwd = fslib_1.NodeFS.toPortablePath(process.cwd()), env = process.env, stdin = process.stdin, stdout = process.stdout, stderr = process.stderr, variables = {}, } = {}) {
      const normalizedEnv = {};
      for (const [key, value] of Object.entries(env))
          if (typeof value !== `undefined`)
              normalizedEnv[key] = value;
      const normalizedBuiltins = new Map(BUILTINS);
      for (const [key, builtin] of Object.entries(builtins))
          normalizedBuiltins.set(key, builtin);
      // This is meant to be the equivalent of /dev/null
      if (stdin === null) {
          stdin = new stream_1.PassThrough();
          stdin.end();
      }
      const ast = parsers_1.parseShell(command);
      // If the shell line doesn't use the args, inject it at the end of the
      // right-most command
      if (!locateArgsVariable(ast) && ast.length > 0 && args.length > 0) {
          let command = ast[ast.length - 1];
          while (command.then)
              command = command.then.line;
          let chain = command.chain;
          while (chain.then)
              chain = chain.then.chain;
          if (chain.type === `command`) {
              chain.args = chain.args.concat(args.map(arg => {
                  return {
                      type: `argument`,
                      segments: [{
                              type: `text`,
                              text: arg,
                          }],
                  };
              }));
          }
      }
      return await executeShellLine(ast, {
          args,
          builtins: normalizedBuiltins,
          initialStdin: stdin,
          initialStdout: stdout,
          initialStderr: stderr,
      }, {
          cwd,
          environment: normalizedEnv,
          exitCode: null,
          stdin,
          stdout,
          stderr,
          variables: Object.assign(Object.create(variables), {
              [`?`]: 0,
          }),
      });
  }
  exports.execute = execute;


  /***/ }),
  /* 132 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  var shell_1 = __webpack_require__(133);
  exports.parseShell = shell_1.parseShell;
  var resolution_1 = __webpack_require__(135);
  exports.parseResolution = resolution_1.parseResolution;
  exports.stringifyResolution = resolution_1.stringifyResolution;
  var syml_1 = __webpack_require__(137);
  exports.parseSyml = syml_1.parseSyml;
  exports.stringifySyml = syml_1.stringifySyml;


  /***/ }),
  /* 133 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const shell_1 = __webpack_require__(134);
  function parseShell(source) {
      try {
          return shell_1.parse(source);
      }
      catch (error) {
          if (error.location)
              error.message = error.message.replace(/(\.)?$/, ` (line ${error.location.start.line}, column ${error.location.start.column})$1`);
          throw error;
      }
  }
  exports.parseShell = parseShell;


  /***/ }),
  /* 134 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*
   * Generated by PEG.js 0.10.0.
   *
   * http://pegjs.org/
   */



  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.location = location;
    this.name     = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return "\"" + literalEscape(expectation.text) + "\"";
          },

          "class": function(expectation) {
            var escapedParts = "",
                i;

            for (i = 0; i < expectation.parts.length; i++) {
              escapedParts += expectation.parts[i] instanceof Array
                ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
                : classEscape(expectation.parts[i]);
            }

            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
          },

          any: function(expectation) {
            return "any character";
          },

          end: function(expectation) {
            return "end of input";
          },

          other: function(expectation) {
            return expectation.description;
          }
        };

    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/"/g,  '\\"')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function classEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/\]/g, '\\]')
        .replace(/\^/g, '\\^')
        .replace(/-/g,  '\\-')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }

    function describeExpected(expected) {
      var descriptions = new Array(expected.length),
          i, j;

      for (i = 0; i < expected.length; i++) {
        descriptions[i] = describeExpectation(expected[i]);
      }

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + " or " + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(", ")
            + ", or "
            + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found) {
      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
    }

    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };

  function peg$parse(input, options) {
    options = options !== void 0 ? options : {};

    var peg$FAILED = {},

        peg$startRuleFunctions = { Start: peg$parseStart },
        peg$startRuleFunction  = peg$parseStart,

        peg$c0 = function(line) { return line ? line : [] },
        peg$c1 = function(main, then) { return [ main ].concat(then || []) },
        peg$c2 = ";",
        peg$c3 = peg$literalExpectation(";", false),
        peg$c4 = function(then) { return then },
        peg$c5 = function(chain, then) { return then ? { chain, then } : { chain } },
        peg$c6 = function(type, then) { return { type, line: then } },
        peg$c7 = "&&",
        peg$c8 = peg$literalExpectation("&&", false),
        peg$c9 = "||",
        peg$c10 = peg$literalExpectation("||", false),
        peg$c11 = function(main, then) { return then ? { ...main, then } : main },
        peg$c12 = function(type, then) { return { type, chain: then } },
        peg$c13 = "|&",
        peg$c14 = peg$literalExpectation("|&", false),
        peg$c15 = "|",
        peg$c16 = peg$literalExpectation("|", false),
        peg$c17 = "=",
        peg$c18 = peg$literalExpectation("=", false),
        peg$c19 = function(name, arg) { return { name, args: [arg] } },
        peg$c20 = function(name) { return { name, args: [] } },
        peg$c21 = "(",
        peg$c22 = peg$literalExpectation("(", false),
        peg$c23 = ")",
        peg$c24 = peg$literalExpectation(")", false),
        peg$c25 = function(subshell) { return { type: `subshell`, subshell } },
        peg$c26 = function(envs, args) { return { type: `command`, args, envs } },
        peg$c27 = function(envs) { return { type: `envs`, envs } },
        peg$c28 = function(args) { return args },
        peg$c29 = ">>",
        peg$c30 = peg$literalExpectation(">>", false),
        peg$c31 = ">",
        peg$c32 = peg$literalExpectation(">", false),
        peg$c33 = "<<<",
        peg$c34 = peg$literalExpectation("<<<", false),
        peg$c35 = "<",
        peg$c36 = peg$literalExpectation("<", false),
        peg$c37 = function(redirect, arg) { return { type: `redirection`, subtype: redirect, args: [arg] } },
        peg$c38 = function(arg) { return arg },
        peg$c39 = function(segments) { return { type: `argument`, segments: [].concat(... segments) } },
        peg$c40 = function(string) { return string },
        peg$c41 = "'",
        peg$c42 = peg$literalExpectation("'", false),
        peg$c43 = function(text) { return [ { type: `text`, text } ] },
        peg$c44 = "\"",
        peg$c45 = peg$literalExpectation("\"", false),
        peg$c46 = function(segments) { return segments },
        peg$c47 = function(shell) { return { type: `shell`, shell, quoted: true } },
        peg$c48 = function(variable) { return { type: `variable`, ...variable, quoted: true } },
        peg$c49 = function(text) { return { type: `text`, text } },
        peg$c50 = function(shell) { return { type: `shell`, shell, quoted: false } },
        peg$c51 = function(variable) { return { type: `variable`, ...variable, quoted: false } },
        peg$c52 = "\\",
        peg$c53 = peg$literalExpectation("\\", false),
        peg$c54 = peg$anyExpectation(),
        peg$c55 = function(c) { return c },
        peg$c56 = /^[^']/,
        peg$c57 = peg$classExpectation(["'"], true, false),
        peg$c58 = function(chars) { return chars.join(``) },
        peg$c59 = /^[^$"]/,
        peg$c60 = peg$classExpectation(["$", "\""], true, false),
        peg$c61 = "$(",
        peg$c62 = peg$literalExpectation("$(", false),
        peg$c63 = function(command) { return command },
        peg$c64 = "${",
        peg$c65 = peg$literalExpectation("${", false),
        peg$c66 = ":-",
        peg$c67 = peg$literalExpectation(":-", false),
        peg$c68 = "}",
        peg$c69 = peg$literalExpectation("}", false),
        peg$c70 = function(name, arg) { return { name, defaultValue: arg } },
        peg$c71 = ":-}",
        peg$c72 = peg$literalExpectation(":-}", false),
        peg$c73 = function(name) { return { name, defaultValue: [] } },
        peg$c74 = function(name) { return { name } },
        peg$c75 = "$",
        peg$c76 = peg$literalExpectation("$", false),
        peg$c77 = /^[a-zA-Z0-9_]/,
        peg$c78 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_"], false, false),
        peg$c79 = function() { return text() },
        peg$c80 = /^[@*?#a-zA-Z0-9_\-]/,
        peg$c81 = peg$classExpectation(["@", "*", "?", "#", ["a", "z"], ["A", "Z"], ["0", "9"], "_", "-"], false, false),
        peg$c82 = /^[(){}<>$|&; \t"']/,
        peg$c83 = peg$classExpectation(["(", ")", "{", "}", "<", ">", "$", "|", "&", ";", " ", "\t", "\"", "'"], false, false),
        peg$c84 = /^[ \t]/,
        peg$c85 = peg$classExpectation([" ", "\t"], false, false),

        peg$currPos          = 0,
        peg$savedPos         = 0,
        peg$posDetailsCache  = [{ line: 1, column: 1 }],
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildStructuredError(
        [peg$otherExpectation(description)],
        input.substring(peg$savedPos, peg$currPos),
        location
      );
    }

    function error(message, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildSimpleError(message, location);
    }

    function peg$literalExpectation(text, ignoreCase) {
      return { type: "literal", text: text, ignoreCase: ignoreCase };
    }

    function peg$classExpectation(parts, inverted, ignoreCase) {
      return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
    }

    function peg$anyExpectation() {
      return { type: "any" };
    }

    function peg$endExpectation() {
      return { type: "end" };
    }

    function peg$otherExpectation(description) {
      return { type: "other", description: description };
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos], p;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line:   details.line,
          column: details.column
        };

        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails   = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line:   startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line:   endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildSimpleError(message, location) {
      return new peg$SyntaxError(message, null, null, location);
    }

    function peg$buildStructuredError(expected, found, location) {
      return new peg$SyntaxError(
        peg$SyntaxError.buildMessage(expected, found),
        expected,
        found,
        location
      );
    }

    function peg$parseStart() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseShellLine();
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c0(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseShellLine() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseCommandLine();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseShellLineThen();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c1(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseShellLineThen() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseS();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseS();
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 59) {
          s2 = peg$c2;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c3); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseS();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseS();
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseShellLine();
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parseS();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parseS();
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c4(s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseCommandLine() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseCommandChain();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseCommandLineThen();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c5(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseCommandLineThen() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseS();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseS();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseCommandLineType();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseS();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseS();
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseCommandLine();
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parseS();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parseS();
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s2, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseCommandLineType() {
      var s0;

      if (input.substr(peg$currPos, 2) === peg$c7) {
        s0 = peg$c7;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c8); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c9) {
          s0 = peg$c9;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c10); }
        }
      }

      return s0;
    }

    function peg$parseCommandChain() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseCommand();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseCommandChainThen();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c11(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseCommandChainThen() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseS();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseS();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseCommandChainType();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseS();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseS();
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseCommandChain();
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parseS();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parseS();
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c12(s2, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseCommandChainType() {
      var s0;

      if (input.substr(peg$currPos, 2) === peg$c13) {
        s0 = peg$c13;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c14); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 124) {
          s0 = peg$c15;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c16); }
        }
      }

      return s0;
    }

    function peg$parseVariableAssignment() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseEnvVariable();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 61) {
          s2 = peg$c17;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c18); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseStrictValueArgument();
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parseS();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseS();
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c19(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseEnvVariable();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c17;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c18); }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c20(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parseCommand() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseS();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseS();
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 40) {
          s2 = peg$c21;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c22); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseS();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseS();
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseShellLine();
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parseS();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parseS();
              }
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s6 = peg$c23;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c24); }
                }
                if (s6 !== peg$FAILED) {
                  s7 = [];
                  s8 = peg$parseS();
                  while (s8 !== peg$FAILED) {
                    s7.push(s8);
                    s8 = peg$parseS();
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c25(s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseVariableAssignment();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseVariableAssignment();
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseArgument();
              if (s5 !== peg$FAILED) {
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseArgument();
                }
              } else {
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseS();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseS();
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c26(s2, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseVariableAssignment();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseVariableAssignment();
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c27(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }

      return s0;
    }

    function peg$parseCommandString() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseS();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseS();
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseValueArgument();
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseValueArgument();
          }
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseS();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseS();
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c28(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseArgument() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseS();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseS();
      }
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c29) {
          s2 = peg$c29;
          peg$currPos += 2;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c30); }
        }
        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 62) {
            s2 = peg$c31;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c32); }
          }
          if (s2 === peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c33) {
              s2 = peg$c33;
              peg$currPos += 3;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c34); }
            }
            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 60) {
                s2 = peg$c35;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c36); }
              }
            }
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseValueArgument();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c37(s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseValueArgument();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c38(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parseValueArgument() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseS();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseS();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseStrictValueArgument();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c38(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseStrictValueArgument() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseArgumentSegment();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseArgumentSegment();
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c39(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseArgumentSegment() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseSglQuoteString();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c40(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseDblQuoteString();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c40(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsePlainString();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c40(s1);
          }
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parseSglQuoteString() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 39) {
        s1 = peg$c41;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c42); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseSglQuoteStringText();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s3 = peg$c41;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c42); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c43(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseDblQuoteString() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 34) {
        s1 = peg$c44;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c45); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseDblQuoteStringSegment();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseDblQuoteStringSegment();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s3 = peg$c44;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c45); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c46(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsePlainString() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsePlainStringSegment();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsePlainStringSegment();
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c46(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseDblQuoteStringSegment() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseSubshell();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c47(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseVariable();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c48(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseDblQuoteStringText();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c49(s1);
          }
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parsePlainStringSegment() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseSubshell();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c50(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseVariable();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c51(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsePlainStringText();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c49(s1);
          }
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parseSglQuoteStringText() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 92) {
        s3 = peg$c52;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c53); }
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c54); }
        }
        if (s4 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c55(s4);
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        if (peg$c56.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c57); }
        }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 92) {
            s3 = peg$c52;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c53); }
          }
          if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c54); }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c55(s4);
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            if (peg$c56.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c57); }
            }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c58(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseDblQuoteStringText() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 92) {
        s3 = peg$c52;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c53); }
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c54); }
        }
        if (s4 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c55(s4);
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        if (peg$c59.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c60); }
        }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 92) {
            s3 = peg$c52;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c53); }
          }
          if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c54); }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c55(s4);
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            if (peg$c59.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c60); }
            }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c58(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsePlainStringText() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 92) {
        s3 = peg$c52;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c53); }
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c54); }
        }
        if (s4 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c55(s4);
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseSpecialShellChars();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c54); }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c55(s4);
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 92) {
            s3 = peg$c52;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c53); }
          }
          if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c54); }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c55(s4);
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$currPos;
            peg$silentFails++;
            s4 = peg$parseSpecialShellChars();
            peg$silentFails--;
            if (s4 === peg$FAILED) {
              s3 = void 0;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c54); }
              }
              if (s4 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c55(s4);
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c58(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseSubshell() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c61) {
        s1 = peg$c61;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c62); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseShellLine();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 41) {
            s3 = peg$c23;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c24); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c63(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseVariable() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c64) {
        s1 = peg$c64;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c65); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseIdentifier();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c66) {
            s3 = peg$c66;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c67); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseCommandString();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 125) {
                s5 = peg$c68;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c69); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c70(s2, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c64) {
          s1 = peg$c64;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c65); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c71) {
              s3 = peg$c71;
              peg$currPos += 3;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c72); }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c73(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c64) {
            s1 = peg$c64;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c65); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 125) {
                s3 = peg$c68;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c69); }
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c74(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 36) {
              s1 = peg$c75;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c76); }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseIdentifier();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c74(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
      }

      return s0;
    }

    function peg$parseEnvVariable() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c77.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c78); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c77.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c78); }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c79();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseIdentifier() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c80.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c81); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c80.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c81); }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c79();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseSpecialShellChars() {
      var s0;

      if (peg$c82.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c83); }
      }

      return s0;
    }

    function peg$parseS() {
      var s0, s1;

      s0 = [];
      if (peg$c84.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c85); }
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (peg$c84.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c85); }
          }
        }
      } else {
        s0 = peg$FAILED;
      }

      return s0;
    }

    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }

      throw peg$buildStructuredError(
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }

  module.exports = {
    SyntaxError: peg$SyntaxError,
    parse:       peg$parse
  };


  /***/ }),
  /* 135 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const resolution_1 = __webpack_require__(136);
  function parseResolution(source) {
      const legacyResolution = source.match(/^\*{1,2}\/(.*)/);
      if (legacyResolution)
          throw new Error(`The override for '${source}' includes a glob pattern. Glob patterns have been removed since their behaviours don't match what you'd expect. Set the override to '${legacyResolution[1]}' instead.`);
      try {
          return resolution_1.parse(source);
      }
      catch (error) {
          if (error.location)
              error.message = error.message.replace(/(\.)?$/, ` (line ${error.location.start.line}, column ${error.location.start.column})$1`);
          throw error;
      }
  }
  exports.parseResolution = parseResolution;
  function stringifyResolution(resolution) {
      let str = ``;
      if (resolution.from) {
          str += resolution.from.fullName;
          if (resolution.from.description)
              str += `@${resolution.from.description}`;
          str += `/`;
      }
      str += resolution.descriptor.fullName;
      if (resolution.descriptor.description)
          str += `@${resolution.descriptor.description}`;
      return str;
  }
  exports.stringifyResolution = stringifyResolution;


  /***/ }),
  /* 136 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*
   * Generated by PEG.js 0.10.0.
   *
   * http://pegjs.org/
   */



  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.location = location;
    this.name     = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return "\"" + literalEscape(expectation.text) + "\"";
          },

          "class": function(expectation) {
            var escapedParts = "",
                i;

            for (i = 0; i < expectation.parts.length; i++) {
              escapedParts += expectation.parts[i] instanceof Array
                ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
                : classEscape(expectation.parts[i]);
            }

            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
          },

          any: function(expectation) {
            return "any character";
          },

          end: function(expectation) {
            return "end of input";
          },

          other: function(expectation) {
            return expectation.description;
          }
        };

    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/"/g,  '\\"')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function classEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/\]/g, '\\]')
        .replace(/\^/g, '\\^')
        .replace(/-/g,  '\\-')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }

    function describeExpected(expected) {
      var descriptions = new Array(expected.length),
          i, j;

      for (i = 0; i < expected.length; i++) {
        descriptions[i] = describeExpectation(expected[i]);
      }

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + " or " + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(", ")
            + ", or "
            + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found) {
      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
    }

    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };

  function peg$parse(input, options) {
    options = options !== void 0 ? options : {};

    var peg$FAILED = {},

        peg$startRuleFunctions = { resolution: peg$parseresolution },
        peg$startRuleFunction  = peg$parseresolution,

        peg$c0 = "/",
        peg$c1 = peg$literalExpectation("/", false),
        peg$c2 = function(from, descriptor) { return { from, descriptor } },
        peg$c3 = function(descriptor) { return { descriptor } },
        peg$c4 = "@",
        peg$c5 = peg$literalExpectation("@", false),
        peg$c6 = function(fullName, description) { return { fullName, description } },
        peg$c7 = function(fullName) { return { fullName } },
        peg$c8 = function() { return text() },
        peg$c9 = /^[^\/@]/,
        peg$c10 = peg$classExpectation(["/", "@"], true, false),
        peg$c11 = /^[^\/]/,
        peg$c12 = peg$classExpectation(["/"], true, false),

        peg$currPos          = 0,
        peg$savedPos         = 0,
        peg$posDetailsCache  = [{ line: 1, column: 1 }],
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildStructuredError(
        [peg$otherExpectation(description)],
        input.substring(peg$savedPos, peg$currPos),
        location
      );
    }

    function error(message, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildSimpleError(message, location);
    }

    function peg$literalExpectation(text, ignoreCase) {
      return { type: "literal", text: text, ignoreCase: ignoreCase };
    }

    function peg$classExpectation(parts, inverted, ignoreCase) {
      return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
    }

    function peg$anyExpectation() {
      return { type: "any" };
    }

    function peg$endExpectation() {
      return { type: "end" };
    }

    function peg$otherExpectation(description) {
      return { type: "other", description: description };
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos], p;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line:   details.line,
          column: details.column
        };

        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails   = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line:   startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line:   endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildSimpleError(message, location) {
      return new peg$SyntaxError(message, null, null, location);
    }

    function peg$buildStructuredError(expected, found, location) {
      return new peg$SyntaxError(
        peg$SyntaxError.buildMessage(expected, found),
        expected,
        found,
        location
      );
    }

    function peg$parseresolution() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsespecifier();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 47) {
          s2 = peg$c0;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c1); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsespecifier();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c2(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsespecifier();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c3(s1);
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parsespecifier() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsefullName();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 64) {
          s2 = peg$c4;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c5); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsedescription();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c6(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsefullName();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c7(s1);
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parsefullName() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 64) {
        s1 = peg$c4;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c5); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseident();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 47) {
            s3 = peg$c0;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c1); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseident();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c8();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseident();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c8();
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseident() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c9.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c10); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c9.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c10); }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c8();
      }
      s0 = s1;

      return s0;
    }

    function peg$parsedescription() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c11.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c12); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c11.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c12); }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c8();
      }
      s0 = s1;

      return s0;
    }

    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }

      throw peg$buildStructuredError(
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }

  module.exports = {
    SyntaxError: peg$SyntaxError,
    parse:       peg$parse
  };


  /***/ }),
  /* 137 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  // @ts-ignore
  const js_yaml_1 = __webpack_require__(138);
  const syml_1 = __webpack_require__(170);
  const simpleStringPattern = /^(?![-?:,\][{}#&*!|>'"%@` \t\r\n]).([ \t]*(?![,\][{}:# \t\r\n]).)*$/;
  // The following keys will always be stored at the top of the object, in the
  // specified order. It's not fair but life isn't fair either.
  const specialObjectKeys = [`__metadata`, `version`, `resolution`, `dependencies`, `peerDependencies`, `dependenciesMeta`, `peerDependenciesMeta`, `binaries`];
  function stringifyString(value) {
      if (value.match(simpleStringPattern)) {
          return value;
      }
      else {
          return JSON.stringify(value);
      }
  }
  function stringifyValue(value, indentLevel) {
      if (value === null) {
          if (indentLevel === 0) {
              throw new Error(`Null is not a valid top-level value`);
          }
          else {
              return ` null`;
          }
      }
      if (typeof value === `number` || typeof value === `boolean`) {
          if (indentLevel === 0) {
              return `${value.toString()}\n`;
          }
          else {
              return ` ${value.toString()}`;
          }
      }
      if (typeof value === `string`) {
          if (indentLevel === 0) {
              return `${stringifyString(value)}\n`;
          }
          else {
              return ` ${stringifyString(value)}`;
          }
      }
      if (Array.isArray(value)) {
          const indent = `  `.repeat(indentLevel);
          return value.map(sub => {
              return `\n${indent}-${stringifyValue(sub, indentLevel + 1)}`;
          }).join(``);
      }
      if (typeof value === `object` && value) {
          const indent = `  `.repeat(indentLevel);
          const keys = Object.keys(value).sort((a, b) => {
              const aIndex = specialObjectKeys.indexOf(a);
              const bIndex = specialObjectKeys.indexOf(b);
              if (aIndex === -1 && bIndex === -1)
                  return a < b ? -1 : a > b ? +1 : 0;
              if (aIndex !== -1 && bIndex === -1)
                  return -1;
              if (aIndex === -1 && bIndex !== -1)
                  return +1;
              return aIndex - bIndex;
          });
          const fields = keys.filter(key => {
              return value[key] !== undefined;
          }).map(key => {
              return `${indent}${stringifyString(key)}:${stringifyValue(value[key], indentLevel + 1)}`;
          }).join(indentLevel === 0 ? `\n\n` : `\n`);
          if (indentLevel === 0) {
              return fields ? `${fields}\n` : ``;
          }
          else {
              return `\n${fields}`;
          }
      }
      throw new Error(`Unsupported value type (${value})`);
  }
  function stringifySyml(value) {
      try {
          return stringifyValue(value, 0);
      }
      catch (error) {
          if (error.location)
              error.message = error.message.replace(/(\.)?$/, ` (line ${error.location.start.line}, column ${error.location.start.column})$1`);
          throw error;
      }
  }
  exports.stringifySyml = stringifySyml;
  function parseViaPeg(source) {
      if (!source.endsWith(`\n`))
          source += `\n`;
      return syml_1.parse(source);
  }
  const LEGACY_REGEXP = /^(#.*(\r?\n))*?#\s+yarn\s+lockfile\s+v1\r?\n/i;
  function parseViaJsYaml(source) {
      if (LEGACY_REGEXP.test(source))
          return parseViaPeg(source);
      let value = js_yaml_1.safeLoad(source, {
          schema: js_yaml_1.FAILSAFE_SCHEMA,
      });
      // Empty files are parsed as `undefined` instead of an empty object
      // Empty files with 2 newlines or more are `null` instead
      if (value === undefined || value === null)
          return {};
      if (typeof value !== `object`)
          throw new Error(`Expected an indexed object, got a ${typeof value} instead. Does your file follow Yaml's rules?`);
      if (Array.isArray(value))
          throw new Error(`Expected an indexed object, got an array instead. Does your file follow Yaml's rules?`);
      return value;
  }
  function parseSyml(source) {
      return parseViaJsYaml(source);
  }
  exports.parseSyml = parseSyml;


  /***/ }),
  /* 138 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";



  var yaml = __webpack_require__(139);


  module.exports = yaml;


  /***/ }),
  /* 139 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";



  var loader = __webpack_require__(140);
  var dumper = __webpack_require__(169);


  function deprecated(name) {
    return function () {
      throw new Error('Function ' + name + ' is deprecated and cannot be used.');
    };
  }


  module.exports.Type                = __webpack_require__(146);
  module.exports.Schema              = __webpack_require__(145);
  module.exports.FAILSAFE_SCHEMA     = __webpack_require__(149);
  module.exports.JSON_SCHEMA         = __webpack_require__(148);
  module.exports.CORE_SCHEMA         = __webpack_require__(147);
  module.exports.DEFAULT_SAFE_SCHEMA = __webpack_require__(144);
  module.exports.DEFAULT_FULL_SCHEMA = __webpack_require__(164);
  module.exports.load                = loader.load;
  module.exports.loadAll             = loader.loadAll;
  module.exports.safeLoad            = loader.safeLoad;
  module.exports.safeLoadAll         = loader.safeLoadAll;
  module.exports.dump                = dumper.dump;
  module.exports.safeDump            = dumper.safeDump;
  module.exports.YAMLException       = __webpack_require__(142);

  // Deprecated schema names from JS-YAML 2.0.x
  module.exports.MINIMAL_SCHEMA = __webpack_require__(149);
  module.exports.SAFE_SCHEMA    = __webpack_require__(144);
  module.exports.DEFAULT_SCHEMA = __webpack_require__(164);

  // Deprecated functions from JS-YAML 1.x.x
  module.exports.scan           = deprecated('scan');
  module.exports.parse          = deprecated('parse');
  module.exports.compose        = deprecated('compose');
  module.exports.addConstructor = deprecated('addConstructor');


  /***/ }),
  /* 140 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  /*eslint-disable max-len,no-use-before-define*/

  var common              = __webpack_require__(141);
  var YAMLException       = __webpack_require__(142);
  var Mark                = __webpack_require__(143);
  var DEFAULT_SAFE_SCHEMA = __webpack_require__(144);
  var DEFAULT_FULL_SCHEMA = __webpack_require__(164);


  var _hasOwnProperty = Object.prototype.hasOwnProperty;


  var CONTEXT_FLOW_IN   = 1;
  var CONTEXT_FLOW_OUT  = 2;
  var CONTEXT_BLOCK_IN  = 3;
  var CONTEXT_BLOCK_OUT = 4;


  var CHOMPING_CLIP  = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP  = 3;


  var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


  function _class(obj) { return Object.prototype.toString.call(obj); }

  function is_EOL(c) {
    return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
  }

  function is_WHITE_SPACE(c) {
    return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
  }

  function is_WS_OR_EOL(c) {
    return (c === 0x09/* Tab */) ||
           (c === 0x20/* Space */) ||
           (c === 0x0A/* LF */) ||
           (c === 0x0D/* CR */);
  }

  function is_FLOW_INDICATOR(c) {
    return c === 0x2C/* , */ ||
           c === 0x5B/* [ */ ||
           c === 0x5D/* ] */ ||
           c === 0x7B/* { */ ||
           c === 0x7D/* } */;
  }

  function fromHexCode(c) {
    var lc;

    if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
      return c - 0x30;
    }

    /*eslint-disable no-bitwise*/
    lc = c | 0x20;

    if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
      return lc - 0x61 + 10;
    }

    return -1;
  }

  function escapedHexLen(c) {
    if (c === 0x78/* x */) { return 2; }
    if (c === 0x75/* u */) { return 4; }
    if (c === 0x55/* U */) { return 8; }
    return 0;
  }

  function fromDecimalCode(c) {
    if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
      return c - 0x30;
    }

    return -1;
  }

  function simpleEscapeSequence(c) {
    /* eslint-disable indent */
    return (c === 0x30/* 0 */) ? '\x00' :
          (c === 0x61/* a */) ? '\x07' :
          (c === 0x62/* b */) ? '\x08' :
          (c === 0x74/* t */) ? '\x09' :
          (c === 0x09/* Tab */) ? '\x09' :
          (c === 0x6E/* n */) ? '\x0A' :
          (c === 0x76/* v */) ? '\x0B' :
          (c === 0x66/* f */) ? '\x0C' :
          (c === 0x72/* r */) ? '\x0D' :
          (c === 0x65/* e */) ? '\x1B' :
          (c === 0x20/* Space */) ? ' ' :
          (c === 0x22/* " */) ? '\x22' :
          (c === 0x2F/* / */) ? '/' :
          (c === 0x5C/* \ */) ? '\x5C' :
          (c === 0x4E/* N */) ? '\x85' :
          (c === 0x5F/* _ */) ? '\xA0' :
          (c === 0x4C/* L */) ? '\u2028' :
          (c === 0x50/* P */) ? '\u2029' : '';
  }

  function charFromCodepoint(c) {
    if (c <= 0xFFFF) {
      return String.fromCharCode(c);
    }
    // Encode UTF-16 surrogate pair
    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
    return String.fromCharCode(
      ((c - 0x010000) >> 10) + 0xD800,
      ((c - 0x010000) & 0x03FF) + 0xDC00
    );
  }

  var simpleEscapeCheck = new Array(256); // integer, for fast access
  var simpleEscapeMap = new Array(256);
  for (var i = 0; i < 256; i++) {
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
  }


  function State(input, options) {
    this.input = input;

    this.filename  = options['filename']  || null;
    this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
    this.onWarning = options['onWarning'] || null;
    this.legacy    = options['legacy']    || false;
    this.json      = options['json']      || false;
    this.listener  = options['listener']  || null;

    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap       = this.schema.compiledTypeMap;

    this.length     = input.length;
    this.position   = 0;
    this.line       = 0;
    this.lineStart  = 0;
    this.lineIndent = 0;

    this.documents = [];

    /*
    this.version;
    this.checkLineBreaks;
    this.tagMap;
    this.anchorMap;
    this.tag;
    this.anchor;
    this.kind;
    this.result;*/

  }


  function generateError(state, message) {
    return new YAMLException(
      message,
      new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
  }

  function throwError(state, message) {
    throw generateError(state, message);
  }

  function throwWarning(state, message) {
    if (state.onWarning) {
      state.onWarning.call(null, generateError(state, message));
    }
  }


  var directiveHandlers = {

    YAML: function handleYamlDirective(state, name, args) {

      var match, major, minor;

      if (state.version !== null) {
        throwError(state, 'duplication of %YAML directive');
      }

      if (args.length !== 1) {
        throwError(state, 'YAML directive accepts exactly one argument');
      }

      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

      if (match === null) {
        throwError(state, 'ill-formed argument of the YAML directive');
      }

      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);

      if (major !== 1) {
        throwError(state, 'unacceptable YAML version of the document');
      }

      state.version = args[0];
      state.checkLineBreaks = (minor < 2);

      if (minor !== 1 && minor !== 2) {
        throwWarning(state, 'unsupported YAML version of the document');
      }
    },

    TAG: function handleTagDirective(state, name, args) {

      var handle, prefix;

      if (args.length !== 2) {
        throwError(state, 'TAG directive accepts exactly two arguments');
      }

      handle = args[0];
      prefix = args[1];

      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
      }

      if (_hasOwnProperty.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }

      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
      }

      state.tagMap[handle] = prefix;
    }
  };


  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;

    if (start < end) {
      _result = state.input.slice(start, end);

      if (checkJson) {
        for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(_character === 0x09 ||
                (0x20 <= _character && _character <= 0x10FFFF))) {
            throwError(state, 'expected valid JSON character');
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError(state, 'the stream contains non-printable characters');
      }

      state.result += _result;
    }
  }

  function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;

    if (!common.isObject(source)) {
      throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
    }

    sourceKeys = Object.keys(source);

    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
      key = sourceKeys[index];

      if (!_hasOwnProperty.call(destination, key)) {
        destination[key] = source[key];
        overridableKeys[key] = true;
      }
    }
  }

  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
    var index, quantity;

    // The output is a plain object here, so keys can only be strings.
    // We need to convert keyNode to a string, but doing so can hang the process
    // (deeply nested arrays that explode exponentially using aliases).
    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);

      for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
        if (Array.isArray(keyNode[index])) {
          throwError(state, 'nested arrays are not supported inside keys');
        }

        if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
          keyNode[index] = '[object Object]';
        }
      }
    }

    // Avoid code execution in load() via toString property
    // (still use its own toString for arrays, timestamps,
    // and whatever user schema extensions happen to have @@toStringTag)
    if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
      keyNode = '[object Object]';
    }


    keyNode = String(keyNode);

    if (_result === null) {
      _result = {};
    }

    if (keyTag === 'tag:yaml.org,2002:merge') {
      if (Array.isArray(valueNode)) {
        for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
          mergeMappings(state, _result, valueNode[index], overridableKeys);
        }
      } else {
        mergeMappings(state, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state.json &&
          !_hasOwnProperty.call(overridableKeys, keyNode) &&
          _hasOwnProperty.call(_result, keyNode)) {
        state.line = startLine || state.line;
        state.position = startPos || state.position;
        throwError(state, 'duplicated mapping key');
      }
      _result[keyNode] = valueNode;
      delete overridableKeys[keyNode];
    }

    return _result;
  }

  function readLineBreak(state) {
    var ch;

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x0A/* LF */) {
      state.position++;
    } else if (ch === 0x0D/* CR */) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
        state.position++;
      }
    } else {
      throwError(state, 'a line break is expected');
    }

    state.line += 1;
    state.lineStart = state.position;
  }

  function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0,
        ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (allowComments && ch === 0x23/* # */) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
      }

      if (is_EOL(ch)) {
        readLineBreak(state);

        ch = state.input.charCodeAt(state.position);
        lineBreaks++;
        state.lineIndent = 0;

        while (ch === 0x20/* Space */) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
      } else {
        break;
      }
    }

    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
      throwWarning(state, 'deficient indentation');
    }

    return lineBreaks;
  }

  function testDocumentSeparator(state) {
    var _position = state.position,
        ch;

    ch = state.input.charCodeAt(_position);

    // Condition state.position === state.lineStart is tested
    // in parent on each call, for efficiency. No needs to test here again.
    if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
        ch === state.input.charCodeAt(_position + 1) &&
        ch === state.input.charCodeAt(_position + 2)) {

      _position += 3;

      ch = state.input.charCodeAt(_position);

      if (ch === 0 || is_WS_OR_EOL(ch)) {
        return true;
      }
    }

    return false;
  }

  function writeFoldedLines(state, count) {
    if (count === 1) {
      state.result += ' ';
    } else if (count > 1) {
      state.result += common.repeat('\n', count - 1);
    }
  }


  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding,
        following,
        captureStart,
        captureEnd,
        hasPendingContent,
        _line,
        _lineStart,
        _lineIndent,
        _kind = state.kind,
        _result = state.result,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (is_WS_OR_EOL(ch)      ||
        is_FLOW_INDICATOR(ch) ||
        ch === 0x23/* # */    ||
        ch === 0x26/* & */    ||
        ch === 0x2A/* * */    ||
        ch === 0x21/* ! */    ||
        ch === 0x7C/* | */    ||
        ch === 0x3E/* > */    ||
        ch === 0x27/* ' */    ||
        ch === 0x22/* " */    ||
        ch === 0x25/* % */    ||
        ch === 0x40/* @ */    ||
        ch === 0x60/* ` */) {
      return false;
    }

    if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }

    state.kind = 'scalar';
    state.result = '';
    captureStart = captureEnd = state.position;
    hasPendingContent = false;

    while (ch !== 0) {
      if (ch === 0x3A/* : */) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following) ||
            withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }

      } else if (ch === 0x23/* # */) {
        preceding = state.input.charCodeAt(state.position - 1);

        if (is_WS_OR_EOL(preceding)) {
          break;
        }

      } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
                 withinFlowCollection && is_FLOW_INDICATOR(ch)) {
        break;

      } else if (is_EOL(ch)) {
        _line = state.line;
        _lineStart = state.lineStart;
        _lineIndent = state.lineIndent;
        skipSeparationSpace(state, false, -1);

        if (state.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd;
          state.line = _line;
          state.lineStart = _lineStart;
          state.lineIndent = _lineIndent;
          break;
        }
      }

      if (hasPendingContent) {
        captureSegment(state, captureStart, captureEnd, false);
        writeFoldedLines(state, state.line - _line);
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
      }

      if (!is_WHITE_SPACE(ch)) {
        captureEnd = state.position + 1;
      }

      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, captureEnd, false);

    if (state.result) {
      return true;
    }

    state.kind = _kind;
    state.result = _result;
    return false;
  }

  function readSingleQuotedScalar(state, nodeIndent) {
    var ch,
        captureStart, captureEnd;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x27/* ' */) {
      return false;
    }

    state.kind = 'scalar';
    state.result = '';
    state.position++;
    captureStart = captureEnd = state.position;

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 0x27/* ' */) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if (ch === 0x27/* ' */) {
          captureStart = state.position;
          state.position++;
          captureEnd = state.position;
        } else {
          return true;
        }

      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;

      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, 'unexpected end of the document within a single quoted scalar');

      } else {
        state.position++;
        captureEnd = state.position;
      }
    }

    throwError(state, 'unexpected end of the stream within a single quoted scalar');
  }

  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart,
        captureEnd,
        hexLength,
        hexResult,
        tmp,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x22/* " */) {
      return false;
    }

    state.kind = 'scalar';
    state.result = '';
    state.position++;
    captureStart = captureEnd = state.position;

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 0x22/* " */) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;

      } else if (ch === 0x5C/* \ */) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent);

          // TODO: rework to inline fn with no type cast?
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;

        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;

          for (; hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);

            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;

            } else {
              throwError(state, 'expected hexadecimal character');
            }
          }

          state.result += charFromCodepoint(hexResult);

          state.position++;

        } else {
          throwError(state, 'unknown escape sequence');
        }

        captureStart = captureEnd = state.position;

      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;

      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, 'unexpected end of the document within a double quoted scalar');

      } else {
        state.position++;
        captureEnd = state.position;
      }
    }

    throwError(state, 'unexpected end of the stream within a double quoted scalar');
  }

  function readFlowCollection(state, nodeIndent) {
    var readNext = true,
        _line,
        _tag     = state.tag,
        _result,
        _anchor  = state.anchor,
        following,
        terminator,
        isPair,
        isExplicitPair,
        isMapping,
        overridableKeys = {},
        keyNode,
        keyTag,
        valueNode,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x5B/* [ */) {
      terminator = 0x5D;/* ] */
      isMapping = false;
      _result = [];
    } else if (ch === 0x7B/* { */) {
      terminator = 0x7D;/* } */
      isMapping = true;
      _result = {};
    } else {
      return false;
    }

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(++state.position);

    while (ch !== 0) {
      skipSeparationSpace(state, true, nodeIndent);

      ch = state.input.charCodeAt(state.position);

      if (ch === terminator) {
        state.position++;
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = isMapping ? 'mapping' : 'sequence';
        state.result = _result;
        return true;
      } else if (!readNext) {
        throwError(state, 'missed comma between flow collection entries');
      }

      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;

      if (ch === 0x3F/* ? */) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }

      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state.tag;
      keyNode = state.result;
      skipSeparationSpace(state, true, nodeIndent);

      ch = state.input.charCodeAt(state.position);

      if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }

      if (isMapping) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
      } else if (isPair) {
        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
      } else {
        _result.push(keyNode);
      }

      skipSeparationSpace(state, true, nodeIndent);

      ch = state.input.charCodeAt(state.position);

      if (ch === 0x2C/* , */) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
        readNext = false;
      }
    }

    throwError(state, 'unexpected end of the stream within a flow collection');
  }

  function readBlockScalar(state, nodeIndent) {
    var captureStart,
        folding,
        chomping       = CHOMPING_CLIP,
        didReadContent = false,
        detectedIndent = false,
        textIndent     = nodeIndent,
        emptyLines     = 0,
        atMoreIndented = false,
        tmp,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x7C/* | */) {
      folding = false;
    } else if (ch === 0x3E/* > */) {
      folding = true;
    } else {
      return false;
    }

    state.kind = 'scalar';
    state.result = '';

    while (ch !== 0) {
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
        if (CHOMPING_CLIP === chomping) {
          chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, 'repeat of a chomping mode identifier');
        }

      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
        if (tmp === 0) {
          throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError(state, 'repeat of an indentation width identifier');
        }

      } else {
        break;
      }
    }

    if (is_WHITE_SPACE(ch)) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (is_WHITE_SPACE(ch));

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (!is_EOL(ch) && (ch !== 0));
      }
    }

    while (ch !== 0) {
      readLineBreak(state);
      state.lineIndent = 0;

      ch = state.input.charCodeAt(state.position);

      while ((!detectedIndent || state.lineIndent < textIndent) &&
             (ch === 0x20/* Space */)) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }

      if (!detectedIndent && state.lineIndent > textIndent) {
        textIndent = state.lineIndent;
      }

      if (is_EOL(ch)) {
        emptyLines++;
        continue;
      }

      // End of the scalar.
      if (state.lineIndent < textIndent) {

        // Perform the chomping.
        if (chomping === CHOMPING_KEEP) {
          state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) { // i.e. only if the scalar is not empty.
            state.result += '\n';
          }
        }

        // Break this `while` cycle and go to the funciton's epilogue.
        break;
      }

      // Folded style: use fancy rules to handle line breaks.
      if (folding) {

        // Lines starting with white space characters (more-indented lines) are not folded.
        if (is_WHITE_SPACE(ch)) {
          atMoreIndented = true;
          // except for the first content line (cf. Example 8.1)
          state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

        // End of more-indented block.
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state.result += common.repeat('\n', emptyLines + 1);

        // Just one line break - perceive as the same line.
        } else if (emptyLines === 0) {
          if (didReadContent) { // i.e. only if we have already read some scalar content.
            state.result += ' ';
          }

        // Several line breaks - perceive as different lines.
        } else {
          state.result += common.repeat('\n', emptyLines);
        }

      // Literal style: just add exact number of line breaks between content lines.
      } else {
        // Keep all line breaks except the header line break.
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      }

      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state.position;

      while (!is_EOL(ch) && (ch !== 0)) {
        ch = state.input.charCodeAt(++state.position);
      }

      captureSegment(state, captureStart, state.position, false);
    }

    return true;
  }

  function readBlockSequence(state, nodeIndent) {
    var _line,
        _tag      = state.tag,
        _anchor   = state.anchor,
        _result   = [],
        following,
        detected  = false,
        ch;

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {

      if (ch !== 0x2D/* - */) {
        break;
      }

      following = state.input.charCodeAt(state.position + 1);

      if (!is_WS_OR_EOL(following)) {
        break;
      }

      detected = true;
      state.position++;

      if (skipSeparationSpace(state, true, -1)) {
        if (state.lineIndent <= nodeIndent) {
          _result.push(null);
          ch = state.input.charCodeAt(state.position);
          continue;
        }
      }

      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(state.result);
      skipSeparationSpace(state, true, -1);

      ch = state.input.charCodeAt(state.position);

      if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
        throwError(state, 'bad indentation of a sequence entry');
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }

    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = 'sequence';
      state.result = _result;
      return true;
    }
    return false;
  }

  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following,
        allowCompact,
        _line,
        _pos,
        _tag          = state.tag,
        _anchor       = state.anchor,
        _result       = {},
        overridableKeys = {},
        keyTag        = null,
        keyNode       = null,
        valueNode     = null,
        atExplicitKey = false,
        detected      = false,
        ch;

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {
      following = state.input.charCodeAt(state.position + 1);
      _line = state.line; // Save the current line.
      _pos = state.position;

      //
      // Explicit notation case. There are two separate blocks:
      // first for the key (denoted by "?") and second for the value (denoted by ":")
      //
      if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

        if (ch === 0x3F/* ? */) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = true;
          allowCompact = true;

        } else if (atExplicitKey) {
          // i.e. 0x3A/* : */ === character after the explicit key.
          atExplicitKey = false;
          allowCompact = true;

        } else {
          throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
        }

        state.position += 1;
        ch = following;

      //
      // Implicit notation case. Flow-style node as the key first, then ":", and the value.
      //
      } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

        if (state.line === _line) {
          ch = state.input.charCodeAt(state.position);

          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }

          if (ch === 0x3A/* : */) {
            ch = state.input.charCodeAt(++state.position);

            if (!is_WS_OR_EOL(ch)) {
              throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
            }

            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }

            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;

          } else if (detected) {
            throwError(state, 'can not read an implicit mapping pair; a colon is missed');

          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true; // Keep the result of `composeNode`.
          }

        } else if (detected) {
          throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else {
        break; // Reading is done. Go to the epilogue.
      }

      //
      // Common reading code for both explicit and implicit notations.
      //
      if (state.line === _line || state.lineIndent > nodeIndent) {
        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state.result;
          } else {
            valueNode = state.result;
          }
        }

        if (!atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
          keyTag = keyNode = valueNode = null;
        }

        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
      }

      if (state.lineIndent > nodeIndent && (ch !== 0)) {
        throwError(state, 'bad indentation of a mapping entry');
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }

    //
    // Epilogue.
    //

    // Special case: last mapping's node contains only the key in explicit notation.
    if (atExplicitKey) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
    }

    // Expose the resulting mapping.
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = 'mapping';
      state.result = _result;
    }

    return detected;
  }

  function readTagProperty(state) {
    var _position,
        isVerbatim = false,
        isNamed    = false,
        tagHandle,
        tagName,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x21/* ! */) return false;

    if (state.tag !== null) {
      throwError(state, 'duplication of a tag property');
    }

    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x3C/* < */) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);

    } else if (ch === 0x21/* ! */) {
      isNamed = true;
      tagHandle = '!!';
      ch = state.input.charCodeAt(++state.position);

    } else {
      tagHandle = '!';
    }

    _position = state.position;

    if (isVerbatim) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (ch !== 0 && ch !== 0x3E/* > */);

      if (state.position < state.length) {
        tagName = state.input.slice(_position, state.position);
        ch = state.input.charCodeAt(++state.position);
      } else {
        throwError(state, 'unexpected end of the stream within a verbatim tag');
      }
    } else {
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {

        if (ch === 0x21/* ! */) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);

            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, 'named tag handle cannot contain such characters');
            }

            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, 'tag suffix cannot contain exclamation marks');
          }
        }

        ch = state.input.charCodeAt(++state.position);
      }

      tagName = state.input.slice(_position, state.position);

      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError(state, 'tag suffix cannot contain flow indicator characters');
      }
    }

    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError(state, 'tag name cannot contain such characters: ' + tagName);
    }

    if (isVerbatim) {
      state.tag = tagName;

    } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
      state.tag = state.tagMap[tagHandle] + tagName;

    } else if (tagHandle === '!') {
      state.tag = '!' + tagName;

    } else if (tagHandle === '!!') {
      state.tag = 'tag:yaml.org,2002:' + tagName;

    } else {
      throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }

    return true;
  }

  function readAnchorProperty(state) {
    var _position,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x26/* & */) return false;

    if (state.anchor !== null) {
      throwError(state, 'duplication of an anchor property');
    }

    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (state.position === _position) {
      throwError(state, 'name of an anchor node must contain at least one character');
    }

    state.anchor = state.input.slice(_position, state.position);
    return true;
  }

  function readAlias(state) {
    var _position, alias,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x2A/* * */) return false;

    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (state.position === _position) {
      throwError(state, 'name of an alias node must contain at least one character');
    }

    alias = state.input.slice(_position, state.position);

    if (!state.anchorMap.hasOwnProperty(alias)) {
      throwError(state, 'unidentified alias "' + alias + '"');
    }

    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
  }

  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles,
        allowBlockScalars,
        allowBlockCollections,
        indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
        atNewLine  = false,
        hasContent = false,
        typeIndex,
        typeQuantity,
        type,
        flowIndent,
        blockIndent;

    if (state.listener !== null) {
      state.listener('open', state);
    }

    state.tag    = null;
    state.anchor = null;
    state.kind   = null;
    state.result = null;

    allowBlockStyles = allowBlockScalars = allowBlockCollections =
      CONTEXT_BLOCK_OUT === nodeContext ||
      CONTEXT_BLOCK_IN  === nodeContext;

    if (allowToSeek) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }

    if (indentStatus === 1) {
      while (readTagProperty(state) || readAnchorProperty(state)) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;

          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }

    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }

    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }

      blockIndent = state.position - state.lineStart;

      if (indentStatus === 1) {
        if (allowBlockCollections &&
            (readBlockSequence(state, blockIndent) ||
             readBlockMapping(state, blockIndent, flowIndent)) ||
            readFlowCollection(state, flowIndent)) {
          hasContent = true;
        } else {
          if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
              readSingleQuotedScalar(state, flowIndent) ||
              readDoubleQuotedScalar(state, flowIndent)) {
            hasContent = true;

          } else if (readAlias(state)) {
            hasContent = true;

            if (state.tag !== null || state.anchor !== null) {
              throwError(state, 'alias node should not have any properties');
            }

          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;

            if (state.tag === null) {
              state.tag = '?';
            }
          }

          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else if (indentStatus === 0) {
        // Special case: block sequences are allowed to have same indentation level as the parent.
        // http://www.yaml.org/spec/1.2/spec.html#id2799784
        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
      }
    }

    if (state.tag !== null && state.tag !== '!') {
      if (state.tag === '?') {
        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
          type = state.implicitTypes[typeIndex];

          // Implicit resolving is not allowed for non-scalar types, and '?'
          // non-specific tag is only assigned to plain scalars. So, it isn't
          // needed to check for 'kind' conformity.

          if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
            state.result = type.construct(state.result);
            state.tag = type.tag;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
            break;
          }
        }
      } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
        type = state.typeMap[state.kind || 'fallback'][state.tag];

        if (state.result !== null && type.kind !== state.kind) {
          throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
        }

        if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
          throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
        } else {
          state.result = type.construct(state.result);
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else {
        throwError(state, 'unknown tag !<' + state.tag + '>');
      }
    }

    if (state.listener !== null) {
      state.listener('close', state);
    }
    return state.tag !== null ||  state.anchor !== null || hasContent;
  }

  function readDocument(state) {
    var documentStart = state.position,
        _position,
        directiveName,
        directiveArgs,
        hasDirectives = false,
        ch;

    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = {};
    state.anchorMap = {};

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      skipSeparationSpace(state, true, -1);

      ch = state.input.charCodeAt(state.position);

      if (state.lineIndent > 0 || ch !== 0x25/* % */) {
        break;
      }

      hasDirectives = true;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveName = state.input.slice(_position, state.position);
      directiveArgs = [];

      if (directiveName.length < 1) {
        throwError(state, 'directive name must not be less than one character in length');
      }

      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x23/* # */) {
          do { ch = state.input.charCodeAt(++state.position); }
          while (ch !== 0 && !is_EOL(ch));
          break;
        }

        if (is_EOL(ch)) break;

        _position = state.position;

        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        directiveArgs.push(state.input.slice(_position, state.position));
      }

      if (ch !== 0) readLineBreak(state);

      if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state, directiveName, directiveArgs);
      } else {
        throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
    }

    skipSeparationSpace(state, true, -1);

    if (state.lineIndent === 0 &&
        state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
        state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
        state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);

    } else if (hasDirectives) {
      throwError(state, 'directives end mark is expected');
    }

    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);

    if (state.checkLineBreaks &&
        PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
      throwWarning(state, 'non-ASCII line breaks are interpreted as content');
    }

    state.documents.push(state.result);

    if (state.position === state.lineStart && testDocumentSeparator(state)) {

      if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
      return;
    }

    if (state.position < (state.length - 1)) {
      throwError(state, 'end of the stream or a document separator is expected');
    } else {
      return;
    }
  }


  function loadDocuments(input, options) {
    input = String(input);
    options = options || {};

    if (input.length !== 0) {

      // Add tailing `\n` if not exists
      if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
          input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
        input += '\n';
      }

      // Strip BOM
      if (input.charCodeAt(0) === 0xFEFF) {
        input = input.slice(1);
      }
    }

    var state = new State(input, options);

    // Use 0 as string terminator. That significantly simplifies bounds check.
    state.input += '\0';

    while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
      state.lineIndent += 1;
      state.position += 1;
    }

    while (state.position < (state.length - 1)) {
      readDocument(state);
    }

    return state.documents;
  }


  function loadAll(input, iterator, options) {
    var documents = loadDocuments(input, options), index, length;

    if (typeof iterator !== 'function') {
      return documents;
    }

    for (index = 0, length = documents.length; index < length; index += 1) {
      iterator(documents[index]);
    }
  }


  function load(input, options) {
    var documents = loadDocuments(input, options);

    if (documents.length === 0) {
      /*eslint-disable no-undefined*/
      return undefined;
    } else if (documents.length === 1) {
      return documents[0];
    }
    throw new YAMLException('expected a single document in the stream, but found more');
  }


  function safeLoadAll(input, output, options) {
    if (typeof output === 'function') {
      loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
    } else {
      return loadAll(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
    }
  }


  function safeLoad(input, options) {
    return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  }


  module.exports.loadAll     = loadAll;
  module.exports.load        = load;
  module.exports.safeLoadAll = safeLoadAll;
  module.exports.safeLoad    = safeLoad;


  /***/ }),
  /* 141 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";



  function isNothing(subject) {
    return (typeof subject === 'undefined') || (subject === null);
  }


  function isObject(subject) {
    return (typeof subject === 'object') && (subject !== null);
  }


  function toArray(sequence) {
    if (Array.isArray(sequence)) return sequence;
    else if (isNothing(sequence)) return [];

    return [ sequence ];
  }


  function extend(target, source) {
    var index, length, key, sourceKeys;

    if (source) {
      sourceKeys = Object.keys(source);

      for (index = 0, length = sourceKeys.length; index < length; index += 1) {
        key = sourceKeys[index];
        target[key] = source[key];
      }
    }

    return target;
  }


  function repeat(string, count) {
    var result = '', cycle;

    for (cycle = 0; cycle < count; cycle += 1) {
      result += string;
    }

    return result;
  }


  function isNegativeZero(number) {
    return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
  }


  module.exports.isNothing      = isNothing;
  module.exports.isObject       = isObject;
  module.exports.toArray        = toArray;
  module.exports.repeat         = repeat;
  module.exports.isNegativeZero = isNegativeZero;
  module.exports.extend         = extend;


  /***/ }),
  /* 142 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  // YAML error class. http://stackoverflow.com/questions/8458984
  //


  function YAMLException(reason, mark) {
    // Super constructor
    Error.call(this);

    this.name = 'YAMLException';
    this.reason = reason;
    this.mark = mark;
    this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');

    // Include stack trace in error object
    if (Error.captureStackTrace) {
      // Chrome and NodeJS
      Error.captureStackTrace(this, this.constructor);
    } else {
      // FF, IE 10+ and Safari 6+. Fallback for others
      this.stack = (new Error()).stack || '';
    }
  }


  // Inherit from Error
  YAMLException.prototype = Object.create(Error.prototype);
  YAMLException.prototype.constructor = YAMLException;


  YAMLException.prototype.toString = function toString(compact) {
    var result = this.name + ': ';

    result += this.reason || '(unknown reason)';

    if (!compact && this.mark) {
      result += ' ' + this.mark.toString();
    }

    return result;
  };


  module.exports = YAMLException;


  /***/ }),
  /* 143 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";



  var common = __webpack_require__(141);


  function Mark(name, buffer, position, line, column) {
    this.name     = name;
    this.buffer   = buffer;
    this.position = position;
    this.line     = line;
    this.column   = column;
  }


  Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
    var head, start, tail, end, snippet;

    if (!this.buffer) return null;

    indent = indent || 4;
    maxLength = maxLength || 75;

    head = '';
    start = this.position;

    while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
      start -= 1;
      if (this.position - start > (maxLength / 2 - 1)) {
        head = ' ... ';
        start += 5;
        break;
      }
    }

    tail = '';
    end = this.position;

    while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
      end += 1;
      if (end - this.position > (maxLength / 2 - 1)) {
        tail = ' ... ';
        end -= 5;
        break;
      }
    }

    snippet = this.buffer.slice(start, end);

    return common.repeat(' ', indent) + head + snippet + tail + '\n' +
           common.repeat(' ', indent + this.position - start + head.length) + '^';
  };


  Mark.prototype.toString = function toString(compact) {
    var snippet, where = '';

    if (this.name) {
      where += 'in "' + this.name + '" ';
    }

    where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

    if (!compact) {
      snippet = this.getSnippet();

      if (snippet) {
        where += ':\n' + snippet;
      }
    }

    return where;
  };


  module.exports = Mark;


  /***/ }),
  /* 144 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  // JS-YAML's default schema for `safeLoad` function.
  // It is not described in the YAML specification.
  //
  // This schema is based on standard YAML's Core schema and includes most of
  // extra types described at YAML tag repository. (http://yaml.org/type/)





  var Schema = __webpack_require__(145);


  module.exports = new Schema({
    include: [
      __webpack_require__(147)
    ],
    implicit: [
      __webpack_require__(157),
      __webpack_require__(158)
    ],
    explicit: [
      __webpack_require__(159),
      __webpack_require__(161),
      __webpack_require__(162),
      __webpack_require__(163)
    ]
  });


  /***/ }),
  /* 145 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  /*eslint-disable max-len*/

  var common        = __webpack_require__(141);
  var YAMLException = __webpack_require__(142);
  var Type          = __webpack_require__(146);


  function compileList(schema, name, result) {
    var exclude = [];

    schema.include.forEach(function (includedSchema) {
      result = compileList(includedSchema, name, result);
    });

    schema[name].forEach(function (currentType) {
      result.forEach(function (previousType, previousIndex) {
        if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
          exclude.push(previousIndex);
        }
      });

      result.push(currentType);
    });

    return result.filter(function (type, index) {
      return exclude.indexOf(index) === -1;
    });
  }


  function compileMap(/* lists... */) {
    var result = {
          scalar: {},
          sequence: {},
          mapping: {},
          fallback: {}
        }, index, length;

    function collectType(type) {
      result[type.kind][type.tag] = result['fallback'][type.tag] = type;
    }

    for (index = 0, length = arguments.length; index < length; index += 1) {
      arguments[index].forEach(collectType);
    }
    return result;
  }


  function Schema(definition) {
    this.include  = definition.include  || [];
    this.implicit = definition.implicit || [];
    this.explicit = definition.explicit || [];

    this.implicit.forEach(function (type) {
      if (type.loadKind && type.loadKind !== 'scalar') {
        throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
      }
    });

    this.compiledImplicit = compileList(this, 'implicit', []);
    this.compiledExplicit = compileList(this, 'explicit', []);
    this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
  }


  Schema.DEFAULT = null;


  Schema.create = function createSchema() {
    var schemas, types;

    switch (arguments.length) {
      case 1:
        schemas = Schema.DEFAULT;
        types = arguments[0];
        break;

      case 2:
        schemas = arguments[0];
        types = arguments[1];
        break;

      default:
        throw new YAMLException('Wrong number of arguments for Schema.create function');
    }

    schemas = common.toArray(schemas);
    types = common.toArray(types);

    if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
      throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
    }

    if (!types.every(function (type) { return type instanceof Type; })) {
      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
    }

    return new Schema({
      include: schemas,
      explicit: types
    });
  };


  module.exports = Schema;


  /***/ }),
  /* 146 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var YAMLException = __webpack_require__(142);

  var TYPE_CONSTRUCTOR_OPTIONS = [
    'kind',
    'resolve',
    'construct',
    'instanceOf',
    'predicate',
    'represent',
    'defaultStyle',
    'styleAliases'
  ];

  var YAML_NODE_KINDS = [
    'scalar',
    'sequence',
    'mapping'
  ];

  function compileStyleAliases(map) {
    var result = {};

    if (map !== null) {
      Object.keys(map).forEach(function (style) {
        map[style].forEach(function (alias) {
          result[String(alias)] = style;
        });
      });
    }

    return result;
  }

  function Type(tag, options) {
    options = options || {};

    Object.keys(options).forEach(function (name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
        throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
      }
    });

    // TODO: Add tag format check.
    this.tag          = tag;
    this.kind         = options['kind']         || null;
    this.resolve      = options['resolve']      || function () { return true; };
    this.construct    = options['construct']    || function (data) { return data; };
    this.instanceOf   = options['instanceOf']   || null;
    this.predicate    = options['predicate']    || null;
    this.represent    = options['represent']    || null;
    this.defaultStyle = options['defaultStyle'] || null;
    this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
  }

  module.exports = Type;


  /***/ }),
  /* 147 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  // Standard YAML's Core schema.
  // http://www.yaml.org/spec/1.2/spec.html#id2804923
  //
  // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
  // So, Core schema has no distinctions from JSON schema is JS-YAML.





  var Schema = __webpack_require__(145);


  module.exports = new Schema({
    include: [
      __webpack_require__(148)
    ]
  });


  /***/ }),
  /* 148 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  // Standard YAML's JSON schema.
  // http://www.yaml.org/spec/1.2/spec.html#id2803231
  //
  // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
  // So, this schema is not such strict as defined in the YAML specification.
  // It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.





  var Schema = __webpack_require__(145);


  module.exports = new Schema({
    include: [
      __webpack_require__(149)
    ],
    implicit: [
      __webpack_require__(153),
      __webpack_require__(154),
      __webpack_require__(155),
      __webpack_require__(156)
    ]
  });


  /***/ }),
  /* 149 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  // Standard YAML's Failsafe schema.
  // http://www.yaml.org/spec/1.2/spec.html#id2802346





  var Schema = __webpack_require__(145);


  module.exports = new Schema({
    explicit: [
      __webpack_require__(150),
      __webpack_require__(151),
      __webpack_require__(152)
    ]
  });


  /***/ }),
  /* 150 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var Type = __webpack_require__(146);

  module.exports = new Type('tag:yaml.org,2002:str', {
    kind: 'scalar',
    construct: function (data) { return data !== null ? data : ''; }
  });


  /***/ }),
  /* 151 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var Type = __webpack_require__(146);

  module.exports = new Type('tag:yaml.org,2002:seq', {
    kind: 'sequence',
    construct: function (data) { return data !== null ? data : []; }
  });


  /***/ }),
  /* 152 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var Type = __webpack_require__(146);

  module.exports = new Type('tag:yaml.org,2002:map', {
    kind: 'mapping',
    construct: function (data) { return data !== null ? data : {}; }
  });


  /***/ }),
  /* 153 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var Type = __webpack_require__(146);

  function resolveYamlNull(data) {
    if (data === null) return true;

    var max = data.length;

    return (max === 1 && data === '~') ||
           (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
  }

  function constructYamlNull() {
    return null;
  }

  function isNull(object) {
    return object === null;
  }

  module.exports = new Type('tag:yaml.org,2002:null', {
    kind: 'scalar',
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function () { return '~';    },
      lowercase: function () { return 'null'; },
      uppercase: function () { return 'NULL'; },
      camelcase: function () { return 'Null'; }
    },
    defaultStyle: 'lowercase'
  });


  /***/ }),
  /* 154 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var Type = __webpack_require__(146);

  function resolveYamlBoolean(data) {
    if (data === null) return false;

    var max = data.length;

    return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
           (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
  }

  function constructYamlBoolean(data) {
    return data === 'true' ||
           data === 'True' ||
           data === 'TRUE';
  }

  function isBoolean(object) {
    return Object.prototype.toString.call(object) === '[object Boolean]';
  }

  module.exports = new Type('tag:yaml.org,2002:bool', {
    kind: 'scalar',
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function (object) { return object ? 'true' : 'false'; },
      uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
      camelcase: function (object) { return object ? 'True' : 'False'; }
    },
    defaultStyle: 'lowercase'
  });


  /***/ }),
  /* 155 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var common = __webpack_require__(141);
  var Type   = __webpack_require__(146);

  function isHexCode(c) {
    return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
           ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
           ((0x61/* a */ <= c) && (c <= 0x66/* f */));
  }

  function isOctCode(c) {
    return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
  }

  function isDecCode(c) {
    return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
  }

  function resolveYamlInteger(data) {
    if (data === null) return false;

    var max = data.length,
        index = 0,
        hasDigits = false,
        ch;

    if (!max) return false;

    ch = data[index];

    // sign
    if (ch === '-' || ch === '+') {
      ch = data[++index];
    }

    if (ch === '0') {
      // 0
      if (index + 1 === max) return true;
      ch = data[++index];

      // base 2, base 8, base 16

      if (ch === 'b') {
        // base 2
        index++;

        for (; index < max; index++) {
          ch = data[index];
          if (ch === '_') continue;
          if (ch !== '0' && ch !== '1') return false;
          hasDigits = true;
        }
        return hasDigits && ch !== '_';
      }


      if (ch === 'x') {
        // base 16
        index++;

        for (; index < max; index++) {
          ch = data[index];
          if (ch === '_') continue;
          if (!isHexCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits && ch !== '_';
      }

      // base 8
      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }

    // base 10 (except 0) or base 60

    // value should not start with `_`;
    if (ch === '_') return false;

    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (ch === ':') break;
      if (!isDecCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }

    // Should have digits and should not end with `_`
    if (!hasDigits || ch === '_') return false;

    // if !base60 - done;
    if (ch !== ':') return true;

    // base60 almost not used, no needs to optimize
    return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
  }

  function constructYamlInteger(data) {
    var value = data, sign = 1, ch, base, digits = [];

    if (value.indexOf('_') !== -1) {
      value = value.replace(/_/g, '');
    }

    ch = value[0];

    if (ch === '-' || ch === '+') {
      if (ch === '-') sign = -1;
      value = value.slice(1);
      ch = value[0];
    }

    if (value === '0') return 0;

    if (ch === '0') {
      if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
      if (value[1] === 'x') return sign * parseInt(value, 16);
      return sign * parseInt(value, 8);
    }

    if (value.indexOf(':') !== -1) {
      value.split(':').forEach(function (v) {
        digits.unshift(parseInt(v, 10));
      });

      value = 0;
      base = 1;

      digits.forEach(function (d) {
        value += (d * base);
        base *= 60;
      });

      return sign * value;

    }

    return sign * parseInt(value, 10);
  }

  function isInteger(object) {
    return (Object.prototype.toString.call(object)) === '[object Number]' &&
           (object % 1 === 0 && !common.isNegativeZero(object));
  }

  module.exports = new Type('tag:yaml.org,2002:int', {
    kind: 'scalar',
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
      binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
      octal:       function (obj) { return obj >= 0 ? '0'  + obj.toString(8) : '-0'  + obj.toString(8).slice(1); },
      decimal:     function (obj) { return obj.toString(10); },
      /* eslint-disable max-len */
      hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
    },
    defaultStyle: 'decimal',
    styleAliases: {
      binary:      [ 2,  'bin' ],
      octal:       [ 8,  'oct' ],
      decimal:     [ 10, 'dec' ],
      hexadecimal: [ 16, 'hex' ]
    }
  });


  /***/ }),
  /* 156 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var common = __webpack_require__(141);
  var Type   = __webpack_require__(146);

  var YAML_FLOAT_PATTERN = new RegExp(
    // 2.5e4, 2.5 and integers
    '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
    // .2e4, .2
    // special case, seems not from spec
    '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
    // 20:59
    '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
    // .inf
    '|[-+]?\\.(?:inf|Inf|INF)' +
    // .nan
    '|\\.(?:nan|NaN|NAN))$');

  function resolveYamlFloat(data) {
    if (data === null) return false;

    if (!YAML_FLOAT_PATTERN.test(data) ||
        // Quick hack to not allow integers end with `_`
        // Probably should update regexp & check speed
        data[data.length - 1] === '_') {
      return false;
    }

    return true;
  }

  function constructYamlFloat(data) {
    var value, sign, base, digits;

    value  = data.replace(/_/g, '').toLowerCase();
    sign   = value[0] === '-' ? -1 : 1;
    digits = [];

    if ('+-'.indexOf(value[0]) >= 0) {
      value = value.slice(1);
    }

    if (value === '.inf') {
      return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

    } else if (value === '.nan') {
      return NaN;

    } else if (value.indexOf(':') >= 0) {
      value.split(':').forEach(function (v) {
        digits.unshift(parseFloat(v, 10));
      });

      value = 0.0;
      base = 1;

      digits.forEach(function (d) {
        value += d * base;
        base *= 60;
      });

      return sign * value;

    }
    return sign * parseFloat(value, 10);
  }


  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

  function representYamlFloat(object, style) {
    var res;

    if (isNaN(object)) {
      switch (style) {
        case 'lowercase': return '.nan';
        case 'uppercase': return '.NAN';
        case 'camelcase': return '.NaN';
      }
    } else if (Number.POSITIVE_INFINITY === object) {
      switch (style) {
        case 'lowercase': return '.inf';
        case 'uppercase': return '.INF';
        case 'camelcase': return '.Inf';
      }
    } else if (Number.NEGATIVE_INFINITY === object) {
      switch (style) {
        case 'lowercase': return '-.inf';
        case 'uppercase': return '-.INF';
        case 'camelcase': return '-.Inf';
      }
    } else if (common.isNegativeZero(object)) {
      return '-0.0';
    }

    res = object.toString(10);

    // JS stringifier can build scientific format without dots: 5e-100,
    // while YAML requres dot: 5.e-100. Fix it with simple hack

    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
  }

  function isFloat(object) {
    return (Object.prototype.toString.call(object) === '[object Number]') &&
           (object % 1 !== 0 || common.isNegativeZero(object));
  }

  module.exports = new Type('tag:yaml.org,2002:float', {
    kind: 'scalar',
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: 'lowercase'
  });


  /***/ }),
  /* 157 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var Type = __webpack_require__(146);

  var YAML_DATE_REGEXP = new RegExp(
    '^([0-9][0-9][0-9][0-9])'          + // [1] year
    '-([0-9][0-9])'                    + // [2] month
    '-([0-9][0-9])$');                   // [3] day

  var YAML_TIMESTAMP_REGEXP = new RegExp(
    '^([0-9][0-9][0-9][0-9])'          + // [1] year
    '-([0-9][0-9]?)'                   + // [2] month
    '-([0-9][0-9]?)'                   + // [3] day
    '(?:[Tt]|[ \\t]+)'                 + // ...
    '([0-9][0-9]?)'                    + // [4] hour
    ':([0-9][0-9])'                    + // [5] minute
    ':([0-9][0-9])'                    + // [6] second
    '(?:\\.([0-9]*))?'                 + // [7] fraction
    '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
    '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

  function resolveYamlTimestamp(data) {
    if (data === null) return false;
    if (YAML_DATE_REGEXP.exec(data) !== null) return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
    return false;
  }

  function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0,
        delta = null, tz_hour, tz_minute, date;

    match = YAML_DATE_REGEXP.exec(data);
    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

    if (match === null) throw new Error('Date resolve error');

    // match: [1] year [2] month [3] day

    year = +(match[1]);
    month = +(match[2]) - 1; // JS month starts with 0
    day = +(match[3]);

    if (!match[4]) { // no hour
      return new Date(Date.UTC(year, month, day));
    }

    // match: [4] hour [5] minute [6] second [7] fraction

    hour = +(match[4]);
    minute = +(match[5]);
    second = +(match[6]);

    if (match[7]) {
      fraction = match[7].slice(0, 3);
      while (fraction.length < 3) { // milli-seconds
        fraction += '0';
      }
      fraction = +fraction;
    }

    // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

    if (match[9]) {
      tz_hour = +(match[10]);
      tz_minute = +(match[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
      if (match[9] === '-') delta = -delta;
    }

    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

    if (delta) date.setTime(date.getTime() - delta);

    return date;
  }

  function representYamlTimestamp(object /*, style*/) {
    return object.toISOString();
  }

  module.exports = new Type('tag:yaml.org,2002:timestamp', {
    kind: 'scalar',
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });


  /***/ }),
  /* 158 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var Type = __webpack_require__(146);

  function resolveYamlMerge(data) {
    return data === '<<' || data === null;
  }

  module.exports = new Type('tag:yaml.org,2002:merge', {
    kind: 'scalar',
    resolve: resolveYamlMerge
  });


  /***/ }),
  /* 159 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  var require;

  /*eslint-disable no-bitwise*/

  var NodeBuffer;

  try {
    // A trick for browserified version, to not include `Buffer` shim
    var _require = require;
    NodeBuffer = __webpack_require__(160).Buffer;
  } catch (__) {}

  var Type       = __webpack_require__(146);


  // [ 64, 65, 66 ] -> [ padding, CR, LF ]
  var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


  function resolveYamlBinary(data) {
    if (data === null) return false;

    var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

    // Convert one by one.
    for (idx = 0; idx < max; idx++) {
      code = map.indexOf(data.charAt(idx));

      // Skip CR/LF
      if (code > 64) continue;

      // Fail on illegal characters
      if (code < 0) return false;

      bitlen += 6;
    }

    // If there are any bits left, source was corrupted
    return (bitlen % 8) === 0;
  }

  function constructYamlBinary(data) {
    var idx, tailbits,
        input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
        max = input.length,
        map = BASE64_MAP,
        bits = 0,
        result = [];

    // Collect by 6*4 bits (3 bytes)

    for (idx = 0; idx < max; idx++) {
      if ((idx % 4 === 0) && idx) {
        result.push((bits >> 16) & 0xFF);
        result.push((bits >> 8) & 0xFF);
        result.push(bits & 0xFF);
      }

      bits = (bits << 6) | map.indexOf(input.charAt(idx));
    }

    // Dump tail

    tailbits = (max % 4) * 6;

    if (tailbits === 0) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    } else if (tailbits === 18) {
      result.push((bits >> 10) & 0xFF);
      result.push((bits >> 2) & 0xFF);
    } else if (tailbits === 12) {
      result.push((bits >> 4) & 0xFF);
    }

    // Wrap into Buffer for NodeJS and leave Array for browser
    if (NodeBuffer) {
      // Support node 6.+ Buffer API when available
      return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
    }

    return result;
  }

  function representYamlBinary(object /*, style*/) {
    var result = '', bits = 0, idx, tail,
        max = object.length,
        map = BASE64_MAP;

    // Convert every three bytes to 4 ASCII characters.

    for (idx = 0; idx < max; idx++) {
      if ((idx % 3 === 0) && idx) {
        result += map[(bits >> 18) & 0x3F];
        result += map[(bits >> 12) & 0x3F];
        result += map[(bits >> 6) & 0x3F];
        result += map[bits & 0x3F];
      }

      bits = (bits << 8) + object[idx];
    }

    // Dump tail

    tail = max % 3;

    if (tail === 0) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    } else if (tail === 2) {
      result += map[(bits >> 10) & 0x3F];
      result += map[(bits >> 4) & 0x3F];
      result += map[(bits << 2) & 0x3F];
      result += map[64];
    } else if (tail === 1) {
      result += map[(bits >> 2) & 0x3F];
      result += map[(bits << 4) & 0x3F];
      result += map[64];
      result += map[64];
    }

    return result;
  }

  function isBinary(object) {
    return NodeBuffer && NodeBuffer.isBuffer(object);
  }

  module.exports = new Type('tag:yaml.org,2002:binary', {
    kind: 'scalar',
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });


  /***/ }),
  /* 160 */
  /***/ (function(module, exports) {

  module.exports = require("buffer");

  /***/ }),
  /* 161 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var Type = __webpack_require__(146);

  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var _toString       = Object.prototype.toString;

  function resolveYamlOmap(data) {
    if (data === null) return true;

    var objectKeys = [], index, length, pair, pairKey, pairHasKey,
        object = data;

    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      pairHasKey = false;

      if (_toString.call(pair) !== '[object Object]') return false;

      for (pairKey in pair) {
        if (_hasOwnProperty.call(pair, pairKey)) {
          if (!pairHasKey) pairHasKey = true;
          else return false;
        }
      }

      if (!pairHasKey) return false;

      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
      else return false;
    }

    return true;
  }

  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }

  module.exports = new Type('tag:yaml.org,2002:omap', {
    kind: 'sequence',
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });


  /***/ }),
  /* 162 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var Type = __webpack_require__(146);

  var _toString = Object.prototype.toString;

  function resolveYamlPairs(data) {
    if (data === null) return true;

    var index, length, pair, keys, result,
        object = data;

    result = new Array(object.length);

    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];

      if (_toString.call(pair) !== '[object Object]') return false;

      keys = Object.keys(pair);

      if (keys.length !== 1) return false;

      result[index] = [ keys[0], pair[keys[0]] ];
    }

    return true;
  }

  function constructYamlPairs(data) {
    if (data === null) return [];

    var index, length, pair, keys, result,
        object = data;

    result = new Array(object.length);

    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];

      keys = Object.keys(pair);

      result[index] = [ keys[0], pair[keys[0]] ];
    }

    return result;
  }

  module.exports = new Type('tag:yaml.org,2002:pairs', {
    kind: 'sequence',
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });


  /***/ }),
  /* 163 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var Type = __webpack_require__(146);

  var _hasOwnProperty = Object.prototype.hasOwnProperty;

  function resolveYamlSet(data) {
    if (data === null) return true;

    var key, object = data;

    for (key in object) {
      if (_hasOwnProperty.call(object, key)) {
        if (object[key] !== null) return false;
      }
    }

    return true;
  }

  function constructYamlSet(data) {
    return data !== null ? data : {};
  }

  module.exports = new Type('tag:yaml.org,2002:set', {
    kind: 'mapping',
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });


  /***/ }),
  /* 164 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  // JS-YAML's default schema for `load` function.
  // It is not described in the YAML specification.
  //
  // This schema is based on JS-YAML's default safe schema and includes
  // JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
  //
  // Also this schema is used as default base schema at `Schema.create` function.





  var Schema = __webpack_require__(145);


  module.exports = Schema.DEFAULT = new Schema({
    include: [
      __webpack_require__(144)
    ],
    explicit: [
      __webpack_require__(165),
      __webpack_require__(166),
      __webpack_require__(167)
    ]
  });


  /***/ }),
  /* 165 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var Type = __webpack_require__(146);

  function resolveJavascriptUndefined() {
    return true;
  }

  function constructJavascriptUndefined() {
    /*eslint-disable no-undefined*/
    return undefined;
  }

  function representJavascriptUndefined() {
    return '';
  }

  function isUndefined(object) {
    return typeof object === 'undefined';
  }

  module.exports = new Type('tag:yaml.org,2002:js/undefined', {
    kind: 'scalar',
    resolve: resolveJavascriptUndefined,
    construct: constructJavascriptUndefined,
    predicate: isUndefined,
    represent: representJavascriptUndefined
  });


  /***/ }),
  /* 166 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var Type = __webpack_require__(146);

  function resolveJavascriptRegExp(data) {
    if (data === null) return false;
    if (data.length === 0) return false;

    var regexp = data,
        tail   = /\/([gim]*)$/.exec(data),
        modifiers = '';

    // if regexp starts with '/' it can have modifiers and must be properly closed
    // `/foo/gim` - modifiers tail can be maximum 3 chars
    if (regexp[0] === '/') {
      if (tail) modifiers = tail[1];

      if (modifiers.length > 3) return false;
      // if expression starts with /, is should be properly terminated
      if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
    }

    return true;
  }

  function constructJavascriptRegExp(data) {
    var regexp = data,
        tail   = /\/([gim]*)$/.exec(data),
        modifiers = '';

    // `/foo/gim` - tail can be maximum 4 chars
    if (regexp[0] === '/') {
      if (tail) modifiers = tail[1];
      regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
    }

    return new RegExp(regexp, modifiers);
  }

  function representJavascriptRegExp(object /*, style*/) {
    var result = '/' + object.source + '/';

    if (object.global) result += 'g';
    if (object.multiline) result += 'm';
    if (object.ignoreCase) result += 'i';

    return result;
  }

  function isRegExp(object) {
    return Object.prototype.toString.call(object) === '[object RegExp]';
  }

  module.exports = new Type('tag:yaml.org,2002:js/regexp', {
    kind: 'scalar',
    resolve: resolveJavascriptRegExp,
    construct: constructJavascriptRegExp,
    predicate: isRegExp,
    represent: representJavascriptRegExp
  });


  /***/ }),
  /* 167 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  var require;

  var esprima;

  // Browserified version does not have esprima
  //
  // 1. For node.js just require module as deps
  // 2. For browser try to require mudule via external AMD system.
  //    If not found - try to fallback to window.esprima. If not
  //    found too - then fail to parse.
  //
  try {
    // workaround to exclude package from browserify list.
    var _require = require;
    esprima = __webpack_require__(168);
  } catch (_) {
    /*global window */
    if (typeof window !== 'undefined') esprima = window.esprima;
  }

  var Type = __webpack_require__(146);

  function resolveJavascriptFunction(data) {
    if (data === null) return false;

    try {
      var source = '(' + data + ')',
          ast    = esprima.parse(source, { range: true });

      if (ast.type                    !== 'Program'             ||
          ast.body.length             !== 1                     ||
          ast.body[0].type            !== 'ExpressionStatement' ||
          (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
            ast.body[0].expression.type !== 'FunctionExpression')) {
        return false;
      }

      return true;
    } catch (err) {
      return false;
    }
  }

  function constructJavascriptFunction(data) {
    /*jslint evil:true*/

    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true }),
        params = [],
        body;

    if (ast.type                    !== 'Program'             ||
        ast.body.length             !== 1                     ||
        ast.body[0].type            !== 'ExpressionStatement' ||
        (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
          ast.body[0].expression.type !== 'FunctionExpression')) {
      throw new Error('Failed to resolve function');
    }

    ast.body[0].expression.params.forEach(function (param) {
      params.push(param.name);
    });

    body = ast.body[0].expression.body.range;

    // Esprima's ranges include the first '{' and the last '}' characters on
    // function expressions. So cut them out.
    if (ast.body[0].expression.body.type === 'BlockStatement') {
      /*eslint-disable no-new-func*/
      return new Function(params, source.slice(body[0] + 1, body[1] - 1));
    }
    // ES6 arrow functions can omit the BlockStatement. In that case, just return
    // the body.
    /*eslint-disable no-new-func*/
    return new Function(params, 'return ' + source.slice(body[0], body[1]));
  }

  function representJavascriptFunction(object /*, style*/) {
    return object.toString();
  }

  function isFunction(object) {
    return Object.prototype.toString.call(object) === '[object Function]';
  }

  module.exports = new Type('tag:yaml.org,2002:js/function', {
    kind: 'scalar',
    resolve: resolveJavascriptFunction,
    construct: constructJavascriptFunction,
    predicate: isFunction,
    represent: representJavascriptFunction
  });


  /***/ }),
  /* 168 */
  /***/ (function(module, exports, __webpack_require__) {

  (function webpackUniversalModuleDefinition(root, factory) {
  /* istanbul ignore next */
  	if(true)
  		module.exports = factory();
  	else {}
  })(this, function() {
  return /******/ (function(modules) { // webpackBootstrap
  /******/ 	// The module cache
  /******/ 	var installedModules = {};

  /******/ 	// The require function
  /******/ 	function __webpack_require__(moduleId) {

  /******/ 		// Check if module is in cache
  /* istanbul ignore if */
  /******/ 		if(installedModules[moduleId])
  /******/ 			return installedModules[moduleId].exports;

  /******/ 		// Create a new module (and put it into the cache)
  /******/ 		var module = installedModules[moduleId] = {
  /******/ 			exports: {},
  /******/ 			id: moduleId,
  /******/ 			loaded: false
  /******/ 		};

  /******/ 		// Execute the module function
  /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

  /******/ 		// Flag the module as loaded
  /******/ 		module.loaded = true;

  /******/ 		// Return the exports of the module
  /******/ 		return module.exports;
  /******/ 	}


  /******/ 	// expose the modules object (__webpack_modules__)
  /******/ 	__webpack_require__.m = modules;

  /******/ 	// expose the module cache
  /******/ 	__webpack_require__.c = installedModules;

  /******/ 	// __webpack_public_path__
  /******/ 	__webpack_require__.p = "";

  /******/ 	// Load entry module and return exports
  /******/ 	return __webpack_require__(0);
  /******/ })
  /************************************************************************/
  /******/ ([
  /* 0 */
  /***/ function(module, exports, __webpack_require__) {

  	"use strict";
  	/*
  	  Copyright JS Foundation and other contributors, https://js.foundation/

  	  Redistribution and use in source and binary forms, with or without
  	  modification, are permitted provided that the following conditions are met:

  	    * Redistributions of source code must retain the above copyright
  	      notice, this list of conditions and the following disclaimer.
  	    * Redistributions in binary form must reproduce the above copyright
  	      notice, this list of conditions and the following disclaimer in the
  	      documentation and/or other materials provided with the distribution.

  	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  	*/
  	Object.defineProperty(exports, "__esModule", { value: true });
  	var comment_handler_1 = __webpack_require__(1);
  	var jsx_parser_1 = __webpack_require__(3);
  	var parser_1 = __webpack_require__(8);
  	var tokenizer_1 = __webpack_require__(15);
  	function parse(code, options, delegate) {
  	    var commentHandler = null;
  	    var proxyDelegate = function (node, metadata) {
  	        if (delegate) {
  	            delegate(node, metadata);
  	        }
  	        if (commentHandler) {
  	            commentHandler.visit(node, metadata);
  	        }
  	    };
  	    var parserDelegate = (typeof delegate === 'function') ? proxyDelegate : null;
  	    var collectComment = false;
  	    if (options) {
  	        collectComment = (typeof options.comment === 'boolean' && options.comment);
  	        var attachComment = (typeof options.attachComment === 'boolean' && options.attachComment);
  	        if (collectComment || attachComment) {
  	            commentHandler = new comment_handler_1.CommentHandler();
  	            commentHandler.attach = attachComment;
  	            options.comment = true;
  	            parserDelegate = proxyDelegate;
  	        }
  	    }
  	    var isModule = false;
  	    if (options && typeof options.sourceType === 'string') {
  	        isModule = (options.sourceType === 'module');
  	    }
  	    var parser;
  	    if (options && typeof options.jsx === 'boolean' && options.jsx) {
  	        parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
  	    }
  	    else {
  	        parser = new parser_1.Parser(code, options, parserDelegate);
  	    }
  	    var program = isModule ? parser.parseModule() : parser.parseScript();
  	    var ast = program;
  	    if (collectComment && commentHandler) {
  	        ast.comments = commentHandler.comments;
  	    }
  	    if (parser.config.tokens) {
  	        ast.tokens = parser.tokens;
  	    }
  	    if (parser.config.tolerant) {
  	        ast.errors = parser.errorHandler.errors;
  	    }
  	    return ast;
  	}
  	exports.parse = parse;
  	function parseModule(code, options, delegate) {
  	    var parsingOptions = options || {};
  	    parsingOptions.sourceType = 'module';
  	    return parse(code, parsingOptions, delegate);
  	}
  	exports.parseModule = parseModule;
  	function parseScript(code, options, delegate) {
  	    var parsingOptions = options || {};
  	    parsingOptions.sourceType = 'script';
  	    return parse(code, parsingOptions, delegate);
  	}
  	exports.parseScript = parseScript;
  	function tokenize(code, options, delegate) {
  	    var tokenizer = new tokenizer_1.Tokenizer(code, options);
  	    var tokens;
  	    tokens = [];
  	    try {
  	        while (true) {
  	            var token = tokenizer.getNextToken();
  	            if (!token) {
  	                break;
  	            }
  	            if (delegate) {
  	                token = delegate(token);
  	            }
  	            tokens.push(token);
  	        }
  	    }
  	    catch (e) {
  	        tokenizer.errorHandler.tolerate(e);
  	    }
  	    if (tokenizer.errorHandler.tolerant) {
  	        tokens.errors = tokenizer.errors();
  	    }
  	    return tokens;
  	}
  	exports.tokenize = tokenize;
  	var syntax_1 = __webpack_require__(2);
  	exports.Syntax = syntax_1.Syntax;
  	// Sync with *.json manifests.
  	exports.version = '4.0.1';


  /***/ },
  /* 1 */
  /***/ function(module, exports, __webpack_require__) {

  	"use strict";
  	Object.defineProperty(exports, "__esModule", { value: true });
  	var syntax_1 = __webpack_require__(2);
  	var CommentHandler = (function () {
  	    function CommentHandler() {
  	        this.attach = false;
  	        this.comments = [];
  	        this.stack = [];
  	        this.leading = [];
  	        this.trailing = [];
  	    }
  	    CommentHandler.prototype.insertInnerComments = function (node, metadata) {
  	        //  innnerComments for properties empty block
  	        //  `function a() {/** comments **\/}`
  	        if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
  	            var innerComments = [];
  	            for (var i = this.leading.length - 1; i >= 0; --i) {
  	                var entry = this.leading[i];
  	                if (metadata.end.offset >= entry.start) {
  	                    innerComments.unshift(entry.comment);
  	                    this.leading.splice(i, 1);
  	                    this.trailing.splice(i, 1);
  	                }
  	            }
  	            if (innerComments.length) {
  	                node.innerComments = innerComments;
  	            }
  	        }
  	    };
  	    CommentHandler.prototype.findTrailingComments = function (metadata) {
  	        var trailingComments = [];
  	        if (this.trailing.length > 0) {
  	            for (var i = this.trailing.length - 1; i >= 0; --i) {
  	                var entry_1 = this.trailing[i];
  	                if (entry_1.start >= metadata.end.offset) {
  	                    trailingComments.unshift(entry_1.comment);
  	                }
  	            }
  	            this.trailing.length = 0;
  	            return trailingComments;
  	        }
  	        var entry = this.stack[this.stack.length - 1];
  	        if (entry && entry.node.trailingComments) {
  	            var firstComment = entry.node.trailingComments[0];
  	            if (firstComment && firstComment.range[0] >= metadata.end.offset) {
  	                trailingComments = entry.node.trailingComments;
  	                delete entry.node.trailingComments;
  	            }
  	        }
  	        return trailingComments;
  	    };
  	    CommentHandler.prototype.findLeadingComments = function (metadata) {
  	        var leadingComments = [];
  	        var target;
  	        while (this.stack.length > 0) {
  	            var entry = this.stack[this.stack.length - 1];
  	            if (entry && entry.start >= metadata.start.offset) {
  	                target = entry.node;
  	                this.stack.pop();
  	            }
  	            else {
  	                break;
  	            }
  	        }
  	        if (target) {
  	            var count = target.leadingComments ? target.leadingComments.length : 0;
  	            for (var i = count - 1; i >= 0; --i) {
  	                var comment = target.leadingComments[i];
  	                if (comment.range[1] <= metadata.start.offset) {
  	                    leadingComments.unshift(comment);
  	                    target.leadingComments.splice(i, 1);
  	                }
  	            }
  	            if (target.leadingComments && target.leadingComments.length === 0) {
  	                delete target.leadingComments;
  	            }
  	            return leadingComments;
  	        }
  	        for (var i = this.leading.length - 1; i >= 0; --i) {
  	            var entry = this.leading[i];
  	            if (entry.start <= metadata.start.offset) {
  	                leadingComments.unshift(entry.comment);
  	                this.leading.splice(i, 1);
  	            }
  	        }
  	        return leadingComments;
  	    };
  	    CommentHandler.prototype.visitNode = function (node, metadata) {
  	        if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
  	            return;
  	        }
  	        this.insertInnerComments(node, metadata);
  	        var trailingComments = this.findTrailingComments(metadata);
  	        var leadingComments = this.findLeadingComments(metadata);
  	        if (leadingComments.length > 0) {
  	            node.leadingComments = leadingComments;
  	        }
  	        if (trailingComments.length > 0) {
  	            node.trailingComments = trailingComments;
  	        }
  	        this.stack.push({
  	            node: node,
  	            start: metadata.start.offset
  	        });
  	    };
  	    CommentHandler.prototype.visitComment = function (node, metadata) {
  	        var type = (node.type[0] === 'L') ? 'Line' : 'Block';
  	        var comment = {
  	            type: type,
  	            value: node.value
  	        };
  	        if (node.range) {
  	            comment.range = node.range;
  	        }
  	        if (node.loc) {
  	            comment.loc = node.loc;
  	        }
  	        this.comments.push(comment);
  	        if (this.attach) {
  	            var entry = {
  	                comment: {
  	                    type: type,
  	                    value: node.value,
  	                    range: [metadata.start.offset, metadata.end.offset]
  	                },
  	                start: metadata.start.offset
  	            };
  	            if (node.loc) {
  	                entry.comment.loc = node.loc;
  	            }
  	            node.type = type;
  	            this.leading.push(entry);
  	            this.trailing.push(entry);
  	        }
  	    };
  	    CommentHandler.prototype.visit = function (node, metadata) {
  	        if (node.type === 'LineComment') {
  	            this.visitComment(node, metadata);
  	        }
  	        else if (node.type === 'BlockComment') {
  	            this.visitComment(node, metadata);
  	        }
  	        else if (this.attach) {
  	            this.visitNode(node, metadata);
  	        }
  	    };
  	    return CommentHandler;
  	}());
  	exports.CommentHandler = CommentHandler;


  /***/ },
  /* 2 */
  /***/ function(module, exports) {

  	"use strict";
  	Object.defineProperty(exports, "__esModule", { value: true });
  	exports.Syntax = {
  	    AssignmentExpression: 'AssignmentExpression',
  	    AssignmentPattern: 'AssignmentPattern',
  	    ArrayExpression: 'ArrayExpression',
  	    ArrayPattern: 'ArrayPattern',
  	    ArrowFunctionExpression: 'ArrowFunctionExpression',
  	    AwaitExpression: 'AwaitExpression',
  	    BlockStatement: 'BlockStatement',
  	    BinaryExpression: 'BinaryExpression',
  	    BreakStatement: 'BreakStatement',
  	    CallExpression: 'CallExpression',
  	    CatchClause: 'CatchClause',
  	    ClassBody: 'ClassBody',
  	    ClassDeclaration: 'ClassDeclaration',
  	    ClassExpression: 'ClassExpression',
  	    ConditionalExpression: 'ConditionalExpression',
  	    ContinueStatement: 'ContinueStatement',
  	    DoWhileStatement: 'DoWhileStatement',
  	    DebuggerStatement: 'DebuggerStatement',
  	    EmptyStatement: 'EmptyStatement',
  	    ExportAllDeclaration: 'ExportAllDeclaration',
  	    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
  	    ExportNamedDeclaration: 'ExportNamedDeclaration',
  	    ExportSpecifier: 'ExportSpecifier',
  	    ExpressionStatement: 'ExpressionStatement',
  	    ForStatement: 'ForStatement',
  	    ForOfStatement: 'ForOfStatement',
  	    ForInStatement: 'ForInStatement',
  	    FunctionDeclaration: 'FunctionDeclaration',
  	    FunctionExpression: 'FunctionExpression',
  	    Identifier: 'Identifier',
  	    IfStatement: 'IfStatement',
  	    ImportDeclaration: 'ImportDeclaration',
  	    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
  	    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
  	    ImportSpecifier: 'ImportSpecifier',
  	    Literal: 'Literal',
  	    LabeledStatement: 'LabeledStatement',
  	    LogicalExpression: 'LogicalExpression',
  	    MemberExpression: 'MemberExpression',
  	    MetaProperty: 'MetaProperty',
  	    MethodDefinition: 'MethodDefinition',
  	    NewExpression: 'NewExpression',
  	    ObjectExpression: 'ObjectExpression',
  	    ObjectPattern: 'ObjectPattern',
  	    Program: 'Program',
  	    Property: 'Property',
  	    RestElement: 'RestElement',
  	    ReturnStatement: 'ReturnStatement',
  	    SequenceExpression: 'SequenceExpression',
  	    SpreadElement: 'SpreadElement',
  	    Super: 'Super',
  	    SwitchCase: 'SwitchCase',
  	    SwitchStatement: 'SwitchStatement',
  	    TaggedTemplateExpression: 'TaggedTemplateExpression',
  	    TemplateElement: 'TemplateElement',
  	    TemplateLiteral: 'TemplateLiteral',
  	    ThisExpression: 'ThisExpression',
  	    ThrowStatement: 'ThrowStatement',
  	    TryStatement: 'TryStatement',
  	    UnaryExpression: 'UnaryExpression',
  	    UpdateExpression: 'UpdateExpression',
  	    VariableDeclaration: 'VariableDeclaration',
  	    VariableDeclarator: 'VariableDeclarator',
  	    WhileStatement: 'WhileStatement',
  	    WithStatement: 'WithStatement',
  	    YieldExpression: 'YieldExpression'
  	};


  /***/ },
  /* 3 */
  /***/ function(module, exports, __webpack_require__) {

  	"use strict";
  /* istanbul ignore next */
  	var __extends = (this && this.__extends) || (function () {
  	    var extendStatics = Object.setPrototypeOf ||
  	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
  	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
  	    return function (d, b) {
  	        extendStatics(d, b);
  	        function __() { this.constructor = d; }
  	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  	    };
  	})();
  	Object.defineProperty(exports, "__esModule", { value: true });
  	var character_1 = __webpack_require__(4);
  	var JSXNode = __webpack_require__(5);
  	var jsx_syntax_1 = __webpack_require__(6);
  	var Node = __webpack_require__(7);
  	var parser_1 = __webpack_require__(8);
  	var token_1 = __webpack_require__(13);
  	var xhtml_entities_1 = __webpack_require__(14);
  	token_1.TokenName[100 /* Identifier */] = 'JSXIdentifier';
  	token_1.TokenName[101 /* Text */] = 'JSXText';
  	// Fully qualified element name, e.g. <svg:path> returns "svg:path"
  	function getQualifiedElementName(elementName) {
  	    var qualifiedName;
  	    switch (elementName.type) {
  	        case jsx_syntax_1.JSXSyntax.JSXIdentifier:
  	            var id = elementName;
  	            qualifiedName = id.name;
  	            break;
  	        case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
  	            var ns = elementName;
  	            qualifiedName = getQualifiedElementName(ns.namespace) + ':' +
  	                getQualifiedElementName(ns.name);
  	            break;
  	        case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
  	            var expr = elementName;
  	            qualifiedName = getQualifiedElementName(expr.object) + '.' +
  	                getQualifiedElementName(expr.property);
  	            break;
  	        /* istanbul ignore next */
  	        default:
  	            break;
  	    }
  	    return qualifiedName;
  	}
  	var JSXParser = (function (_super) {
  	    __extends(JSXParser, _super);
  	    function JSXParser(code, options, delegate) {
  	        return _super.call(this, code, options, delegate) || this;
  	    }
  	    JSXParser.prototype.parsePrimaryExpression = function () {
  	        return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
  	    };
  	    JSXParser.prototype.startJSX = function () {
  	        // Unwind the scanner before the lookahead token.
  	        this.scanner.index = this.startMarker.index;
  	        this.scanner.lineNumber = this.startMarker.line;
  	        this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
  	    };
  	    JSXParser.prototype.finishJSX = function () {
  	        // Prime the next lookahead.
  	        this.nextToken();
  	    };
  	    JSXParser.prototype.reenterJSX = function () {
  	        this.startJSX();
  	        this.expectJSX('}');
  	        // Pop the closing '}' added from the lookahead.
  	        if (this.config.tokens) {
  	            this.tokens.pop();
  	        }
  	    };
  	    JSXParser.prototype.createJSXNode = function () {
  	        this.collectComments();
  	        return {
  	            index: this.scanner.index,
  	            line: this.scanner.lineNumber,
  	            column: this.scanner.index - this.scanner.lineStart
  	        };
  	    };
  	    JSXParser.prototype.createJSXChildNode = function () {
  	        return {
  	            index: this.scanner.index,
  	            line: this.scanner.lineNumber,
  	            column: this.scanner.index - this.scanner.lineStart
  	        };
  	    };
  	    JSXParser.prototype.scanXHTMLEntity = function (quote) {
  	        var result = '&';
  	        var valid = true;
  	        var terminated = false;
  	        var numeric = false;
  	        var hex = false;
  	        while (!this.scanner.eof() && valid && !terminated) {
  	            var ch = this.scanner.source[this.scanner.index];
  	            if (ch === quote) {
  	                break;
  	            }
  	            terminated = (ch === ';');
  	            result += ch;
  	            ++this.scanner.index;
  	            if (!terminated) {
  	                switch (result.length) {
  	                    case 2:
  	                        // e.g. '&#123;'
  	                        numeric = (ch === '#');
  	                        break;
  	                    case 3:
  	                        if (numeric) {
  	                            // e.g. '&#x41;'
  	                            hex = (ch === 'x');
  	                            valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
  	                            numeric = numeric && !hex;
  	                        }
  	                        break;
  	                    default:
  	                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
  	                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
  	                        break;
  	                }
  	            }
  	        }
  	        if (valid && terminated && result.length > 2) {
  	            // e.g. '&#x41;' becomes just '#x41'
  	            var str = result.substr(1, result.length - 2);
  	            if (numeric && str.length > 1) {
  	                result = String.fromCharCode(parseInt(str.substr(1), 10));
  	            }
  	            else if (hex && str.length > 2) {
  	                result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
  	            }
  	            else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
  	                result = xhtml_entities_1.XHTMLEntities[str];
  	            }
  	        }
  	        return result;
  	    };
  	    // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
  	    JSXParser.prototype.lexJSX = function () {
  	        var cp = this.scanner.source.charCodeAt(this.scanner.index);
  	        // < > / : = { }
  	        if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
  	            var value = this.scanner.source[this.scanner.index++];
  	            return {
  	                type: 7 /* Punctuator */,
  	                value: value,
  	                lineNumber: this.scanner.lineNumber,
  	                lineStart: this.scanner.lineStart,
  	                start: this.scanner.index - 1,
  	                end: this.scanner.index
  	            };
  	        }
  	        // " '
  	        if (cp === 34 || cp === 39) {
  	            var start = this.scanner.index;
  	            var quote = this.scanner.source[this.scanner.index++];
  	            var str = '';
  	            while (!this.scanner.eof()) {
  	                var ch = this.scanner.source[this.scanner.index++];
  	                if (ch === quote) {
  	                    break;
  	                }
  	                else if (ch === '&') {
  	                    str += this.scanXHTMLEntity(quote);
  	                }
  	                else {
  	                    str += ch;
  	                }
  	            }
  	            return {
  	                type: 8 /* StringLiteral */,
  	                value: str,
  	                lineNumber: this.scanner.lineNumber,
  	                lineStart: this.scanner.lineStart,
  	                start: start,
  	                end: this.scanner.index
  	            };
  	        }
  	        // ... or .
  	        if (cp === 46) {
  	            var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
  	            var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
  	            var value = (n1 === 46 && n2 === 46) ? '...' : '.';
  	            var start = this.scanner.index;
  	            this.scanner.index += value.length;
  	            return {
  	                type: 7 /* Punctuator */,
  	                value: value,
  	                lineNumber: this.scanner.lineNumber,
  	                lineStart: this.scanner.lineStart,
  	                start: start,
  	                end: this.scanner.index
  	            };
  	        }
  	        // `
  	        if (cp === 96) {
  	            // Only placeholder, since it will be rescanned as a real assignment expression.
  	            return {
  	                type: 10 /* Template */,
  	                value: '',
  	                lineNumber: this.scanner.lineNumber,
  	                lineStart: this.scanner.lineStart,
  	                start: this.scanner.index,
  	                end: this.scanner.index
  	            };
  	        }
  	        // Identifer can not contain backslash (char code 92).
  	        if (character_1.Character.isIdentifierStart(cp) && (cp !== 92)) {
  	            var start = this.scanner.index;
  	            ++this.scanner.index;
  	            while (!this.scanner.eof()) {
  	                var ch = this.scanner.source.charCodeAt(this.scanner.index);
  	                if (character_1.Character.isIdentifierPart(ch) && (ch !== 92)) {
  	                    ++this.scanner.index;
  	                }
  	                else if (ch === 45) {
  	                    // Hyphen (char code 45) can be part of an identifier.
  	                    ++this.scanner.index;
  	                }
  	                else {
  	                    break;
  	                }
  	            }
  	            var id = this.scanner.source.slice(start, this.scanner.index);
  	            return {
  	                type: 100 /* Identifier */,
  	                value: id,
  	                lineNumber: this.scanner.lineNumber,
  	                lineStart: this.scanner.lineStart,
  	                start: start,
  	                end: this.scanner.index
  	            };
  	        }
  	        return this.scanner.lex();
  	    };
  	    JSXParser.prototype.nextJSXToken = function () {
  	        this.collectComments();
  	        this.startMarker.index = this.scanner.index;
  	        this.startMarker.line = this.scanner.lineNumber;
  	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
  	        var token = this.lexJSX();
  	        this.lastMarker.index = this.scanner.index;
  	        this.lastMarker.line = this.scanner.lineNumber;
  	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
  	        if (this.config.tokens) {
  	            this.tokens.push(this.convertToken(token));
  	        }
  	        return token;
  	    };
  	    JSXParser.prototype.nextJSXText = function () {
  	        this.startMarker.index = this.scanner.index;
  	        this.startMarker.line = this.scanner.lineNumber;
  	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
  	        var start = this.scanner.index;
  	        var text = '';
  	        while (!this.scanner.eof()) {
  	            var ch = this.scanner.source[this.scanner.index];
  	            if (ch === '{' || ch === '<') {
  	                break;
  	            }
  	            ++this.scanner.index;
  	            text += ch;
  	            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
  	                ++this.scanner.lineNumber;
  	                if (ch === '\r' && this.scanner.source[this.scanner.index] === '\n') {
  	                    ++this.scanner.index;
  	                }
  	                this.scanner.lineStart = this.scanner.index;
  	            }
  	        }
  	        this.lastMarker.index = this.scanner.index;
  	        this.lastMarker.line = this.scanner.lineNumber;
  	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
  	        var token = {
  	            type: 101 /* Text */,
  	            value: text,
  	            lineNumber: this.scanner.lineNumber,
  	            lineStart: this.scanner.lineStart,
  	            start: start,
  	            end: this.scanner.index
  	        };
  	        if ((text.length > 0) && this.config.tokens) {
  	            this.tokens.push(this.convertToken(token));
  	        }
  	        return token;
  	    };
  	    JSXParser.prototype.peekJSXToken = function () {
  	        var state = this.scanner.saveState();
  	        this.scanner.scanComments();
  	        var next = this.lexJSX();
  	        this.scanner.restoreState(state);
  	        return next;
  	    };
  	    // Expect the next JSX token to match the specified punctuator.
  	    // If not, an exception will be thrown.
  	    JSXParser.prototype.expectJSX = function (value) {
  	        var token = this.nextJSXToken();
  	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
  	            this.throwUnexpectedToken(token);
  	        }
  	    };
  	    // Return true if the next JSX token matches the specified punctuator.
  	    JSXParser.prototype.matchJSX = function (value) {
  	        var next = this.peekJSXToken();
  	        return next.type === 7 /* Punctuator */ && next.value === value;
  	    };
  	    JSXParser.prototype.parseJSXIdentifier = function () {
  	        var node = this.createJSXNode();
  	        var token = this.nextJSXToken();
  	        if (token.type !== 100 /* Identifier */) {
  	            this.throwUnexpectedToken(token);
  	        }
  	        return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
  	    };
  	    JSXParser.prototype.parseJSXElementName = function () {
  	        var node = this.createJSXNode();
  	        var elementName = this.parseJSXIdentifier();
  	        if (this.matchJSX(':')) {
  	            var namespace = elementName;
  	            this.expectJSX(':');
  	            var name_1 = this.parseJSXIdentifier();
  	            elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
  	        }
  	        else if (this.matchJSX('.')) {
  	            while (this.matchJSX('.')) {
  	                var object = elementName;
  	                this.expectJSX('.');
  	                var property = this.parseJSXIdentifier();
  	                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
  	            }
  	        }
  	        return elementName;
  	    };
  	    JSXParser.prototype.parseJSXAttributeName = function () {
  	        var node = this.createJSXNode();
  	        var attributeName;
  	        var identifier = this.parseJSXIdentifier();
  	        if (this.matchJSX(':')) {
  	            var namespace = identifier;
  	            this.expectJSX(':');
  	            var name_2 = this.parseJSXIdentifier();
  	            attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
  	        }
  	        else {
  	            attributeName = identifier;
  	        }
  	        return attributeName;
  	    };
  	    JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
  	        var node = this.createJSXNode();
  	        var token = this.nextJSXToken();
  	        if (token.type !== 8 /* StringLiteral */) {
  	            this.throwUnexpectedToken(token);
  	        }
  	        var raw = this.getTokenRaw(token);
  	        return this.finalize(node, new Node.Literal(token.value, raw));
  	    };
  	    JSXParser.prototype.parseJSXExpressionAttribute = function () {
  	        var node = this.createJSXNode();
  	        this.expectJSX('{');
  	        this.finishJSX();
  	        if (this.match('}')) {
  	            this.tolerateError('JSX attributes must only be assigned a non-empty expression');
  	        }
  	        var expression = this.parseAssignmentExpression();
  	        this.reenterJSX();
  	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
  	    };
  	    JSXParser.prototype.parseJSXAttributeValue = function () {
  	        return this.matchJSX('{') ? this.parseJSXExpressionAttribute() :
  	            this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
  	    };
  	    JSXParser.prototype.parseJSXNameValueAttribute = function () {
  	        var node = this.createJSXNode();
  	        var name = this.parseJSXAttributeName();
  	        var value = null;
  	        if (this.matchJSX('=')) {
  	            this.expectJSX('=');
  	            value = this.parseJSXAttributeValue();
  	        }
  	        return this.finalize(node, new JSXNode.JSXAttribute(name, value));
  	    };
  	    JSXParser.prototype.parseJSXSpreadAttribute = function () {
  	        var node = this.createJSXNode();
  	        this.expectJSX('{');
  	        this.expectJSX('...');
  	        this.finishJSX();
  	        var argument = this.parseAssignmentExpression();
  	        this.reenterJSX();
  	        return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
  	    };
  	    JSXParser.prototype.parseJSXAttributes = function () {
  	        var attributes = [];
  	        while (!this.matchJSX('/') && !this.matchJSX('>')) {
  	            var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() :
  	                this.parseJSXNameValueAttribute();
  	            attributes.push(attribute);
  	        }
  	        return attributes;
  	    };
  	    JSXParser.prototype.parseJSXOpeningElement = function () {
  	        var node = this.createJSXNode();
  	        this.expectJSX('<');
  	        var name = this.parseJSXElementName();
  	        var attributes = this.parseJSXAttributes();
  	        var selfClosing = this.matchJSX('/');
  	        if (selfClosing) {
  	            this.expectJSX('/');
  	        }
  	        this.expectJSX('>');
  	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
  	    };
  	    JSXParser.prototype.parseJSXBoundaryElement = function () {
  	        var node = this.createJSXNode();
  	        this.expectJSX('<');
  	        if (this.matchJSX('/')) {
  	            this.expectJSX('/');
  	            var name_3 = this.parseJSXElementName();
  	            this.expectJSX('>');
  	            return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
  	        }
  	        var name = this.parseJSXElementName();
  	        var attributes = this.parseJSXAttributes();
  	        var selfClosing = this.matchJSX('/');
  	        if (selfClosing) {
  	            this.expectJSX('/');
  	        }
  	        this.expectJSX('>');
  	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
  	    };
  	    JSXParser.prototype.parseJSXEmptyExpression = function () {
  	        var node = this.createJSXChildNode();
  	        this.collectComments();
  	        this.lastMarker.index = this.scanner.index;
  	        this.lastMarker.line = this.scanner.lineNumber;
  	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
  	        return this.finalize(node, new JSXNode.JSXEmptyExpression());
  	    };
  	    JSXParser.prototype.parseJSXExpressionContainer = function () {
  	        var node = this.createJSXNode();
  	        this.expectJSX('{');
  	        var expression;
  	        if (this.matchJSX('}')) {
  	            expression = this.parseJSXEmptyExpression();
  	            this.expectJSX('}');
  	        }
  	        else {
  	            this.finishJSX();
  	            expression = this.parseAssignmentExpression();
  	            this.reenterJSX();
  	        }
  	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
  	    };
  	    JSXParser.prototype.parseJSXChildren = function () {
  	        var children = [];
  	        while (!this.scanner.eof()) {
  	            var node = this.createJSXChildNode();
  	            var token = this.nextJSXText();
  	            if (token.start < token.end) {
  	                var raw = this.getTokenRaw(token);
  	                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
  	                children.push(child);
  	            }
  	            if (this.scanner.source[this.scanner.index] === '{') {
  	                var container = this.parseJSXExpressionContainer();
  	                children.push(container);
  	            }
  	            else {
  	                break;
  	            }
  	        }
  	        return children;
  	    };
  	    JSXParser.prototype.parseComplexJSXElement = function (el) {
  	        var stack = [];
  	        while (!this.scanner.eof()) {
  	            el.children = el.children.concat(this.parseJSXChildren());
  	            var node = this.createJSXChildNode();
  	            var element = this.parseJSXBoundaryElement();
  	            if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
  	                var opening = element;
  	                if (opening.selfClosing) {
  	                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
  	                    el.children.push(child);
  	                }
  	                else {
  	                    stack.push(el);
  	                    el = { node: node, opening: opening, closing: null, children: [] };
  	                }
  	            }
  	            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
  	                el.closing = element;
  	                var open_1 = getQualifiedElementName(el.opening.name);
  	                var close_1 = getQualifiedElementName(el.closing.name);
  	                if (open_1 !== close_1) {
  	                    this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
  	                }
  	                if (stack.length > 0) {
  	                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
  	                    el = stack[stack.length - 1];
  	                    el.children.push(child);
  	                    stack.pop();
  	                }
  	                else {
  	                    break;
  	                }
  	            }
  	        }
  	        return el;
  	    };
  	    JSXParser.prototype.parseJSXElement = function () {
  	        var node = this.createJSXNode();
  	        var opening = this.parseJSXOpeningElement();
  	        var children = [];
  	        var closing = null;
  	        if (!opening.selfClosing) {
  	            var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
  	            children = el.children;
  	            closing = el.closing;
  	        }
  	        return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
  	    };
  	    JSXParser.prototype.parseJSXRoot = function () {
  	        // Pop the opening '<' added from the lookahead.
  	        if (this.config.tokens) {
  	            this.tokens.pop();
  	        }
  	        this.startJSX();
  	        var element = this.parseJSXElement();
  	        this.finishJSX();
  	        return element;
  	    };
  	    JSXParser.prototype.isStartOfExpression = function () {
  	        return _super.prototype.isStartOfExpression.call(this) || this.match('<');
  	    };
  	    return JSXParser;
  	}(parser_1.Parser));
  	exports.JSXParser = JSXParser;


  /***/ },
  /* 4 */
  /***/ function(module, exports) {

  	"use strict";
  	Object.defineProperty(exports, "__esModule", { value: true });
  	// See also tools/generate-unicode-regex.js.
  	var Regex = {
  	    // Unicode v8.0.0 NonAsciiIdentifierStart:
  	    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
  	    // Unicode v8.0.0 NonAsciiIdentifierPart:
  	    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
  	};
  	exports.Character = {
  	    /* tslint:disable:no-bitwise */
  	    fromCodePoint: function (cp) {
  	        return (cp < 0x10000) ? String.fromCharCode(cp) :
  	            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
  	                String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
  	    },
  	    // https://tc39.github.io/ecma262/#sec-white-space
  	    isWhiteSpace: function (cp) {
  	        return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||
  	            (cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);
  	    },
  	    // https://tc39.github.io/ecma262/#sec-line-terminators
  	    isLineTerminator: function (cp) {
  	        return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);
  	    },
  	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
  	    isIdentifierStart: function (cp) {
  	        return (cp === 0x24) || (cp === 0x5F) ||
  	            (cp >= 0x41 && cp <= 0x5A) ||
  	            (cp >= 0x61 && cp <= 0x7A) ||
  	            (cp === 0x5C) ||
  	            ((cp >= 0x80) && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp)));
  	    },
  	    isIdentifierPart: function (cp) {
  	        return (cp === 0x24) || (cp === 0x5F) ||
  	            (cp >= 0x41 && cp <= 0x5A) ||
  	            (cp >= 0x61 && cp <= 0x7A) ||
  	            (cp >= 0x30 && cp <= 0x39) ||
  	            (cp === 0x5C) ||
  	            ((cp >= 0x80) && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp)));
  	    },
  	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
  	    isDecimalDigit: function (cp) {
  	        return (cp >= 0x30 && cp <= 0x39); // 0..9
  	    },
  	    isHexDigit: function (cp) {
  	        return (cp >= 0x30 && cp <= 0x39) ||
  	            (cp >= 0x41 && cp <= 0x46) ||
  	            (cp >= 0x61 && cp <= 0x66); // a..f
  	    },
  	    isOctalDigit: function (cp) {
  	        return (cp >= 0x30 && cp <= 0x37); // 0..7
  	    }
  	};


  /***/ },
  /* 5 */
  /***/ function(module, exports, __webpack_require__) {

  	"use strict";
  	Object.defineProperty(exports, "__esModule", { value: true });
  	var jsx_syntax_1 = __webpack_require__(6);
  	/* tslint:disable:max-classes-per-file */
  	var JSXClosingElement = (function () {
  	    function JSXClosingElement(name) {
  	        this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
  	        this.name = name;
  	    }
  	    return JSXClosingElement;
  	}());
  	exports.JSXClosingElement = JSXClosingElement;
  	var JSXElement = (function () {
  	    function JSXElement(openingElement, children, closingElement) {
  	        this.type = jsx_syntax_1.JSXSyntax.JSXElement;
  	        this.openingElement = openingElement;
  	        this.children = children;
  	        this.closingElement = closingElement;
  	    }
  	    return JSXElement;
  	}());
  	exports.JSXElement = JSXElement;
  	var JSXEmptyExpression = (function () {
  	    function JSXEmptyExpression() {
  	        this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
  	    }
  	    return JSXEmptyExpression;
  	}());
  	exports.JSXEmptyExpression = JSXEmptyExpression;
  	var JSXExpressionContainer = (function () {
  	    function JSXExpressionContainer(expression) {
  	        this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
  	        this.expression = expression;
  	    }
  	    return JSXExpressionContainer;
  	}());
  	exports.JSXExpressionContainer = JSXExpressionContainer;
  	var JSXIdentifier = (function () {
  	    function JSXIdentifier(name) {
  	        this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
  	        this.name = name;
  	    }
  	    return JSXIdentifier;
  	}());
  	exports.JSXIdentifier = JSXIdentifier;
  	var JSXMemberExpression = (function () {
  	    function JSXMemberExpression(object, property) {
  	        this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
  	        this.object = object;
  	        this.property = property;
  	    }
  	    return JSXMemberExpression;
  	}());
  	exports.JSXMemberExpression = JSXMemberExpression;
  	var JSXAttribute = (function () {
  	    function JSXAttribute(name, value) {
  	        this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
  	        this.name = name;
  	        this.value = value;
  	    }
  	    return JSXAttribute;
  	}());
  	exports.JSXAttribute = JSXAttribute;
  	var JSXNamespacedName = (function () {
  	    function JSXNamespacedName(namespace, name) {
  	        this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
  	        this.namespace = namespace;
  	        this.name = name;
  	    }
  	    return JSXNamespacedName;
  	}());
  	exports.JSXNamespacedName = JSXNamespacedName;
  	var JSXOpeningElement = (function () {
  	    function JSXOpeningElement(name, selfClosing, attributes) {
  	        this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
  	        this.name = name;
  	        this.selfClosing = selfClosing;
  	        this.attributes = attributes;
  	    }
  	    return JSXOpeningElement;
  	}());
  	exports.JSXOpeningElement = JSXOpeningElement;
  	var JSXSpreadAttribute = (function () {
  	    function JSXSpreadAttribute(argument) {
  	        this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
  	        this.argument = argument;
  	    }
  	    return JSXSpreadAttribute;
  	}());
  	exports.JSXSpreadAttribute = JSXSpreadAttribute;
  	var JSXText = (function () {
  	    function JSXText(value, raw) {
  	        this.type = jsx_syntax_1.JSXSyntax.JSXText;
  	        this.value = value;
  	        this.raw = raw;
  	    }
  	    return JSXText;
  	}());
  	exports.JSXText = JSXText;


  /***/ },
  /* 6 */
  /***/ function(module, exports) {

  	"use strict";
  	Object.defineProperty(exports, "__esModule", { value: true });
  	exports.JSXSyntax = {
  	    JSXAttribute: 'JSXAttribute',
  	    JSXClosingElement: 'JSXClosingElement',
  	    JSXElement: 'JSXElement',
  	    JSXEmptyExpression: 'JSXEmptyExpression',
  	    JSXExpressionContainer: 'JSXExpressionContainer',
  	    JSXIdentifier: 'JSXIdentifier',
  	    JSXMemberExpression: 'JSXMemberExpression',
  	    JSXNamespacedName: 'JSXNamespacedName',
  	    JSXOpeningElement: 'JSXOpeningElement',
  	    JSXSpreadAttribute: 'JSXSpreadAttribute',
  	    JSXText: 'JSXText'
  	};


  /***/ },
  /* 7 */
  /***/ function(module, exports, __webpack_require__) {

  	"use strict";
  	Object.defineProperty(exports, "__esModule", { value: true });
  	var syntax_1 = __webpack_require__(2);
  	/* tslint:disable:max-classes-per-file */
  	var ArrayExpression = (function () {
  	    function ArrayExpression(elements) {
  	        this.type = syntax_1.Syntax.ArrayExpression;
  	        this.elements = elements;
  	    }
  	    return ArrayExpression;
  	}());
  	exports.ArrayExpression = ArrayExpression;
  	var ArrayPattern = (function () {
  	    function ArrayPattern(elements) {
  	        this.type = syntax_1.Syntax.ArrayPattern;
  	        this.elements = elements;
  	    }
  	    return ArrayPattern;
  	}());
  	exports.ArrayPattern = ArrayPattern;
  	var ArrowFunctionExpression = (function () {
  	    function ArrowFunctionExpression(params, body, expression) {
  	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
  	        this.id = null;
  	        this.params = params;
  	        this.body = body;
  	        this.generator = false;
  	        this.expression = expression;
  	        this.async = false;
  	    }
  	    return ArrowFunctionExpression;
  	}());
  	exports.ArrowFunctionExpression = ArrowFunctionExpression;
  	var AssignmentExpression = (function () {
  	    function AssignmentExpression(operator, left, right) {
  	        this.type = syntax_1.Syntax.AssignmentExpression;
  	        this.operator = operator;
  	        this.left = left;
  	        this.right = right;
  	    }
  	    return AssignmentExpression;
  	}());
  	exports.AssignmentExpression = AssignmentExpression;
  	var AssignmentPattern = (function () {
  	    function AssignmentPattern(left, right) {
  	        this.type = syntax_1.Syntax.AssignmentPattern;
  	        this.left = left;
  	        this.right = right;
  	    }
  	    return AssignmentPattern;
  	}());
  	exports.AssignmentPattern = AssignmentPattern;
  	var AsyncArrowFunctionExpression = (function () {
  	    function AsyncArrowFunctionExpression(params, body, expression) {
  	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
  	        this.id = null;
  	        this.params = params;
  	        this.body = body;
  	        this.generator = false;
  	        this.expression = expression;
  	        this.async = true;
  	    }
  	    return AsyncArrowFunctionExpression;
  	}());
  	exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
  	var AsyncFunctionDeclaration = (function () {
  	    function AsyncFunctionDeclaration(id, params, body) {
  	        this.type = syntax_1.Syntax.FunctionDeclaration;
  	        this.id = id;
  	        this.params = params;
  	        this.body = body;
  	        this.generator = false;
  	        this.expression = false;
  	        this.async = true;
  	    }
  	    return AsyncFunctionDeclaration;
  	}());
  	exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
  	var AsyncFunctionExpression = (function () {
  	    function AsyncFunctionExpression(id, params, body) {
  	        this.type = syntax_1.Syntax.FunctionExpression;
  	        this.id = id;
  	        this.params = params;
  	        this.body = body;
  	        this.generator = false;
  	        this.expression = false;
  	        this.async = true;
  	    }
  	    return AsyncFunctionExpression;
  	}());
  	exports.AsyncFunctionExpression = AsyncFunctionExpression;
  	var AwaitExpression = (function () {
  	    function AwaitExpression(argument) {
  	        this.type = syntax_1.Syntax.AwaitExpression;
  	        this.argument = argument;
  	    }
  	    return AwaitExpression;
  	}());
  	exports.AwaitExpression = AwaitExpression;
  	var BinaryExpression = (function () {
  	    function BinaryExpression(operator, left, right) {
  	        var logical = (operator === '||' || operator === '&&');
  	        this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
  	        this.operator = operator;
  	        this.left = left;
  	        this.right = right;
  	    }
  	    return BinaryExpression;
  	}());
  	exports.BinaryExpression = BinaryExpression;
  	var BlockStatement = (function () {
  	    function BlockStatement(body) {
  	        this.type = syntax_1.Syntax.BlockStatement;
  	        this.body = body;
  	    }
  	    return BlockStatement;
  	}());
  	exports.BlockStatement = BlockStatement;
  	var BreakStatement = (function () {
  	    function BreakStatement(label) {
  	        this.type = syntax_1.Syntax.BreakStatement;
  	        this.label = label;
  	    }
  	    return BreakStatement;
  	}());
  	exports.BreakStatement = BreakStatement;
  	var CallExpression = (function () {
  	    function CallExpression(callee, args) {
  	        this.type = syntax_1.Syntax.CallExpression;
  	        this.callee = callee;
  	        this.arguments = args;
  	    }
  	    return CallExpression;
  	}());
  	exports.CallExpression = CallExpression;
  	var CatchClause = (function () {
  	    function CatchClause(param, body) {
  	        this.type = syntax_1.Syntax.CatchClause;
  	        this.param = param;
  	        this.body = body;
  	    }
  	    return CatchClause;
  	}());
  	exports.CatchClause = CatchClause;
  	var ClassBody = (function () {
  	    function ClassBody(body) {
  	        this.type = syntax_1.Syntax.ClassBody;
  	        this.body = body;
  	    }
  	    return ClassBody;
  	}());
  	exports.ClassBody = ClassBody;
  	var ClassDeclaration = (function () {
  	    function ClassDeclaration(id, superClass, body) {
  	        this.type = syntax_1.Syntax.ClassDeclaration;
  	        this.id = id;
  	        this.superClass = superClass;
  	        this.body = body;
  	    }
  	    return ClassDeclaration;
  	}());
  	exports.ClassDeclaration = ClassDeclaration;
  	var ClassExpression = (function () {
  	    function ClassExpression(id, superClass, body) {
  	        this.type = syntax_1.Syntax.ClassExpression;
  	        this.id = id;
  	        this.superClass = superClass;
  	        this.body = body;
  	    }
  	    return ClassExpression;
  	}());
  	exports.ClassExpression = ClassExpression;
  	var ComputedMemberExpression = (function () {
  	    function ComputedMemberExpression(object, property) {
  	        this.type = syntax_1.Syntax.MemberExpression;
  	        this.computed = true;
  	        this.object = object;
  	        this.property = property;
  	    }
  	    return ComputedMemberExpression;
  	}());
  	exports.ComputedMemberExpression = ComputedMemberExpression;
  	var ConditionalExpression = (function () {
  	    function ConditionalExpression(test, consequent, alternate) {
  	        this.type = syntax_1.Syntax.ConditionalExpression;
  	        this.test = test;
  	        this.consequent = consequent;
  	        this.alternate = alternate;
  	    }
  	    return ConditionalExpression;
  	}());
  	exports.ConditionalExpression = ConditionalExpression;
  	var ContinueStatement = (function () {
  	    function ContinueStatement(label) {
  	        this.type = syntax_1.Syntax.ContinueStatement;
  	        this.label = label;
  	    }
  	    return ContinueStatement;
  	}());
  	exports.ContinueStatement = ContinueStatement;
  	var DebuggerStatement = (function () {
  	    function DebuggerStatement() {
  	        this.type = syntax_1.Syntax.DebuggerStatement;
  	    }
  	    return DebuggerStatement;
  	}());
  	exports.DebuggerStatement = DebuggerStatement;
  	var Directive = (function () {
  	    function Directive(expression, directive) {
  	        this.type = syntax_1.Syntax.ExpressionStatement;
  	        this.expression = expression;
  	        this.directive = directive;
  	    }
  	    return Directive;
  	}());
  	exports.Directive = Directive;
  	var DoWhileStatement = (function () {
  	    function DoWhileStatement(body, test) {
  	        this.type = syntax_1.Syntax.DoWhileStatement;
  	        this.body = body;
  	        this.test = test;
  	    }
  	    return DoWhileStatement;
  	}());
  	exports.DoWhileStatement = DoWhileStatement;
  	var EmptyStatement = (function () {
  	    function EmptyStatement() {
  	        this.type = syntax_1.Syntax.EmptyStatement;
  	    }
  	    return EmptyStatement;
  	}());
  	exports.EmptyStatement = EmptyStatement;
  	var ExportAllDeclaration = (function () {
  	    function ExportAllDeclaration(source) {
  	        this.type = syntax_1.Syntax.ExportAllDeclaration;
  	        this.source = source;
  	    }
  	    return ExportAllDeclaration;
  	}());
  	exports.ExportAllDeclaration = ExportAllDeclaration;
  	var ExportDefaultDeclaration = (function () {
  	    function ExportDefaultDeclaration(declaration) {
  	        this.type = syntax_1.Syntax.ExportDefaultDeclaration;
  	        this.declaration = declaration;
  	    }
  	    return ExportDefaultDeclaration;
  	}());
  	exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
  	var ExportNamedDeclaration = (function () {
  	    function ExportNamedDeclaration(declaration, specifiers, source) {
  	        this.type = syntax_1.Syntax.ExportNamedDeclaration;
  	        this.declaration = declaration;
  	        this.specifiers = specifiers;
  	        this.source = source;
  	    }
  	    return ExportNamedDeclaration;
  	}());
  	exports.ExportNamedDeclaration = ExportNamedDeclaration;
  	var ExportSpecifier = (function () {
  	    function ExportSpecifier(local, exported) {
  	        this.type = syntax_1.Syntax.ExportSpecifier;
  	        this.exported = exported;
  	        this.local = local;
  	    }
  	    return ExportSpecifier;
  	}());
  	exports.ExportSpecifier = ExportSpecifier;
  	var ExpressionStatement = (function () {
  	    function ExpressionStatement(expression) {
  	        this.type = syntax_1.Syntax.ExpressionStatement;
  	        this.expression = expression;
  	    }
  	    return ExpressionStatement;
  	}());
  	exports.ExpressionStatement = ExpressionStatement;
  	var ForInStatement = (function () {
  	    function ForInStatement(left, right, body) {
  	        this.type = syntax_1.Syntax.ForInStatement;
  	        this.left = left;
  	        this.right = right;
  	        this.body = body;
  	        this.each = false;
  	    }
  	    return ForInStatement;
  	}());
  	exports.ForInStatement = ForInStatement;
  	var ForOfStatement = (function () {
  	    function ForOfStatement(left, right, body) {
  	        this.type = syntax_1.Syntax.ForOfStatement;
  	        this.left = left;
  	        this.right = right;
  	        this.body = body;
  	    }
  	    return ForOfStatement;
  	}());
  	exports.ForOfStatement = ForOfStatement;
  	var ForStatement = (function () {
  	    function ForStatement(init, test, update, body) {
  	        this.type = syntax_1.Syntax.ForStatement;
  	        this.init = init;
  	        this.test = test;
  	        this.update = update;
  	        this.body = body;
  	    }
  	    return ForStatement;
  	}());
  	exports.ForStatement = ForStatement;
  	var FunctionDeclaration = (function () {
  	    function FunctionDeclaration(id, params, body, generator) {
  	        this.type = syntax_1.Syntax.FunctionDeclaration;
  	        this.id = id;
  	        this.params = params;
  	        this.body = body;
  	        this.generator = generator;
  	        this.expression = false;
  	        this.async = false;
  	    }
  	    return FunctionDeclaration;
  	}());
  	exports.FunctionDeclaration = FunctionDeclaration;
  	var FunctionExpression = (function () {
  	    function FunctionExpression(id, params, body, generator) {
  	        this.type = syntax_1.Syntax.FunctionExpression;
  	        this.id = id;
  	        this.params = params;
  	        this.body = body;
  	        this.generator = generator;
  	        this.expression = false;
  	        this.async = false;
  	    }
  	    return FunctionExpression;
  	}());
  	exports.FunctionExpression = FunctionExpression;
  	var Identifier = (function () {
  	    function Identifier(name) {
  	        this.type = syntax_1.Syntax.Identifier;
  	        this.name = name;
  	    }
  	    return Identifier;
  	}());
  	exports.Identifier = Identifier;
  	var IfStatement = (function () {
  	    function IfStatement(test, consequent, alternate) {
  	        this.type = syntax_1.Syntax.IfStatement;
  	        this.test = test;
  	        this.consequent = consequent;
  	        this.alternate = alternate;
  	    }
  	    return IfStatement;
  	}());
  	exports.IfStatement = IfStatement;
  	var ImportDeclaration = (function () {
  	    function ImportDeclaration(specifiers, source) {
  	        this.type = syntax_1.Syntax.ImportDeclaration;
  	        this.specifiers = specifiers;
  	        this.source = source;
  	    }
  	    return ImportDeclaration;
  	}());
  	exports.ImportDeclaration = ImportDeclaration;
  	var ImportDefaultSpecifier = (function () {
  	    function ImportDefaultSpecifier(local) {
  	        this.type = syntax_1.Syntax.ImportDefaultSpecifier;
  	        this.local = local;
  	    }
  	    return ImportDefaultSpecifier;
  	}());
  	exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
  	var ImportNamespaceSpecifier = (function () {
  	    function ImportNamespaceSpecifier(local) {
  	        this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
  	        this.local = local;
  	    }
  	    return ImportNamespaceSpecifier;
  	}());
  	exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
  	var ImportSpecifier = (function () {
  	    function ImportSpecifier(local, imported) {
  	        this.type = syntax_1.Syntax.ImportSpecifier;
  	        this.local = local;
  	        this.imported = imported;
  	    }
  	    return ImportSpecifier;
  	}());
  	exports.ImportSpecifier = ImportSpecifier;
  	var LabeledStatement = (function () {
  	    function LabeledStatement(label, body) {
  	        this.type = syntax_1.Syntax.LabeledStatement;
  	        this.label = label;
  	        this.body = body;
  	    }
  	    return LabeledStatement;
  	}());
  	exports.LabeledStatement = LabeledStatement;
  	var Literal = (function () {
  	    function Literal(value, raw) {
  	        this.type = syntax_1.Syntax.Literal;
  	        this.value = value;
  	        this.raw = raw;
  	    }
  	    return Literal;
  	}());
  	exports.Literal = Literal;
  	var MetaProperty = (function () {
  	    function MetaProperty(meta, property) {
  	        this.type = syntax_1.Syntax.MetaProperty;
  	        this.meta = meta;
  	        this.property = property;
  	    }
  	    return MetaProperty;
  	}());
  	exports.MetaProperty = MetaProperty;
  	var MethodDefinition = (function () {
  	    function MethodDefinition(key, computed, value, kind, isStatic) {
  	        this.type = syntax_1.Syntax.MethodDefinition;
  	        this.key = key;
  	        this.computed = computed;
  	        this.value = value;
  	        this.kind = kind;
  	        this.static = isStatic;
  	    }
  	    return MethodDefinition;
  	}());
  	exports.MethodDefinition = MethodDefinition;
  	var Module = (function () {
  	    function Module(body) {
  	        this.type = syntax_1.Syntax.Program;
  	        this.body = body;
  	        this.sourceType = 'module';
  	    }
  	    return Module;
  	}());
  	exports.Module = Module;
  	var NewExpression = (function () {
  	    function NewExpression(callee, args) {
  	        this.type = syntax_1.Syntax.NewExpression;
  	        this.callee = callee;
  	        this.arguments = args;
  	    }
  	    return NewExpression;
  	}());
  	exports.NewExpression = NewExpression;
  	var ObjectExpression = (function () {
  	    function ObjectExpression(properties) {
  	        this.type = syntax_1.Syntax.ObjectExpression;
  	        this.properties = properties;
  	    }
  	    return ObjectExpression;
  	}());
  	exports.ObjectExpression = ObjectExpression;
  	var ObjectPattern = (function () {
  	    function ObjectPattern(properties) {
  	        this.type = syntax_1.Syntax.ObjectPattern;
  	        this.properties = properties;
  	    }
  	    return ObjectPattern;
  	}());
  	exports.ObjectPattern = ObjectPattern;
  	var Property = (function () {
  	    function Property(kind, key, computed, value, method, shorthand) {
  	        this.type = syntax_1.Syntax.Property;
  	        this.key = key;
  	        this.computed = computed;
  	        this.value = value;
  	        this.kind = kind;
  	        this.method = method;
  	        this.shorthand = shorthand;
  	    }
  	    return Property;
  	}());
  	exports.Property = Property;
  	var RegexLiteral = (function () {
  	    function RegexLiteral(value, raw, pattern, flags) {
  	        this.type = syntax_1.Syntax.Literal;
  	        this.value = value;
  	        this.raw = raw;
  	        this.regex = { pattern: pattern, flags: flags };
  	    }
  	    return RegexLiteral;
  	}());
  	exports.RegexLiteral = RegexLiteral;
  	var RestElement = (function () {
  	    function RestElement(argument) {
  	        this.type = syntax_1.Syntax.RestElement;
  	        this.argument = argument;
  	    }
  	    return RestElement;
  	}());
  	exports.RestElement = RestElement;
  	var ReturnStatement = (function () {
  	    function ReturnStatement(argument) {
  	        this.type = syntax_1.Syntax.ReturnStatement;
  	        this.argument = argument;
  	    }
  	    return ReturnStatement;
  	}());
  	exports.ReturnStatement = ReturnStatement;
  	var Script = (function () {
  	    function Script(body) {
  	        this.type = syntax_1.Syntax.Program;
  	        this.body = body;
  	        this.sourceType = 'script';
  	    }
  	    return Script;
  	}());
  	exports.Script = Script;
  	var SequenceExpression = (function () {
  	    function SequenceExpression(expressions) {
  	        this.type = syntax_1.Syntax.SequenceExpression;
  	        this.expressions = expressions;
  	    }
  	    return SequenceExpression;
  	}());
  	exports.SequenceExpression = SequenceExpression;
  	var SpreadElement = (function () {
  	    function SpreadElement(argument) {
  	        this.type = syntax_1.Syntax.SpreadElement;
  	        this.argument = argument;
  	    }
  	    return SpreadElement;
  	}());
  	exports.SpreadElement = SpreadElement;
  	var StaticMemberExpression = (function () {
  	    function StaticMemberExpression(object, property) {
  	        this.type = syntax_1.Syntax.MemberExpression;
  	        this.computed = false;
  	        this.object = object;
  	        this.property = property;
  	    }
  	    return StaticMemberExpression;
  	}());
  	exports.StaticMemberExpression = StaticMemberExpression;
  	var Super = (function () {
  	    function Super() {
  	        this.type = syntax_1.Syntax.Super;
  	    }
  	    return Super;
  	}());
  	exports.Super = Super;
  	var SwitchCase = (function () {
  	    function SwitchCase(test, consequent) {
  	        this.type = syntax_1.Syntax.SwitchCase;
  	        this.test = test;
  	        this.consequent = consequent;
  	    }
  	    return SwitchCase;
  	}());
  	exports.SwitchCase = SwitchCase;
  	var SwitchStatement = (function () {
  	    function SwitchStatement(discriminant, cases) {
  	        this.type = syntax_1.Syntax.SwitchStatement;
  	        this.discriminant = discriminant;
  	        this.cases = cases;
  	    }
  	    return SwitchStatement;
  	}());
  	exports.SwitchStatement = SwitchStatement;
  	var TaggedTemplateExpression = (function () {
  	    function TaggedTemplateExpression(tag, quasi) {
  	        this.type = syntax_1.Syntax.TaggedTemplateExpression;
  	        this.tag = tag;
  	        this.quasi = quasi;
  	    }
  	    return TaggedTemplateExpression;
  	}());
  	exports.TaggedTemplateExpression = TaggedTemplateExpression;
  	var TemplateElement = (function () {
  	    function TemplateElement(value, tail) {
  	        this.type = syntax_1.Syntax.TemplateElement;
  	        this.value = value;
  	        this.tail = tail;
  	    }
  	    return TemplateElement;
  	}());
  	exports.TemplateElement = TemplateElement;
  	var TemplateLiteral = (function () {
  	    function TemplateLiteral(quasis, expressions) {
  	        this.type = syntax_1.Syntax.TemplateLiteral;
  	        this.quasis = quasis;
  	        this.expressions = expressions;
  	    }
  	    return TemplateLiteral;
  	}());
  	exports.TemplateLiteral = TemplateLiteral;
  	var ThisExpression = (function () {
  	    function ThisExpression() {
  	        this.type = syntax_1.Syntax.ThisExpression;
  	    }
  	    return ThisExpression;
  	}());
  	exports.ThisExpression = ThisExpression;
  	var ThrowStatement = (function () {
  	    function ThrowStatement(argument) {
  	        this.type = syntax_1.Syntax.ThrowStatement;
  	        this.argument = argument;
  	    }
  	    return ThrowStatement;
  	}());
  	exports.ThrowStatement = ThrowStatement;
  	var TryStatement = (function () {
  	    function TryStatement(block, handler, finalizer) {
  	        this.type = syntax_1.Syntax.TryStatement;
  	        this.block = block;
  	        this.handler = handler;
  	        this.finalizer = finalizer;
  	    }
  	    return TryStatement;
  	}());
  	exports.TryStatement = TryStatement;
  	var UnaryExpression = (function () {
  	    function UnaryExpression(operator, argument) {
  	        this.type = syntax_1.Syntax.UnaryExpression;
  	        this.operator = operator;
  	        this.argument = argument;
  	        this.prefix = true;
  	    }
  	    return UnaryExpression;
  	}());
  	exports.UnaryExpression = UnaryExpression;
  	var UpdateExpression = (function () {
  	    function UpdateExpression(operator, argument, prefix) {
  	        this.type = syntax_1.Syntax.UpdateExpression;
  	        this.operator = operator;
  	        this.argument = argument;
  	        this.prefix = prefix;
  	    }
  	    return UpdateExpression;
  	}());
  	exports.UpdateExpression = UpdateExpression;
  	var VariableDeclaration = (function () {
  	    function VariableDeclaration(declarations, kind) {
  	        this.type = syntax_1.Syntax.VariableDeclaration;
  	        this.declarations = declarations;
  	        this.kind = kind;
  	    }
  	    return VariableDeclaration;
  	}());
  	exports.VariableDeclaration = VariableDeclaration;
  	var VariableDeclarator = (function () {
  	    function VariableDeclarator(id, init) {
  	        this.type = syntax_1.Syntax.VariableDeclarator;
  	        this.id = id;
  	        this.init = init;
  	    }
  	    return VariableDeclarator;
  	}());
  	exports.VariableDeclarator = VariableDeclarator;
  	var WhileStatement = (function () {
  	    function WhileStatement(test, body) {
  	        this.type = syntax_1.Syntax.WhileStatement;
  	        this.test = test;
  	        this.body = body;
  	    }
  	    return WhileStatement;
  	}());
  	exports.WhileStatement = WhileStatement;
  	var WithStatement = (function () {
  	    function WithStatement(object, body) {
  	        this.type = syntax_1.Syntax.WithStatement;
  	        this.object = object;
  	        this.body = body;
  	    }
  	    return WithStatement;
  	}());
  	exports.WithStatement = WithStatement;
  	var YieldExpression = (function () {
  	    function YieldExpression(argument, delegate) {
  	        this.type = syntax_1.Syntax.YieldExpression;
  	        this.argument = argument;
  	        this.delegate = delegate;
  	    }
  	    return YieldExpression;
  	}());
  	exports.YieldExpression = YieldExpression;


  /***/ },
  /* 8 */
  /***/ function(module, exports, __webpack_require__) {

  	"use strict";
  	Object.defineProperty(exports, "__esModule", { value: true });
  	var assert_1 = __webpack_require__(9);
  	var error_handler_1 = __webpack_require__(10);
  	var messages_1 = __webpack_require__(11);
  	var Node = __webpack_require__(7);
  	var scanner_1 = __webpack_require__(12);
  	var syntax_1 = __webpack_require__(2);
  	var token_1 = __webpack_require__(13);
  	var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
  	var Parser = (function () {
  	    function Parser(code, options, delegate) {
  	        if (options === void 0) { options = {}; }
  	        this.config = {
  	            range: (typeof options.range === 'boolean') && options.range,
  	            loc: (typeof options.loc === 'boolean') && options.loc,
  	            source: null,
  	            tokens: (typeof options.tokens === 'boolean') && options.tokens,
  	            comment: (typeof options.comment === 'boolean') && options.comment,
  	            tolerant: (typeof options.tolerant === 'boolean') && options.tolerant
  	        };
  	        if (this.config.loc && options.source && options.source !== null) {
  	            this.config.source = String(options.source);
  	        }
  	        this.delegate = delegate;
  	        this.errorHandler = new error_handler_1.ErrorHandler();
  	        this.errorHandler.tolerant = this.config.tolerant;
  	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
  	        this.scanner.trackComment = this.config.comment;
  	        this.operatorPrecedence = {
  	            ')': 0,
  	            ';': 0,
  	            ',': 0,
  	            '=': 0,
  	            ']': 0,
  	            '||': 1,
  	            '&&': 2,
  	            '|': 3,
  	            '^': 4,
  	            '&': 5,
  	            '==': 6,
  	            '!=': 6,
  	            '===': 6,
  	            '!==': 6,
  	            '<': 7,
  	            '>': 7,
  	            '<=': 7,
  	            '>=': 7,
  	            '<<': 8,
  	            '>>': 8,
  	            '>>>': 8,
  	            '+': 9,
  	            '-': 9,
  	            '*': 11,
  	            '/': 11,
  	            '%': 11
  	        };
  	        this.lookahead = {
  	            type: 2 /* EOF */,
  	            value: '',
  	            lineNumber: this.scanner.lineNumber,
  	            lineStart: 0,
  	            start: 0,
  	            end: 0
  	        };
  	        this.hasLineTerminator = false;
  	        this.context = {
  	            isModule: false,
  	            await: false,
  	            allowIn: true,
  	            allowStrictDirective: true,
  	            allowYield: true,
  	            firstCoverInitializedNameError: null,
  	            isAssignmentTarget: false,
  	            isBindingElement: false,
  	            inFunctionBody: false,
  	            inIteration: false,
  	            inSwitch: false,
  	            labelSet: {},
  	            strict: false
  	        };
  	        this.tokens = [];
  	        this.startMarker = {
  	            index: 0,
  	            line: this.scanner.lineNumber,
  	            column: 0
  	        };
  	        this.lastMarker = {
  	            index: 0,
  	            line: this.scanner.lineNumber,
  	            column: 0
  	        };
  	        this.nextToken();
  	        this.lastMarker = {
  	            index: this.scanner.index,
  	            line: this.scanner.lineNumber,
  	            column: this.scanner.index - this.scanner.lineStart
  	        };
  	    }
  	    Parser.prototype.throwError = function (messageFormat) {
  	        var values = [];
  	        for (var _i = 1; _i < arguments.length; _i++) {
  	            values[_i - 1] = arguments[_i];
  	        }
  	        var args = Array.prototype.slice.call(arguments, 1);
  	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
  	            assert_1.assert(idx < args.length, 'Message reference must be in range');
  	            return args[idx];
  	        });
  	        var index = this.lastMarker.index;
  	        var line = this.lastMarker.line;
  	        var column = this.lastMarker.column + 1;
  	        throw this.errorHandler.createError(index, line, column, msg);
  	    };
  	    Parser.prototype.tolerateError = function (messageFormat) {
  	        var values = [];
  	        for (var _i = 1; _i < arguments.length; _i++) {
  	            values[_i - 1] = arguments[_i];
  	        }
  	        var args = Array.prototype.slice.call(arguments, 1);
  	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
  	            assert_1.assert(idx < args.length, 'Message reference must be in range');
  	            return args[idx];
  	        });
  	        var index = this.lastMarker.index;
  	        var line = this.scanner.lineNumber;
  	        var column = this.lastMarker.column + 1;
  	        this.errorHandler.tolerateError(index, line, column, msg);
  	    };
  	    // Throw an exception because of the token.
  	    Parser.prototype.unexpectedTokenError = function (token, message) {
  	        var msg = message || messages_1.Messages.UnexpectedToken;
  	        var value;
  	        if (token) {
  	            if (!message) {
  	                msg = (token.type === 2 /* EOF */) ? messages_1.Messages.UnexpectedEOS :
  	                    (token.type === 3 /* Identifier */) ? messages_1.Messages.UnexpectedIdentifier :
  	                        (token.type === 6 /* NumericLiteral */) ? messages_1.Messages.UnexpectedNumber :
  	                            (token.type === 8 /* StringLiteral */) ? messages_1.Messages.UnexpectedString :
  	                                (token.type === 10 /* Template */) ? messages_1.Messages.UnexpectedTemplate :
  	                                    messages_1.Messages.UnexpectedToken;
  	                if (token.type === 4 /* Keyword */) {
  	                    if (this.scanner.isFutureReservedWord(token.value)) {
  	                        msg = messages_1.Messages.UnexpectedReserved;
  	                    }
  	                    else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
  	                        msg = messages_1.Messages.StrictReservedWord;
  	                    }
  	                }
  	            }
  	            value = token.value;
  	        }
  	        else {
  	            value = 'ILLEGAL';
  	        }
  	        msg = msg.replace('%0', value);
  	        if (token && typeof token.lineNumber === 'number') {
  	            var index = token.start;
  	            var line = token.lineNumber;
  	            var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
  	            var column = token.start - lastMarkerLineStart + 1;
  	            return this.errorHandler.createError(index, line, column, msg);
  	        }
  	        else {
  	            var index = this.lastMarker.index;
  	            var line = this.lastMarker.line;
  	            var column = this.lastMarker.column + 1;
  	            return this.errorHandler.createError(index, line, column, msg);
  	        }
  	    };
  	    Parser.prototype.throwUnexpectedToken = function (token, message) {
  	        throw this.unexpectedTokenError(token, message);
  	    };
  	    Parser.prototype.tolerateUnexpectedToken = function (token, message) {
  	        this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
  	    };
  	    Parser.prototype.collectComments = function () {
  	        if (!this.config.comment) {
  	            this.scanner.scanComments();
  	        }
  	        else {
  	            var comments = this.scanner.scanComments();
  	            if (comments.length > 0 && this.delegate) {
  	                for (var i = 0; i < comments.length; ++i) {
  	                    var e = comments[i];
  	                    var node = void 0;
  	                    node = {
  	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
  	                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
  	                    };
  	                    if (this.config.range) {
  	                        node.range = e.range;
  	                    }
  	                    if (this.config.loc) {
  	                        node.loc = e.loc;
  	                    }
  	                    var metadata = {
  	                        start: {
  	                            line: e.loc.start.line,
  	                            column: e.loc.start.column,
  	                            offset: e.range[0]
  	                        },
  	                        end: {
  	                            line: e.loc.end.line,
  	                            column: e.loc.end.column,
  	                            offset: e.range[1]
  	                        }
  	                    };
  	                    this.delegate(node, metadata);
  	                }
  	            }
  	        }
  	    };
  	    // From internal representation to an external structure
  	    Parser.prototype.getTokenRaw = function (token) {
  	        return this.scanner.source.slice(token.start, token.end);
  	    };
  	    Parser.prototype.convertToken = function (token) {
  	        var t = {
  	            type: token_1.TokenName[token.type],
  	            value: this.getTokenRaw(token)
  	        };
  	        if (this.config.range) {
  	            t.range = [token.start, token.end];
  	        }
  	        if (this.config.loc) {
  	            t.loc = {
  	                start: {
  	                    line: this.startMarker.line,
  	                    column: this.startMarker.column
  	                },
  	                end: {
  	                    line: this.scanner.lineNumber,
  	                    column: this.scanner.index - this.scanner.lineStart
  	                }
  	            };
  	        }
  	        if (token.type === 9 /* RegularExpression */) {
  	            var pattern = token.pattern;
  	            var flags = token.flags;
  	            t.regex = { pattern: pattern, flags: flags };
  	        }
  	        return t;
  	    };
  	    Parser.prototype.nextToken = function () {
  	        var token = this.lookahead;
  	        this.lastMarker.index = this.scanner.index;
  	        this.lastMarker.line = this.scanner.lineNumber;
  	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
  	        this.collectComments();
  	        if (this.scanner.index !== this.startMarker.index) {
  	            this.startMarker.index = this.scanner.index;
  	            this.startMarker.line = this.scanner.lineNumber;
  	            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
  	        }
  	        var next = this.scanner.lex();
  	        this.hasLineTerminator = (token.lineNumber !== next.lineNumber);
  	        if (next && this.context.strict && next.type === 3 /* Identifier */) {
  	            if (this.scanner.isStrictModeReservedWord(next.value)) {
  	                next.type = 4 /* Keyword */;
  	            }
  	        }
  	        this.lookahead = next;
  	        if (this.config.tokens && next.type !== 2 /* EOF */) {
  	            this.tokens.push(this.convertToken(next));
  	        }
  	        return token;
  	    };
  	    Parser.prototype.nextRegexToken = function () {
  	        this.collectComments();
  	        var token = this.scanner.scanRegExp();
  	        if (this.config.tokens) {
  	            // Pop the previous token, '/' or '/='
  	            // This is added from the lookahead token.
  	            this.tokens.pop();
  	            this.tokens.push(this.convertToken(token));
  	        }
  	        // Prime the next lookahead.
  	        this.lookahead = token;
  	        this.nextToken();
  	        return token;
  	    };
  	    Parser.prototype.createNode = function () {
  	        return {
  	            index: this.startMarker.index,
  	            line: this.startMarker.line,
  	            column: this.startMarker.column
  	        };
  	    };
  	    Parser.prototype.startNode = function (token, lastLineStart) {
  	        if (lastLineStart === void 0) { lastLineStart = 0; }
  	        var column = token.start - token.lineStart;
  	        var line = token.lineNumber;
  	        if (column < 0) {
  	            column += lastLineStart;
  	            line--;
  	        }
  	        return {
  	            index: token.start,
  	            line: line,
  	            column: column
  	        };
  	    };
  	    Parser.prototype.finalize = function (marker, node) {
  	        if (this.config.range) {
  	            node.range = [marker.index, this.lastMarker.index];
  	        }
  	        if (this.config.loc) {
  	            node.loc = {
  	                start: {
  	                    line: marker.line,
  	                    column: marker.column,
  	                },
  	                end: {
  	                    line: this.lastMarker.line,
  	                    column: this.lastMarker.column
  	                }
  	            };
  	            if (this.config.source) {
  	                node.loc.source = this.config.source;
  	            }
  	        }
  	        if (this.delegate) {
  	            var metadata = {
  	                start: {
  	                    line: marker.line,
  	                    column: marker.column,
  	                    offset: marker.index
  	                },
  	                end: {
  	                    line: this.lastMarker.line,
  	                    column: this.lastMarker.column,
  	                    offset: this.lastMarker.index
  	                }
  	            };
  	            this.delegate(node, metadata);
  	        }
  	        return node;
  	    };
  	    // Expect the next token to match the specified punctuator.
  	    // If not, an exception will be thrown.
  	    Parser.prototype.expect = function (value) {
  	        var token = this.nextToken();
  	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
  	            this.throwUnexpectedToken(token);
  	        }
  	    };
  	    // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
  	    Parser.prototype.expectCommaSeparator = function () {
  	        if (this.config.tolerant) {
  	            var token = this.lookahead;
  	            if (token.type === 7 /* Punctuator */ && token.value === ',') {
  	                this.nextToken();
  	            }
  	            else if (token.type === 7 /* Punctuator */ && token.value === ';') {
  	                this.nextToken();
  	                this.tolerateUnexpectedToken(token);
  	            }
  	            else {
  	                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
  	            }
  	        }
  	        else {
  	            this.expect(',');
  	        }
  	    };
  	    // Expect the next token to match the specified keyword.
  	    // If not, an exception will be thrown.
  	    Parser.prototype.expectKeyword = function (keyword) {
  	        var token = this.nextToken();
  	        if (token.type !== 4 /* Keyword */ || token.value !== keyword) {
  	            this.throwUnexpectedToken(token);
  	        }
  	    };
  	    // Return true if the next token matches the specified punctuator.
  	    Parser.prototype.match = function (value) {
  	        return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;
  	    };
  	    // Return true if the next token matches the specified keyword
  	    Parser.prototype.matchKeyword = function (keyword) {
  	        return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;
  	    };
  	    // Return true if the next token matches the specified contextual keyword
  	    // (where an identifier is sometimes a keyword depending on the context)
  	    Parser.prototype.matchContextualKeyword = function (keyword) {
  	        return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;
  	    };
  	    // Return true if the next token is an assignment operator
  	    Parser.prototype.matchAssign = function () {
  	        if (this.lookahead.type !== 7 /* Punctuator */) {
  	            return false;
  	        }
  	        var op = this.lookahead.value;
  	        return op === '=' ||
  	            op === '*=' ||
  	            op === '**=' ||
  	            op === '/=' ||
  	            op === '%=' ||
  	            op === '+=' ||
  	            op === '-=' ||
  	            op === '<<=' ||
  	            op === '>>=' ||
  	            op === '>>>=' ||
  	            op === '&=' ||
  	            op === '^=' ||
  	            op === '|=';
  	    };
  	    // Cover grammar support.
  	    //
  	    // When an assignment expression position starts with an left parenthesis, the determination of the type
  	    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
  	    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
  	    //
  	    // There are three productions that can be parsed in a parentheses pair that needs to be determined
  	    // after the outermost pair is closed. They are:
  	    //
  	    //   1. AssignmentExpression
  	    //   2. BindingElements
  	    //   3. AssignmentTargets
  	    //
  	    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
  	    // binding element or assignment target.
  	    //
  	    // The three productions have the relationship:
  	    //
  	    //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
  	    //
  	    // with a single exception that CoverInitializedName when used directly in an Expression, generates
  	    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
  	    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
  	    //
  	    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
  	    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
  	    // the CoverInitializedName check is conducted.
  	    //
  	    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
  	    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
  	    // pattern. The CoverInitializedName check is deferred.
  	    Parser.prototype.isolateCoverGrammar = function (parseFunction) {
  	        var previousIsBindingElement = this.context.isBindingElement;
  	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
  	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
  	        this.context.isBindingElement = true;
  	        this.context.isAssignmentTarget = true;
  	        this.context.firstCoverInitializedNameError = null;
  	        var result = parseFunction.call(this);
  	        if (this.context.firstCoverInitializedNameError !== null) {
  	            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
  	        }
  	        this.context.isBindingElement = previousIsBindingElement;
  	        this.context.isAssignmentTarget = previousIsAssignmentTarget;
  	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
  	        return result;
  	    };
  	    Parser.prototype.inheritCoverGrammar = function (parseFunction) {
  	        var previousIsBindingElement = this.context.isBindingElement;
  	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
  	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
  	        this.context.isBindingElement = true;
  	        this.context.isAssignmentTarget = true;
  	        this.context.firstCoverInitializedNameError = null;
  	        var result = parseFunction.call(this);
  	        this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
  	        this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
  	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
  	        return result;
  	    };
  	    Parser.prototype.consumeSemicolon = function () {
  	        if (this.match(';')) {
  	            this.nextToken();
  	        }
  	        else if (!this.hasLineTerminator) {
  	            if (this.lookahead.type !== 2 /* EOF */ && !this.match('}')) {
  	                this.throwUnexpectedToken(this.lookahead);
  	            }
  	            this.lastMarker.index = this.startMarker.index;
  	            this.lastMarker.line = this.startMarker.line;
  	            this.lastMarker.column = this.startMarker.column;
  	        }
  	    };
  	    // https://tc39.github.io/ecma262/#sec-primary-expression
  	    Parser.prototype.parsePrimaryExpression = function () {
  	        var node = this.createNode();
  	        var expr;
  	        var token, raw;
  	        switch (this.lookahead.type) {
  	            case 3 /* Identifier */:
  	                if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {
  	                    this.tolerateUnexpectedToken(this.lookahead);
  	                }
  	                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
  	                break;
  	            case 6 /* NumericLiteral */:
  	            case 8 /* StringLiteral */:
  	                if (this.context.strict && this.lookahead.octal) {
  	                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
  	                }
  	                this.context.isAssignmentTarget = false;
  	                this.context.isBindingElement = false;
  	                token = this.nextToken();
  	                raw = this.getTokenRaw(token);
  	                expr = this.finalize(node, new Node.Literal(token.value, raw));
  	                break;
  	            case 1 /* BooleanLiteral */:
  	                this.context.isAssignmentTarget = false;
  	                this.context.isBindingElement = false;
  	                token = this.nextToken();
  	                raw = this.getTokenRaw(token);
  	                expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));
  	                break;
  	            case 5 /* NullLiteral */:
  	                this.context.isAssignmentTarget = false;
  	                this.context.isBindingElement = false;
  	                token = this.nextToken();
  	                raw = this.getTokenRaw(token);
  	                expr = this.finalize(node, new Node.Literal(null, raw));
  	                break;
  	            case 10 /* Template */:
  	                expr = this.parseTemplateLiteral();
  	                break;
  	            case 7 /* Punctuator */:
  	                switch (this.lookahead.value) {
  	                    case '(':
  	                        this.context.isBindingElement = false;
  	                        expr = this.inheritCoverGrammar(this.parseGroupExpression);
  	                        break;
  	                    case '[':
  	                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
  	                        break;
  	                    case '{':
  	                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
  	                        break;
  	                    case '/':
  	                    case '/=':
  	                        this.context.isAssignmentTarget = false;
  	                        this.context.isBindingElement = false;
  	                        this.scanner.index = this.startMarker.index;
  	                        token = this.nextRegexToken();
  	                        raw = this.getTokenRaw(token);
  	                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
  	                        break;
  	                    default:
  	                        expr = this.throwUnexpectedToken(this.nextToken());
  	                }
  	                break;
  	            case 4 /* Keyword */:
  	                if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
  	                    expr = this.parseIdentifierName();
  	                }
  	                else if (!this.context.strict && this.matchKeyword('let')) {
  	                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
  	                }
  	                else {
  	                    this.context.isAssignmentTarget = false;
  	                    this.context.isBindingElement = false;
  	                    if (this.matchKeyword('function')) {
  	                        expr = this.parseFunctionExpression();
  	                    }
  	                    else if (this.matchKeyword('this')) {
  	                        this.nextToken();
  	                        expr = this.finalize(node, new Node.ThisExpression());
  	                    }
  	                    else if (this.matchKeyword('class')) {
  	                        expr = this.parseClassExpression();
  	                    }
  	                    else {
  	                        expr = this.throwUnexpectedToken(this.nextToken());
  	                    }
  	                }
  	                break;
  	            default:
  	                expr = this.throwUnexpectedToken(this.nextToken());
  	        }
  	        return expr;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-array-initializer
  	    Parser.prototype.parseSpreadElement = function () {
  	        var node = this.createNode();
  	        this.expect('...');
  	        var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
  	        return this.finalize(node, new Node.SpreadElement(arg));
  	    };
  	    Parser.prototype.parseArrayInitializer = function () {
  	        var node = this.createNode();
  	        var elements = [];
  	        this.expect('[');
  	        while (!this.match(']')) {
  	            if (this.match(',')) {
  	                this.nextToken();
  	                elements.push(null);
  	            }
  	            else if (this.match('...')) {
  	                var element = this.parseSpreadElement();
  	                if (!this.match(']')) {
  	                    this.context.isAssignmentTarget = false;
  	                    this.context.isBindingElement = false;
  	                    this.expect(',');
  	                }
  	                elements.push(element);
  	            }
  	            else {
  	                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
  	                if (!this.match(']')) {
  	                    this.expect(',');
  	                }
  	            }
  	        }
  	        this.expect(']');
  	        return this.finalize(node, new Node.ArrayExpression(elements));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-object-initializer
  	    Parser.prototype.parsePropertyMethod = function (params) {
  	        this.context.isAssignmentTarget = false;
  	        this.context.isBindingElement = false;
  	        var previousStrict = this.context.strict;
  	        var previousAllowStrictDirective = this.context.allowStrictDirective;
  	        this.context.allowStrictDirective = params.simple;
  	        var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
  	        if (this.context.strict && params.firstRestricted) {
  	            this.tolerateUnexpectedToken(params.firstRestricted, params.message);
  	        }
  	        if (this.context.strict && params.stricted) {
  	            this.tolerateUnexpectedToken(params.stricted, params.message);
  	        }
  	        this.context.strict = previousStrict;
  	        this.context.allowStrictDirective = previousAllowStrictDirective;
  	        return body;
  	    };
  	    Parser.prototype.parsePropertyMethodFunction = function () {
  	        var isGenerator = false;
  	        var node = this.createNode();
  	        var previousAllowYield = this.context.allowYield;
  	        this.context.allowYield = true;
  	        var params = this.parseFormalParameters();
  	        var method = this.parsePropertyMethod(params);
  	        this.context.allowYield = previousAllowYield;
  	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
  	    };
  	    Parser.prototype.parsePropertyMethodAsyncFunction = function () {
  	        var node = this.createNode();
  	        var previousAllowYield = this.context.allowYield;
  	        var previousAwait = this.context.await;
  	        this.context.allowYield = false;
  	        this.context.await = true;
  	        var params = this.parseFormalParameters();
  	        var method = this.parsePropertyMethod(params);
  	        this.context.allowYield = previousAllowYield;
  	        this.context.await = previousAwait;
  	        return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
  	    };
  	    Parser.prototype.parseObjectPropertyKey = function () {
  	        var node = this.createNode();
  	        var token = this.nextToken();
  	        var key;
  	        switch (token.type) {
  	            case 8 /* StringLiteral */:
  	            case 6 /* NumericLiteral */:
  	                if (this.context.strict && token.octal) {
  	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
  	                }
  	                var raw = this.getTokenRaw(token);
  	                key = this.finalize(node, new Node.Literal(token.value, raw));
  	                break;
  	            case 3 /* Identifier */:
  	            case 1 /* BooleanLiteral */:
  	            case 5 /* NullLiteral */:
  	            case 4 /* Keyword */:
  	                key = this.finalize(node, new Node.Identifier(token.value));
  	                break;
  	            case 7 /* Punctuator */:
  	                if (token.value === '[') {
  	                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
  	                    this.expect(']');
  	                }
  	                else {
  	                    key = this.throwUnexpectedToken(token);
  	                }
  	                break;
  	            default:
  	                key = this.throwUnexpectedToken(token);
  	        }
  	        return key;
  	    };
  	    Parser.prototype.isPropertyKey = function (key, value) {
  	        return (key.type === syntax_1.Syntax.Identifier && key.name === value) ||
  	            (key.type === syntax_1.Syntax.Literal && key.value === value);
  	    };
  	    Parser.prototype.parseObjectProperty = function (hasProto) {
  	        var node = this.createNode();
  	        var token = this.lookahead;
  	        var kind;
  	        var key = null;
  	        var value = null;
  	        var computed = false;
  	        var method = false;
  	        var shorthand = false;
  	        var isAsync = false;
  	        if (token.type === 3 /* Identifier */) {
  	            var id = token.value;
  	            this.nextToken();
  	            computed = this.match('[');
  	            isAsync = !this.hasLineTerminator && (id === 'async') &&
  	                !this.match(':') && !this.match('(') && !this.match('*') && !this.match(',');
  	            key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
  	        }
  	        else if (this.match('*')) {
  	            this.nextToken();
  	        }
  	        else {
  	            computed = this.match('[');
  	            key = this.parseObjectPropertyKey();
  	        }
  	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
  	        if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {
  	            kind = 'get';
  	            computed = this.match('[');
  	            key = this.parseObjectPropertyKey();
  	            this.context.allowYield = false;
  	            value = this.parseGetterMethod();
  	        }
  	        else if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {
  	            kind = 'set';
  	            computed = this.match('[');
  	            key = this.parseObjectPropertyKey();
  	            value = this.parseSetterMethod();
  	        }
  	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
  	            kind = 'init';
  	            computed = this.match('[');
  	            key = this.parseObjectPropertyKey();
  	            value = this.parseGeneratorMethod();
  	            method = true;
  	        }
  	        else {
  	            if (!key) {
  	                this.throwUnexpectedToken(this.lookahead);
  	            }
  	            kind = 'init';
  	            if (this.match(':') && !isAsync) {
  	                if (!computed && this.isPropertyKey(key, '__proto__')) {
  	                    if (hasProto.value) {
  	                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
  	                    }
  	                    hasProto.value = true;
  	                }
  	                this.nextToken();
  	                value = this.inheritCoverGrammar(this.parseAssignmentExpression);
  	            }
  	            else if (this.match('(')) {
  	                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
  	                method = true;
  	            }
  	            else if (token.type === 3 /* Identifier */) {
  	                var id = this.finalize(node, new Node.Identifier(token.value));
  	                if (this.match('=')) {
  	                    this.context.firstCoverInitializedNameError = this.lookahead;
  	                    this.nextToken();
  	                    shorthand = true;
  	                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
  	                    value = this.finalize(node, new Node.AssignmentPattern(id, init));
  	                }
  	                else {
  	                    shorthand = true;
  	                    value = id;
  	                }
  	            }
  	            else {
  	                this.throwUnexpectedToken(this.nextToken());
  	            }
  	        }
  	        return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
  	    };
  	    Parser.prototype.parseObjectInitializer = function () {
  	        var node = this.createNode();
  	        this.expect('{');
  	        var properties = [];
  	        var hasProto = { value: false };
  	        while (!this.match('}')) {
  	            properties.push(this.parseObjectProperty(hasProto));
  	            if (!this.match('}')) {
  	                this.expectCommaSeparator();
  	            }
  	        }
  	        this.expect('}');
  	        return this.finalize(node, new Node.ObjectExpression(properties));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-template-literals
  	    Parser.prototype.parseTemplateHead = function () {
  	        assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
  	        var node = this.createNode();
  	        var token = this.nextToken();
  	        var raw = token.value;
  	        var cooked = token.cooked;
  	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
  	    };
  	    Parser.prototype.parseTemplateElement = function () {
  	        if (this.lookahead.type !== 10 /* Template */) {
  	            this.throwUnexpectedToken();
  	        }
  	        var node = this.createNode();
  	        var token = this.nextToken();
  	        var raw = token.value;
  	        var cooked = token.cooked;
  	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
  	    };
  	    Parser.prototype.parseTemplateLiteral = function () {
  	        var node = this.createNode();
  	        var expressions = [];
  	        var quasis = [];
  	        var quasi = this.parseTemplateHead();
  	        quasis.push(quasi);
  	        while (!quasi.tail) {
  	            expressions.push(this.parseExpression());
  	            quasi = this.parseTemplateElement();
  	            quasis.push(quasi);
  	        }
  	        return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-grouping-operator
  	    Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
  	        switch (expr.type) {
  	            case syntax_1.Syntax.Identifier:
  	            case syntax_1.Syntax.MemberExpression:
  	            case syntax_1.Syntax.RestElement:
  	            case syntax_1.Syntax.AssignmentPattern:
  	                break;
  	            case syntax_1.Syntax.SpreadElement:
  	                expr.type = syntax_1.Syntax.RestElement;
  	                this.reinterpretExpressionAsPattern(expr.argument);
  	                break;
  	            case syntax_1.Syntax.ArrayExpression:
  	                expr.type = syntax_1.Syntax.ArrayPattern;
  	                for (var i = 0; i < expr.elements.length; i++) {
  	                    if (expr.elements[i] !== null) {
  	                        this.reinterpretExpressionAsPattern(expr.elements[i]);
  	                    }
  	                }
  	                break;
  	            case syntax_1.Syntax.ObjectExpression:
  	                expr.type = syntax_1.Syntax.ObjectPattern;
  	                for (var i = 0; i < expr.properties.length; i++) {
  	                    this.reinterpretExpressionAsPattern(expr.properties[i].value);
  	                }
  	                break;
  	            case syntax_1.Syntax.AssignmentExpression:
  	                expr.type = syntax_1.Syntax.AssignmentPattern;
  	                delete expr.operator;
  	                this.reinterpretExpressionAsPattern(expr.left);
  	                break;
  	            default:
  	                // Allow other node type for tolerant parsing.
  	                break;
  	        }
  	    };
  	    Parser.prototype.parseGroupExpression = function () {
  	        var expr;
  	        this.expect('(');
  	        if (this.match(')')) {
  	            this.nextToken();
  	            if (!this.match('=>')) {
  	                this.expect('=>');
  	            }
  	            expr = {
  	                type: ArrowParameterPlaceHolder,
  	                params: [],
  	                async: false
  	            };
  	        }
  	        else {
  	            var startToken = this.lookahead;
  	            var params = [];
  	            if (this.match('...')) {
  	                expr = this.parseRestElement(params);
  	                this.expect(')');
  	                if (!this.match('=>')) {
  	                    this.expect('=>');
  	                }
  	                expr = {
  	                    type: ArrowParameterPlaceHolder,
  	                    params: [expr],
  	                    async: false
  	                };
  	            }
  	            else {
  	                var arrow = false;
  	                this.context.isBindingElement = true;
  	                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
  	                if (this.match(',')) {
  	                    var expressions = [];
  	                    this.context.isAssignmentTarget = false;
  	                    expressions.push(expr);
  	                    while (this.lookahead.type !== 2 /* EOF */) {
  	                        if (!this.match(',')) {
  	                            break;
  	                        }
  	                        this.nextToken();
  	                        if (this.match(')')) {
  	                            this.nextToken();
  	                            for (var i = 0; i < expressions.length; i++) {
  	                                this.reinterpretExpressionAsPattern(expressions[i]);
  	                            }
  	                            arrow = true;
  	                            expr = {
  	                                type: ArrowParameterPlaceHolder,
  	                                params: expressions,
  	                                async: false
  	                            };
  	                        }
  	                        else if (this.match('...')) {
  	                            if (!this.context.isBindingElement) {
  	                                this.throwUnexpectedToken(this.lookahead);
  	                            }
  	                            expressions.push(this.parseRestElement(params));
  	                            this.expect(')');
  	                            if (!this.match('=>')) {
  	                                this.expect('=>');
  	                            }
  	                            this.context.isBindingElement = false;
  	                            for (var i = 0; i < expressions.length; i++) {
  	                                this.reinterpretExpressionAsPattern(expressions[i]);
  	                            }
  	                            arrow = true;
  	                            expr = {
  	                                type: ArrowParameterPlaceHolder,
  	                                params: expressions,
  	                                async: false
  	                            };
  	                        }
  	                        else {
  	                            expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
  	                        }
  	                        if (arrow) {
  	                            break;
  	                        }
  	                    }
  	                    if (!arrow) {
  	                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
  	                    }
  	                }
  	                if (!arrow) {
  	                    this.expect(')');
  	                    if (this.match('=>')) {
  	                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
  	                            arrow = true;
  	                            expr = {
  	                                type: ArrowParameterPlaceHolder,
  	                                params: [expr],
  	                                async: false
  	                            };
  	                        }
  	                        if (!arrow) {
  	                            if (!this.context.isBindingElement) {
  	                                this.throwUnexpectedToken(this.lookahead);
  	                            }
  	                            if (expr.type === syntax_1.Syntax.SequenceExpression) {
  	                                for (var i = 0; i < expr.expressions.length; i++) {
  	                                    this.reinterpretExpressionAsPattern(expr.expressions[i]);
  	                                }
  	                            }
  	                            else {
  	                                this.reinterpretExpressionAsPattern(expr);
  	                            }
  	                            var parameters = (expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr]);
  	                            expr = {
  	                                type: ArrowParameterPlaceHolder,
  	                                params: parameters,
  	                                async: false
  	                            };
  	                        }
  	                    }
  	                    this.context.isBindingElement = false;
  	                }
  	            }
  	        }
  	        return expr;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
  	    Parser.prototype.parseArguments = function () {
  	        this.expect('(');
  	        var args = [];
  	        if (!this.match(')')) {
  	            while (true) {
  	                var expr = this.match('...') ? this.parseSpreadElement() :
  	                    this.isolateCoverGrammar(this.parseAssignmentExpression);
  	                args.push(expr);
  	                if (this.match(')')) {
  	                    break;
  	                }
  	                this.expectCommaSeparator();
  	                if (this.match(')')) {
  	                    break;
  	                }
  	            }
  	        }
  	        this.expect(')');
  	        return args;
  	    };
  	    Parser.prototype.isIdentifierName = function (token) {
  	        return token.type === 3 /* Identifier */ ||
  	            token.type === 4 /* Keyword */ ||
  	            token.type === 1 /* BooleanLiteral */ ||
  	            token.type === 5 /* NullLiteral */;
  	    };
  	    Parser.prototype.parseIdentifierName = function () {
  	        var node = this.createNode();
  	        var token = this.nextToken();
  	        if (!this.isIdentifierName(token)) {
  	            this.throwUnexpectedToken(token);
  	        }
  	        return this.finalize(node, new Node.Identifier(token.value));
  	    };
  	    Parser.prototype.parseNewExpression = function () {
  	        var node = this.createNode();
  	        var id = this.parseIdentifierName();
  	        assert_1.assert(id.name === 'new', 'New expression must start with `new`');
  	        var expr;
  	        if (this.match('.')) {
  	            this.nextToken();
  	            if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {
  	                var property = this.parseIdentifierName();
  	                expr = new Node.MetaProperty(id, property);
  	            }
  	            else {
  	                this.throwUnexpectedToken(this.lookahead);
  	            }
  	        }
  	        else {
  	            var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
  	            var args = this.match('(') ? this.parseArguments() : [];
  	            expr = new Node.NewExpression(callee, args);
  	            this.context.isAssignmentTarget = false;
  	            this.context.isBindingElement = false;
  	        }
  	        return this.finalize(node, expr);
  	    };
  	    Parser.prototype.parseAsyncArgument = function () {
  	        var arg = this.parseAssignmentExpression();
  	        this.context.firstCoverInitializedNameError = null;
  	        return arg;
  	    };
  	    Parser.prototype.parseAsyncArguments = function () {
  	        this.expect('(');
  	        var args = [];
  	        if (!this.match(')')) {
  	            while (true) {
  	                var expr = this.match('...') ? this.parseSpreadElement() :
  	                    this.isolateCoverGrammar(this.parseAsyncArgument);
  	                args.push(expr);
  	                if (this.match(')')) {
  	                    break;
  	                }
  	                this.expectCommaSeparator();
  	                if (this.match(')')) {
  	                    break;
  	                }
  	            }
  	        }
  	        this.expect(')');
  	        return args;
  	    };
  	    Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
  	        var startToken = this.lookahead;
  	        var maybeAsync = this.matchContextualKeyword('async');
  	        var previousAllowIn = this.context.allowIn;
  	        this.context.allowIn = true;
  	        var expr;
  	        if (this.matchKeyword('super') && this.context.inFunctionBody) {
  	            expr = this.createNode();
  	            this.nextToken();
  	            expr = this.finalize(expr, new Node.Super());
  	            if (!this.match('(') && !this.match('.') && !this.match('[')) {
  	                this.throwUnexpectedToken(this.lookahead);
  	            }
  	        }
  	        else {
  	            expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
  	        }
  	        while (true) {
  	            if (this.match('.')) {
  	                this.context.isBindingElement = false;
  	                this.context.isAssignmentTarget = true;
  	                this.expect('.');
  	                var property = this.parseIdentifierName();
  	                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
  	            }
  	            else if (this.match('(')) {
  	                var asyncArrow = maybeAsync && (startToken.lineNumber === this.lookahead.lineNumber);
  	                this.context.isBindingElement = false;
  	                this.context.isAssignmentTarget = false;
  	                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
  	                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
  	                if (asyncArrow && this.match('=>')) {
  	                    for (var i = 0; i < args.length; ++i) {
  	                        this.reinterpretExpressionAsPattern(args[i]);
  	                    }
  	                    expr = {
  	                        type: ArrowParameterPlaceHolder,
  	                        params: args,
  	                        async: true
  	                    };
  	                }
  	            }
  	            else if (this.match('[')) {
  	                this.context.isBindingElement = false;
  	                this.context.isAssignmentTarget = true;
  	                this.expect('[');
  	                var property = this.isolateCoverGrammar(this.parseExpression);
  	                this.expect(']');
  	                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
  	            }
  	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
  	                var quasi = this.parseTemplateLiteral();
  	                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
  	            }
  	            else {
  	                break;
  	            }
  	        }
  	        this.context.allowIn = previousAllowIn;
  	        return expr;
  	    };
  	    Parser.prototype.parseSuper = function () {
  	        var node = this.createNode();
  	        this.expectKeyword('super');
  	        if (!this.match('[') && !this.match('.')) {
  	            this.throwUnexpectedToken(this.lookahead);
  	        }
  	        return this.finalize(node, new Node.Super());
  	    };
  	    Parser.prototype.parseLeftHandSideExpression = function () {
  	        assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
  	        var node = this.startNode(this.lookahead);
  	        var expr = (this.matchKeyword('super') && this.context.inFunctionBody) ? this.parseSuper() :
  	            this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
  	        while (true) {
  	            if (this.match('[')) {
  	                this.context.isBindingElement = false;
  	                this.context.isAssignmentTarget = true;
  	                this.expect('[');
  	                var property = this.isolateCoverGrammar(this.parseExpression);
  	                this.expect(']');
  	                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
  	            }
  	            else if (this.match('.')) {
  	                this.context.isBindingElement = false;
  	                this.context.isAssignmentTarget = true;
  	                this.expect('.');
  	                var property = this.parseIdentifierName();
  	                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
  	            }
  	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
  	                var quasi = this.parseTemplateLiteral();
  	                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
  	            }
  	            else {
  	                break;
  	            }
  	        }
  	        return expr;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-update-expressions
  	    Parser.prototype.parseUpdateExpression = function () {
  	        var expr;
  	        var startToken = this.lookahead;
  	        if (this.match('++') || this.match('--')) {
  	            var node = this.startNode(startToken);
  	            var token = this.nextToken();
  	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
  	            if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
  	                this.tolerateError(messages_1.Messages.StrictLHSPrefix);
  	            }
  	            if (!this.context.isAssignmentTarget) {
  	                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
  	            }
  	            var prefix = true;
  	            expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
  	            this.context.isAssignmentTarget = false;
  	            this.context.isBindingElement = false;
  	        }
  	        else {
  	            expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
  	            if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {
  	                if (this.match('++') || this.match('--')) {
  	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
  	                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);
  	                    }
  	                    if (!this.context.isAssignmentTarget) {
  	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
  	                    }
  	                    this.context.isAssignmentTarget = false;
  	                    this.context.isBindingElement = false;
  	                    var operator = this.nextToken().value;
  	                    var prefix = false;
  	                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
  	                }
  	            }
  	        }
  	        return expr;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-unary-operators
  	    Parser.prototype.parseAwaitExpression = function () {
  	        var node = this.createNode();
  	        this.nextToken();
  	        var argument = this.parseUnaryExpression();
  	        return this.finalize(node, new Node.AwaitExpression(argument));
  	    };
  	    Parser.prototype.parseUnaryExpression = function () {
  	        var expr;
  	        if (this.match('+') || this.match('-') || this.match('~') || this.match('!') ||
  	            this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
  	            var node = this.startNode(this.lookahead);
  	            var token = this.nextToken();
  	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
  	            expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
  	            if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
  	                this.tolerateError(messages_1.Messages.StrictDelete);
  	            }
  	            this.context.isAssignmentTarget = false;
  	            this.context.isBindingElement = false;
  	        }
  	        else if (this.context.await && this.matchContextualKeyword('await')) {
  	            expr = this.parseAwaitExpression();
  	        }
  	        else {
  	            expr = this.parseUpdateExpression();
  	        }
  	        return expr;
  	    };
  	    Parser.prototype.parseExponentiationExpression = function () {
  	        var startToken = this.lookahead;
  	        var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
  	        if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
  	            this.nextToken();
  	            this.context.isAssignmentTarget = false;
  	            this.context.isBindingElement = false;
  	            var left = expr;
  	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
  	            expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
  	        }
  	        return expr;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-exp-operator
  	    // https://tc39.github.io/ecma262/#sec-multiplicative-operators
  	    // https://tc39.github.io/ecma262/#sec-additive-operators
  	    // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
  	    // https://tc39.github.io/ecma262/#sec-relational-operators
  	    // https://tc39.github.io/ecma262/#sec-equality-operators
  	    // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
  	    // https://tc39.github.io/ecma262/#sec-binary-logical-operators
  	    Parser.prototype.binaryPrecedence = function (token) {
  	        var op = token.value;
  	        var precedence;
  	        if (token.type === 7 /* Punctuator */) {
  	            precedence = this.operatorPrecedence[op] || 0;
  	        }
  	        else if (token.type === 4 /* Keyword */) {
  	            precedence = (op === 'instanceof' || (this.context.allowIn && op === 'in')) ? 7 : 0;
  	        }
  	        else {
  	            precedence = 0;
  	        }
  	        return precedence;
  	    };
  	    Parser.prototype.parseBinaryExpression = function () {
  	        var startToken = this.lookahead;
  	        var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
  	        var token = this.lookahead;
  	        var prec = this.binaryPrecedence(token);
  	        if (prec > 0) {
  	            this.nextToken();
  	            this.context.isAssignmentTarget = false;
  	            this.context.isBindingElement = false;
  	            var markers = [startToken, this.lookahead];
  	            var left = expr;
  	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
  	            var stack = [left, token.value, right];
  	            var precedences = [prec];
  	            while (true) {
  	                prec = this.binaryPrecedence(this.lookahead);
  	                if (prec <= 0) {
  	                    break;
  	                }
  	                // Reduce: make a binary expression from the three topmost entries.
  	                while ((stack.length > 2) && (prec <= precedences[precedences.length - 1])) {
  	                    right = stack.pop();
  	                    var operator = stack.pop();
  	                    precedences.pop();
  	                    left = stack.pop();
  	                    markers.pop();
  	                    var node = this.startNode(markers[markers.length - 1]);
  	                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
  	                }
  	                // Shift.
  	                stack.push(this.nextToken().value);
  	                precedences.push(prec);
  	                markers.push(this.lookahead);
  	                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
  	            }
  	            // Final reduce to clean-up the stack.
  	            var i = stack.length - 1;
  	            expr = stack[i];
  	            var lastMarker = markers.pop();
  	            while (i > 1) {
  	                var marker = markers.pop();
  	                var lastLineStart = lastMarker && lastMarker.lineStart;
  	                var node = this.startNode(marker, lastLineStart);
  	                var operator = stack[i - 1];
  	                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
  	                i -= 2;
  	                lastMarker = marker;
  	            }
  	        }
  	        return expr;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-conditional-operator
  	    Parser.prototype.parseConditionalExpression = function () {
  	        var startToken = this.lookahead;
  	        var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
  	        if (this.match('?')) {
  	            this.nextToken();
  	            var previousAllowIn = this.context.allowIn;
  	            this.context.allowIn = true;
  	            var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
  	            this.context.allowIn = previousAllowIn;
  	            this.expect(':');
  	            var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
  	            expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
  	            this.context.isAssignmentTarget = false;
  	            this.context.isBindingElement = false;
  	        }
  	        return expr;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-assignment-operators
  	    Parser.prototype.checkPatternParam = function (options, param) {
  	        switch (param.type) {
  	            case syntax_1.Syntax.Identifier:
  	                this.validateParam(options, param, param.name);
  	                break;
  	            case syntax_1.Syntax.RestElement:
  	                this.checkPatternParam(options, param.argument);
  	                break;
  	            case syntax_1.Syntax.AssignmentPattern:
  	                this.checkPatternParam(options, param.left);
  	                break;
  	            case syntax_1.Syntax.ArrayPattern:
  	                for (var i = 0; i < param.elements.length; i++) {
  	                    if (param.elements[i] !== null) {
  	                        this.checkPatternParam(options, param.elements[i]);
  	                    }
  	                }
  	                break;
  	            case syntax_1.Syntax.ObjectPattern:
  	                for (var i = 0; i < param.properties.length; i++) {
  	                    this.checkPatternParam(options, param.properties[i].value);
  	                }
  	                break;
  	            default:
  	                break;
  	        }
  	        options.simple = options.simple && (param instanceof Node.Identifier);
  	    };
  	    Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
  	        var params = [expr];
  	        var options;
  	        var asyncArrow = false;
  	        switch (expr.type) {
  	            case syntax_1.Syntax.Identifier:
  	                break;
  	            case ArrowParameterPlaceHolder:
  	                params = expr.params;
  	                asyncArrow = expr.async;
  	                break;
  	            default:
  	                return null;
  	        }
  	        options = {
  	            simple: true,
  	            paramSet: {}
  	        };
  	        for (var i = 0; i < params.length; ++i) {
  	            var param = params[i];
  	            if (param.type === syntax_1.Syntax.AssignmentPattern) {
  	                if (param.right.type === syntax_1.Syntax.YieldExpression) {
  	                    if (param.right.argument) {
  	                        this.throwUnexpectedToken(this.lookahead);
  	                    }
  	                    param.right.type = syntax_1.Syntax.Identifier;
  	                    param.right.name = 'yield';
  	                    delete param.right.argument;
  	                    delete param.right.delegate;
  	                }
  	            }
  	            else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {
  	                this.throwUnexpectedToken(this.lookahead);
  	            }
  	            this.checkPatternParam(options, param);
  	            params[i] = param;
  	        }
  	        if (this.context.strict || !this.context.allowYield) {
  	            for (var i = 0; i < params.length; ++i) {
  	                var param = params[i];
  	                if (param.type === syntax_1.Syntax.YieldExpression) {
  	                    this.throwUnexpectedToken(this.lookahead);
  	                }
  	            }
  	        }
  	        if (options.message === messages_1.Messages.StrictParamDupe) {
  	            var token = this.context.strict ? options.stricted : options.firstRestricted;
  	            this.throwUnexpectedToken(token, options.message);
  	        }
  	        return {
  	            simple: options.simple,
  	            params: params,
  	            stricted: options.stricted,
  	            firstRestricted: options.firstRestricted,
  	            message: options.message
  	        };
  	    };
  	    Parser.prototype.parseAssignmentExpression = function () {
  	        var expr;
  	        if (!this.context.allowYield && this.matchKeyword('yield')) {
  	            expr = this.parseYieldExpression();
  	        }
  	        else {
  	            var startToken = this.lookahead;
  	            var token = startToken;
  	            expr = this.parseConditionalExpression();
  	            if (token.type === 3 /* Identifier */ && (token.lineNumber === this.lookahead.lineNumber) && token.value === 'async') {
  	                if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword('yield')) {
  	                    var arg = this.parsePrimaryExpression();
  	                    this.reinterpretExpressionAsPattern(arg);
  	                    expr = {
  	                        type: ArrowParameterPlaceHolder,
  	                        params: [arg],
  	                        async: true
  	                    };
  	                }
  	            }
  	            if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
  	                // https://tc39.github.io/ecma262/#sec-arrow-function-definitions
  	                this.context.isAssignmentTarget = false;
  	                this.context.isBindingElement = false;
  	                var isAsync = expr.async;
  	                var list = this.reinterpretAsCoverFormalsList(expr);
  	                if (list) {
  	                    if (this.hasLineTerminator) {
  	                        this.tolerateUnexpectedToken(this.lookahead);
  	                    }
  	                    this.context.firstCoverInitializedNameError = null;
  	                    var previousStrict = this.context.strict;
  	                    var previousAllowStrictDirective = this.context.allowStrictDirective;
  	                    this.context.allowStrictDirective = list.simple;
  	                    var previousAllowYield = this.context.allowYield;
  	                    var previousAwait = this.context.await;
  	                    this.context.allowYield = true;
  	                    this.context.await = isAsync;
  	                    var node = this.startNode(startToken);
  	                    this.expect('=>');
  	                    var body = void 0;
  	                    if (this.match('{')) {
  	                        var previousAllowIn = this.context.allowIn;
  	                        this.context.allowIn = true;
  	                        body = this.parseFunctionSourceElements();
  	                        this.context.allowIn = previousAllowIn;
  	                    }
  	                    else {
  	                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
  	                    }
  	                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
  	                    if (this.context.strict && list.firstRestricted) {
  	                        this.throwUnexpectedToken(list.firstRestricted, list.message);
  	                    }
  	                    if (this.context.strict && list.stricted) {
  	                        this.tolerateUnexpectedToken(list.stricted, list.message);
  	                    }
  	                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) :
  	                        this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
  	                    this.context.strict = previousStrict;
  	                    this.context.allowStrictDirective = previousAllowStrictDirective;
  	                    this.context.allowYield = previousAllowYield;
  	                    this.context.await = previousAwait;
  	                }
  	            }
  	            else {
  	                if (this.matchAssign()) {
  	                    if (!this.context.isAssignmentTarget) {
  	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
  	                    }
  	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
  	                        var id = expr;
  	                        if (this.scanner.isRestrictedWord(id.name)) {
  	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
  	                        }
  	                        if (this.scanner.isStrictModeReservedWord(id.name)) {
  	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
  	                        }
  	                    }
  	                    if (!this.match('=')) {
  	                        this.context.isAssignmentTarget = false;
  	                        this.context.isBindingElement = false;
  	                    }
  	                    else {
  	                        this.reinterpretExpressionAsPattern(expr);
  	                    }
  	                    token = this.nextToken();
  	                    var operator = token.value;
  	                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
  	                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
  	                    this.context.firstCoverInitializedNameError = null;
  	                }
  	            }
  	        }
  	        return expr;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-comma-operator
  	    Parser.prototype.parseExpression = function () {
  	        var startToken = this.lookahead;
  	        var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
  	        if (this.match(',')) {
  	            var expressions = [];
  	            expressions.push(expr);
  	            while (this.lookahead.type !== 2 /* EOF */) {
  	                if (!this.match(',')) {
  	                    break;
  	                }
  	                this.nextToken();
  	                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
  	            }
  	            expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
  	        }
  	        return expr;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-block
  	    Parser.prototype.parseStatementListItem = function () {
  	        var statement;
  	        this.context.isAssignmentTarget = true;
  	        this.context.isBindingElement = true;
  	        if (this.lookahead.type === 4 /* Keyword */) {
  	            switch (this.lookahead.value) {
  	                case 'export':
  	                    if (!this.context.isModule) {
  	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
  	                    }
  	                    statement = this.parseExportDeclaration();
  	                    break;
  	                case 'import':
  	                    if (!this.context.isModule) {
  	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
  	                    }
  	                    statement = this.parseImportDeclaration();
  	                    break;
  	                case 'const':
  	                    statement = this.parseLexicalDeclaration({ inFor: false });
  	                    break;
  	                case 'function':
  	                    statement = this.parseFunctionDeclaration();
  	                    break;
  	                case 'class':
  	                    statement = this.parseClassDeclaration();
  	                    break;
  	                case 'let':
  	                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
  	                    break;
  	                default:
  	                    statement = this.parseStatement();
  	                    break;
  	            }
  	        }
  	        else {
  	            statement = this.parseStatement();
  	        }
  	        return statement;
  	    };
  	    Parser.prototype.parseBlock = function () {
  	        var node = this.createNode();
  	        this.expect('{');
  	        var block = [];
  	        while (true) {
  	            if (this.match('}')) {
  	                break;
  	            }
  	            block.push(this.parseStatementListItem());
  	        }
  	        this.expect('}');
  	        return this.finalize(node, new Node.BlockStatement(block));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-let-and-const-declarations
  	    Parser.prototype.parseLexicalBinding = function (kind, options) {
  	        var node = this.createNode();
  	        var params = [];
  	        var id = this.parsePattern(params, kind);
  	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
  	            if (this.scanner.isRestrictedWord(id.name)) {
  	                this.tolerateError(messages_1.Messages.StrictVarName);
  	            }
  	        }
  	        var init = null;
  	        if (kind === 'const') {
  	            if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
  	                if (this.match('=')) {
  	                    this.nextToken();
  	                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);
  	                }
  	                else {
  	                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');
  	                }
  	            }
  	        }
  	        else if ((!options.inFor && id.type !== syntax_1.Syntax.Identifier) || this.match('=')) {
  	            this.expect('=');
  	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
  	        }
  	        return this.finalize(node, new Node.VariableDeclarator(id, init));
  	    };
  	    Parser.prototype.parseBindingList = function (kind, options) {
  	        var list = [this.parseLexicalBinding(kind, options)];
  	        while (this.match(',')) {
  	            this.nextToken();
  	            list.push(this.parseLexicalBinding(kind, options));
  	        }
  	        return list;
  	    };
  	    Parser.prototype.isLexicalDeclaration = function () {
  	        var state = this.scanner.saveState();
  	        this.scanner.scanComments();
  	        var next = this.scanner.lex();
  	        this.scanner.restoreState(state);
  	        return (next.type === 3 /* Identifier */) ||
  	            (next.type === 7 /* Punctuator */ && next.value === '[') ||
  	            (next.type === 7 /* Punctuator */ && next.value === '{') ||
  	            (next.type === 4 /* Keyword */ && next.value === 'let') ||
  	            (next.type === 4 /* Keyword */ && next.value === 'yield');
  	    };
  	    Parser.prototype.parseLexicalDeclaration = function (options) {
  	        var node = this.createNode();
  	        var kind = this.nextToken().value;
  	        assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
  	        var declarations = this.parseBindingList(kind, options);
  	        this.consumeSemicolon();
  	        return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
  	    Parser.prototype.parseBindingRestElement = function (params, kind) {
  	        var node = this.createNode();
  	        this.expect('...');
  	        var arg = this.parsePattern(params, kind);
  	        return this.finalize(node, new Node.RestElement(arg));
  	    };
  	    Parser.prototype.parseArrayPattern = function (params, kind) {
  	        var node = this.createNode();
  	        this.expect('[');
  	        var elements = [];
  	        while (!this.match(']')) {
  	            if (this.match(',')) {
  	                this.nextToken();
  	                elements.push(null);
  	            }
  	            else {
  	                if (this.match('...')) {
  	                    elements.push(this.parseBindingRestElement(params, kind));
  	                    break;
  	                }
  	                else {
  	                    elements.push(this.parsePatternWithDefault(params, kind));
  	                }
  	                if (!this.match(']')) {
  	                    this.expect(',');
  	                }
  	            }
  	        }
  	        this.expect(']');
  	        return this.finalize(node, new Node.ArrayPattern(elements));
  	    };
  	    Parser.prototype.parsePropertyPattern = function (params, kind) {
  	        var node = this.createNode();
  	        var computed = false;
  	        var shorthand = false;
  	        var method = false;
  	        var key;
  	        var value;
  	        if (this.lookahead.type === 3 /* Identifier */) {
  	            var keyToken = this.lookahead;
  	            key = this.parseVariableIdentifier();
  	            var init = this.finalize(node, new Node.Identifier(keyToken.value));
  	            if (this.match('=')) {
  	                params.push(keyToken);
  	                shorthand = true;
  	                this.nextToken();
  	                var expr = this.parseAssignmentExpression();
  	                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
  	            }
  	            else if (!this.match(':')) {
  	                params.push(keyToken);
  	                shorthand = true;
  	                value = init;
  	            }
  	            else {
  	                this.expect(':');
  	                value = this.parsePatternWithDefault(params, kind);
  	            }
  	        }
  	        else {
  	            computed = this.match('[');
  	            key = this.parseObjectPropertyKey();
  	            this.expect(':');
  	            value = this.parsePatternWithDefault(params, kind);
  	        }
  	        return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
  	    };
  	    Parser.prototype.parseObjectPattern = function (params, kind) {
  	        var node = this.createNode();
  	        var properties = [];
  	        this.expect('{');
  	        while (!this.match('}')) {
  	            properties.push(this.parsePropertyPattern(params, kind));
  	            if (!this.match('}')) {
  	                this.expect(',');
  	            }
  	        }
  	        this.expect('}');
  	        return this.finalize(node, new Node.ObjectPattern(properties));
  	    };
  	    Parser.prototype.parsePattern = function (params, kind) {
  	        var pattern;
  	        if (this.match('[')) {
  	            pattern = this.parseArrayPattern(params, kind);
  	        }
  	        else if (this.match('{')) {
  	            pattern = this.parseObjectPattern(params, kind);
  	        }
  	        else {
  	            if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
  	                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
  	            }
  	            params.push(this.lookahead);
  	            pattern = this.parseVariableIdentifier(kind);
  	        }
  	        return pattern;
  	    };
  	    Parser.prototype.parsePatternWithDefault = function (params, kind) {
  	        var startToken = this.lookahead;
  	        var pattern = this.parsePattern(params, kind);
  	        if (this.match('=')) {
  	            this.nextToken();
  	            var previousAllowYield = this.context.allowYield;
  	            this.context.allowYield = true;
  	            var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
  	            this.context.allowYield = previousAllowYield;
  	            pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
  	        }
  	        return pattern;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-variable-statement
  	    Parser.prototype.parseVariableIdentifier = function (kind) {
  	        var node = this.createNode();
  	        var token = this.nextToken();
  	        if (token.type === 4 /* Keyword */ && token.value === 'yield') {
  	            if (this.context.strict) {
  	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
  	            }
  	            else if (!this.context.allowYield) {
  	                this.throwUnexpectedToken(token);
  	            }
  	        }
  	        else if (token.type !== 3 /* Identifier */) {
  	            if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {
  	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
  	            }
  	            else {
  	                if (this.context.strict || token.value !== 'let' || kind !== 'var') {
  	                    this.throwUnexpectedToken(token);
  	                }
  	            }
  	        }
  	        else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === 'await') {
  	            this.tolerateUnexpectedToken(token);
  	        }
  	        return this.finalize(node, new Node.Identifier(token.value));
  	    };
  	    Parser.prototype.parseVariableDeclaration = function (options) {
  	        var node = this.createNode();
  	        var params = [];
  	        var id = this.parsePattern(params, 'var');
  	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
  	            if (this.scanner.isRestrictedWord(id.name)) {
  	                this.tolerateError(messages_1.Messages.StrictVarName);
  	            }
  	        }
  	        var init = null;
  	        if (this.match('=')) {
  	            this.nextToken();
  	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
  	        }
  	        else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
  	            this.expect('=');
  	        }
  	        return this.finalize(node, new Node.VariableDeclarator(id, init));
  	    };
  	    Parser.prototype.parseVariableDeclarationList = function (options) {
  	        var opt = { inFor: options.inFor };
  	        var list = [];
  	        list.push(this.parseVariableDeclaration(opt));
  	        while (this.match(',')) {
  	            this.nextToken();
  	            list.push(this.parseVariableDeclaration(opt));
  	        }
  	        return list;
  	    };
  	    Parser.prototype.parseVariableStatement = function () {
  	        var node = this.createNode();
  	        this.expectKeyword('var');
  	        var declarations = this.parseVariableDeclarationList({ inFor: false });
  	        this.consumeSemicolon();
  	        return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-empty-statement
  	    Parser.prototype.parseEmptyStatement = function () {
  	        var node = this.createNode();
  	        this.expect(';');
  	        return this.finalize(node, new Node.EmptyStatement());
  	    };
  	    // https://tc39.github.io/ecma262/#sec-expression-statement
  	    Parser.prototype.parseExpressionStatement = function () {
  	        var node = this.createNode();
  	        var expr = this.parseExpression();
  	        this.consumeSemicolon();
  	        return this.finalize(node, new Node.ExpressionStatement(expr));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-if-statement
  	    Parser.prototype.parseIfClause = function () {
  	        if (this.context.strict && this.matchKeyword('function')) {
  	            this.tolerateError(messages_1.Messages.StrictFunction);
  	        }
  	        return this.parseStatement();
  	    };
  	    Parser.prototype.parseIfStatement = function () {
  	        var node = this.createNode();
  	        var consequent;
  	        var alternate = null;
  	        this.expectKeyword('if');
  	        this.expect('(');
  	        var test = this.parseExpression();
  	        if (!this.match(')') && this.config.tolerant) {
  	            this.tolerateUnexpectedToken(this.nextToken());
  	            consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
  	        }
  	        else {
  	            this.expect(')');
  	            consequent = this.parseIfClause();
  	            if (this.matchKeyword('else')) {
  	                this.nextToken();
  	                alternate = this.parseIfClause();
  	            }
  	        }
  	        return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-do-while-statement
  	    Parser.prototype.parseDoWhileStatement = function () {
  	        var node = this.createNode();
  	        this.expectKeyword('do');
  	        var previousInIteration = this.context.inIteration;
  	        this.context.inIteration = true;
  	        var body = this.parseStatement();
  	        this.context.inIteration = previousInIteration;
  	        this.expectKeyword('while');
  	        this.expect('(');
  	        var test = this.parseExpression();
  	        if (!this.match(')') && this.config.tolerant) {
  	            this.tolerateUnexpectedToken(this.nextToken());
  	        }
  	        else {
  	            this.expect(')');
  	            if (this.match(';')) {
  	                this.nextToken();
  	            }
  	        }
  	        return this.finalize(node, new Node.DoWhileStatement(body, test));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-while-statement
  	    Parser.prototype.parseWhileStatement = function () {
  	        var node = this.createNode();
  	        var body;
  	        this.expectKeyword('while');
  	        this.expect('(');
  	        var test = this.parseExpression();
  	        if (!this.match(')') && this.config.tolerant) {
  	            this.tolerateUnexpectedToken(this.nextToken());
  	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
  	        }
  	        else {
  	            this.expect(')');
  	            var previousInIteration = this.context.inIteration;
  	            this.context.inIteration = true;
  	            body = this.parseStatement();
  	            this.context.inIteration = previousInIteration;
  	        }
  	        return this.finalize(node, new Node.WhileStatement(test, body));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-for-statement
  	    // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
  	    Parser.prototype.parseForStatement = function () {
  	        var init = null;
  	        var test = null;
  	        var update = null;
  	        var forIn = true;
  	        var left, right;
  	        var node = this.createNode();
  	        this.expectKeyword('for');
  	        this.expect('(');
  	        if (this.match(';')) {
  	            this.nextToken();
  	        }
  	        else {
  	            if (this.matchKeyword('var')) {
  	                init = this.createNode();
  	                this.nextToken();
  	                var previousAllowIn = this.context.allowIn;
  	                this.context.allowIn = false;
  	                var declarations = this.parseVariableDeclarationList({ inFor: true });
  	                this.context.allowIn = previousAllowIn;
  	                if (declarations.length === 1 && this.matchKeyword('in')) {
  	                    var decl = declarations[0];
  	                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
  	                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
  	                    }
  	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
  	                    this.nextToken();
  	                    left = init;
  	                    right = this.parseExpression();
  	                    init = null;
  	                }
  	                else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
  	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
  	                    this.nextToken();
  	                    left = init;
  	                    right = this.parseAssignmentExpression();
  	                    init = null;
  	                    forIn = false;
  	                }
  	                else {
  	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
  	                    this.expect(';');
  	                }
  	            }
  	            else if (this.matchKeyword('const') || this.matchKeyword('let')) {
  	                init = this.createNode();
  	                var kind = this.nextToken().value;
  	                if (!this.context.strict && this.lookahead.value === 'in') {
  	                    init = this.finalize(init, new Node.Identifier(kind));
  	                    this.nextToken();
  	                    left = init;
  	                    right = this.parseExpression();
  	                    init = null;
  	                }
  	                else {
  	                    var previousAllowIn = this.context.allowIn;
  	                    this.context.allowIn = false;
  	                    var declarations = this.parseBindingList(kind, { inFor: true });
  	                    this.context.allowIn = previousAllowIn;
  	                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
  	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
  	                        this.nextToken();
  	                        left = init;
  	                        right = this.parseExpression();
  	                        init = null;
  	                    }
  	                    else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
  	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
  	                        this.nextToken();
  	                        left = init;
  	                        right = this.parseAssignmentExpression();
  	                        init = null;
  	                        forIn = false;
  	                    }
  	                    else {
  	                        this.consumeSemicolon();
  	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
  	                    }
  	                }
  	            }
  	            else {
  	                var initStartToken = this.lookahead;
  	                var previousAllowIn = this.context.allowIn;
  	                this.context.allowIn = false;
  	                init = this.inheritCoverGrammar(this.parseAssignmentExpression);
  	                this.context.allowIn = previousAllowIn;
  	                if (this.matchKeyword('in')) {
  	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
  	                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
  	                    }
  	                    this.nextToken();
  	                    this.reinterpretExpressionAsPattern(init);
  	                    left = init;
  	                    right = this.parseExpression();
  	                    init = null;
  	                }
  	                else if (this.matchContextualKeyword('of')) {
  	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
  	                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
  	                    }
  	                    this.nextToken();
  	                    this.reinterpretExpressionAsPattern(init);
  	                    left = init;
  	                    right = this.parseAssignmentExpression();
  	                    init = null;
  	                    forIn = false;
  	                }
  	                else {
  	                    if (this.match(',')) {
  	                        var initSeq = [init];
  	                        while (this.match(',')) {
  	                            this.nextToken();
  	                            initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
  	                        }
  	                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
  	                    }
  	                    this.expect(';');
  	                }
  	            }
  	        }
  	        if (typeof left === 'undefined') {
  	            if (!this.match(';')) {
  	                test = this.parseExpression();
  	            }
  	            this.expect(';');
  	            if (!this.match(')')) {
  	                update = this.parseExpression();
  	            }
  	        }
  	        var body;
  	        if (!this.match(')') && this.config.tolerant) {
  	            this.tolerateUnexpectedToken(this.nextToken());
  	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
  	        }
  	        else {
  	            this.expect(')');
  	            var previousInIteration = this.context.inIteration;
  	            this.context.inIteration = true;
  	            body = this.isolateCoverGrammar(this.parseStatement);
  	            this.context.inIteration = previousInIteration;
  	        }
  	        return (typeof left === 'undefined') ?
  	            this.finalize(node, new Node.ForStatement(init, test, update, body)) :
  	            forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) :
  	                this.finalize(node, new Node.ForOfStatement(left, right, body));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-continue-statement
  	    Parser.prototype.parseContinueStatement = function () {
  	        var node = this.createNode();
  	        this.expectKeyword('continue');
  	        var label = null;
  	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
  	            var id = this.parseVariableIdentifier();
  	            label = id;
  	            var key = '$' + id.name;
  	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
  	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
  	            }
  	        }
  	        this.consumeSemicolon();
  	        if (label === null && !this.context.inIteration) {
  	            this.throwError(messages_1.Messages.IllegalContinue);
  	        }
  	        return this.finalize(node, new Node.ContinueStatement(label));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-break-statement
  	    Parser.prototype.parseBreakStatement = function () {
  	        var node = this.createNode();
  	        this.expectKeyword('break');
  	        var label = null;
  	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
  	            var id = this.parseVariableIdentifier();
  	            var key = '$' + id.name;
  	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
  	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
  	            }
  	            label = id;
  	        }
  	        this.consumeSemicolon();
  	        if (label === null && !this.context.inIteration && !this.context.inSwitch) {
  	            this.throwError(messages_1.Messages.IllegalBreak);
  	        }
  	        return this.finalize(node, new Node.BreakStatement(label));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-return-statement
  	    Parser.prototype.parseReturnStatement = function () {
  	        if (!this.context.inFunctionBody) {
  	            this.tolerateError(messages_1.Messages.IllegalReturn);
  	        }
  	        var node = this.createNode();
  	        this.expectKeyword('return');
  	        var hasArgument = (!this.match(';') && !this.match('}') &&
  	            !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */) ||
  	            this.lookahead.type === 8 /* StringLiteral */ ||
  	            this.lookahead.type === 10 /* Template */;
  	        var argument = hasArgument ? this.parseExpression() : null;
  	        this.consumeSemicolon();
  	        return this.finalize(node, new Node.ReturnStatement(argument));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-with-statement
  	    Parser.prototype.parseWithStatement = function () {
  	        if (this.context.strict) {
  	            this.tolerateError(messages_1.Messages.StrictModeWith);
  	        }
  	        var node = this.createNode();
  	        var body;
  	        this.expectKeyword('with');
  	        this.expect('(');
  	        var object = this.parseExpression();
  	        if (!this.match(')') && this.config.tolerant) {
  	            this.tolerateUnexpectedToken(this.nextToken());
  	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
  	        }
  	        else {
  	            this.expect(')');
  	            body = this.parseStatement();
  	        }
  	        return this.finalize(node, new Node.WithStatement(object, body));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-switch-statement
  	    Parser.prototype.parseSwitchCase = function () {
  	        var node = this.createNode();
  	        var test;
  	        if (this.matchKeyword('default')) {
  	            this.nextToken();
  	            test = null;
  	        }
  	        else {
  	            this.expectKeyword('case');
  	            test = this.parseExpression();
  	        }
  	        this.expect(':');
  	        var consequent = [];
  	        while (true) {
  	            if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
  	                break;
  	            }
  	            consequent.push(this.parseStatementListItem());
  	        }
  	        return this.finalize(node, new Node.SwitchCase(test, consequent));
  	    };
  	    Parser.prototype.parseSwitchStatement = function () {
  	        var node = this.createNode();
  	        this.expectKeyword('switch');
  	        this.expect('(');
  	        var discriminant = this.parseExpression();
  	        this.expect(')');
  	        var previousInSwitch = this.context.inSwitch;
  	        this.context.inSwitch = true;
  	        var cases = [];
  	        var defaultFound = false;
  	        this.expect('{');
  	        while (true) {
  	            if (this.match('}')) {
  	                break;
  	            }
  	            var clause = this.parseSwitchCase();
  	            if (clause.test === null) {
  	                if (defaultFound) {
  	                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
  	                }
  	                defaultFound = true;
  	            }
  	            cases.push(clause);
  	        }
  	        this.expect('}');
  	        this.context.inSwitch = previousInSwitch;
  	        return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-labelled-statements
  	    Parser.prototype.parseLabelledStatement = function () {
  	        var node = this.createNode();
  	        var expr = this.parseExpression();
  	        var statement;
  	        if ((expr.type === syntax_1.Syntax.Identifier) && this.match(':')) {
  	            this.nextToken();
  	            var id = expr;
  	            var key = '$' + id.name;
  	            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
  	                this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
  	            }
  	            this.context.labelSet[key] = true;
  	            var body = void 0;
  	            if (this.matchKeyword('class')) {
  	                this.tolerateUnexpectedToken(this.lookahead);
  	                body = this.parseClassDeclaration();
  	            }
  	            else if (this.matchKeyword('function')) {
  	                var token = this.lookahead;
  	                var declaration = this.parseFunctionDeclaration();
  	                if (this.context.strict) {
  	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
  	                }
  	                else if (declaration.generator) {
  	                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
  	                }
  	                body = declaration;
  	            }
  	            else {
  	                body = this.parseStatement();
  	            }
  	            delete this.context.labelSet[key];
  	            statement = new Node.LabeledStatement(id, body);
  	        }
  	        else {
  	            this.consumeSemicolon();
  	            statement = new Node.ExpressionStatement(expr);
  	        }
  	        return this.finalize(node, statement);
  	    };
  	    // https://tc39.github.io/ecma262/#sec-throw-statement
  	    Parser.prototype.parseThrowStatement = function () {
  	        var node = this.createNode();
  	        this.expectKeyword('throw');
  	        if (this.hasLineTerminator) {
  	            this.throwError(messages_1.Messages.NewlineAfterThrow);
  	        }
  	        var argument = this.parseExpression();
  	        this.consumeSemicolon();
  	        return this.finalize(node, new Node.ThrowStatement(argument));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-try-statement
  	    Parser.prototype.parseCatchClause = function () {
  	        var node = this.createNode();
  	        this.expectKeyword('catch');
  	        this.expect('(');
  	        if (this.match(')')) {
  	            this.throwUnexpectedToken(this.lookahead);
  	        }
  	        var params = [];
  	        var param = this.parsePattern(params);
  	        var paramMap = {};
  	        for (var i = 0; i < params.length; i++) {
  	            var key = '$' + params[i].value;
  	            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
  	                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
  	            }
  	            paramMap[key] = true;
  	        }
  	        if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
  	            if (this.scanner.isRestrictedWord(param.name)) {
  	                this.tolerateError(messages_1.Messages.StrictCatchVariable);
  	            }
  	        }
  	        this.expect(')');
  	        var body = this.parseBlock();
  	        return this.finalize(node, new Node.CatchClause(param, body));
  	    };
  	    Parser.prototype.parseFinallyClause = function () {
  	        this.expectKeyword('finally');
  	        return this.parseBlock();
  	    };
  	    Parser.prototype.parseTryStatement = function () {
  	        var node = this.createNode();
  	        this.expectKeyword('try');
  	        var block = this.parseBlock();
  	        var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
  	        var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
  	        if (!handler && !finalizer) {
  	            this.throwError(messages_1.Messages.NoCatchOrFinally);
  	        }
  	        return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-debugger-statement
  	    Parser.prototype.parseDebuggerStatement = function () {
  	        var node = this.createNode();
  	        this.expectKeyword('debugger');
  	        this.consumeSemicolon();
  	        return this.finalize(node, new Node.DebuggerStatement());
  	    };
  	    // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
  	    Parser.prototype.parseStatement = function () {
  	        var statement;
  	        switch (this.lookahead.type) {
  	            case 1 /* BooleanLiteral */:
  	            case 5 /* NullLiteral */:
  	            case 6 /* NumericLiteral */:
  	            case 8 /* StringLiteral */:
  	            case 10 /* Template */:
  	            case 9 /* RegularExpression */:
  	                statement = this.parseExpressionStatement();
  	                break;
  	            case 7 /* Punctuator */:
  	                var value = this.lookahead.value;
  	                if (value === '{') {
  	                    statement = this.parseBlock();
  	                }
  	                else if (value === '(') {
  	                    statement = this.parseExpressionStatement();
  	                }
  	                else if (value === ';') {
  	                    statement = this.parseEmptyStatement();
  	                }
  	                else {
  	                    statement = this.parseExpressionStatement();
  	                }
  	                break;
  	            case 3 /* Identifier */:
  	                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
  	                break;
  	            case 4 /* Keyword */:
  	                switch (this.lookahead.value) {
  	                    case 'break':
  	                        statement = this.parseBreakStatement();
  	                        break;
  	                    case 'continue':
  	                        statement = this.parseContinueStatement();
  	                        break;
  	                    case 'debugger':
  	                        statement = this.parseDebuggerStatement();
  	                        break;
  	                    case 'do':
  	                        statement = this.parseDoWhileStatement();
  	                        break;
  	                    case 'for':
  	                        statement = this.parseForStatement();
  	                        break;
  	                    case 'function':
  	                        statement = this.parseFunctionDeclaration();
  	                        break;
  	                    case 'if':
  	                        statement = this.parseIfStatement();
  	                        break;
  	                    case 'return':
  	                        statement = this.parseReturnStatement();
  	                        break;
  	                    case 'switch':
  	                        statement = this.parseSwitchStatement();
  	                        break;
  	                    case 'throw':
  	                        statement = this.parseThrowStatement();
  	                        break;
  	                    case 'try':
  	                        statement = this.parseTryStatement();
  	                        break;
  	                    case 'var':
  	                        statement = this.parseVariableStatement();
  	                        break;
  	                    case 'while':
  	                        statement = this.parseWhileStatement();
  	                        break;
  	                    case 'with':
  	                        statement = this.parseWithStatement();
  	                        break;
  	                    default:
  	                        statement = this.parseExpressionStatement();
  	                        break;
  	                }
  	                break;
  	            default:
  	                statement = this.throwUnexpectedToken(this.lookahead);
  	        }
  	        return statement;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-function-definitions
  	    Parser.prototype.parseFunctionSourceElements = function () {
  	        var node = this.createNode();
  	        this.expect('{');
  	        var body = this.parseDirectivePrologues();
  	        var previousLabelSet = this.context.labelSet;
  	        var previousInIteration = this.context.inIteration;
  	        var previousInSwitch = this.context.inSwitch;
  	        var previousInFunctionBody = this.context.inFunctionBody;
  	        this.context.labelSet = {};
  	        this.context.inIteration = false;
  	        this.context.inSwitch = false;
  	        this.context.inFunctionBody = true;
  	        while (this.lookahead.type !== 2 /* EOF */) {
  	            if (this.match('}')) {
  	                break;
  	            }
  	            body.push(this.parseStatementListItem());
  	        }
  	        this.expect('}');
  	        this.context.labelSet = previousLabelSet;
  	        this.context.inIteration = previousInIteration;
  	        this.context.inSwitch = previousInSwitch;
  	        this.context.inFunctionBody = previousInFunctionBody;
  	        return this.finalize(node, new Node.BlockStatement(body));
  	    };
  	    Parser.prototype.validateParam = function (options, param, name) {
  	        var key = '$' + name;
  	        if (this.context.strict) {
  	            if (this.scanner.isRestrictedWord(name)) {
  	                options.stricted = param;
  	                options.message = messages_1.Messages.StrictParamName;
  	            }
  	            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
  	                options.stricted = param;
  	                options.message = messages_1.Messages.StrictParamDupe;
  	            }
  	        }
  	        else if (!options.firstRestricted) {
  	            if (this.scanner.isRestrictedWord(name)) {
  	                options.firstRestricted = param;
  	                options.message = messages_1.Messages.StrictParamName;
  	            }
  	            else if (this.scanner.isStrictModeReservedWord(name)) {
  	                options.firstRestricted = param;
  	                options.message = messages_1.Messages.StrictReservedWord;
  	            }
  	            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
  	                options.stricted = param;
  	                options.message = messages_1.Messages.StrictParamDupe;
  	            }
  	        }
  	        /* istanbul ignore next */
  	        if (typeof Object.defineProperty === 'function') {
  	            Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
  	        }
  	        else {
  	            options.paramSet[key] = true;
  	        }
  	    };
  	    Parser.prototype.parseRestElement = function (params) {
  	        var node = this.createNode();
  	        this.expect('...');
  	        var arg = this.parsePattern(params);
  	        if (this.match('=')) {
  	            this.throwError(messages_1.Messages.DefaultRestParameter);
  	        }
  	        if (!this.match(')')) {
  	            this.throwError(messages_1.Messages.ParameterAfterRestParameter);
  	        }
  	        return this.finalize(node, new Node.RestElement(arg));
  	    };
  	    Parser.prototype.parseFormalParameter = function (options) {
  	        var params = [];
  	        var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
  	        for (var i = 0; i < params.length; i++) {
  	            this.validateParam(options, params[i], params[i].value);
  	        }
  	        options.simple = options.simple && (param instanceof Node.Identifier);
  	        options.params.push(param);
  	    };
  	    Parser.prototype.parseFormalParameters = function (firstRestricted) {
  	        var options;
  	        options = {
  	            simple: true,
  	            params: [],
  	            firstRestricted: firstRestricted
  	        };
  	        this.expect('(');
  	        if (!this.match(')')) {
  	            options.paramSet = {};
  	            while (this.lookahead.type !== 2 /* EOF */) {
  	                this.parseFormalParameter(options);
  	                if (this.match(')')) {
  	                    break;
  	                }
  	                this.expect(',');
  	                if (this.match(')')) {
  	                    break;
  	                }
  	            }
  	        }
  	        this.expect(')');
  	        return {
  	            simple: options.simple,
  	            params: options.params,
  	            stricted: options.stricted,
  	            firstRestricted: options.firstRestricted,
  	            message: options.message
  	        };
  	    };
  	    Parser.prototype.matchAsyncFunction = function () {
  	        var match = this.matchContextualKeyword('async');
  	        if (match) {
  	            var state = this.scanner.saveState();
  	            this.scanner.scanComments();
  	            var next = this.scanner.lex();
  	            this.scanner.restoreState(state);
  	            match = (state.lineNumber === next.lineNumber) && (next.type === 4 /* Keyword */) && (next.value === 'function');
  	        }
  	        return match;
  	    };
  	    Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
  	        var node = this.createNode();
  	        var isAsync = this.matchContextualKeyword('async');
  	        if (isAsync) {
  	            this.nextToken();
  	        }
  	        this.expectKeyword('function');
  	        var isGenerator = isAsync ? false : this.match('*');
  	        if (isGenerator) {
  	            this.nextToken();
  	        }
  	        var message;
  	        var id = null;
  	        var firstRestricted = null;
  	        if (!identifierIsOptional || !this.match('(')) {
  	            var token = this.lookahead;
  	            id = this.parseVariableIdentifier();
  	            if (this.context.strict) {
  	                if (this.scanner.isRestrictedWord(token.value)) {
  	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
  	                }
  	            }
  	            else {
  	                if (this.scanner.isRestrictedWord(token.value)) {
  	                    firstRestricted = token;
  	                    message = messages_1.Messages.StrictFunctionName;
  	                }
  	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
  	                    firstRestricted = token;
  	                    message = messages_1.Messages.StrictReservedWord;
  	                }
  	            }
  	        }
  	        var previousAllowAwait = this.context.await;
  	        var previousAllowYield = this.context.allowYield;
  	        this.context.await = isAsync;
  	        this.context.allowYield = !isGenerator;
  	        var formalParameters = this.parseFormalParameters(firstRestricted);
  	        var params = formalParameters.params;
  	        var stricted = formalParameters.stricted;
  	        firstRestricted = formalParameters.firstRestricted;
  	        if (formalParameters.message) {
  	            message = formalParameters.message;
  	        }
  	        var previousStrict = this.context.strict;
  	        var previousAllowStrictDirective = this.context.allowStrictDirective;
  	        this.context.allowStrictDirective = formalParameters.simple;
  	        var body = this.parseFunctionSourceElements();
  	        if (this.context.strict && firstRestricted) {
  	            this.throwUnexpectedToken(firstRestricted, message);
  	        }
  	        if (this.context.strict && stricted) {
  	            this.tolerateUnexpectedToken(stricted, message);
  	        }
  	        this.context.strict = previousStrict;
  	        this.context.allowStrictDirective = previousAllowStrictDirective;
  	        this.context.await = previousAllowAwait;
  	        this.context.allowYield = previousAllowYield;
  	        return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) :
  	            this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
  	    };
  	    Parser.prototype.parseFunctionExpression = function () {
  	        var node = this.createNode();
  	        var isAsync = this.matchContextualKeyword('async');
  	        if (isAsync) {
  	            this.nextToken();
  	        }
  	        this.expectKeyword('function');
  	        var isGenerator = isAsync ? false : this.match('*');
  	        if (isGenerator) {
  	            this.nextToken();
  	        }
  	        var message;
  	        var id = null;
  	        var firstRestricted;
  	        var previousAllowAwait = this.context.await;
  	        var previousAllowYield = this.context.allowYield;
  	        this.context.await = isAsync;
  	        this.context.allowYield = !isGenerator;
  	        if (!this.match('(')) {
  	            var token = this.lookahead;
  	            id = (!this.context.strict && !isGenerator && this.matchKeyword('yield')) ? this.parseIdentifierName() : this.parseVariableIdentifier();
  	            if (this.context.strict) {
  	                if (this.scanner.isRestrictedWord(token.value)) {
  	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
  	                }
  	            }
  	            else {
  	                if (this.scanner.isRestrictedWord(token.value)) {
  	                    firstRestricted = token;
  	                    message = messages_1.Messages.StrictFunctionName;
  	                }
  	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
  	                    firstRestricted = token;
  	                    message = messages_1.Messages.StrictReservedWord;
  	                }
  	            }
  	        }
  	        var formalParameters = this.parseFormalParameters(firstRestricted);
  	        var params = formalParameters.params;
  	        var stricted = formalParameters.stricted;
  	        firstRestricted = formalParameters.firstRestricted;
  	        if (formalParameters.message) {
  	            message = formalParameters.message;
  	        }
  	        var previousStrict = this.context.strict;
  	        var previousAllowStrictDirective = this.context.allowStrictDirective;
  	        this.context.allowStrictDirective = formalParameters.simple;
  	        var body = this.parseFunctionSourceElements();
  	        if (this.context.strict && firstRestricted) {
  	            this.throwUnexpectedToken(firstRestricted, message);
  	        }
  	        if (this.context.strict && stricted) {
  	            this.tolerateUnexpectedToken(stricted, message);
  	        }
  	        this.context.strict = previousStrict;
  	        this.context.allowStrictDirective = previousAllowStrictDirective;
  	        this.context.await = previousAllowAwait;
  	        this.context.allowYield = previousAllowYield;
  	        return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) :
  	            this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
  	    Parser.prototype.parseDirective = function () {
  	        var token = this.lookahead;
  	        var node = this.createNode();
  	        var expr = this.parseExpression();
  	        var directive = (expr.type === syntax_1.Syntax.Literal) ? this.getTokenRaw(token).slice(1, -1) : null;
  	        this.consumeSemicolon();
  	        return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
  	    };
  	    Parser.prototype.parseDirectivePrologues = function () {
  	        var firstRestricted = null;
  	        var body = [];
  	        while (true) {
  	            var token = this.lookahead;
  	            if (token.type !== 8 /* StringLiteral */) {
  	                break;
  	            }
  	            var statement = this.parseDirective();
  	            body.push(statement);
  	            var directive = statement.directive;
  	            if (typeof directive !== 'string') {
  	                break;
  	            }
  	            if (directive === 'use strict') {
  	                this.context.strict = true;
  	                if (firstRestricted) {
  	                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
  	                }
  	                if (!this.context.allowStrictDirective) {
  	                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
  	                }
  	            }
  	            else {
  	                if (!firstRestricted && token.octal) {
  	                    firstRestricted = token;
  	                }
  	            }
  	        }
  	        return body;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-method-definitions
  	    Parser.prototype.qualifiedPropertyName = function (token) {
  	        switch (token.type) {
  	            case 3 /* Identifier */:
  	            case 8 /* StringLiteral */:
  	            case 1 /* BooleanLiteral */:
  	            case 5 /* NullLiteral */:
  	            case 6 /* NumericLiteral */:
  	            case 4 /* Keyword */:
  	                return true;
  	            case 7 /* Punctuator */:
  	                return token.value === '[';
  	            default:
  	                break;
  	        }
  	        return false;
  	    };
  	    Parser.prototype.parseGetterMethod = function () {
  	        var node = this.createNode();
  	        var isGenerator = false;
  	        var previousAllowYield = this.context.allowYield;
  	        this.context.allowYield = !isGenerator;
  	        var formalParameters = this.parseFormalParameters();
  	        if (formalParameters.params.length > 0) {
  	            this.tolerateError(messages_1.Messages.BadGetterArity);
  	        }
  	        var method = this.parsePropertyMethod(formalParameters);
  	        this.context.allowYield = previousAllowYield;
  	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
  	    };
  	    Parser.prototype.parseSetterMethod = function () {
  	        var node = this.createNode();
  	        var isGenerator = false;
  	        var previousAllowYield = this.context.allowYield;
  	        this.context.allowYield = !isGenerator;
  	        var formalParameters = this.parseFormalParameters();
  	        if (formalParameters.params.length !== 1) {
  	            this.tolerateError(messages_1.Messages.BadSetterArity);
  	        }
  	        else if (formalParameters.params[0] instanceof Node.RestElement) {
  	            this.tolerateError(messages_1.Messages.BadSetterRestParameter);
  	        }
  	        var method = this.parsePropertyMethod(formalParameters);
  	        this.context.allowYield = previousAllowYield;
  	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
  	    };
  	    Parser.prototype.parseGeneratorMethod = function () {
  	        var node = this.createNode();
  	        var isGenerator = true;
  	        var previousAllowYield = this.context.allowYield;
  	        this.context.allowYield = true;
  	        var params = this.parseFormalParameters();
  	        this.context.allowYield = false;
  	        var method = this.parsePropertyMethod(params);
  	        this.context.allowYield = previousAllowYield;
  	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-generator-function-definitions
  	    Parser.prototype.isStartOfExpression = function () {
  	        var start = true;
  	        var value = this.lookahead.value;
  	        switch (this.lookahead.type) {
  	            case 7 /* Punctuator */:
  	                start = (value === '[') || (value === '(') || (value === '{') ||
  	                    (value === '+') || (value === '-') ||
  	                    (value === '!') || (value === '~') ||
  	                    (value === '++') || (value === '--') ||
  	                    (value === '/') || (value === '/='); // regular expression literal
  	                break;
  	            case 4 /* Keyword */:
  	                start = (value === 'class') || (value === 'delete') ||
  	                    (value === 'function') || (value === 'let') || (value === 'new') ||
  	                    (value === 'super') || (value === 'this') || (value === 'typeof') ||
  	                    (value === 'void') || (value === 'yield');
  	                break;
  	            default:
  	                break;
  	        }
  	        return start;
  	    };
  	    Parser.prototype.parseYieldExpression = function () {
  	        var node = this.createNode();
  	        this.expectKeyword('yield');
  	        var argument = null;
  	        var delegate = false;
  	        if (!this.hasLineTerminator) {
  	            var previousAllowYield = this.context.allowYield;
  	            this.context.allowYield = false;
  	            delegate = this.match('*');
  	            if (delegate) {
  	                this.nextToken();
  	                argument = this.parseAssignmentExpression();
  	            }
  	            else if (this.isStartOfExpression()) {
  	                argument = this.parseAssignmentExpression();
  	            }
  	            this.context.allowYield = previousAllowYield;
  	        }
  	        return this.finalize(node, new Node.YieldExpression(argument, delegate));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-class-definitions
  	    Parser.prototype.parseClassElement = function (hasConstructor) {
  	        var token = this.lookahead;
  	        var node = this.createNode();
  	        var kind = '';
  	        var key = null;
  	        var value = null;
  	        var computed = false;
  	        var method = false;
  	        var isStatic = false;
  	        var isAsync = false;
  	        if (this.match('*')) {
  	            this.nextToken();
  	        }
  	        else {
  	            computed = this.match('[');
  	            key = this.parseObjectPropertyKey();
  	            var id = key;
  	            if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
  	                token = this.lookahead;
  	                isStatic = true;
  	                computed = this.match('[');
  	                if (this.match('*')) {
  	                    this.nextToken();
  	                }
  	                else {
  	                    key = this.parseObjectPropertyKey();
  	                }
  	            }
  	            if ((token.type === 3 /* Identifier */) && !this.hasLineTerminator && (token.value === 'async')) {
  	                var punctuator = this.lookahead.value;
  	                if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {
  	                    isAsync = true;
  	                    token = this.lookahead;
  	                    key = this.parseObjectPropertyKey();
  	                    if (token.type === 3 /* Identifier */ && token.value === 'constructor') {
  	                        this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
  	                    }
  	                }
  	            }
  	        }
  	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
  	        if (token.type === 3 /* Identifier */) {
  	            if (token.value === 'get' && lookaheadPropertyKey) {
  	                kind = 'get';
  	                computed = this.match('[');
  	                key = this.parseObjectPropertyKey();
  	                this.context.allowYield = false;
  	                value = this.parseGetterMethod();
  	            }
  	            else if (token.value === 'set' && lookaheadPropertyKey) {
  	                kind = 'set';
  	                computed = this.match('[');
  	                key = this.parseObjectPropertyKey();
  	                value = this.parseSetterMethod();
  	            }
  	        }
  	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
  	            kind = 'init';
  	            computed = this.match('[');
  	            key = this.parseObjectPropertyKey();
  	            value = this.parseGeneratorMethod();
  	            method = true;
  	        }
  	        if (!kind && key && this.match('(')) {
  	            kind = 'init';
  	            value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
  	            method = true;
  	        }
  	        if (!kind) {
  	            this.throwUnexpectedToken(this.lookahead);
  	        }
  	        if (kind === 'init') {
  	            kind = 'method';
  	        }
  	        if (!computed) {
  	            if (isStatic && this.isPropertyKey(key, 'prototype')) {
  	                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
  	            }
  	            if (!isStatic && this.isPropertyKey(key, 'constructor')) {
  	                if (kind !== 'method' || !method || (value && value.generator)) {
  	                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
  	                }
  	                if (hasConstructor.value) {
  	                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
  	                }
  	                else {
  	                    hasConstructor.value = true;
  	                }
  	                kind = 'constructor';
  	            }
  	        }
  	        return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
  	    };
  	    Parser.prototype.parseClassElementList = function () {
  	        var body = [];
  	        var hasConstructor = { value: false };
  	        this.expect('{');
  	        while (!this.match('}')) {
  	            if (this.match(';')) {
  	                this.nextToken();
  	            }
  	            else {
  	                body.push(this.parseClassElement(hasConstructor));
  	            }
  	        }
  	        this.expect('}');
  	        return body;
  	    };
  	    Parser.prototype.parseClassBody = function () {
  	        var node = this.createNode();
  	        var elementList = this.parseClassElementList();
  	        return this.finalize(node, new Node.ClassBody(elementList));
  	    };
  	    Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
  	        var node = this.createNode();
  	        var previousStrict = this.context.strict;
  	        this.context.strict = true;
  	        this.expectKeyword('class');
  	        var id = (identifierIsOptional && (this.lookahead.type !== 3 /* Identifier */)) ? null : this.parseVariableIdentifier();
  	        var superClass = null;
  	        if (this.matchKeyword('extends')) {
  	            this.nextToken();
  	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
  	        }
  	        var classBody = this.parseClassBody();
  	        this.context.strict = previousStrict;
  	        return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
  	    };
  	    Parser.prototype.parseClassExpression = function () {
  	        var node = this.createNode();
  	        var previousStrict = this.context.strict;
  	        this.context.strict = true;
  	        this.expectKeyword('class');
  	        var id = (this.lookahead.type === 3 /* Identifier */) ? this.parseVariableIdentifier() : null;
  	        var superClass = null;
  	        if (this.matchKeyword('extends')) {
  	            this.nextToken();
  	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
  	        }
  	        var classBody = this.parseClassBody();
  	        this.context.strict = previousStrict;
  	        return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-scripts
  	    // https://tc39.github.io/ecma262/#sec-modules
  	    Parser.prototype.parseModule = function () {
  	        this.context.strict = true;
  	        this.context.isModule = true;
  	        this.scanner.isModule = true;
  	        var node = this.createNode();
  	        var body = this.parseDirectivePrologues();
  	        while (this.lookahead.type !== 2 /* EOF */) {
  	            body.push(this.parseStatementListItem());
  	        }
  	        return this.finalize(node, new Node.Module(body));
  	    };
  	    Parser.prototype.parseScript = function () {
  	        var node = this.createNode();
  	        var body = this.parseDirectivePrologues();
  	        while (this.lookahead.type !== 2 /* EOF */) {
  	            body.push(this.parseStatementListItem());
  	        }
  	        return this.finalize(node, new Node.Script(body));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-imports
  	    Parser.prototype.parseModuleSpecifier = function () {
  	        var node = this.createNode();
  	        if (this.lookahead.type !== 8 /* StringLiteral */) {
  	            this.throwError(messages_1.Messages.InvalidModuleSpecifier);
  	        }
  	        var token = this.nextToken();
  	        var raw = this.getTokenRaw(token);
  	        return this.finalize(node, new Node.Literal(token.value, raw));
  	    };
  	    // import {<foo as bar>} ...;
  	    Parser.prototype.parseImportSpecifier = function () {
  	        var node = this.createNode();
  	        var imported;
  	        var local;
  	        if (this.lookahead.type === 3 /* Identifier */) {
  	            imported = this.parseVariableIdentifier();
  	            local = imported;
  	            if (this.matchContextualKeyword('as')) {
  	                this.nextToken();
  	                local = this.parseVariableIdentifier();
  	            }
  	        }
  	        else {
  	            imported = this.parseIdentifierName();
  	            local = imported;
  	            if (this.matchContextualKeyword('as')) {
  	                this.nextToken();
  	                local = this.parseVariableIdentifier();
  	            }
  	            else {
  	                this.throwUnexpectedToken(this.nextToken());
  	            }
  	        }
  	        return this.finalize(node, new Node.ImportSpecifier(local, imported));
  	    };
  	    // {foo, bar as bas}
  	    Parser.prototype.parseNamedImports = function () {
  	        this.expect('{');
  	        var specifiers = [];
  	        while (!this.match('}')) {
  	            specifiers.push(this.parseImportSpecifier());
  	            if (!this.match('}')) {
  	                this.expect(',');
  	            }
  	        }
  	        this.expect('}');
  	        return specifiers;
  	    };
  	    // import <foo> ...;
  	    Parser.prototype.parseImportDefaultSpecifier = function () {
  	        var node = this.createNode();
  	        var local = this.parseIdentifierName();
  	        return this.finalize(node, new Node.ImportDefaultSpecifier(local));
  	    };
  	    // import <* as foo> ...;
  	    Parser.prototype.parseImportNamespaceSpecifier = function () {
  	        var node = this.createNode();
  	        this.expect('*');
  	        if (!this.matchContextualKeyword('as')) {
  	            this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
  	        }
  	        this.nextToken();
  	        var local = this.parseIdentifierName();
  	        return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
  	    };
  	    Parser.prototype.parseImportDeclaration = function () {
  	        if (this.context.inFunctionBody) {
  	            this.throwError(messages_1.Messages.IllegalImportDeclaration);
  	        }
  	        var node = this.createNode();
  	        this.expectKeyword('import');
  	        var src;
  	        var specifiers = [];
  	        if (this.lookahead.type === 8 /* StringLiteral */) {
  	            // import 'foo';
  	            src = this.parseModuleSpecifier();
  	        }
  	        else {
  	            if (this.match('{')) {
  	                // import {bar}
  	                specifiers = specifiers.concat(this.parseNamedImports());
  	            }
  	            else if (this.match('*')) {
  	                // import * as foo
  	                specifiers.push(this.parseImportNamespaceSpecifier());
  	            }
  	            else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
  	                // import foo
  	                specifiers.push(this.parseImportDefaultSpecifier());
  	                if (this.match(',')) {
  	                    this.nextToken();
  	                    if (this.match('*')) {
  	                        // import foo, * as foo
  	                        specifiers.push(this.parseImportNamespaceSpecifier());
  	                    }
  	                    else if (this.match('{')) {
  	                        // import foo, {bar}
  	                        specifiers = specifiers.concat(this.parseNamedImports());
  	                    }
  	                    else {
  	                        this.throwUnexpectedToken(this.lookahead);
  	                    }
  	                }
  	            }
  	            else {
  	                this.throwUnexpectedToken(this.nextToken());
  	            }
  	            if (!this.matchContextualKeyword('from')) {
  	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
  	                this.throwError(message, this.lookahead.value);
  	            }
  	            this.nextToken();
  	            src = this.parseModuleSpecifier();
  	        }
  	        this.consumeSemicolon();
  	        return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
  	    };
  	    // https://tc39.github.io/ecma262/#sec-exports
  	    Parser.prototype.parseExportSpecifier = function () {
  	        var node = this.createNode();
  	        var local = this.parseIdentifierName();
  	        var exported = local;
  	        if (this.matchContextualKeyword('as')) {
  	            this.nextToken();
  	            exported = this.parseIdentifierName();
  	        }
  	        return this.finalize(node, new Node.ExportSpecifier(local, exported));
  	    };
  	    Parser.prototype.parseExportDeclaration = function () {
  	        if (this.context.inFunctionBody) {
  	            this.throwError(messages_1.Messages.IllegalExportDeclaration);
  	        }
  	        var node = this.createNode();
  	        this.expectKeyword('export');
  	        var exportDeclaration;
  	        if (this.matchKeyword('default')) {
  	            // export default ...
  	            this.nextToken();
  	            if (this.matchKeyword('function')) {
  	                // export default function foo () {}
  	                // export default function () {}
  	                var declaration = this.parseFunctionDeclaration(true);
  	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
  	            }
  	            else if (this.matchKeyword('class')) {
  	                // export default class foo {}
  	                var declaration = this.parseClassDeclaration(true);
  	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
  	            }
  	            else if (this.matchContextualKeyword('async')) {
  	                // export default async function f () {}
  	                // export default async function () {}
  	                // export default async x => x
  	                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
  	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
  	            }
  	            else {
  	                if (this.matchContextualKeyword('from')) {
  	                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
  	                }
  	                // export default {};
  	                // export default [];
  	                // export default (1 + 2);
  	                var declaration = this.match('{') ? this.parseObjectInitializer() :
  	                    this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
  	                this.consumeSemicolon();
  	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
  	            }
  	        }
  	        else if (this.match('*')) {
  	            // export * from 'foo';
  	            this.nextToken();
  	            if (!this.matchContextualKeyword('from')) {
  	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
  	                this.throwError(message, this.lookahead.value);
  	            }
  	            this.nextToken();
  	            var src = this.parseModuleSpecifier();
  	            this.consumeSemicolon();
  	            exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
  	        }
  	        else if (this.lookahead.type === 4 /* Keyword */) {
  	            // export var f = 1;
  	            var declaration = void 0;
  	            switch (this.lookahead.value) {
  	                case 'let':
  	                case 'const':
  	                    declaration = this.parseLexicalDeclaration({ inFor: false });
  	                    break;
  	                case 'var':
  	                case 'class':
  	                case 'function':
  	                    declaration = this.parseStatementListItem();
  	                    break;
  	                default:
  	                    this.throwUnexpectedToken(this.lookahead);
  	            }
  	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
  	        }
  	        else if (this.matchAsyncFunction()) {
  	            var declaration = this.parseFunctionDeclaration();
  	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
  	        }
  	        else {
  	            var specifiers = [];
  	            var source = null;
  	            var isExportFromIdentifier = false;
  	            this.expect('{');
  	            while (!this.match('}')) {
  	                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
  	                specifiers.push(this.parseExportSpecifier());
  	                if (!this.match('}')) {
  	                    this.expect(',');
  	                }
  	            }
  	            this.expect('}');
  	            if (this.matchContextualKeyword('from')) {
  	                // export {default} from 'foo';
  	                // export {foo} from 'foo';
  	                this.nextToken();
  	                source = this.parseModuleSpecifier();
  	                this.consumeSemicolon();
  	            }
  	            else if (isExportFromIdentifier) {
  	                // export {default}; // missing fromClause
  	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
  	                this.throwError(message, this.lookahead.value);
  	            }
  	            else {
  	                // export {foo};
  	                this.consumeSemicolon();
  	            }
  	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
  	        }
  	        return exportDeclaration;
  	    };
  	    return Parser;
  	}());
  	exports.Parser = Parser;


  /***/ },
  /* 9 */
  /***/ function(module, exports) {

  	"use strict";
  	// Ensure the condition is true, otherwise throw an error.
  	// This is only to have a better contract semantic, i.e. another safety net
  	// to catch a logic error. The condition shall be fulfilled in normal case.
  	// Do NOT use this to enforce a certain condition on any user input.
  	Object.defineProperty(exports, "__esModule", { value: true });
  	function assert(condition, message) {
  	    /* istanbul ignore if */
  	    if (!condition) {
  	        throw new Error('ASSERT: ' + message);
  	    }
  	}
  	exports.assert = assert;


  /***/ },
  /* 10 */
  /***/ function(module, exports) {

  	"use strict";
  	/* tslint:disable:max-classes-per-file */
  	Object.defineProperty(exports, "__esModule", { value: true });
  	var ErrorHandler = (function () {
  	    function ErrorHandler() {
  	        this.errors = [];
  	        this.tolerant = false;
  	    }
  	    ErrorHandler.prototype.recordError = function (error) {
  	        this.errors.push(error);
  	    };
  	    ErrorHandler.prototype.tolerate = function (error) {
  	        if (this.tolerant) {
  	            this.recordError(error);
  	        }
  	        else {
  	            throw error;
  	        }
  	    };
  	    ErrorHandler.prototype.constructError = function (msg, column) {
  	        var error = new Error(msg);
  	        try {
  	            throw error;
  	        }
  	        catch (base) {
  	            /* istanbul ignore else */
  	            if (Object.create && Object.defineProperty) {
  	                error = Object.create(base);
  	                Object.defineProperty(error, 'column', { value: column });
  	            }
  	        }
  	        /* istanbul ignore next */
  	        return error;
  	    };
  	    ErrorHandler.prototype.createError = function (index, line, col, description) {
  	        var msg = 'Line ' + line + ': ' + description;
  	        var error = this.constructError(msg, col);
  	        error.index = index;
  	        error.lineNumber = line;
  	        error.description = description;
  	        return error;
  	    };
  	    ErrorHandler.prototype.throwError = function (index, line, col, description) {
  	        throw this.createError(index, line, col, description);
  	    };
  	    ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
  	        var error = this.createError(index, line, col, description);
  	        if (this.tolerant) {
  	            this.recordError(error);
  	        }
  	        else {
  	            throw error;
  	        }
  	    };
  	    return ErrorHandler;
  	}());
  	exports.ErrorHandler = ErrorHandler;


  /***/ },
  /* 11 */
  /***/ function(module, exports) {

  	"use strict";
  	Object.defineProperty(exports, "__esModule", { value: true });
  	// Error messages should be identical to V8.
  	exports.Messages = {
  	    BadGetterArity: 'Getter must not have any formal parameters',
  	    BadSetterArity: 'Setter must have exactly one formal parameter',
  	    BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
  	    ConstructorIsAsync: 'Class constructor may not be an async method',
  	    ConstructorSpecialMethod: 'Class constructor may not be an accessor',
  	    DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
  	    DefaultRestParameter: 'Unexpected token =',
  	    DuplicateBinding: 'Duplicate binding %0',
  	    DuplicateConstructor: 'A class may only have one constructor',
  	    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
  	    ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
  	    GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
  	    IllegalBreak: 'Illegal break statement',
  	    IllegalContinue: 'Illegal continue statement',
  	    IllegalExportDeclaration: 'Unexpected token',
  	    IllegalImportDeclaration: 'Unexpected token',
  	    IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list',
  	    IllegalReturn: 'Illegal return statement',
  	    InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
  	    InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
  	    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
  	    InvalidLHSInForIn: 'Invalid left-hand side in for-in',
  	    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
  	    InvalidModuleSpecifier: 'Unexpected token',
  	    InvalidRegExp: 'Invalid regular expression',
  	    LetInLexicalBinding: 'let is disallowed as a lexically bound name',
  	    MissingFromClause: 'Unexpected token',
  	    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
  	    NewlineAfterThrow: 'Illegal newline after throw',
  	    NoAsAfterImportNamespace: 'Unexpected token',
  	    NoCatchOrFinally: 'Missing catch or finally after try',
  	    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
  	    Redeclaration: '%0 \'%1\' has already been declared',
  	    StaticPrototype: 'Classes may not have static property named prototype',
  	    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
  	    StrictDelete: 'Delete of an unqualified identifier in strict mode.',
  	    StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
  	    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
  	    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
  	    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
  	    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
  	    StrictModeWith: 'Strict mode code may not include a with statement',
  	    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
  	    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
  	    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
  	    StrictReservedWord: 'Use of future reserved word in strict mode',
  	    StrictVarName: 'Variable name may not be eval or arguments in strict mode',
  	    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
  	    UnexpectedEOS: 'Unexpected end of input',
  	    UnexpectedIdentifier: 'Unexpected identifier',
  	    UnexpectedNumber: 'Unexpected number',
  	    UnexpectedReserved: 'Unexpected reserved word',
  	    UnexpectedString: 'Unexpected string',
  	    UnexpectedTemplate: 'Unexpected quasi %0',
  	    UnexpectedToken: 'Unexpected token %0',
  	    UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
  	    UnknownLabel: 'Undefined label \'%0\'',
  	    UnterminatedRegExp: 'Invalid regular expression: missing /'
  	};


  /***/ },
  /* 12 */
  /***/ function(module, exports, __webpack_require__) {

  	"use strict";
  	Object.defineProperty(exports, "__esModule", { value: true });
  	var assert_1 = __webpack_require__(9);
  	var character_1 = __webpack_require__(4);
  	var messages_1 = __webpack_require__(11);
  	function hexValue(ch) {
  	    return '0123456789abcdef'.indexOf(ch.toLowerCase());
  	}
  	function octalValue(ch) {
  	    return '01234567'.indexOf(ch);
  	}
  	var Scanner = (function () {
  	    function Scanner(code, handler) {
  	        this.source = code;
  	        this.errorHandler = handler;
  	        this.trackComment = false;
  	        this.isModule = false;
  	        this.length = code.length;
  	        this.index = 0;
  	        this.lineNumber = (code.length > 0) ? 1 : 0;
  	        this.lineStart = 0;
  	        this.curlyStack = [];
  	    }
  	    Scanner.prototype.saveState = function () {
  	        return {
  	            index: this.index,
  	            lineNumber: this.lineNumber,
  	            lineStart: this.lineStart
  	        };
  	    };
  	    Scanner.prototype.restoreState = function (state) {
  	        this.index = state.index;
  	        this.lineNumber = state.lineNumber;
  	        this.lineStart = state.lineStart;
  	    };
  	    Scanner.prototype.eof = function () {
  	        return this.index >= this.length;
  	    };
  	    Scanner.prototype.throwUnexpectedToken = function (message) {
  	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
  	        return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
  	    };
  	    Scanner.prototype.tolerateUnexpectedToken = function (message) {
  	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
  	        this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
  	    };
  	    // https://tc39.github.io/ecma262/#sec-comments
  	    Scanner.prototype.skipSingleLineComment = function (offset) {
  	        var comments = [];
  	        var start, loc;
  	        if (this.trackComment) {
  	            comments = [];
  	            start = this.index - offset;
  	            loc = {
  	                start: {
  	                    line: this.lineNumber,
  	                    column: this.index - this.lineStart - offset
  	                },
  	                end: {}
  	            };
  	        }
  	        while (!this.eof()) {
  	            var ch = this.source.charCodeAt(this.index);
  	            ++this.index;
  	            if (character_1.Character.isLineTerminator(ch)) {
  	                if (this.trackComment) {
  	                    loc.end = {
  	                        line: this.lineNumber,
  	                        column: this.index - this.lineStart - 1
  	                    };
  	                    var entry = {
  	                        multiLine: false,
  	                        slice: [start + offset, this.index - 1],
  	                        range: [start, this.index - 1],
  	                        loc: loc
  	                    };
  	                    comments.push(entry);
  	                }
  	                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
  	                    ++this.index;
  	                }
  	                ++this.lineNumber;
  	                this.lineStart = this.index;
  	                return comments;
  	            }
  	        }
  	        if (this.trackComment) {
  	            loc.end = {
  	                line: this.lineNumber,
  	                column: this.index - this.lineStart
  	            };
  	            var entry = {
  	                multiLine: false,
  	                slice: [start + offset, this.index],
  	                range: [start, this.index],
  	                loc: loc
  	            };
  	            comments.push(entry);
  	        }
  	        return comments;
  	    };
  	    Scanner.prototype.skipMultiLineComment = function () {
  	        var comments = [];
  	        var start, loc;
  	        if (this.trackComment) {
  	            comments = [];
  	            start = this.index - 2;
  	            loc = {
  	                start: {
  	                    line: this.lineNumber,
  	                    column: this.index - this.lineStart - 2
  	                },
  	                end: {}
  	            };
  	        }
  	        while (!this.eof()) {
  	            var ch = this.source.charCodeAt(this.index);
  	            if (character_1.Character.isLineTerminator(ch)) {
  	                if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
  	                    ++this.index;
  	                }
  	                ++this.lineNumber;
  	                ++this.index;
  	                this.lineStart = this.index;
  	            }
  	            else if (ch === 0x2A) {
  	                // Block comment ends with '*/'.
  	                if (this.source.charCodeAt(this.index + 1) === 0x2F) {
  	                    this.index += 2;
  	                    if (this.trackComment) {
  	                        loc.end = {
  	                            line: this.lineNumber,
  	                            column: this.index - this.lineStart
  	                        };
  	                        var entry = {
  	                            multiLine: true,
  	                            slice: [start + 2, this.index - 2],
  	                            range: [start, this.index],
  	                            loc: loc
  	                        };
  	                        comments.push(entry);
  	                    }
  	                    return comments;
  	                }
  	                ++this.index;
  	            }
  	            else {
  	                ++this.index;
  	            }
  	        }
  	        // Ran off the end of the file - the whole thing is a comment
  	        if (this.trackComment) {
  	            loc.end = {
  	                line: this.lineNumber,
  	                column: this.index - this.lineStart
  	            };
  	            var entry = {
  	                multiLine: true,
  	                slice: [start + 2, this.index],
  	                range: [start, this.index],
  	                loc: loc
  	            };
  	            comments.push(entry);
  	        }
  	        this.tolerateUnexpectedToken();
  	        return comments;
  	    };
  	    Scanner.prototype.scanComments = function () {
  	        var comments;
  	        if (this.trackComment) {
  	            comments = [];
  	        }
  	        var start = (this.index === 0);
  	        while (!this.eof()) {
  	            var ch = this.source.charCodeAt(this.index);
  	            if (character_1.Character.isWhiteSpace(ch)) {
  	                ++this.index;
  	            }
  	            else if (character_1.Character.isLineTerminator(ch)) {
  	                ++this.index;
  	                if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
  	                    ++this.index;
  	                }
  	                ++this.lineNumber;
  	                this.lineStart = this.index;
  	                start = true;
  	            }
  	            else if (ch === 0x2F) {
  	                ch = this.source.charCodeAt(this.index + 1);
  	                if (ch === 0x2F) {
  	                    this.index += 2;
  	                    var comment = this.skipSingleLineComment(2);
  	                    if (this.trackComment) {
  	                        comments = comments.concat(comment);
  	                    }
  	                    start = true;
  	                }
  	                else if (ch === 0x2A) {
  	                    this.index += 2;
  	                    var comment = this.skipMultiLineComment();
  	                    if (this.trackComment) {
  	                        comments = comments.concat(comment);
  	                    }
  	                }
  	                else {
  	                    break;
  	                }
  	            }
  	            else if (start && ch === 0x2D) {
  	                // U+003E is '>'
  	                if ((this.source.charCodeAt(this.index + 1) === 0x2D) && (this.source.charCodeAt(this.index + 2) === 0x3E)) {
  	                    // '-->' is a single-line comment
  	                    this.index += 3;
  	                    var comment = this.skipSingleLineComment(3);
  	                    if (this.trackComment) {
  	                        comments = comments.concat(comment);
  	                    }
  	                }
  	                else {
  	                    break;
  	                }
  	            }
  	            else if (ch === 0x3C && !this.isModule) {
  	                if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
  	                    this.index += 4; // `<!--`
  	                    var comment = this.skipSingleLineComment(4);
  	                    if (this.trackComment) {
  	                        comments = comments.concat(comment);
  	                    }
  	                }
  	                else {
  	                    break;
  	                }
  	            }
  	            else {
  	                break;
  	            }
  	        }
  	        return comments;
  	    };
  	    // https://tc39.github.io/ecma262/#sec-future-reserved-words
  	    Scanner.prototype.isFutureReservedWord = function (id) {
  	        switch (id) {
  	            case 'enum':
  	            case 'export':
  	            case 'import':
  	            case 'super':
  	                return true;
  	            default:
  	                return false;
  	        }
  	    };
  	    Scanner.prototype.isStrictModeReservedWord = function (id) {
  	        switch (id) {
  	            case 'implements':
  	            case 'interface':
  	            case 'package':
  	            case 'private':
  	            case 'protected':
  	            case 'public':
  	            case 'static':
  	            case 'yield':
  	            case 'let':
  	                return true;
  	            default:
  	                return false;
  	        }
  	    };
  	    Scanner.prototype.isRestrictedWord = function (id) {
  	        return id === 'eval' || id === 'arguments';
  	    };
  	    // https://tc39.github.io/ecma262/#sec-keywords
  	    Scanner.prototype.isKeyword = function (id) {
  	        switch (id.length) {
  	            case 2:
  	                return (id === 'if') || (id === 'in') || (id === 'do');
  	            case 3:
  	                return (id === 'var') || (id === 'for') || (id === 'new') ||
  	                    (id === 'try') || (id === 'let');
  	            case 4:
  	                return (id === 'this') || (id === 'else') || (id === 'case') ||
  	                    (id === 'void') || (id === 'with') || (id === 'enum');
  	            case 5:
  	                return (id === 'while') || (id === 'break') || (id === 'catch') ||
  	                    (id === 'throw') || (id === 'const') || (id === 'yield') ||
  	                    (id === 'class') || (id === 'super');
  	            case 6:
  	                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
  	                    (id === 'switch') || (id === 'export') || (id === 'import');
  	            case 7:
  	                return (id === 'default') || (id === 'finally') || (id === 'extends');
  	            case 8:
  	                return (id === 'function') || (id === 'continue') || (id === 'debugger');
  	            case 10:
  	                return (id === 'instanceof');
  	            default:
  	                return false;
  	        }
  	    };
  	    Scanner.prototype.codePointAt = function (i) {
  	        var cp = this.source.charCodeAt(i);
  	        if (cp >= 0xD800 && cp <= 0xDBFF) {
  	            var second = this.source.charCodeAt(i + 1);
  	            if (second >= 0xDC00 && second <= 0xDFFF) {
  	                var first = cp;
  	                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
  	            }
  	        }
  	        return cp;
  	    };
  	    Scanner.prototype.scanHexEscape = function (prefix) {
  	        var len = (prefix === 'u') ? 4 : 2;
  	        var code = 0;
  	        for (var i = 0; i < len; ++i) {
  	            if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
  	                code = code * 16 + hexValue(this.source[this.index++]);
  	            }
  	            else {
  	                return null;
  	            }
  	        }
  	        return String.fromCharCode(code);
  	    };
  	    Scanner.prototype.scanUnicodeCodePointEscape = function () {
  	        var ch = this.source[this.index];
  	        var code = 0;
  	        // At least, one hex digit is required.
  	        if (ch === '}') {
  	            this.throwUnexpectedToken();
  	        }
  	        while (!this.eof()) {
  	            ch = this.source[this.index++];
  	            if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
  	                break;
  	            }
  	            code = code * 16 + hexValue(ch);
  	        }
  	        if (code > 0x10FFFF || ch !== '}') {
  	            this.throwUnexpectedToken();
  	        }
  	        return character_1.Character.fromCodePoint(code);
  	    };
  	    Scanner.prototype.getIdentifier = function () {
  	        var start = this.index++;
  	        while (!this.eof()) {
  	            var ch = this.source.charCodeAt(this.index);
  	            if (ch === 0x5C) {
  	                // Blackslash (U+005C) marks Unicode escape sequence.
  	                this.index = start;
  	                return this.getComplexIdentifier();
  	            }
  	            else if (ch >= 0xD800 && ch < 0xDFFF) {
  	                // Need to handle surrogate pairs.
  	                this.index = start;
  	                return this.getComplexIdentifier();
  	            }
  	            if (character_1.Character.isIdentifierPart(ch)) {
  	                ++this.index;
  	            }
  	            else {
  	                break;
  	            }
  	        }
  	        return this.source.slice(start, this.index);
  	    };
  	    Scanner.prototype.getComplexIdentifier = function () {
  	        var cp = this.codePointAt(this.index);
  	        var id = character_1.Character.fromCodePoint(cp);
  	        this.index += id.length;
  	        // '\u' (U+005C, U+0075) denotes an escaped character.
  	        var ch;
  	        if (cp === 0x5C) {
  	            if (this.source.charCodeAt(this.index) !== 0x75) {
  	                this.throwUnexpectedToken();
  	            }
  	            ++this.index;
  	            if (this.source[this.index] === '{') {
  	                ++this.index;
  	                ch = this.scanUnicodeCodePointEscape();
  	            }
  	            else {
  	                ch = this.scanHexEscape('u');
  	                if (ch === null || ch === '\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
  	                    this.throwUnexpectedToken();
  	                }
  	            }
  	            id = ch;
  	        }
  	        while (!this.eof()) {
  	            cp = this.codePointAt(this.index);
  	            if (!character_1.Character.isIdentifierPart(cp)) {
  	                break;
  	            }
  	            ch = character_1.Character.fromCodePoint(cp);
  	            id += ch;
  	            this.index += ch.length;
  	            // '\u' (U+005C, U+0075) denotes an escaped character.
  	            if (cp === 0x5C) {
  	                id = id.substr(0, id.length - 1);
  	                if (this.source.charCodeAt(this.index) !== 0x75) {
  	                    this.throwUnexpectedToken();
  	                }
  	                ++this.index;
  	                if (this.source[this.index] === '{') {
  	                    ++this.index;
  	                    ch = this.scanUnicodeCodePointEscape();
  	                }
  	                else {
  	                    ch = this.scanHexEscape('u');
  	                    if (ch === null || ch === '\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
  	                        this.throwUnexpectedToken();
  	                    }
  	                }
  	                id += ch;
  	            }
  	        }
  	        return id;
  	    };
  	    Scanner.prototype.octalToDecimal = function (ch) {
  	        // \0 is not octal escape sequence
  	        var octal = (ch !== '0');
  	        var code = octalValue(ch);
  	        if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
  	            octal = true;
  	            code = code * 8 + octalValue(this.source[this.index++]);
  	            // 3 digits are only allowed when string starts
  	            // with 0, 1, 2, 3
  	            if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
  	                code = code * 8 + octalValue(this.source[this.index++]);
  	            }
  	        }
  	        return {
  	            code: code,
  	            octal: octal
  	        };
  	    };
  	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
  	    Scanner.prototype.scanIdentifier = function () {
  	        var type;
  	        var start = this.index;
  	        // Backslash (U+005C) starts an escaped character.
  	        var id = (this.source.charCodeAt(start) === 0x5C) ? this.getComplexIdentifier() : this.getIdentifier();
  	        // There is no keyword or literal with only one character.
  	        // Thus, it must be an identifier.
  	        if (id.length === 1) {
  	            type = 3 /* Identifier */;
  	        }
  	        else if (this.isKeyword(id)) {
  	            type = 4 /* Keyword */;
  	        }
  	        else if (id === 'null') {
  	            type = 5 /* NullLiteral */;
  	        }
  	        else if (id === 'true' || id === 'false') {
  	            type = 1 /* BooleanLiteral */;
  	        }
  	        else {
  	            type = 3 /* Identifier */;
  	        }
  	        if (type !== 3 /* Identifier */ && (start + id.length !== this.index)) {
  	            var restore = this.index;
  	            this.index = start;
  	            this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
  	            this.index = restore;
  	        }
  	        return {
  	            type: type,
  	            value: id,
  	            lineNumber: this.lineNumber,
  	            lineStart: this.lineStart,
  	            start: start,
  	            end: this.index
  	        };
  	    };
  	    // https://tc39.github.io/ecma262/#sec-punctuators
  	    Scanner.prototype.scanPunctuator = function () {
  	        var start = this.index;
  	        // Check for most common single-character punctuators.
  	        var str = this.source[this.index];
  	        switch (str) {
  	            case '(':
  	            case '{':
  	                if (str === '{') {
  	                    this.curlyStack.push('{');
  	                }
  	                ++this.index;
  	                break;
  	            case '.':
  	                ++this.index;
  	                if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
  	                    // Spread operator: ...
  	                    this.index += 2;
  	                    str = '...';
  	                }
  	                break;
  	            case '}':
  	                ++this.index;
  	                this.curlyStack.pop();
  	                break;
  	            case ')':
  	            case ';':
  	            case ',':
  	            case '[':
  	            case ']':
  	            case ':':
  	            case '?':
  	            case '~':
  	                ++this.index;
  	                break;
  	            default:
  	                // 4-character punctuator.
  	                str = this.source.substr(this.index, 4);
  	                if (str === '>>>=') {
  	                    this.index += 4;
  	                }
  	                else {
  	                    // 3-character punctuators.
  	                    str = str.substr(0, 3);
  	                    if (str === '===' || str === '!==' || str === '>>>' ||
  	                        str === '<<=' || str === '>>=' || str === '**=') {
  	                        this.index += 3;
  	                    }
  	                    else {
  	                        // 2-character punctuators.
  	                        str = str.substr(0, 2);
  	                        if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
  	                            str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
  	                            str === '++' || str === '--' || str === '<<' || str === '>>' ||
  	                            str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
  	                            str === '<=' || str === '>=' || str === '=>' || str === '**') {
  	                            this.index += 2;
  	                        }
  	                        else {
  	                            // 1-character punctuators.
  	                            str = this.source[this.index];
  	                            if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
  	                                ++this.index;
  	                            }
  	                        }
  	                    }
  	                }
  	        }
  	        if (this.index === start) {
  	            this.throwUnexpectedToken();
  	        }
  	        return {
  	            type: 7 /* Punctuator */,
  	            value: str,
  	            lineNumber: this.lineNumber,
  	            lineStart: this.lineStart,
  	            start: start,
  	            end: this.index
  	        };
  	    };
  	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
  	    Scanner.prototype.scanHexLiteral = function (start) {
  	        var num = '';
  	        while (!this.eof()) {
  	            if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
  	                break;
  	            }
  	            num += this.source[this.index++];
  	        }
  	        if (num.length === 0) {
  	            this.throwUnexpectedToken();
  	        }
  	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
  	            this.throwUnexpectedToken();
  	        }
  	        return {
  	            type: 6 /* NumericLiteral */,
  	            value: parseInt('0x' + num, 16),
  	            lineNumber: this.lineNumber,
  	            lineStart: this.lineStart,
  	            start: start,
  	            end: this.index
  	        };
  	    };
  	    Scanner.prototype.scanBinaryLiteral = function (start) {
  	        var num = '';
  	        var ch;
  	        while (!this.eof()) {
  	            ch = this.source[this.index];
  	            if (ch !== '0' && ch !== '1') {
  	                break;
  	            }
  	            num += this.source[this.index++];
  	        }
  	        if (num.length === 0) {
  	            // only 0b or 0B
  	            this.throwUnexpectedToken();
  	        }
  	        if (!this.eof()) {
  	            ch = this.source.charCodeAt(this.index);
  	            /* istanbul ignore else */
  	            if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
  	                this.throwUnexpectedToken();
  	            }
  	        }
  	        return {
  	            type: 6 /* NumericLiteral */,
  	            value: parseInt(num, 2),
  	            lineNumber: this.lineNumber,
  	            lineStart: this.lineStart,
  	            start: start,
  	            end: this.index
  	        };
  	    };
  	    Scanner.prototype.scanOctalLiteral = function (prefix, start) {
  	        var num = '';
  	        var octal = false;
  	        if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
  	            octal = true;
  	            num = '0' + this.source[this.index++];
  	        }
  	        else {
  	            ++this.index;
  	        }
  	        while (!this.eof()) {
  	            if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
  	                break;
  	            }
  	            num += this.source[this.index++];
  	        }
  	        if (!octal && num.length === 0) {
  	            // only 0o or 0O
  	            this.throwUnexpectedToken();
  	        }
  	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
  	            this.throwUnexpectedToken();
  	        }
  	        return {
  	            type: 6 /* NumericLiteral */,
  	            value: parseInt(num, 8),
  	            octal: octal,
  	            lineNumber: this.lineNumber,
  	            lineStart: this.lineStart,
  	            start: start,
  	            end: this.index
  	        };
  	    };
  	    Scanner.prototype.isImplicitOctalLiteral = function () {
  	        // Implicit octal, unless there is a non-octal digit.
  	        // (Annex B.1.1 on Numeric Literals)
  	        for (var i = this.index + 1; i < this.length; ++i) {
  	            var ch = this.source[i];
  	            if (ch === '8' || ch === '9') {
  	                return false;
  	            }
  	            if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
  	                return true;
  	            }
  	        }
  	        return true;
  	    };
  	    Scanner.prototype.scanNumericLiteral = function () {
  	        var start = this.index;
  	        var ch = this.source[start];
  	        assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');
  	        var num = '';
  	        if (ch !== '.') {
  	            num = this.source[this.index++];
  	            ch = this.source[this.index];
  	            // Hex number starts with '0x'.
  	            // Octal number starts with '0'.
  	            // Octal number in ES6 starts with '0o'.
  	            // Binary number in ES6 starts with '0b'.
  	            if (num === '0') {
  	                if (ch === 'x' || ch === 'X') {
  	                    ++this.index;
  	                    return this.scanHexLiteral(start);
  	                }
  	                if (ch === 'b' || ch === 'B') {
  	                    ++this.index;
  	                    return this.scanBinaryLiteral(start);
  	                }
  	                if (ch === 'o' || ch === 'O') {
  	                    return this.scanOctalLiteral(ch, start);
  	                }
  	                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
  	                    if (this.isImplicitOctalLiteral()) {
  	                        return this.scanOctalLiteral(ch, start);
  	                    }
  	                }
  	            }
  	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
  	                num += this.source[this.index++];
  	            }
  	            ch = this.source[this.index];
  	        }
  	        if (ch === '.') {
  	            num += this.source[this.index++];
  	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
  	                num += this.source[this.index++];
  	            }
  	            ch = this.source[this.index];
  	        }
  	        if (ch === 'e' || ch === 'E') {
  	            num += this.source[this.index++];
  	            ch = this.source[this.index];
  	            if (ch === '+' || ch === '-') {
  	                num += this.source[this.index++];
  	            }
  	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
  	                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
  	                    num += this.source[this.index++];
  	                }
  	            }
  	            else {
  	                this.throwUnexpectedToken();
  	            }
  	        }
  	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
  	            this.throwUnexpectedToken();
  	        }
  	        return {
  	            type: 6 /* NumericLiteral */,
  	            value: parseFloat(num),
  	            lineNumber: this.lineNumber,
  	            lineStart: this.lineStart,
  	            start: start,
  	            end: this.index
  	        };
  	    };
  	    // https://tc39.github.io/ecma262/#sec-literals-string-literals
  	    Scanner.prototype.scanStringLiteral = function () {
  	        var start = this.index;
  	        var quote = this.source[start];
  	        assert_1.assert((quote === '\'' || quote === '"'), 'String literal must starts with a quote');
  	        ++this.index;
  	        var octal = false;
  	        var str = '';
  	        while (!this.eof()) {
  	            var ch = this.source[this.index++];
  	            if (ch === quote) {
  	                quote = '';
  	                break;
  	            }
  	            else if (ch === '\\') {
  	                ch = this.source[this.index++];
  	                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
  	                    switch (ch) {
  	                        case 'u':
  	                            if (this.source[this.index] === '{') {
  	                                ++this.index;
  	                                str += this.scanUnicodeCodePointEscape();
  	                            }
  	                            else {
  	                                var unescaped_1 = this.scanHexEscape(ch);
  	                                if (unescaped_1 === null) {
  	                                    this.throwUnexpectedToken();
  	                                }
  	                                str += unescaped_1;
  	                            }
  	                            break;
  	                        case 'x':
  	                            var unescaped = this.scanHexEscape(ch);
  	                            if (unescaped === null) {
  	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
  	                            }
  	                            str += unescaped;
  	                            break;
  	                        case 'n':
  	                            str += '\n';
  	                            break;
  	                        case 'r':
  	                            str += '\r';
  	                            break;
  	                        case 't':
  	                            str += '\t';
  	                            break;
  	                        case 'b':
  	                            str += '\b';
  	                            break;
  	                        case 'f':
  	                            str += '\f';
  	                            break;
  	                        case 'v':
  	                            str += '\x0B';
  	                            break;
  	                        case '8':
  	                        case '9':
  	                            str += ch;
  	                            this.tolerateUnexpectedToken();
  	                            break;
  	                        default:
  	                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
  	                                var octToDec = this.octalToDecimal(ch);
  	                                octal = octToDec.octal || octal;
  	                                str += String.fromCharCode(octToDec.code);
  	                            }
  	                            else {
  	                                str += ch;
  	                            }
  	                            break;
  	                    }
  	                }
  	                else {
  	                    ++this.lineNumber;
  	                    if (ch === '\r' && this.source[this.index] === '\n') {
  	                        ++this.index;
  	                    }
  	                    this.lineStart = this.index;
  	                }
  	            }
  	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
  	                break;
  	            }
  	            else {
  	                str += ch;
  	            }
  	        }
  	        if (quote !== '') {
  	            this.index = start;
  	            this.throwUnexpectedToken();
  	        }
  	        return {
  	            type: 8 /* StringLiteral */,
  	            value: str,
  	            octal: octal,
  	            lineNumber: this.lineNumber,
  	            lineStart: this.lineStart,
  	            start: start,
  	            end: this.index
  	        };
  	    };
  	    // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
  	    Scanner.prototype.scanTemplate = function () {
  	        var cooked = '';
  	        var terminated = false;
  	        var start = this.index;
  	        var head = (this.source[start] === '`');
  	        var tail = false;
  	        var rawOffset = 2;
  	        ++this.index;
  	        while (!this.eof()) {
  	            var ch = this.source[this.index++];
  	            if (ch === '`') {
  	                rawOffset = 1;
  	                tail = true;
  	                terminated = true;
  	                break;
  	            }
  	            else if (ch === '$') {
  	                if (this.source[this.index] === '{') {
  	                    this.curlyStack.push('${');
  	                    ++this.index;
  	                    terminated = true;
  	                    break;
  	                }
  	                cooked += ch;
  	            }
  	            else if (ch === '\\') {
  	                ch = this.source[this.index++];
  	                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
  	                    switch (ch) {
  	                        case 'n':
  	                            cooked += '\n';
  	                            break;
  	                        case 'r':
  	                            cooked += '\r';
  	                            break;
  	                        case 't':
  	                            cooked += '\t';
  	                            break;
  	                        case 'u':
  	                            if (this.source[this.index] === '{') {
  	                                ++this.index;
  	                                cooked += this.scanUnicodeCodePointEscape();
  	                            }
  	                            else {
  	                                var restore = this.index;
  	                                var unescaped_2 = this.scanHexEscape(ch);
  	                                if (unescaped_2 !== null) {
  	                                    cooked += unescaped_2;
  	                                }
  	                                else {
  	                                    this.index = restore;
  	                                    cooked += ch;
  	                                }
  	                            }
  	                            break;
  	                        case 'x':
  	                            var unescaped = this.scanHexEscape(ch);
  	                            if (unescaped === null) {
  	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
  	                            }
  	                            cooked += unescaped;
  	                            break;
  	                        case 'b':
  	                            cooked += '\b';
  	                            break;
  	                        case 'f':
  	                            cooked += '\f';
  	                            break;
  	                        case 'v':
  	                            cooked += '\v';
  	                            break;
  	                        default:
  	                            if (ch === '0') {
  	                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
  	                                    // Illegal: \01 \02 and so on
  	                                    this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
  	                                }
  	                                cooked += '\0';
  	                            }
  	                            else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
  	                                // Illegal: \1 \2
  	                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
  	                            }
  	                            else {
  	                                cooked += ch;
  	                            }
  	                            break;
  	                    }
  	                }
  	                else {
  	                    ++this.lineNumber;
  	                    if (ch === '\r' && this.source[this.index] === '\n') {
  	                        ++this.index;
  	                    }
  	                    this.lineStart = this.index;
  	                }
  	            }
  	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
  	                ++this.lineNumber;
  	                if (ch === '\r' && this.source[this.index] === '\n') {
  	                    ++this.index;
  	                }
  	                this.lineStart = this.index;
  	                cooked += '\n';
  	            }
  	            else {
  	                cooked += ch;
  	            }
  	        }
  	        if (!terminated) {
  	            this.throwUnexpectedToken();
  	        }
  	        if (!head) {
  	            this.curlyStack.pop();
  	        }
  	        return {
  	            type: 10 /* Template */,
  	            value: this.source.slice(start + 1, this.index - rawOffset),
  	            cooked: cooked,
  	            head: head,
  	            tail: tail,
  	            lineNumber: this.lineNumber,
  	            lineStart: this.lineStart,
  	            start: start,
  	            end: this.index
  	        };
  	    };
  	    // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
  	    Scanner.prototype.testRegExp = function (pattern, flags) {
  	        // The BMP character to use as a replacement for astral symbols when
  	        // translating an ES6 "u"-flagged pattern to an ES5-compatible
  	        // approximation.
  	        // Note: replacing with '\uFFFF' enables false positives in unlikely
  	        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
  	        // pattern that would not be detected by this substitution.
  	        var astralSubstitute = '\uFFFF';
  	        var tmp = pattern;
  	        var self = this;
  	        if (flags.indexOf('u') >= 0) {
  	            tmp = tmp
  	                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
  	                var codePoint = parseInt($1 || $2, 16);
  	                if (codePoint > 0x10FFFF) {
  	                    self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
  	                }
  	                if (codePoint <= 0xFFFF) {
  	                    return String.fromCharCode(codePoint);
  	                }
  	                return astralSubstitute;
  	            })
  	                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
  	        }
  	        // First, detect invalid regular expressions.
  	        try {
  	            RegExp(tmp);
  	        }
  	        catch (e) {
  	            this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
  	        }
  	        // Return a regular expression object for this pattern-flag pair, or
  	        // `null` in case the current environment doesn't support the flags it
  	        // uses.
  	        try {
  	            return new RegExp(pattern, flags);
  	        }
  	        catch (exception) {
  	            /* istanbul ignore next */
  	            return null;
  	        }
  	    };
  	    Scanner.prototype.scanRegExpBody = function () {
  	        var ch = this.source[this.index];
  	        assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
  	        var str = this.source[this.index++];
  	        var classMarker = false;
  	        var terminated = false;
  	        while (!this.eof()) {
  	            ch = this.source[this.index++];
  	            str += ch;
  	            if (ch === '\\') {
  	                ch = this.source[this.index++];
  	                // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
  	                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
  	                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
  	                }
  	                str += ch;
  	            }
  	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
  	                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
  	            }
  	            else if (classMarker) {
  	                if (ch === ']') {
  	                    classMarker = false;
  	                }
  	            }
  	            else {
  	                if (ch === '/') {
  	                    terminated = true;
  	                    break;
  	                }
  	                else if (ch === '[') {
  	                    classMarker = true;
  	                }
  	            }
  	        }
  	        if (!terminated) {
  	            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
  	        }
  	        // Exclude leading and trailing slash.
  	        return str.substr(1, str.length - 2);
  	    };
  	    Scanner.prototype.scanRegExpFlags = function () {
  	        var str = '';
  	        var flags = '';
  	        while (!this.eof()) {
  	            var ch = this.source[this.index];
  	            if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
  	                break;
  	            }
  	            ++this.index;
  	            if (ch === '\\' && !this.eof()) {
  	                ch = this.source[this.index];
  	                if (ch === 'u') {
  	                    ++this.index;
  	                    var restore = this.index;
  	                    var char = this.scanHexEscape('u');
  	                    if (char !== null) {
  	                        flags += char;
  	                        for (str += '\\u'; restore < this.index; ++restore) {
  	                            str += this.source[restore];
  	                        }
  	                    }
  	                    else {
  	                        this.index = restore;
  	                        flags += 'u';
  	                        str += '\\u';
  	                    }
  	                    this.tolerateUnexpectedToken();
  	                }
  	                else {
  	                    str += '\\';
  	                    this.tolerateUnexpectedToken();
  	                }
  	            }
  	            else {
  	                flags += ch;
  	                str += ch;
  	            }
  	        }
  	        return flags;
  	    };
  	    Scanner.prototype.scanRegExp = function () {
  	        var start = this.index;
  	        var pattern = this.scanRegExpBody();
  	        var flags = this.scanRegExpFlags();
  	        var value = this.testRegExp(pattern, flags);
  	        return {
  	            type: 9 /* RegularExpression */,
  	            value: '',
  	            pattern: pattern,
  	            flags: flags,
  	            regex: value,
  	            lineNumber: this.lineNumber,
  	            lineStart: this.lineStart,
  	            start: start,
  	            end: this.index
  	        };
  	    };
  	    Scanner.prototype.lex = function () {
  	        if (this.eof()) {
  	            return {
  	                type: 2 /* EOF */,
  	                value: '',
  	                lineNumber: this.lineNumber,
  	                lineStart: this.lineStart,
  	                start: this.index,
  	                end: this.index
  	            };
  	        }
  	        var cp = this.source.charCodeAt(this.index);
  	        if (character_1.Character.isIdentifierStart(cp)) {
  	            return this.scanIdentifier();
  	        }
  	        // Very common: ( and ) and ;
  	        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
  	            return this.scanPunctuator();
  	        }
  	        // String literal starts with single quote (U+0027) or double quote (U+0022).
  	        if (cp === 0x27 || cp === 0x22) {
  	            return this.scanStringLiteral();
  	        }
  	        // Dot (.) U+002E can also start a floating-point number, hence the need
  	        // to check the next character.
  	        if (cp === 0x2E) {
  	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
  	                return this.scanNumericLiteral();
  	            }
  	            return this.scanPunctuator();
  	        }
  	        if (character_1.Character.isDecimalDigit(cp)) {
  	            return this.scanNumericLiteral();
  	        }
  	        // Template literals start with ` (U+0060) for template head
  	        // or } (U+007D) for template middle or template tail.
  	        if (cp === 0x60 || (cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${')) {
  	            return this.scanTemplate();
  	        }
  	        // Possible identifier start in a surrogate pair.
  	        if (cp >= 0xD800 && cp < 0xDFFF) {
  	            if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
  	                return this.scanIdentifier();
  	            }
  	        }
  	        return this.scanPunctuator();
  	    };
  	    return Scanner;
  	}());
  	exports.Scanner = Scanner;


  /***/ },
  /* 13 */
  /***/ function(module, exports) {

  	"use strict";
  	Object.defineProperty(exports, "__esModule", { value: true });
  	exports.TokenName = {};
  	exports.TokenName[1 /* BooleanLiteral */] = 'Boolean';
  	exports.TokenName[2 /* EOF */] = '<end>';
  	exports.TokenName[3 /* Identifier */] = 'Identifier';
  	exports.TokenName[4 /* Keyword */] = 'Keyword';
  	exports.TokenName[5 /* NullLiteral */] = 'Null';
  	exports.TokenName[6 /* NumericLiteral */] = 'Numeric';
  	exports.TokenName[7 /* Punctuator */] = 'Punctuator';
  	exports.TokenName[8 /* StringLiteral */] = 'String';
  	exports.TokenName[9 /* RegularExpression */] = 'RegularExpression';
  	exports.TokenName[10 /* Template */] = 'Template';


  /***/ },
  /* 14 */
  /***/ function(module, exports) {

  	"use strict";
  	// Generated by generate-xhtml-entities.js. DO NOT MODIFY!
  	Object.defineProperty(exports, "__esModule", { value: true });
  	exports.XHTMLEntities = {
  	    quot: '\u0022',
  	    amp: '\u0026',
  	    apos: '\u0027',
  	    gt: '\u003E',
  	    nbsp: '\u00A0',
  	    iexcl: '\u00A1',
  	    cent: '\u00A2',
  	    pound: '\u00A3',
  	    curren: '\u00A4',
  	    yen: '\u00A5',
  	    brvbar: '\u00A6',
  	    sect: '\u00A7',
  	    uml: '\u00A8',
  	    copy: '\u00A9',
  	    ordf: '\u00AA',
  	    laquo: '\u00AB',
  	    not: '\u00AC',
  	    shy: '\u00AD',
  	    reg: '\u00AE',
  	    macr: '\u00AF',
  	    deg: '\u00B0',
  	    plusmn: '\u00B1',
  	    sup2: '\u00B2',
  	    sup3: '\u00B3',
  	    acute: '\u00B4',
  	    micro: '\u00B5',
  	    para: '\u00B6',
  	    middot: '\u00B7',
  	    cedil: '\u00B8',
  	    sup1: '\u00B9',
  	    ordm: '\u00BA',
  	    raquo: '\u00BB',
  	    frac14: '\u00BC',
  	    frac12: '\u00BD',
  	    frac34: '\u00BE',
  	    iquest: '\u00BF',
  	    Agrave: '\u00C0',
  	    Aacute: '\u00C1',
  	    Acirc: '\u00C2',
  	    Atilde: '\u00C3',
  	    Auml: '\u00C4',
  	    Aring: '\u00C5',
  	    AElig: '\u00C6',
  	    Ccedil: '\u00C7',
  	    Egrave: '\u00C8',
  	    Eacute: '\u00C9',
  	    Ecirc: '\u00CA',
  	    Euml: '\u00CB',
  	    Igrave: '\u00CC',
  	    Iacute: '\u00CD',
  	    Icirc: '\u00CE',
  	    Iuml: '\u00CF',
  	    ETH: '\u00D0',
  	    Ntilde: '\u00D1',
  	    Ograve: '\u00D2',
  	    Oacute: '\u00D3',
  	    Ocirc: '\u00D4',
  	    Otilde: '\u00D5',
  	    Ouml: '\u00D6',
  	    times: '\u00D7',
  	    Oslash: '\u00D8',
  	    Ugrave: '\u00D9',
  	    Uacute: '\u00DA',
  	    Ucirc: '\u00DB',
  	    Uuml: '\u00DC',
  	    Yacute: '\u00DD',
  	    THORN: '\u00DE',
  	    szlig: '\u00DF',
  	    agrave: '\u00E0',
  	    aacute: '\u00E1',
  	    acirc: '\u00E2',
  	    atilde: '\u00E3',
  	    auml: '\u00E4',
  	    aring: '\u00E5',
  	    aelig: '\u00E6',
  	    ccedil: '\u00E7',
  	    egrave: '\u00E8',
  	    eacute: '\u00E9',
  	    ecirc: '\u00EA',
  	    euml: '\u00EB',
  	    igrave: '\u00EC',
  	    iacute: '\u00ED',
  	    icirc: '\u00EE',
  	    iuml: '\u00EF',
  	    eth: '\u00F0',
  	    ntilde: '\u00F1',
  	    ograve: '\u00F2',
  	    oacute: '\u00F3',
  	    ocirc: '\u00F4',
  	    otilde: '\u00F5',
  	    ouml: '\u00F6',
  	    divide: '\u00F7',
  	    oslash: '\u00F8',
  	    ugrave: '\u00F9',
  	    uacute: '\u00FA',
  	    ucirc: '\u00FB',
  	    uuml: '\u00FC',
  	    yacute: '\u00FD',
  	    thorn: '\u00FE',
  	    yuml: '\u00FF',
  	    OElig: '\u0152',
  	    oelig: '\u0153',
  	    Scaron: '\u0160',
  	    scaron: '\u0161',
  	    Yuml: '\u0178',
  	    fnof: '\u0192',
  	    circ: '\u02C6',
  	    tilde: '\u02DC',
  	    Alpha: '\u0391',
  	    Beta: '\u0392',
  	    Gamma: '\u0393',
  	    Delta: '\u0394',
  	    Epsilon: '\u0395',
  	    Zeta: '\u0396',
  	    Eta: '\u0397',
  	    Theta: '\u0398',
  	    Iota: '\u0399',
  	    Kappa: '\u039A',
  	    Lambda: '\u039B',
  	    Mu: '\u039C',
  	    Nu: '\u039D',
  	    Xi: '\u039E',
  	    Omicron: '\u039F',
  	    Pi: '\u03A0',
  	    Rho: '\u03A1',
  	    Sigma: '\u03A3',
  	    Tau: '\u03A4',
  	    Upsilon: '\u03A5',
  	    Phi: '\u03A6',
  	    Chi: '\u03A7',
  	    Psi: '\u03A8',
  	    Omega: '\u03A9',
  	    alpha: '\u03B1',
  	    beta: '\u03B2',
  	    gamma: '\u03B3',
  	    delta: '\u03B4',
  	    epsilon: '\u03B5',
  	    zeta: '\u03B6',
  	    eta: '\u03B7',
  	    theta: '\u03B8',
  	    iota: '\u03B9',
  	    kappa: '\u03BA',
  	    lambda: '\u03BB',
  	    mu: '\u03BC',
  	    nu: '\u03BD',
  	    xi: '\u03BE',
  	    omicron: '\u03BF',
  	    pi: '\u03C0',
  	    rho: '\u03C1',
  	    sigmaf: '\u03C2',
  	    sigma: '\u03C3',
  	    tau: '\u03C4',
  	    upsilon: '\u03C5',
  	    phi: '\u03C6',
  	    chi: '\u03C7',
  	    psi: '\u03C8',
  	    omega: '\u03C9',
  	    thetasym: '\u03D1',
  	    upsih: '\u03D2',
  	    piv: '\u03D6',
  	    ensp: '\u2002',
  	    emsp: '\u2003',
  	    thinsp: '\u2009',
  	    zwnj: '\u200C',
  	    zwj: '\u200D',
  	    lrm: '\u200E',
  	    rlm: '\u200F',
  	    ndash: '\u2013',
  	    mdash: '\u2014',
  	    lsquo: '\u2018',
  	    rsquo: '\u2019',
  	    sbquo: '\u201A',
  	    ldquo: '\u201C',
  	    rdquo: '\u201D',
  	    bdquo: '\u201E',
  	    dagger: '\u2020',
  	    Dagger: '\u2021',
  	    bull: '\u2022',
  	    hellip: '\u2026',
  	    permil: '\u2030',
  	    prime: '\u2032',
  	    Prime: '\u2033',
  	    lsaquo: '\u2039',
  	    rsaquo: '\u203A',
  	    oline: '\u203E',
  	    frasl: '\u2044',
  	    euro: '\u20AC',
  	    image: '\u2111',
  	    weierp: '\u2118',
  	    real: '\u211C',
  	    trade: '\u2122',
  	    alefsym: '\u2135',
  	    larr: '\u2190',
  	    uarr: '\u2191',
  	    rarr: '\u2192',
  	    darr: '\u2193',
  	    harr: '\u2194',
  	    crarr: '\u21B5',
  	    lArr: '\u21D0',
  	    uArr: '\u21D1',
  	    rArr: '\u21D2',
  	    dArr: '\u21D3',
  	    hArr: '\u21D4',
  	    forall: '\u2200',
  	    part: '\u2202',
  	    exist: '\u2203',
  	    empty: '\u2205',
  	    nabla: '\u2207',
  	    isin: '\u2208',
  	    notin: '\u2209',
  	    ni: '\u220B',
  	    prod: '\u220F',
  	    sum: '\u2211',
  	    minus: '\u2212',
  	    lowast: '\u2217',
  	    radic: '\u221A',
  	    prop: '\u221D',
  	    infin: '\u221E',
  	    ang: '\u2220',
  	    and: '\u2227',
  	    or: '\u2228',
  	    cap: '\u2229',
  	    cup: '\u222A',
  	    int: '\u222B',
  	    there4: '\u2234',
  	    sim: '\u223C',
  	    cong: '\u2245',
  	    asymp: '\u2248',
  	    ne: '\u2260',
  	    equiv: '\u2261',
  	    le: '\u2264',
  	    ge: '\u2265',
  	    sub: '\u2282',
  	    sup: '\u2283',
  	    nsub: '\u2284',
  	    sube: '\u2286',
  	    supe: '\u2287',
  	    oplus: '\u2295',
  	    otimes: '\u2297',
  	    perp: '\u22A5',
  	    sdot: '\u22C5',
  	    lceil: '\u2308',
  	    rceil: '\u2309',
  	    lfloor: '\u230A',
  	    rfloor: '\u230B',
  	    loz: '\u25CA',
  	    spades: '\u2660',
  	    clubs: '\u2663',
  	    hearts: '\u2665',
  	    diams: '\u2666',
  	    lang: '\u27E8',
  	    rang: '\u27E9'
  	};


  /***/ },
  /* 15 */
  /***/ function(module, exports, __webpack_require__) {

  	"use strict";
  	Object.defineProperty(exports, "__esModule", { value: true });
  	var error_handler_1 = __webpack_require__(10);
  	var scanner_1 = __webpack_require__(12);
  	var token_1 = __webpack_require__(13);
  	var Reader = (function () {
  	    function Reader() {
  	        this.values = [];
  	        this.curly = this.paren = -1;
  	    }
  	    // A function following one of those tokens is an expression.
  	    Reader.prototype.beforeFunctionExpression = function (t) {
  	        return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
  	            'return', 'case', 'delete', 'throw', 'void',
  	            // assignment operators
  	            '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',
  	            '&=', '|=', '^=', ',',
  	            // binary/unary operators
  	            '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
  	            '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
  	            '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
  	    };
  	    // Determine if forward slash (/) is an operator or part of a regular expression
  	    // https://github.com/mozilla/sweet.js/wiki/design
  	    Reader.prototype.isRegexStart = function () {
  	        var previous = this.values[this.values.length - 1];
  	        var regex = (previous !== null);
  	        switch (previous) {
  	            case 'this':
  	            case ']':
  	                regex = false;
  	                break;
  	            case ')':
  	                var keyword = this.values[this.paren - 1];
  	                regex = (keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with');
  	                break;
  	            case '}':
  	                // Dividing a function by anything makes little sense,
  	                // but we have to check for that.
  	                regex = false;
  	                if (this.values[this.curly - 3] === 'function') {
  	                    // Anonymous function, e.g. function(){} /42
  	                    var check = this.values[this.curly - 4];
  	                    regex = check ? !this.beforeFunctionExpression(check) : false;
  	                }
  	                else if (this.values[this.curly - 4] === 'function') {
  	                    // Named function, e.g. function f(){} /42/
  	                    var check = this.values[this.curly - 5];
  	                    regex = check ? !this.beforeFunctionExpression(check) : true;
  	                }
  	                break;
  	            default:
  	                break;
  	        }
  	        return regex;
  	    };
  	    Reader.prototype.push = function (token) {
  	        if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {
  	            if (token.value === '{') {
  	                this.curly = this.values.length;
  	            }
  	            else if (token.value === '(') {
  	                this.paren = this.values.length;
  	            }
  	            this.values.push(token.value);
  	        }
  	        else {
  	            this.values.push(null);
  	        }
  	    };
  	    return Reader;
  	}());
  	var Tokenizer = (function () {
  	    function Tokenizer(code, config) {
  	        this.errorHandler = new error_handler_1.ErrorHandler();
  	        this.errorHandler.tolerant = config ? (typeof config.tolerant === 'boolean' && config.tolerant) : false;
  	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
  	        this.scanner.trackComment = config ? (typeof config.comment === 'boolean' && config.comment) : false;
  	        this.trackRange = config ? (typeof config.range === 'boolean' && config.range) : false;
  	        this.trackLoc = config ? (typeof config.loc === 'boolean' && config.loc) : false;
  	        this.buffer = [];
  	        this.reader = new Reader();
  	    }
  	    Tokenizer.prototype.errors = function () {
  	        return this.errorHandler.errors;
  	    };
  	    Tokenizer.prototype.getNextToken = function () {
  	        if (this.buffer.length === 0) {
  	            var comments = this.scanner.scanComments();
  	            if (this.scanner.trackComment) {
  	                for (var i = 0; i < comments.length; ++i) {
  	                    var e = comments[i];
  	                    var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
  	                    var comment = {
  	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
  	                        value: value
  	                    };
  	                    if (this.trackRange) {
  	                        comment.range = e.range;
  	                    }
  	                    if (this.trackLoc) {
  	                        comment.loc = e.loc;
  	                    }
  	                    this.buffer.push(comment);
  	                }
  	            }
  	            if (!this.scanner.eof()) {
  	                var loc = void 0;
  	                if (this.trackLoc) {
  	                    loc = {
  	                        start: {
  	                            line: this.scanner.lineNumber,
  	                            column: this.scanner.index - this.scanner.lineStart
  	                        },
  	                        end: {}
  	                    };
  	                }
  	                var startRegex = (this.scanner.source[this.scanner.index] === '/') && this.reader.isRegexStart();
  	                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
  	                this.reader.push(token);
  	                var entry = {
  	                    type: token_1.TokenName[token.type],
  	                    value: this.scanner.source.slice(token.start, token.end)
  	                };
  	                if (this.trackRange) {
  	                    entry.range = [token.start, token.end];
  	                }
  	                if (this.trackLoc) {
  	                    loc.end = {
  	                        line: this.scanner.lineNumber,
  	                        column: this.scanner.index - this.scanner.lineStart
  	                    };
  	                    entry.loc = loc;
  	                }
  	                if (token.type === 9 /* RegularExpression */) {
  	                    var pattern = token.pattern;
  	                    var flags = token.flags;
  	                    entry.regex = { pattern: pattern, flags: flags };
  	                }
  	                this.buffer.push(entry);
  	            }
  	        }
  	        return this.buffer.shift();
  	    };
  	    return Tokenizer;
  	}());
  	exports.Tokenizer = Tokenizer;


  /***/ }
  /******/ ])
  });
  ;

  /***/ }),
  /* 169 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  /*eslint-disable no-use-before-define*/

  var common              = __webpack_require__(141);
  var YAMLException       = __webpack_require__(142);
  var DEFAULT_FULL_SCHEMA = __webpack_require__(164);
  var DEFAULT_SAFE_SCHEMA = __webpack_require__(144);

  var _toString       = Object.prototype.toString;
  var _hasOwnProperty = Object.prototype.hasOwnProperty;

  var CHAR_TAB                  = 0x09; /* Tab */
  var CHAR_LINE_FEED            = 0x0A; /* LF */
  var CHAR_SPACE                = 0x20; /* Space */
  var CHAR_EXCLAMATION          = 0x21; /* ! */
  var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
  var CHAR_SHARP                = 0x23; /* # */
  var CHAR_PERCENT              = 0x25; /* % */
  var CHAR_AMPERSAND            = 0x26; /* & */
  var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
  var CHAR_ASTERISK             = 0x2A; /* * */
  var CHAR_COMMA                = 0x2C; /* , */
  var CHAR_MINUS                = 0x2D; /* - */
  var CHAR_COLON                = 0x3A; /* : */
  var CHAR_GREATER_THAN         = 0x3E; /* > */
  var CHAR_QUESTION             = 0x3F; /* ? */
  var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
  var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
  var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
  var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
  var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
  var CHAR_VERTICAL_LINE        = 0x7C; /* | */
  var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

  var ESCAPE_SEQUENCES = {};

  ESCAPE_SEQUENCES[0x00]   = '\\0';
  ESCAPE_SEQUENCES[0x07]   = '\\a';
  ESCAPE_SEQUENCES[0x08]   = '\\b';
  ESCAPE_SEQUENCES[0x09]   = '\\t';
  ESCAPE_SEQUENCES[0x0A]   = '\\n';
  ESCAPE_SEQUENCES[0x0B]   = '\\v';
  ESCAPE_SEQUENCES[0x0C]   = '\\f';
  ESCAPE_SEQUENCES[0x0D]   = '\\r';
  ESCAPE_SEQUENCES[0x1B]   = '\\e';
  ESCAPE_SEQUENCES[0x22]   = '\\"';
  ESCAPE_SEQUENCES[0x5C]   = '\\\\';
  ESCAPE_SEQUENCES[0x85]   = '\\N';
  ESCAPE_SEQUENCES[0xA0]   = '\\_';
  ESCAPE_SEQUENCES[0x2028] = '\\L';
  ESCAPE_SEQUENCES[0x2029] = '\\P';

  var DEPRECATED_BOOLEANS_SYNTAX = [
    'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
    'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
  ];

  function compileStyleMap(schema, map) {
    var result, keys, index, length, tag, style, type;

    if (map === null) return {};

    result = {};
    keys = Object.keys(map);

    for (index = 0, length = keys.length; index < length; index += 1) {
      tag = keys[index];
      style = String(map[tag]);

      if (tag.slice(0, 2) === '!!') {
        tag = 'tag:yaml.org,2002:' + tag.slice(2);
      }
      type = schema.compiledTypeMap['fallback'][tag];

      if (type && _hasOwnProperty.call(type.styleAliases, style)) {
        style = type.styleAliases[style];
      }

      result[tag] = style;
    }

    return result;
  }

  function encodeHex(character) {
    var string, handle, length;

    string = character.toString(16).toUpperCase();

    if (character <= 0xFF) {
      handle = 'x';
      length = 2;
    } else if (character <= 0xFFFF) {
      handle = 'u';
      length = 4;
    } else if (character <= 0xFFFFFFFF) {
      handle = 'U';
      length = 8;
    } else {
      throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
    }

    return '\\' + handle + common.repeat('0', length - string.length) + string;
  }

  function State(options) {
    this.schema        = options['schema'] || DEFAULT_FULL_SCHEMA;
    this.indent        = Math.max(1, (options['indent'] || 2));
    this.noArrayIndent = options['noArrayIndent'] || false;
    this.skipInvalid   = options['skipInvalid'] || false;
    this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
    this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
    this.sortKeys      = options['sortKeys'] || false;
    this.lineWidth     = options['lineWidth'] || 80;
    this.noRefs        = options['noRefs'] || false;
    this.noCompatMode  = options['noCompatMode'] || false;
    this.condenseFlow  = options['condenseFlow'] || false;

    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;

    this.tag = null;
    this.result = '';

    this.duplicates = [];
    this.usedDuplicates = null;
  }

  // Indents every line in a string. Empty lines (\n only) are not indented.
  function indentString(string, spaces) {
    var ind = common.repeat(' ', spaces),
        position = 0,
        next = -1,
        result = '',
        line,
        length = string.length;

    while (position < length) {
      next = string.indexOf('\n', position);
      if (next === -1) {
        line = string.slice(position);
        position = length;
      } else {
        line = string.slice(position, next + 1);
        position = next + 1;
      }

      if (line.length && line !== '\n') result += ind;

      result += line;
    }

    return result;
  }

  function generateNextLine(state, level) {
    return '\n' + common.repeat(' ', state.indent * level);
  }

  function testImplicitResolving(state, str) {
    var index, length, type;

    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
      type = state.implicitTypes[index];

      if (type.resolve(str)) {
        return true;
      }
    }

    return false;
  }

  // [33] s-white ::= s-space | s-tab
  function isWhitespace(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
  }

  // Returns true if the character can be printed without escaping.
  // From YAML 1.2: "any allowed characters known to be non-printable
  // should also be escaped. [However,] This isn’t mandatory"
  // Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
  function isPrintable(c) {
    return  (0x00020 <= c && c <= 0x00007E)
        || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
        || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)
        ||  (0x10000 <= c && c <= 0x10FFFF);
  }

  // Simplified test for values allowed after the first character in plain style.
  function isPlainSafe(c) {
    // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
    // where nb-char ::= c-printable - b-char - c-byte-order-mark.
    return isPrintable(c) && c !== 0xFEFF
      // - c-flow-indicator
      && c !== CHAR_COMMA
      && c !== CHAR_LEFT_SQUARE_BRACKET
      && c !== CHAR_RIGHT_SQUARE_BRACKET
      && c !== CHAR_LEFT_CURLY_BRACKET
      && c !== CHAR_RIGHT_CURLY_BRACKET
      // - ":" - "#"
      && c !== CHAR_COLON
      && c !== CHAR_SHARP;
  }

  // Simplified test for values allowed as the first character in plain style.
  function isPlainSafeFirst(c) {
    // Uses a subset of ns-char - c-indicator
    // where ns-char = nb-char - s-white.
    return isPrintable(c) && c !== 0xFEFF
      && !isWhitespace(c) // - s-white
      // - (c-indicator ::=
      // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
      && c !== CHAR_MINUS
      && c !== CHAR_QUESTION
      && c !== CHAR_COLON
      && c !== CHAR_COMMA
      && c !== CHAR_LEFT_SQUARE_BRACKET
      && c !== CHAR_RIGHT_SQUARE_BRACKET
      && c !== CHAR_LEFT_CURLY_BRACKET
      && c !== CHAR_RIGHT_CURLY_BRACKET
      // | “#” | “&” | “*” | “!” | “|” | “>” | “'” | “"”
      && c !== CHAR_SHARP
      && c !== CHAR_AMPERSAND
      && c !== CHAR_ASTERISK
      && c !== CHAR_EXCLAMATION
      && c !== CHAR_VERTICAL_LINE
      && c !== CHAR_GREATER_THAN
      && c !== CHAR_SINGLE_QUOTE
      && c !== CHAR_DOUBLE_QUOTE
      // | “%” | “@” | “`”)
      && c !== CHAR_PERCENT
      && c !== CHAR_COMMERCIAL_AT
      && c !== CHAR_GRAVE_ACCENT;
  }

  // Determines whether block indentation indicator is required.
  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }

  var STYLE_PLAIN   = 1,
      STYLE_SINGLE  = 2,
      STYLE_LITERAL = 3,
      STYLE_FOLDED  = 4,
      STYLE_DOUBLE  = 5;

  // Determines which scalar styles are possible and returns the preferred style.
  // lineWidth = -1 => no limit.
  // Pre-conditions: str.length > 0.
  // Post-conditions:
  //    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
  //    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
  //    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
    var i;
    var char;
    var hasLineBreak = false;
    var hasFoldableLine = false; // only checked if shouldTrackWidth
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1; // count the first line correctly
    var plain = isPlainSafeFirst(string.charCodeAt(0))
            && !isWhitespace(string.charCodeAt(string.length - 1));

    if (singleLineOnly) {
      // Case: no block styles.
      // Check for disallowed characters to rule out plain and single.
      for (i = 0; i < string.length; i++) {
        char = string.charCodeAt(i);
        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char);
      }
    } else {
      // Case: block styles permitted.
      for (i = 0; i < string.length; i++) {
        char = string.charCodeAt(i);
        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true;
          // Check if any line can be folded.
          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine ||
              // Foldable line = too long, and not more-indented.
              (i - previousLineBreak - 1 > lineWidth &&
               string[previousLineBreak + 1] !== ' ');
            previousLineBreak = i;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char);
      }
      // in case the end is missing a \n
      hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
        (i - previousLineBreak - 1 > lineWidth &&
         string[previousLineBreak + 1] !== ' '));
    }
    // Although every style can represent \n without escaping, prefer block styles
    // for multiline, since they're more readable and they don't add empty lines.
    // Also prefer folding a super-long line.
    if (!hasLineBreak && !hasFoldableLine) {
      // Strings interpretable as another type have to be quoted;
      // e.g. the string 'true' vs. the boolean true.
      return plain && !testAmbiguousType(string)
        ? STYLE_PLAIN : STYLE_SINGLE;
    }
    // Edge case: block indentation indicator can only have one digit.
    if (indentPerLevel > 9 && needIndentIndicator(string)) {
      return STYLE_DOUBLE;
    }
    // At this point we know block styles are valid.
    // Prefer literal style unless we want to fold.
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }

  // Note: line breaking/folding is implemented for only the folded style.
  // NB. We drop the last trailing newline (if any) of a returned block scalar
  //  since the dumper adds its own newline. This always works:
  //    • No ending newline => unaffected; already using strip "-" chomping.
  //    • Ending newline    => removed then restored.
  //  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
  function writeScalar(state, string, level, iskey) {
    state.dump = (function () {
      if (string.length === 0) {
        return "''";
      }
      if (!state.noCompatMode &&
          DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
        return "'" + string + "'";
      }

      var indent = state.indent * Math.max(1, level); // no 0-indent scalars
      // As indentation gets deeper, let the width decrease monotonically
      // to the lower bound min(state.lineWidth, 40).
      // Note that this implies
      //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
      //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
      // This behaves better than a constant minimum width which disallows narrower options,
      // or an indent threshold which causes the width to suddenly increase.
      var lineWidth = state.lineWidth === -1
        ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

      // Without knowing if keys are implicit/explicit, assume implicit for safety.
      var singleLineOnly = iskey
        // No block styles in flow mode.
        || (state.flowLevel > -1 && level >= state.flowLevel);
      function testAmbiguity(string) {
        return testImplicitResolving(state, string);
      }

      switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return '|' + blockHeader(string, state.indent)
            + dropEndingNewline(indentString(string, indent));
        case STYLE_FOLDED:
          return '>' + blockHeader(string, state.indent)
            + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string, lineWidth) + '"';
        default:
          throw new YAMLException('impossible error: invalid scalar style');
      }
    }());
  }

  // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

    // note the special case: the string '\n' counts as a "trailing" empty line.
    var clip =          string[string.length - 1] === '\n';
    var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
    var chomp = keep ? '+' : (clip ? '' : '-');

    return indentIndicator + chomp + '\n';
  }

  // (See the note for writeScalar.)
  function dropEndingNewline(string) {
    return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
  }

  // Note: a long line without a suitable break point will exceed the width limit.
  // Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
  function foldString(string, width) {
    // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
    // unless they're before or after a more-indented line, or at the very
    // beginning or end, in which case $k$ maps to $k$.
    // Therefore, parse each chunk as newline(s) followed by a content line.
    var lineRe = /(\n+)([^\n]*)/g;

    // first line (possibly an empty line)
    var result = (function () {
      var nextLF = string.indexOf('\n');
      nextLF = nextLF !== -1 ? nextLF : string.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string.slice(0, nextLF), width);
    }());
    // If we haven't reached the first content line yet, don't add an extra \n.
    var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
    var moreIndented;

    // rest of the lines
    var match;
    while ((match = lineRe.exec(string))) {
      var prefix = match[1], line = match[2];
      moreIndented = (line[0] === ' ');
      result += prefix
        + (!prevMoreIndented && !moreIndented && line !== ''
          ? '\n' : '')
        + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }

    return result;
  }

  // Greedy line breaking.
  // Picks the longest line under the limit each time,
  // otherwise settles for the shortest line over the limit.
  // NB. More-indented lines *cannot* be folded, as that would add an extra \n.
  function foldLine(line, width) {
    if (line === '' || line[0] === ' ') return line;

    // Since a more-indented line adds a \n, breaks can't be followed by a space.
    var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
    var match;
    // start is an inclusive index. end, curr, and next are exclusive.
    var start = 0, end, curr = 0, next = 0;
    var result = '';

    // Invariants: 0 <= start <= length-1.
    //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
    // Inside the loop:
    //   A match implies length >= 2, so curr and next are <= length-2.
    while ((match = breakRe.exec(line))) {
      next = match.index;
      // maintain invariant: curr - start <= width
      if (next - start > width) {
        end = (curr > start) ? curr : next; // derive end <= length-2
        result += '\n' + line.slice(start, end);
        // skip the space that was output as \n
        start = end + 1;                    // derive start <= length-1
      }
      curr = next;
    }

    // By the invariants, start <= length-1, so there is something left over.
    // It is either the whole string or a part starting from non-whitespace.
    result += '\n';
    // Insert a break if the remainder is too long and there is a break available.
    if (line.length - start > width && curr > start) {
      result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
    } else {
      result += line.slice(start);
    }

    return result.slice(1); // drop extra \n joiner
  }

  // Escapes a double-quoted string.
  function escapeString(string) {
    var result = '';
    var char, nextChar;
    var escapeSeq;

    for (var i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
      if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {
        nextChar = string.charCodeAt(i + 1);
        if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {
          // Combine the surrogate pair and store it escaped.
          result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
          // Advance index one extra since we already used that char here.
          i++; continue;
        }
      }
      escapeSeq = ESCAPE_SEQUENCES[char];
      result += !escapeSeq && isPrintable(char)
        ? string[i]
        : escapeSeq || encodeHex(char);
    }

    return result;
  }

  function writeFlowSequence(state, level, object) {
    var _result = '',
        _tag    = state.tag,
        index,
        length;

    for (index = 0, length = object.length; index < length; index += 1) {
      // Write only valid elements.
      if (writeNode(state, level, object[index], false, false)) {
        if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
        _result += state.dump;
      }
    }

    state.tag = _tag;
    state.dump = '[' + _result + ']';
  }

  function writeBlockSequence(state, level, object, compact) {
    var _result = '',
        _tag    = state.tag,
        index,
        length;

    for (index = 0, length = object.length; index < length; index += 1) {
      // Write only valid elements.
      if (writeNode(state, level + 1, object[index], true, true)) {
        if (!compact || index !== 0) {
          _result += generateNextLine(state, level);
        }

        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          _result += '-';
        } else {
          _result += '- ';
        }

        _result += state.dump;
      }
    }

    state.tag = _tag;
    state.dump = _result || '[]'; // Empty sequence if no valid values.
  }

  function writeFlowMapping(state, level, object) {
    var _result       = '',
        _tag          = state.tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        pairBuffer;

    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = state.condenseFlow ? '"' : '';

      if (index !== 0) pairBuffer += ', ';

      objectKey = objectKeyList[index];
      objectValue = object[objectKey];

      if (!writeNode(state, level, objectKey, false, false)) {
        continue; // Skip this pair because of invalid key;
      }

      if (state.dump.length > 1024) pairBuffer += '? ';

      pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

      if (!writeNode(state, level, objectValue, false, false)) {
        continue; // Skip this pair because of invalid value.
      }

      pairBuffer += state.dump;

      // Both key and value are valid.
      _result += pairBuffer;
    }

    state.tag = _tag;
    state.dump = '{' + _result + '}';
  }

  function writeBlockMapping(state, level, object, compact) {
    var _result       = '',
        _tag          = state.tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        explicitPair,
        pairBuffer;

    // Allow sorting keys so that the output file is deterministic
    if (state.sortKeys === true) {
      // Default sorting
      objectKeyList.sort();
    } else if (typeof state.sortKeys === 'function') {
      // Custom sort function
      objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
      // Something is wrong
      throw new YAMLException('sortKeys must be a boolean or a function');
    }

    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = '';

      if (!compact || index !== 0) {
        pairBuffer += generateNextLine(state, level);
      }

      objectKey = objectKeyList[index];
      objectValue = object[objectKey];

      if (!writeNode(state, level + 1, objectKey, true, true, true)) {
        continue; // Skip this pair because of invalid key.
      }

      explicitPair = (state.tag !== null && state.tag !== '?') ||
                     (state.dump && state.dump.length > 1024);

      if (explicitPair) {
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += '?';
        } else {
          pairBuffer += '? ';
        }
      }

      pairBuffer += state.dump;

      if (explicitPair) {
        pairBuffer += generateNextLine(state, level);
      }

      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
        continue; // Skip this pair because of invalid value.
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += ':';
      } else {
        pairBuffer += ': ';
      }

      pairBuffer += state.dump;

      // Both key and value are valid.
      _result += pairBuffer;
    }

    state.tag = _tag;
    state.dump = _result || '{}'; // Empty mapping if no valid pairs.
  }

  function detectType(state, object, explicit) {
    var _result, typeList, index, length, type, style;

    typeList = explicit ? state.explicitTypes : state.implicitTypes;

    for (index = 0, length = typeList.length; index < length; index += 1) {
      type = typeList[index];

      if ((type.instanceOf  || type.predicate) &&
          (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
          (!type.predicate  || type.predicate(object))) {

        state.tag = explicit ? type.tag : '?';

        if (type.represent) {
          style = state.styleMap[type.tag] || type.defaultStyle;

          if (_toString.call(type.represent) === '[object Function]') {
            _result = type.represent(object, style);
          } else if (_hasOwnProperty.call(type.represent, style)) {
            _result = type.represent[style](object, style);
          } else {
            throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
          }

          state.dump = _result;
        }

        return true;
      }
    }

    return false;
  }

  // Serializes `object` and writes it to global `result`.
  // Returns true on success, or false on invalid object.
  //
  function writeNode(state, level, object, block, compact, iskey) {
    state.tag = null;
    state.dump = object;

    if (!detectType(state, object, false)) {
      detectType(state, object, true);
    }

    var type = _toString.call(state.dump);

    if (block) {
      block = (state.flowLevel < 0 || state.flowLevel > level);
    }

    var objectOrArray = type === '[object Object]' || type === '[object Array]',
        duplicateIndex,
        duplicate;

    if (objectOrArray) {
      duplicateIndex = state.duplicates.indexOf(object);
      duplicate = duplicateIndex !== -1;
    }

    if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
      compact = false;
    }

    if (duplicate && state.usedDuplicates[duplicateIndex]) {
      state.dump = '*ref_' + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
        state.usedDuplicates[duplicateIndex] = true;
      }
      if (type === '[object Object]') {
        if (block && (Object.keys(state.dump).length !== 0)) {
          writeBlockMapping(state, level, state.dump, compact);
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + state.dump;
          }
        } else {
          writeFlowMapping(state, level, state.dump);
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
          }
        }
      } else if (type === '[object Array]') {
        var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;
        if (block && (state.dump.length !== 0)) {
          writeBlockSequence(state, arrayLevel, state.dump, compact);
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + state.dump;
          }
        } else {
          writeFlowSequence(state, arrayLevel, state.dump);
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
          }
        }
      } else if (type === '[object String]') {
        if (state.tag !== '?') {
          writeScalar(state, state.dump, level, iskey);
        }
      } else {
        if (state.skipInvalid) return false;
        throw new YAMLException('unacceptable kind of an object to dump ' + type);
      }

      if (state.tag !== null && state.tag !== '?') {
        state.dump = '!<' + state.tag + '> ' + state.dump;
      }
    }

    return true;
  }

  function getDuplicateReferences(object, state) {
    var objects = [],
        duplicatesIndexes = [],
        index,
        length;

    inspectNode(object, objects, duplicatesIndexes);

    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    }
    state.usedDuplicates = new Array(length);
  }

  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList,
        index,
        length;

    if (object !== null && typeof object === 'object') {
      index = objects.indexOf(object);
      if (index !== -1) {
        if (duplicatesIndexes.indexOf(index) === -1) {
          duplicatesIndexes.push(index);
        }
      } else {
        objects.push(object);

        if (Array.isArray(object)) {
          for (index = 0, length = object.length; index < length; index += 1) {
            inspectNode(object[index], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object);

          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }

  function dump(input, options) {
    options = options || {};

    var state = new State(options);

    if (!state.noRefs) getDuplicateReferences(input, state);

    if (writeNode(state, 0, input, true, true)) return state.dump + '\n';

    return '';
  }

  function safeDump(input, options) {
    return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  }

  module.exports.dump     = dump;
  module.exports.safeDump = safeDump;


  /***/ }),
  /* 170 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*
   * Generated by PEG.js 0.10.0.
   *
   * http://pegjs.org/
   */



  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.location = location;
    this.name     = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return "\"" + literalEscape(expectation.text) + "\"";
          },

          "class": function(expectation) {
            var escapedParts = "",
                i;

            for (i = 0; i < expectation.parts.length; i++) {
              escapedParts += expectation.parts[i] instanceof Array
                ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
                : classEscape(expectation.parts[i]);
            }

            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
          },

          any: function(expectation) {
            return "any character";
          },

          end: function(expectation) {
            return "end of input";
          },

          other: function(expectation) {
            return expectation.description;
          }
        };

    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/"/g,  '\\"')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function classEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/\]/g, '\\]')
        .replace(/\^/g, '\\^')
        .replace(/-/g,  '\\-')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }

    function describeExpected(expected) {
      var descriptions = new Array(expected.length),
          i, j;

      for (i = 0; i < expected.length; i++) {
        descriptions[i] = describeExpectation(expected[i]);
      }

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + " or " + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(", ")
            + ", or "
            + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found) {
      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
    }

    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };

  function peg$parse(input, options) {
    options = options !== void 0 ? options : {};

    var peg$FAILED = {},

        peg$startRuleFunctions = { Start: peg$parseStart },
        peg$startRuleFunction  = peg$parseStart,

        peg$c0 = function(statements) { return [].concat(... statements) },
        peg$c1 = "-",
        peg$c2 = peg$literalExpectation("-", false),
        peg$c3 = function(value) { return value },
        peg$c4 = function(statements) { return Object.assign({}, ... statements) },
        peg$c5 = "#",
        peg$c6 = peg$literalExpectation("#", false),
        peg$c7 = peg$anyExpectation(),
        peg$c8 = function() { return {} },
        peg$c9 = ":",
        peg$c10 = peg$literalExpectation(":", false),
        peg$c11 = function(property, value) { return {[property]: value} },
        peg$c12 = ",",
        peg$c13 = peg$literalExpectation(",", false),
        peg$c14 = function(property, other) { return other },
        peg$c15 = function(property, others, value) { return Object.assign({}, ... [property].concat(others).map(property => ({[property]: value}))) },
        peg$c16 = function(statements) { return statements },
        peg$c17 = function(expression) { return expression },
        peg$c18 = peg$otherExpectation("correct indentation"),
        peg$c19 = " ",
        peg$c20 = peg$literalExpectation(" ", false),
        peg$c21 = function(spaces) { return spaces.length === indentLevel * INDENT_STEP },
        peg$c22 = function(spaces) { return spaces.length === (indentLevel + 1) * INDENT_STEP },
        peg$c23 = function() { indentLevel++; return true },
        peg$c24 = function() { indentLevel--; return true },
        peg$c25 = function() { return text() },
        peg$c26 = peg$otherExpectation("pseudostring"),
        peg$c27 = /^[^\r\n\t ?:,\][{}#&*!|>'"%@`\-]/,
        peg$c28 = peg$classExpectation(["\r", "\n", "\t", " ", "?", ":", ",", "]", "[", "{", "}", "#", "&", "*", "!", "|", ">", "'", "\"", "%", "@", "`", "-"], true, false),
        peg$c29 = /^[^\r\n\t ,\][{}:#"']/,
        peg$c30 = peg$classExpectation(["\r", "\n", "\t", " ", ",", "]", "[", "{", "}", ":", "#", "\"", "'"], true, false),
        peg$c31 = function() { return text().replace(/^ *| *$/g, '') },
        peg$c32 = "--",
        peg$c33 = peg$literalExpectation("--", false),
        peg$c34 = /^[a-zA-Z\/0-9]/,
        peg$c35 = peg$classExpectation([["a", "z"], ["A", "Z"], "/", ["0", "9"]], false, false),
        peg$c36 = /^[^\r\n\t :,]/,
        peg$c37 = peg$classExpectation(["\r", "\n", "\t", " ", ":", ","], true, false),
        peg$c38 = "null",
        peg$c39 = peg$literalExpectation("null", false),
        peg$c40 = function() { return null },
        peg$c41 = "true",
        peg$c42 = peg$literalExpectation("true", false),
        peg$c43 = function() { return true },
        peg$c44 = "false",
        peg$c45 = peg$literalExpectation("false", false),
        peg$c46 = function() { return false },
        peg$c47 = peg$otherExpectation("string"),
        peg$c48 = "\"",
        peg$c49 = peg$literalExpectation("\"", false),
        peg$c50 = function() { return "" },
        peg$c51 = function(chars) { return chars },
        peg$c52 = function(chars) { return chars.join(``) },
        peg$c53 = /^[^"\\\0-\x1F\x7F]/,
        peg$c54 = peg$classExpectation(["\"", "\\", ["\0", "\x1F"], "\x7F"], true, false),
        peg$c55 = "\\\"",
        peg$c56 = peg$literalExpectation("\\\"", false),
        peg$c57 = function() { return `"` },
        peg$c58 = "\\\\",
        peg$c59 = peg$literalExpectation("\\\\", false),
        peg$c60 = function() { return `\\` },
        peg$c61 = "\\/",
        peg$c62 = peg$literalExpectation("\\/", false),
        peg$c63 = function() { return `/`  },
        peg$c64 = "\\b",
        peg$c65 = peg$literalExpectation("\\b", false),
        peg$c66 = function() { return `\b` },
        peg$c67 = "\\f",
        peg$c68 = peg$literalExpectation("\\f", false),
        peg$c69 = function() { return `\f` },
        peg$c70 = "\\n",
        peg$c71 = peg$literalExpectation("\\n", false),
        peg$c72 = function() { return `\n` },
        peg$c73 = "\\r",
        peg$c74 = peg$literalExpectation("\\r", false),
        peg$c75 = function() { return `\r` },
        peg$c76 = "\\t",
        peg$c77 = peg$literalExpectation("\\t", false),
        peg$c78 = function() { return `\t` },
        peg$c79 = "\\u",
        peg$c80 = peg$literalExpectation("\\u", false),
        peg$c81 = function(h1, h2, h3, h4) {
              return String.fromCharCode(parseInt(`0x${h1}${h2}${h3}${h4}`));
            },
        peg$c82 = /^[0-9a-fA-F]/,
        peg$c83 = peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false),
        peg$c84 = peg$otherExpectation("blank space"),
        peg$c85 = /^[ \t]/,
        peg$c86 = peg$classExpectation([" ", "\t"], false, false),
        peg$c87 = peg$otherExpectation("white space"),
        peg$c88 = /^[ \t\n\r]/,
        peg$c89 = peg$classExpectation([" ", "\t", "\n", "\r"], false, false),
        peg$c90 = "\r\n",
        peg$c91 = peg$literalExpectation("\r\n", false),
        peg$c92 = "\n",
        peg$c93 = peg$literalExpectation("\n", false),
        peg$c94 = "\r",
        peg$c95 = peg$literalExpectation("\r", false),

        peg$currPos          = 0,
        peg$savedPos         = 0,
        peg$posDetailsCache  = [{ line: 1, column: 1 }],
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildStructuredError(
        [peg$otherExpectation(description)],
        input.substring(peg$savedPos, peg$currPos),
        location
      );
    }

    function error(message, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildSimpleError(message, location);
    }

    function peg$literalExpectation(text, ignoreCase) {
      return { type: "literal", text: text, ignoreCase: ignoreCase };
    }

    function peg$classExpectation(parts, inverted, ignoreCase) {
      return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
    }

    function peg$anyExpectation() {
      return { type: "any" };
    }

    function peg$endExpectation() {
      return { type: "end" };
    }

    function peg$otherExpectation(description) {
      return { type: "other", description: description };
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos], p;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line:   details.line,
          column: details.column
        };

        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails   = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line:   startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line:   endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildSimpleError(message, location) {
      return new peg$SyntaxError(message, null, null, location);
    }

    function peg$buildStructuredError(expected, found, location) {
      return new peg$SyntaxError(
        peg$SyntaxError.buildMessage(expected, found),
        expected,
        found,
        location
      );
    }

    function peg$parseStart() {
      var s0;

      s0 = peg$parsePropertyStatements();

      return s0;
    }

    function peg$parseItemStatements() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseItemStatement();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseItemStatement();
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c0(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseItemStatement() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parseSamedent();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 45) {
          s2 = peg$c1;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c2); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseB();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseExpression();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c3(s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsePropertyStatements() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsePropertyStatement();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsePropertyStatement();
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c4(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsePropertyStatement() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parseB();
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 35) {
          s3 = peg$c5;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c6); }
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$currPos;
          s6 = peg$currPos;
          peg$silentFails++;
          s7 = peg$parseEOL();
          peg$silentFails--;
          if (s7 === peg$FAILED) {
            s6 = void 0;
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          if (s6 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s7 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c7); }
            }
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$currPos;
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$parseEOL();
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c7); }
                }
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseEOL_ANY();
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseEOL_ANY();
            }
          } else {
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c8();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseSamedent();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseName();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseB();
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s4 = peg$c9;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c10); }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseB();
                if (s5 === peg$FAILED) {
                  s5 = null;
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseExpression();
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c11(s2, s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseSamedent();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseLegacyName();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseB();
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                  s4 = peg$c9;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c10); }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseB();
                  if (s5 === peg$FAILED) {
                    s5 = null;
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseExpression();
                    if (s6 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c11(s2, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseSamedent();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseLegacyName();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseB();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseLegacyLiteral();
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseEOL_ANY();
                    if (s6 !== peg$FAILED) {
                      while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$parseEOL_ANY();
                      }
                    } else {
                      s5 = peg$FAILED;
                    }
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c11(s2, s4);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseSamedent();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseLegacyName();
                if (s2 !== peg$FAILED) {
                  s3 = [];
                  s4 = peg$currPos;
                  s5 = peg$parseB();
                  if (s5 === peg$FAILED) {
                    s5 = null;
                  }
                  if (s5 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 44) {
                      s6 = peg$c12;
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c13); }
                    }
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseB();
                      if (s7 === peg$FAILED) {
                        s7 = null;
                      }
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseLegacyName();
                        if (s8 !== peg$FAILED) {
                          peg$savedPos = s4;
                          s5 = peg$c14(s2, s8);
                          s4 = s5;
                        } else {
                          peg$currPos = s4;
                          s4 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                  if (s4 !== peg$FAILED) {
                    while (s4 !== peg$FAILED) {
                      s3.push(s4);
                      s4 = peg$currPos;
                      s5 = peg$parseB();
                      if (s5 === peg$FAILED) {
                        s5 = null;
                      }
                      if (s5 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 44) {
                          s6 = peg$c12;
                          peg$currPos++;
                        } else {
                          s6 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c13); }
                        }
                        if (s6 !== peg$FAILED) {
                          s7 = peg$parseB();
                          if (s7 === peg$FAILED) {
                            s7 = null;
                          }
                          if (s7 !== peg$FAILED) {
                            s8 = peg$parseLegacyName();
                            if (s8 !== peg$FAILED) {
                              peg$savedPos = s4;
                              s5 = peg$c14(s2, s8);
                              s4 = s5;
                            } else {
                              peg$currPos = s4;
                              s4 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s4;
                          s4 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                      }
                    }
                  } else {
                    s3 = peg$FAILED;
                  }
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parseB();
                    if (s4 === peg$FAILED) {
                      s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 58) {
                        s5 = peg$c9;
                        peg$currPos++;
                      } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c10); }
                      }
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parseB();
                        if (s6 === peg$FAILED) {
                          s6 = null;
                        }
                        if (s6 !== peg$FAILED) {
                          s7 = peg$parseExpression();
                          if (s7 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c15(s2, s3, s7);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseExpression() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      s2 = peg$currPos;
      s3 = peg$parseEOL();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseExtradent();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 45) {
            s5 = peg$c1;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c2); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parseB();
            if (s6 !== peg$FAILED) {
              s3 = [s3, s4, s5, s6];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      peg$silentFails--;
      if (s2 !== peg$FAILED) {
        peg$currPos = s1;
        s1 = void 0;
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseEOL_ANY();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseIndent();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseItemStatements();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseDedent();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c16(s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseEOL();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseIndent();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsePropertyStatements();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseDedent();
              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c16(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseLiteral();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseEOL_ANY();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseEOL_ANY();
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c17(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }

      return s0;
    }

    function peg$parseSamedent() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      if (input.charCodeAt(peg$currPos) === 32) {
        s2 = peg$c19;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c20); }
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (input.charCodeAt(peg$currPos) === 32) {
          s2 = peg$c19;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c20); }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = peg$currPos;
        s2 = peg$c21(s1);
        if (s2) {
          s2 = void 0;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c18); }
      }

      return s0;
    }

    function peg$parseExtradent() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (input.charCodeAt(peg$currPos) === 32) {
        s2 = peg$c19;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c20); }
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (input.charCodeAt(peg$currPos) === 32) {
          s2 = peg$c19;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c20); }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = peg$currPos;
        s2 = peg$c22(s1);
        if (s2) {
          s2 = void 0;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseIndent() {
      var s0;

      peg$savedPos = peg$currPos;
      s0 = peg$c23();
      if (s0) {
        s0 = void 0;
      } else {
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseDedent() {
      var s0;

      peg$savedPos = peg$currPos;
      s0 = peg$c24();
      if (s0) {
        s0 = void 0;
      } else {
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseName() {
      var s0;

      s0 = peg$parsestring();
      if (s0 === peg$FAILED) {
        s0 = peg$parsepseudostring();
      }

      return s0;
    }

    function peg$parseLegacyName() {
      var s0, s1, s2;

      s0 = peg$parsestring();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsepseudostringLegacy();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsepseudostringLegacy();
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c25();
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseLiteral() {
      var s0;

      s0 = peg$parsenull();
      if (s0 === peg$FAILED) {
        s0 = peg$parseboolean();
        if (s0 === peg$FAILED) {
          s0 = peg$parsestring();
          if (s0 === peg$FAILED) {
            s0 = peg$parsepseudostring();
          }
        }
      }

      return s0;
    }

    function peg$parseLegacyLiteral() {
      var s0;

      s0 = peg$parsenull();
      if (s0 === peg$FAILED) {
        s0 = peg$parsestring();
        if (s0 === peg$FAILED) {
          s0 = peg$parsepseudostringLegacy();
        }
      }

      return s0;
    }

    function peg$parsepseudostring() {
      var s0, s1, s2, s3, s4, s5;

      peg$silentFails++;
      s0 = peg$currPos;
      if (peg$c27.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c28); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parseB();
        if (s4 === peg$FAILED) {
          s4 = null;
        }
        if (s4 !== peg$FAILED) {
          if (peg$c29.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c30); }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parseB();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            if (peg$c29.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c30); }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c31();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c26); }
      }

      return s0;
    }

    function peg$parsepseudostringLegacy() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c32) {
        s1 = peg$c32;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c33); }
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        if (peg$c34.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c35); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          if (peg$c36.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c37); }
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            if (peg$c36.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c37); }
            }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c31();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsenull() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c38) {
        s1 = peg$c38;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c39); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c40();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseboolean() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c41) {
        s1 = peg$c41;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c42); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c43();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c44) {
          s1 = peg$c44;
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c45); }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c46();
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parsestring() {
      var s0, s1, s2, s3;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 34) {
        s1 = peg$c48;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c49); }
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 34) {
          s2 = peg$c48;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c49); }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c50();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c48;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c49); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsechars();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c48;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c49); }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c51(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c47); }
      }

      return s0;
    }

    function peg$parsechars() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsechar();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsechar();
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c52(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsechar() {
      var s0, s1, s2, s3, s4, s5;

      if (peg$c53.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c54); }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c55) {
          s1 = peg$c55;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c56); }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c57();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c58) {
            s1 = peg$c58;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c59); }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c60();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c61) {
              s1 = peg$c61;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c62); }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c63();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c64) {
                s1 = peg$c64;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c65); }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c66();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c67) {
                  s1 = peg$c67;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c68); }
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c69();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c70) {
                    s1 = peg$c70;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c71); }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c72();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c73) {
                      s1 = peg$c73;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c74); }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c75();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 2) === peg$c76) {
                        s1 = peg$c76;
                        peg$currPos += 2;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c77); }
                      }
                      if (s1 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c78();
                      }
                      s0 = s1;
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 2) === peg$c79) {
                          s1 = peg$c79;
                          peg$currPos += 2;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c80); }
                        }
                        if (s1 !== peg$FAILED) {
                          s2 = peg$parsehexDigit();
                          if (s2 !== peg$FAILED) {
                            s3 = peg$parsehexDigit();
                            if (s3 !== peg$FAILED) {
                              s4 = peg$parsehexDigit();
                              if (s4 !== peg$FAILED) {
                                s5 = peg$parsehexDigit();
                                if (s5 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s1 = peg$c81(s2, s3, s4, s5);
                                  s0 = s1;
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsehexDigit() {
      var s0;

      if (peg$c82.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c83); }
      }

      return s0;
    }

    function peg$parseB() {
      var s0, s1;

      peg$silentFails++;
      s0 = [];
      if (peg$c85.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c86); }
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (peg$c85.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c86); }
          }
        }
      } else {
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c84); }
      }

      return s0;
    }

    function peg$parseS() {
      var s0, s1;

      peg$silentFails++;
      s0 = [];
      if (peg$c88.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c89); }
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (peg$c88.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c89); }
          }
        }
      } else {
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c87); }
      }

      return s0;
    }

    function peg$parseEOL_ANY() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseEOL();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parseB();
        if (s4 === peg$FAILED) {
          s4 = null;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseEOL();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parseB();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseEOL();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseEOL() {
      var s0;

      if (input.substr(peg$currPos, 2) === peg$c90) {
        s0 = peg$c90;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c91); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 10) {
          s0 = peg$c92;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c93); }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 13) {
            s0 = peg$c94;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c95); }
          }
        }
      }

      return s0;
    }


      const INDENT_STEP = 2;

      let indentLevel = 0;


    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }

      throw peg$buildStructuredError(
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }

  module.exports = {
    SyntaxError: peg$SyntaxError,
    parse:       peg$parse
  };


  /***/ }),
  /* 171 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importDefault = (this && this.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const cross_spawn_1 = __importDefault(__webpack_require__(27));
  const stream_1 = __webpack_require__(24);
  var Pipe;
  (function (Pipe) {
      Pipe[Pipe["STDOUT"] = 1] = "STDOUT";
      Pipe[Pipe["STDERR"] = 2] = "STDERR";
  })(Pipe || (Pipe = {}));
  ;
  function nextTick() {
      return new Promise(resolve => {
          process.nextTick(resolve);
      });
  }
  function makeProcess(name, args, opts, spawnOpts) {
      return (stdio) => {
          const stdin = stdio[0] instanceof stream_1.Transform
              ? `pipe`
              : stdio[0];
          const stdout = stdio[1] instanceof stream_1.Transform
              ? `pipe`
              : stdio[1];
          const stderr = stdio[2] instanceof stream_1.Transform
              ? `pipe`
              : stdio[2];
          const child = cross_spawn_1.default(name, args, Object.assign({}, spawnOpts, { stdio: [
                  stdin,
                  stdout,
                  stderr,
              ] }));
          if (stdio[0] instanceof stream_1.Transform)
              stdio[0].pipe(child.stdin);
          if (stdio[1] instanceof stream_1.Transform)
              child.stdout.pipe(stdio[1], { end: stdio[1] !== opts.initialStdout });
          if (stdio[2] instanceof stream_1.Transform)
              child.stderr.pipe(stdio[2], { end: stdio[2] !== opts.initialStderr });
          return {
              stdin: child.stdin,
              promise: new Promise(resolve => {
                  child.on(`error`, error => {
                      // @ts-ignore
                      switch (error.code) {
                          case `ENOENT`:
                              {
                                  stdio[2].write(`command not found: ${name}\n`);
                                  resolve(127);
                              }
                              break;
                          case `EACCESS`:
                              {
                                  stdio[2].write(`permission denied: ${name}\n`);
                                  resolve(128);
                              }
                              break;
                          default:
                              {
                                  stdio[2].write(`uncaught error: ${error.message}\n`);
                                  resolve(1);
                              }
                              break;
                      }
                  });
                  child.on(`exit`, code => {
                      if (code !== null) {
                          resolve(code);
                      }
                      else {
                          resolve(129);
                      }
                  });
              }),
          };
      };
  }
  exports.makeProcess = makeProcess;
  function makeBuiltin(builtin) {
      return (stdio) => {
          const stdin = stdio[0] === `pipe`
              ? new stream_1.PassThrough()
              : stdio[0];
          return {
              stdin,
              promise: nextTick().then(() => builtin({
                  stdin,
                  stdout: stdio[1],
                  stderr: stdio[2],
              })),
          };
      };
  }
  exports.makeBuiltin = makeBuiltin;
  class ProtectedStream {
      constructor(stream) {
          this.stream = stream;
      }
      close() {
          // Ignore close request
      }
      get() {
          return this.stream;
      }
  }
  exports.ProtectedStream = ProtectedStream;
  class PipeStream {
      constructor() {
          this.stream = null;
      }
      close() {
          if (this.stream === null) {
              throw new Error(`Assertion failed: No stream attached`);
          }
          else {
              this.stream.end();
          }
      }
      attach(stream) {
          this.stream = stream;
      }
      get() {
          if (this.stream === null) {
              throw new Error(`Assertion failed: No stream attached`);
          }
          else {
              return this.stream;
          }
      }
  }
  class Handle {
      constructor(ancestor, implementation) {
          this.stdin = null;
          this.stdout = null;
          this.stderr = null;
          this.pipe = null;
          this.ancestor = ancestor;
          this.implementation = implementation;
      }
      static start(implementation, { stdin, stdout, stderr }) {
          const chain = new Handle(null, implementation);
          chain.stdin = stdin;
          chain.stdout = stdout;
          chain.stderr = stderr;
          return chain;
      }
      pipeTo(implementation, source = Pipe.STDOUT) {
          const next = new Handle(this, implementation);
          const pipe = new PipeStream();
          next.pipe = pipe;
          next.stdout = this.stdout;
          next.stderr = this.stderr;
          if ((source & Pipe.STDOUT) === Pipe.STDOUT)
              this.stdout = pipe;
          else if (this.ancestor !== null)
              this.stderr = this.ancestor.stdout;
          if ((source & Pipe.STDERR) === Pipe.STDERR)
              this.stderr = pipe;
          else if (this.ancestor !== null)
              this.stderr = this.ancestor.stderr;
          return next;
      }
      async exec() {
          const stdio = [
              `ignore`,
              `ignore`,
              `ignore`,
          ];
          if (this.pipe) {
              stdio[0] = `pipe`;
          }
          else {
              if (this.stdin === null) {
                  throw new Error(`Assertion failed: No input stream registered`);
              }
              else {
                  stdio[0] = this.stdin.get();
              }
          }
          let stdoutLock;
          if (this.stdout === null) {
              throw new Error(`Assertion failed: No output stream registered`);
          }
          else {
              stdoutLock = this.stdout;
              stdio[1] = stdoutLock.get();
          }
          let stderrLock;
          if (this.stderr === null) {
              throw new Error(`Assertion failed: No error stream registered`);
          }
          else {
              stderrLock = this.stderr;
              stdio[2] = stderrLock.get();
          }
          const child = this.implementation(stdio);
          if (this.pipe)
              this.pipe.attach(child.stdin);
          return await child.promise.then(code => {
              stdoutLock.close();
              stderrLock.close();
              return code;
          });
      }
      async run() {
          const promises = [];
          for (let handle = this; handle; handle = handle.ancestor)
              promises.push(handle.exec());
          const exitCodes = await Promise.all(promises);
          return exitCodes[0];
      }
  }
  exports.Handle = Handle;
  function start(p, opts) {
      return Handle.start(p, opts);
  }
  exports.start = start;


  /***/ }),
  /* 172 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importDefault = (this && this.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      result["default"] = mod;
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const fslib_1 = __webpack_require__(5);
  const parsers_1 = __webpack_require__(132);
  const semver_1 = __importDefault(__webpack_require__(41));
  const miscUtils = __importStar(__webpack_require__(128));
  const structUtils = __importStar(__webpack_require__(173));
  ;
  ;
  ;
  ;
  class Manifest {
      constructor() {
          this.indent = `  `;
          this.name = null;
          this.version = null;
          this["private"] = false;
          this.license = null;
          this.main = null;
          this.module = null;
          this.languageName = null;
          this.bin = new Map();
          this.scripts = new Map();
          this.dependencies = new Map();
          this.devDependencies = new Map();
          this.peerDependencies = new Map();
          this.workspaceDefinitions = [];
          this.dependenciesMeta = new Map();
          this.peerDependenciesMeta = new Map();
          this.resolutions = [];
          this.files = null;
          this.publishConfig = null;
          this.raw = {};
          /**
           * errors found in the raw manifest while loading
           */
          this.errors = [];
      }
      static async find(path, { baseFs = new fslib_1.NodeFS() } = {}) {
          return await Manifest.fromFile(fslib_1.ppath.join(path, fslib_1.toFilename(`package.json`)), { baseFs });
      }
      static async fromFile(path, { baseFs = new fslib_1.NodeFS() } = {}) {
          const manifest = new Manifest();
          await manifest.loadFile(path, { baseFs });
          return manifest;
      }
      static fromText(text) {
          const manifest = new Manifest();
          manifest.loadFromText(text);
          return manifest;
      }
      loadFromText(text) {
          let data;
          try {
              data = JSON.parse(text || `{}`);
          }
          catch (error) {
              error.message += ` (when parsing ${text})`;
              throw error;
          }
          this.load(data);
          this.indent = getIndent(text);
      }
      async loadFile(path, { baseFs = new fslib_1.NodeFS() }) {
          const content = await baseFs.readFilePromise(path, `utf8`);
          let data;
          try {
              data = JSON.parse(content || `{}`);
          }
          catch (error) {
              error.message += ` (when parsing ${path})`;
              throw error;
          }
          this.load(data);
          this.indent = getIndent(content);
      }
      load(data) {
          if (typeof data !== `object` || data === null)
              throw new Error(`Utterly invalid manifest data (${data})`);
          this.raw = data;
          const errors = [];
          if (typeof data.name === `string`) {
              try {
                  this.name = structUtils.parseIdent(data.name);
              }
              catch (error) {
                  errors.push(new Error(`Parsing failed for the 'name' field`));
              }
          }
          if (typeof data.version === `string`)
              this.version = data.version;
          if (typeof data.private === `boolean`)
              this.private = data.private;
          if (typeof data.license === `string`)
              this.license = data.license;
          if (typeof data.languageName === `string`)
              this.languageName = data.languageName;
          if (typeof data.bin === `string`) {
              if (this.name !== null) {
                  this.bin = new Map([[this.name.name, data.bin]]);
              }
              else {
                  errors.push(new Error(`String bin field, but no attached package name`));
              }
          }
          else if (typeof data.bin === `object` && data.bin !== null) {
              for (const [key, value] of Object.entries(data.bin)) {
                  if (typeof value !== `string`) {
                      errors.push(new Error(`Invalid bin definition for '${key}'`));
                      continue;
                  }
                  this.bin.set(key, value);
              }
          }
          if (typeof data.scripts === `object` && data.scripts !== null) {
              for (const [key, value] of Object.entries(data.scripts)) {
                  if (typeof value !== `string`) {
                      errors.push(new Error(`Invalid script definition for '${key}'`));
                      continue;
                  }
                  this.scripts.set(key, value);
              }
          }
          if (typeof data.dependencies === `object` && data.dependencies !== null) {
              for (const [name, range] of Object.entries(data.dependencies)) {
                  if (typeof range !== 'string') {
                      errors.push(new Error(`Invalid dependency range for '${name}'`));
                      continue;
                  }
                  let ident;
                  try {
                      ident = structUtils.parseIdent(name);
                  }
                  catch (error) {
                      errors.push(new Error(`Parsing failed for the dependency name '${name}'`));
                      continue;
                  }
                  const descriptor = structUtils.makeDescriptor(ident, range);
                  this.dependencies.set(descriptor.identHash, descriptor);
              }
          }
          if (typeof data.devDependencies === `object` && data.devDependencies !== null) {
              for (const [name, range] of Object.entries(data.devDependencies)) {
                  if (typeof range !== `string`) {
                      errors.push(new Error(`Invalid dependency range for '${name}'`));
                      continue;
                  }
                  let ident;
                  try {
                      ident = structUtils.parseIdent(name);
                  }
                  catch (error) {
                      errors.push(new Error(`Parsing failed for the dependency name '${name}'`));
                      continue;
                  }
                  const descriptor = structUtils.makeDescriptor(ident, range);
                  this.devDependencies.set(descriptor.identHash, descriptor);
              }
          }
          if (typeof data.peerDependencies === `object` && data.peerDependencies !== null) {
              for (const [name, range] of Object.entries(data.peerDependencies)) {
                  if (typeof range !== 'string') {
                      errors.push(new Error(`Invalid dependency range for '${name}'`));
                      continue;
                  }
                  let ident;
                  try {
                      ident = structUtils.parseIdent(name);
                  }
                  catch (error) {
                      errors.push(new Error(`Parsing failed for the dependency name '${name}'`));
                      continue;
                  }
                  const descriptor = structUtils.makeDescriptor(ident, range);
                  this.peerDependencies.set(descriptor.identHash, descriptor);
              }
          }
          const workspaces = Array.isArray(data.workspaces)
              ? data.workspaces
              : typeof data.workspaces === `object` && data.workspaces !== null && Array.isArray(data.workspaces.packages)
                  ? data.workspaces.packages
                  : [];
          for (const entry of workspaces) {
              if (typeof entry !== `string`) {
                  errors.push(new Error(`Invalid workspace definition for '${entry}'`));
                  continue;
              }
              this.workspaceDefinitions.push({
                  pattern: entry,
              });
          }
          if (typeof data.dependenciesMeta === `object` && data.dependenciesMeta !== null) {
              for (const [pattern, meta] of Object.entries(data.dependenciesMeta)) {
                  if (typeof meta !== `object` || meta === null) {
                      errors.push(new Error(`Invalid meta field for '${pattern}`));
                      continue;
                  }
                  const descriptor = structUtils.parseDescriptor(pattern);
                  const dependencyMeta = this.ensureDependencyMeta(descriptor);
                  Object.assign(dependencyMeta, meta);
              }
          }
          if (typeof data.peerDependenciesMeta === `object` && data.peerDependenciesMeta !== null) {
              for (const [pattern, meta] of Object.entries(data.peerDependenciesMeta)) {
                  if (typeof meta !== `object` || meta === null) {
                      errors.push(new Error(`Invalid meta field for '${pattern}`));
                      continue;
                  }
                  const descriptor = structUtils.parseDescriptor(pattern);
                  const peerDependencyMeta = this.ensurePeerDependencyMeta(descriptor);
                  Object.assign(peerDependencyMeta, meta);
              }
          }
          if (typeof data.resolutions === `object` && data.resolutions !== null) {
              for (const [pattern, reference] of Object.entries(data.resolutions)) {
                  if (typeof reference !== `string`) {
                      errors.push(new Error(`Invalid resolution entry for '${pattern}'`));
                      continue;
                  }
                  try {
                      this.resolutions.push({ pattern: parsers_1.parseResolution(pattern), reference });
                  }
                  catch (error) {
                      errors.push(error);
                      continue;
                  }
              }
          }
          if (Array.isArray(data.files) && data.files.length !== 0) {
              this.files = new Set();
              for (const filename of data.files) {
                  if (typeof filename !== `string`) {
                      errors.push(new Error(`Invalid files entry for '${filename}'`));
                      continue;
                  }
                  this.files.add(filename);
              }
          }
          if (typeof data.publishConfig === `object` && data.publishConfig !== null) {
              this.publishConfig = {};
              if (typeof data.publishConfig.access === `string`)
                  this.publishConfig.access = data.publishConfig.access;
              if (typeof data.publishConfig.main === `string`)
                  this.publishConfig.main = data.publishConfig.main;
              if (typeof data.publishConfig.registry === `string`)
                  this.publishConfig.registry = data.publishConfig.registry;
              if (typeof data.publishConfig.module === `string`)
                  this.publishConfig.module = data.publishConfig.module;
              if (typeof data.publishConfig.bin === `string`) {
                  if (this.name !== null) {
                      this.publishConfig.bin = new Map([[this.name.name, data.publishConfig.bin]]);
                  }
                  else {
                      errors.push(new Error(`String bin field, but no attached package name`));
                  }
              }
              else if (typeof data.publishConfig.bin === `object` && data.publishConfig.bin !== null) {
                  this.publishConfig.bin = new Map();
                  for (const [key, value] of Object.entries(data.publishConfig.bin)) {
                      if (typeof value !== `string`) {
                          errors.push(new Error(`Invalid bin definition for '${key}'`));
                          continue;
                      }
                      this.publishConfig.bin.set(key, value);
                  }
              }
          }
          // We treat optional dependencies after both the regular dependency field
          // and the dependenciesMeta field have been generated (because we will
          // override them)
          if (typeof data.optionalDependencies === `object` && data.optionalDependencies !== null) {
              for (const [name, range] of Object.entries(data.optionalDependencies)) {
                  if (typeof range !== `string`) {
                      errors.push(new Error(`Invalid dependency range for '${name}'`));
                      continue;
                  }
                  let ident;
                  try {
                      ident = structUtils.parseIdent(name);
                  }
                  catch (error) {
                      errors.push(new Error(`Parsing failed for the dependency name '${name}'`));
                      continue;
                  }
                  // Note that we store the optional dependencies in the same store as
                  // the one that keep the regular dependencies, because they're
                  // effectively the same (the only difference is that optional
                  // dependencies have an extra field set in dependenciesMeta).
                  const realDescriptor = structUtils.makeDescriptor(ident, range);
                  this.dependencies.set(realDescriptor.identHash, realDescriptor);
                  const identDescriptor = structUtils.makeDescriptor(ident, `unknown`);
                  const dependencyMeta = this.ensureDependencyMeta(identDescriptor);
                  Object.assign(dependencyMeta, { optional: true });
              }
          }
          this.errors = errors;
      }
      getForScope(type) {
          switch (type) {
              case `dependencies`:
                  return this.dependencies;
              case `devDependencies`:
                  return this.devDependencies;
              case `peerDependencies`:
                  return this.peerDependencies;
              default: {
                  throw new Error(`Unsupported value ("${type}")`);
              }
          }
      }
      hasHardDependency(ident) {
          if (this.dependencies.has(ident.identHash))
              return true;
          if (this.devDependencies.has(ident.identHash))
              return true;
          return false;
      }
      ensureDependencyMeta(descriptor) {
          if (descriptor.range !== `unknown` && !semver_1.default.valid(descriptor.range))
              throw new Error(`Invalid meta field range for '${structUtils.stringifyDescriptor(descriptor)}'`);
          const identString = structUtils.stringifyIdent(descriptor);
          const range = descriptor.range !== `unknown` ? descriptor.range : null;
          let dependencyMetaSet = this.dependenciesMeta.get(identString);
          if (!dependencyMetaSet)
              this.dependenciesMeta.set(identString, dependencyMetaSet = new Map());
          let dependencyMeta = dependencyMetaSet.get(range);
          if (!dependencyMeta)
              dependencyMetaSet.set(range, dependencyMeta = {});
          return dependencyMeta;
      }
      ensurePeerDependencyMeta(descriptor) {
          if (descriptor.range !== `unknown`)
              throw new Error(`Invalid meta field range for '${structUtils.stringifyDescriptor(descriptor)}'`);
          const identString = structUtils.stringifyIdent(descriptor);
          let peerDependencyMeta = this.peerDependenciesMeta.get(identString);
          if (!peerDependencyMeta)
              this.peerDependenciesMeta.set(identString, peerDependencyMeta = {});
          return peerDependencyMeta;
      }
      setRawField(name, value, { after = [] } = {}) {
          const afterSet = new Set(after.filter(key => {
              return Object.prototype.hasOwnProperty.call(this.raw, key);
          }));
          if (afterSet.size === 0 || Object.prototype.hasOwnProperty.call(this.raw, name)) {
              this.raw[name] = value;
          }
          else {
              const oldRaw = this.raw;
              const newRaw = this.raw = {};
              let inserted = false;
              for (const key of Object.keys(oldRaw)) {
                  newRaw[key] = oldRaw[key];
                  if (!inserted) {
                      afterSet.delete(key);
                      if (afterSet.size === 0) {
                          newRaw[name] = value;
                          inserted = true;
                      }
                  }
              }
          }
      }
      exportTo(data, { compatibilityMode = true } = {}) {
          // Note that we even set the fields that we re-set later; it
          // allows us to preserve the key ordering
          Object.assign(data, this.raw);
          if (this.name !== null)
              data.name = structUtils.stringifyIdent(this.name);
          else
              delete data.name;
          if (this.version !== null)
              data.version = this.version;
          else
              delete data.version;
          if (this.private)
              data.private = true;
          else
              delete data.private;
          if (this.license !== null)
              data.license = this.license;
          else
              delete data.license;
          if (this.languageName !== null)
              data.languageName = this.languageName;
          else
              delete data.languageName;
          if (this.bin.size === 0) {
              data.bin = undefined;
          }
          else if (this.bin.size === 1 && this.name !== null && this.bin.has(this.name.name)) {
              data.bin = this.bin.get(this.name.name);
          }
          else {
              data.bin = Object.assign({}, ...Array.from(this.bin.keys()).sort().map(name => {
                  return { [name]: this.bin.get(name) };
              }));
          }
          const regularDependencies = [];
          const optionalDependencies = [];
          for (const dependency of this.dependencies.values()) {
              const dependencyMetaSet = this.dependenciesMeta.get(structUtils.stringifyIdent(dependency));
              let isOptionallyBuilt = false;
              if (compatibilityMode) {
                  if (dependencyMetaSet) {
                      const meta = dependencyMetaSet.get(null);
                      if (meta && meta.optional) {
                          isOptionallyBuilt = true;
                      }
                  }
              }
              if (isOptionallyBuilt) {
                  optionalDependencies.push(dependency);
              }
              else {
                  regularDependencies.push(dependency);
              }
          }
          data.dependencies = regularDependencies.length === 0 ? undefined : Object.assign({}, ...structUtils.sortDescriptors(regularDependencies).map(dependency => {
              return { [structUtils.stringifyIdent(dependency)]: dependency.range };
          }));
          data.optionalDependencies = optionalDependencies.length === 0 ? undefined : Object.assign({}, ...structUtils.sortDescriptors(optionalDependencies).map(dependency => {
              return { [structUtils.stringifyIdent(dependency)]: dependency.range };
          }));
          data.devDependencies = this.devDependencies.size === 0 ? undefined : Object.assign({}, ...structUtils.sortDescriptors(this.devDependencies.values()).map(dependency => {
              return { [structUtils.stringifyIdent(dependency)]: dependency.range };
          }));
          data.peerDependencies = this.peerDependencies.size === 0 ? undefined : Object.assign({}, ...structUtils.sortDescriptors(this.peerDependencies.values()).map(dependency => {
              return { [structUtils.stringifyIdent(dependency)]: dependency.range };
          }));
          data.dependenciesMeta = {};
          for (const [identString, dependencyMetaSet] of miscUtils.sortMap(this.dependenciesMeta.entries(), ([identString, dependencyMetaSet]) => identString)) {
              for (const [range, meta] of miscUtils.sortMap(dependencyMetaSet.entries(), ([range, meta]) => range !== null ? `0${range}` : `1`)) {
                  const key = range !== null
                      ? structUtils.stringifyDescriptor(structUtils.makeDescriptor(structUtils.parseIdent(identString), range))
                      : identString;
                  const metaCopy = Object.assign({}, meta);
                  if (compatibilityMode && range === null)
                      delete metaCopy.optional;
                  if (Object.keys(metaCopy).length === 0)
                      continue;
                  data.dependenciesMeta[key] = metaCopy;
              }
          }
          if (Object.keys(data.dependenciesMeta).length === 0)
              data.dependenciesMeta = undefined;
          data.peerDependenciesMeta = this.peerDependenciesMeta.size === 0 ? undefined : Object.assign({}, ...miscUtils.sortMap(this.peerDependenciesMeta.entries(), ([identString, meta]) => identString).map(([identString, meta]) => {
              return { [identString]: meta };
          }));
          data.resolutions = this.resolutions.length === 0 ? undefined : Object.assign({}, ...this.resolutions.map(({ pattern, reference }) => {
              return { [parsers_1.stringifyResolution(pattern)]: reference };
          }));
          if (this.files === null)
              data.files = undefined;
          else
              data.files = Array.from(this.files);
          return data;
      }
  }
  Manifest.allDependencies = [`dependencies`, `devDependencies`, `peerDependencies`];
  Manifest.hardDependencies = [`dependencies`, `devDependencies`];
  exports.Manifest = Manifest;
  ;
  function getIndent(content) {
      const indentMatch = content.match(/^[ \t]+/m);
      if (indentMatch) {
          return indentMatch[0];
      }
      else {
          return `  `;
      }
  }


  /***/ }),
  /* 173 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importDefault = (this && this.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      result["default"] = mod;
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const fslib_1 = __webpack_require__(5);
  const querystring_1 = __importDefault(__webpack_require__(174));
  const semver_1 = __importDefault(__webpack_require__(41));
  const hashUtils = __importStar(__webpack_require__(175));
  const miscUtils = __importStar(__webpack_require__(128));
  const VIRTUAL_PROTOCOL = `virtual:`;
  const VIRTUAL_ABBREVIATE = 5;
  function makeIdent(scope, name) {
      return { identHash: hashUtils.makeHash(scope, name), scope, name };
  }
  exports.makeIdent = makeIdent;
  function makeDescriptor(ident, range) {
      return { identHash: ident.identHash, scope: ident.scope, name: ident.name, descriptorHash: hashUtils.makeHash(ident.identHash, range), range };
  }
  exports.makeDescriptor = makeDescriptor;
  function makeLocator(ident, reference) {
      return { identHash: ident.identHash, scope: ident.scope, name: ident.name, locatorHash: hashUtils.makeHash(ident.identHash, reference), reference };
  }
  exports.makeLocator = makeLocator;
  function convertToIdent(source) {
      return { identHash: source.identHash, scope: source.scope, name: source.name };
  }
  exports.convertToIdent = convertToIdent;
  function convertDescriptorToLocator(descriptor) {
      return { identHash: descriptor.identHash, scope: descriptor.scope, name: descriptor.name, locatorHash: descriptor.descriptorHash, reference: descriptor.range };
  }
  exports.convertDescriptorToLocator = convertDescriptorToLocator;
  function convertLocatorToDescriptor(locator) {
      return { identHash: locator.identHash, scope: locator.scope, name: locator.name, descriptorHash: locator.locatorHash, range: locator.reference };
  }
  exports.convertLocatorToDescriptor = convertLocatorToDescriptor;
  function convertPackageToLocator(pkg) {
      return { identHash: pkg.identHash, scope: pkg.scope, name: pkg.name, locatorHash: pkg.locatorHash, reference: pkg.reference };
  }
  exports.convertPackageToLocator = convertPackageToLocator;
  function renamePackage(pkg, locator) {
      return Object.assign({}, locator, { version: pkg.version, languageName: pkg.languageName, linkType: pkg.linkType, dependencies: new Map(pkg.dependencies), peerDependencies: new Map(pkg.peerDependencies), dependenciesMeta: new Map(pkg.dependenciesMeta), peerDependenciesMeta: new Map(pkg.peerDependenciesMeta), bin: new Map(pkg.bin) });
  }
  exports.renamePackage = renamePackage;
  function virtualizeDescriptor(descriptor, entropy) {
      if (entropy.includes(`#`))
          throw new Error(`Invalid entropy`);
      return makeDescriptor(descriptor, `virtual:${entropy}#${descriptor.range}`);
  }
  exports.virtualizeDescriptor = virtualizeDescriptor;
  function virtualizePackage(pkg, entropy) {
      if (entropy.includes(`#`))
          throw new Error(`Invalid entropy`);
      return renamePackage(pkg, makeLocator(pkg, `virtual:${entropy}#${pkg.reference}`));
  }
  exports.virtualizePackage = virtualizePackage;
  function isVirtualDescriptor(descriptor) {
      return descriptor.range.startsWith(VIRTUAL_PROTOCOL);
  }
  exports.isVirtualDescriptor = isVirtualDescriptor;
  function isVirtualLocator(locator) {
      return locator.reference.startsWith(VIRTUAL_PROTOCOL);
  }
  exports.isVirtualLocator = isVirtualLocator;
  function devirtualizeDescriptor(descriptor) {
      if (!isVirtualDescriptor(descriptor))
          throw new Error(`Not a virtual descriptor`);
      return makeDescriptor(descriptor, descriptor.range.replace(/^[^#]*#/, ``));
  }
  exports.devirtualizeDescriptor = devirtualizeDescriptor;
  function devirtualizeLocator(locator) {
      if (!isVirtualLocator(locator))
          throw new Error(`Not a virtual descriptor`);
      return makeLocator(locator, locator.reference.replace(/^[^#]*#/, ``));
  }
  exports.devirtualizeLocator = devirtualizeLocator;
  function bindDescriptor(descriptor, params) {
      if (descriptor.range.includes(`?`))
          return descriptor;
      return makeDescriptor(descriptor, `${descriptor.range}?${querystring_1.default.stringify(params)}`);
  }
  exports.bindDescriptor = bindDescriptor;
  function areIdentsEqual(a, b) {
      return a.identHash === b.identHash;
  }
  exports.areIdentsEqual = areIdentsEqual;
  function areDescriptorsEqual(a, b) {
      return a.descriptorHash === b.descriptorHash;
  }
  exports.areDescriptorsEqual = areDescriptorsEqual;
  function areLocatorsEqual(a, b) {
      return a.locatorHash === b.locatorHash;
  }
  exports.areLocatorsEqual = areLocatorsEqual;
  function parseIdent(string) {
      const ident = tryParseIdent(string);
      if (!ident)
          throw new Error(`Invalid ident (${string})`);
      return ident;
  }
  exports.parseIdent = parseIdent;
  function tryParseIdent(string) {
      const match = string.match(/^(?:@([^\/]+?)\/)?([^\/]+)$/);
      if (!match)
          return null;
      const [, scope, name] = match;
      const realScope = typeof scope !== `undefined`
          ? scope
          : null;
      return makeIdent(realScope, name);
  }
  exports.tryParseIdent = tryParseIdent;
  function parseDescriptor(string, strict = false) {
      const descriptor = tryParseDescriptor(string, strict);
      if (!descriptor)
          throw new Error(`Invalid descriptor (${string})`);
      return descriptor;
  }
  exports.parseDescriptor = parseDescriptor;
  function tryParseDescriptor(string, strict = false) {
      const match = strict
          ? string.match(/^(?:@([^\/]+?)\/)?([^\/]+?)(?:@(.+))$/)
          : string.match(/^(?:@([^\/]+?)\/)?([^\/]+?)(?:@(.+))?$/);
      if (!match)
          return null;
      const [, scope, name, range] = match;
      if (range === `unknown`)
          throw new Error(`Invalid range (${string})`);
      const realScope = typeof scope !== `undefined`
          ? scope
          : null;
      const realRange = typeof range !== `undefined`
          ? range
          : `unknown`;
      return makeDescriptor(makeIdent(realScope, name), realRange);
  }
  exports.tryParseDescriptor = tryParseDescriptor;
  function parseLocator(string, strict = false) {
      const locator = tryParseLocator(string, strict);
      if (!locator)
          throw new Error(`Invalid locator (${string})`);
      return locator;
  }
  exports.parseLocator = parseLocator;
  function tryParseLocator(string, strict = false) {
      const match = strict
          ? string.match(/^(?:@([^\/]+?)\/)?([^\/]+?)(?:@(.+))$/)
          : string.match(/^(?:@([^\/]+?)\/)?([^\/]+?)(?:@(.+))?$/);
      if (!match)
          return null;
      const [, scope, name, reference] = match;
      if (reference === `unknown`)
          throw new Error(`Invalid reference (${string})`);
      const realScope = typeof scope !== `undefined`
          ? scope
          : null;
      const realReference = typeof reference !== `undefined`
          ? reference
          : `unknown`;
      return makeLocator(makeIdent(realScope, name), realReference);
  }
  exports.tryParseLocator = tryParseLocator;
  function parseRange(range) {
      const protocolIndex = range.indexOf(`:`);
      const protocol = protocolIndex !== -1 ? range.slice(0, protocolIndex + 1) : null;
      const protocolRest = protocolIndex !== -1 ? range.slice(protocolIndex + 1) : range;
      const hashIndex = protocolRest.indexOf(`#`);
      const source = hashIndex !== -1 ? protocolRest.slice(0, hashIndex) : null;
      const selector = hashIndex !== -1 ? protocolRest.slice(hashIndex + 1) : protocolRest;
      return { protocol, source, selector };
  }
  exports.parseRange = parseRange;
  function makeRange({ protocol, source, selector }) {
      let range = ``;
      if (protocol !== null)
          range += `${protocol}`;
      if (source !== null)
          range += `${source}#`;
      return range + selector;
  }
  exports.makeRange = makeRange;
  function requirableIdent(ident) {
      if (ident.scope) {
          return `@${ident.scope}/${ident.name}`;
      }
      else {
          return `${ident.name}`;
      }
  }
  exports.requirableIdent = requirableIdent;
  function stringifyIdent(ident) {
      if (ident.scope) {
          return `@${ident.scope}/${ident.name}`;
      }
      else {
          return `${ident.name}`;
      }
  }
  exports.stringifyIdent = stringifyIdent;
  function stringifyDescriptor(descriptor) {
      if (descriptor.scope) {
          return `@${descriptor.scope}/${descriptor.name}@${descriptor.range}`;
      }
      else {
          return `${descriptor.name}@${descriptor.range}`;
      }
  }
  exports.stringifyDescriptor = stringifyDescriptor;
  function stringifyLocator(locator) {
      if (locator.scope) {
          return `@${locator.scope}/${locator.name}@${locator.reference}`;
      }
      else {
          return `${locator.name}@${locator.reference}`;
      }
  }
  exports.stringifyLocator = stringifyLocator;
  function slugifyIdent(ident) {
      if (ident.scope !== null) {
          return `@${ident.scope}-${ident.name}`;
      }
      else {
          return ident.name;
      }
  }
  exports.slugifyIdent = slugifyIdent;
  function slugifyLocator(locator) {
      const protocolIndex = locator.reference.indexOf(`:`);
      const protocol = protocolIndex !== -1
          ? locator.reference.slice(0, protocolIndex)
          : `exotic`;
      const version = protocolIndex !== -1
          ? semver_1.default.valid(locator.reference.slice(protocolIndex + 1))
          : null;
      const humanReference = version !== null
          ? `${protocol}-${version}`
          : protocol;
      // 10 hex characters means that 47 different entries have 10^-9 chances of
      // causing a hash collision. Since this hash is joined with the package name
      // (making it highly unlikely you'll have more than a handful of instances
      // of any single package), this should provide a good enough guard in most
      // cases.
      //
      // Also note that eCryptfs eats some bytes, so the theoretical maximum for a
      // file size is around 140 bytes (but we don't need as much, as explained).
      const hashTruncate = 10;
      const slug = locator.scope
          ? `${slugifyIdent(locator)}-${humanReference}-${locator.locatorHash.slice(0, hashTruncate)}`
          : `${slugifyIdent(locator)}-${humanReference}-${locator.locatorHash.slice(0, hashTruncate)}`;
      return fslib_1.toFilename(slug);
  }
  exports.slugifyLocator = slugifyLocator;
  function prettyIdent(configuration, ident) {
      if (ident.scope) {
          return `${configuration.format(`@${ident.scope}/`, `#d75f00`)}${configuration.format(ident.name, `#d7875f`)}`;
      }
      else {
          return `${configuration.format(ident.name, `#d7875f`)}`;
      }
  }
  exports.prettyIdent = prettyIdent;
  function prettyRangeNoColors(range) {
      if (range.startsWith(VIRTUAL_PROTOCOL)) {
          const nested = prettyRangeNoColors(range.substr(range.indexOf(`#`) + 1));
          const abbrev = range.substr(VIRTUAL_PROTOCOL.length, VIRTUAL_ABBREVIATE);
          // I'm not satisfied of how the virtual packages appear in the output
          return false ? undefined : `${nested} [${abbrev}]`;
      }
      else {
          return range.replace(/\?.*/, `?[...]`);
      }
  }
  function prettyRange(configuration, range) {
      return `${configuration.format(prettyRangeNoColors(range), `#00afaf`)}`;
  }
  exports.prettyRange = prettyRange;
  function prettyDescriptor(configuration, descriptor) {
      return `${prettyIdent(configuration, descriptor)}${configuration.format(`@`, `#00afaf`)}${prettyRange(configuration, descriptor.range)}`;
  }
  exports.prettyDescriptor = prettyDescriptor;
  function prettyReference(configuration, reference) {
      return `${configuration.format(prettyRangeNoColors(reference), `#87afff`)}`;
  }
  exports.prettyReference = prettyReference;
  function prettyLocator(configuration, locator) {
      return `${prettyIdent(configuration, locator)}${configuration.format(`@`, `#87afff`)}${prettyReference(configuration, locator.reference)}`;
  }
  exports.prettyLocator = prettyLocator;
  function prettyLocatorNoColors(locator) {
      return `${stringifyIdent(locator)}@${prettyRangeNoColors(locator.reference)}`;
  }
  exports.prettyLocatorNoColors = prettyLocatorNoColors;
  function sortDescriptors(descriptors) {
      return miscUtils.sortMap(descriptors, [
          descriptor => stringifyIdent(descriptor),
          descriptor => descriptor.range,
      ]);
  }
  exports.sortDescriptors = sortDescriptors;
  function prettyWorkspace(configuration, workspace) {
      const byIdent = workspace.project.workspacesByIdent.get(workspace.locator.identHash);
      if (!byIdent || byIdent.length <= 1) {
          return prettyIdent(configuration, workspace.locator);
      }
      else {
          return prettyLocator(configuration, workspace.anchoredLocator);
      }
  }
  exports.prettyWorkspace = prettyWorkspace;


  /***/ }),
  /* 174 */
  /***/ (function(module, exports) {

  module.exports = require("querystring");

  /***/ }),
  /* 175 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const fslib_1 = __webpack_require__(5);
  const crypto_1 = __webpack_require__(9);
  function makeHash(...args) {
      const hmac = crypto_1.createHmac(`sha512`, `berry`);
      for (const arg of args)
          hmac.update(arg ? arg : ``);
      return hmac.digest(`hex`);
  }
  exports.makeHash = makeHash;
  function checksumFile(path) {
      return new Promise((resolve, reject) => {
          const fs = new fslib_1.NodeFS();
          const hmac = crypto_1.createHmac(`sha512`, `berry`);
          const stream = fs.createReadStream(path, {});
          stream.on(`data`, chunk => {
              hmac.update(chunk);
          });
          stream.on(`error`, error => {
              reject(error);
          });
          stream.on(`end`, () => {
              resolve(hmac.digest(`hex`));
          });
      });
  }
  exports.checksumFile = checksumFile;


  /***/ }),
  /* 176 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const Report_1 = __webpack_require__(177);
  class StreamReport extends Report_1.Report {
      constructor({ configuration, stdout, json = false, includeFooter = true, includeLogs = !json, includeInfos = includeLogs, includeWarnings = includeLogs }) {
          super();
          this.cacheHitCount = 0;
          this.cacheMissCount = 0;
          this.warningCount = 0;
          this.errorCount = 0;
          this.startTime = Date.now();
          this.indent = 0;
          this.configuration = configuration;
          this.includeFooter = includeFooter;
          this.includeInfos = includeInfos;
          this.includeWarnings = includeWarnings;
          this.json = json;
          this.stdout = stdout;
      }
      static async start(opts, cb) {
          const report = new this(opts);
          try {
              await cb(report);
          }
          catch (error) {
              report.reportExceptionOnce(error);
          }
          finally {
              await report.finalize();
          }
          return report;
      }
      hasErrors() {
          return this.errorCount > 0;
      }
      exitCode() {
          return this.hasErrors() ? 1 : 0;
      }
      reportCacheHit(locator) {
          this.cacheHitCount += 1;
      }
      reportCacheMiss(locator) {
          this.cacheMissCount += 1;
      }
      startTimerSync(what, cb) {
          this.reportInfo(null, `┌ ${what}`);
          const before = Date.now();
          this.indent += 1;
          try {
              return cb();
          }
          catch (error) {
              this.reportExceptionOnce(error);
              throw error;
          }
          finally {
              const after = Date.now();
              this.indent -= 1;
              if (this.configuration.get(`enableTimers`)) {
                  this.reportInfo(null, `└ Completed in ${this.formatTiming(after - before)}`);
              }
              else {
                  this.reportInfo(null, `└ Completed`);
              }
          }
      }
      async startTimerPromise(what, cb) {
          this.reportInfo(null, `┌ ${what}`);
          const before = Date.now();
          this.indent += 1;
          try {
              return await cb();
          }
          catch (error) {
              this.reportExceptionOnce(error);
              throw error;
          }
          finally {
              const after = Date.now();
              this.indent -= 1;
              if (this.configuration.get(`enableTimers`)) {
                  this.reportInfo(null, `└ Completed in ${this.formatTiming(after - before)}`);
              }
              else {
                  this.reportInfo(null, `└ Completed`);
              }
          }
      }
      reportSeparator() {
          if (this.indent === 0) {
              this.stdout.write(`\n`);
          }
          else {
              this.reportInfo(null, ``);
          }
      }
      reportInfo(name, text) {
          if (!this.includeInfos)
              return;
          if (!this.json) {
              this.stdout.write(`${this.configuration.format(`➤`, `blueBright`)} ${this.formatName(name)}: ${this.formatIndent()}${text}\n`);
          }
          else {
              this.reportJson({ type: `info`, name, displayName: this.formatName(name), indent: this.formatIndent(), data: text });
          }
      }
      reportWarning(name, text) {
          this.warningCount += 1;
          if (!this.includeWarnings)
              return;
          if (!this.json) {
              this.stdout.write(`${this.configuration.format(`➤`, `yellowBright`)} ${this.formatName(name)}: ${this.formatIndent()}${text}\n`);
          }
          else {
              this.reportJson({ type: `warning`, name, displayName: this.formatName(name), indent: this.formatIndent(), data: text });
          }
      }
      reportError(name, text) {
          this.errorCount += 1;
          if (!this.json) {
              this.stdout.write(`${this.configuration.format(`➤`, `redBright`)} ${this.formatName(name)}: ${this.formatIndent()}${text}\n`);
          }
          else {
              this.reportJson({ type: `error`, name, displayName: this.formatName(name), indent: this.formatIndent(), data: text });
          }
      }
      reportJson(data) {
          if (this.json) {
              this.stdout.write(`${JSON.stringify(data)}\n`);
          }
      }
      async finalize() {
          if (!this.includeFooter)
              return;
          let installStatus = ``;
          if (this.errorCount > 0)
              installStatus = `Failed with errors`;
          else if (this.warningCount > 0)
              installStatus = `Done with warnings`;
          else
              installStatus = `Done`;
          let fetchStatus = ``;
          if (this.cacheHitCount > 1)
              fetchStatus += ` - ${this.cacheHitCount} packages were already cached`;
          else if (this.cacheHitCount === 1)
              fetchStatus += ` - one package was already cached`;
          if (this.cacheHitCount > 0) {
              if (this.cacheMissCount > 1) {
                  fetchStatus += `, ${this.cacheMissCount} had to be fetched`;
              }
              else if (this.cacheMissCount === 1) {
                  fetchStatus += `, one had to be fetched`;
              }
          }
          else {
              if (this.cacheMissCount > 1) {
                  fetchStatus += ` - ${this.cacheMissCount} packages had to be fetched`;
              }
              else if (this.cacheMissCount === 1) {
                  fetchStatus += ` - one package had to be fetched`;
              }
          }
          const timing = this.formatTiming(Date.now() - this.startTime);
          const message = this.configuration.get(`enableTimers`)
              ? `${installStatus} in ${timing}${fetchStatus}`
              : installStatus;
          if (this.errorCount > 0) {
              this.reportError(Report_1.MessageName.UNNAMED, message);
          }
          else if (this.warningCount > 0) {
              this.reportWarning(Report_1.MessageName.UNNAMED, message);
          }
          else {
              this.reportInfo(Report_1.MessageName.UNNAMED, message);
          }
      }
      formatTiming(timing) {
          return timing < 60 * 1000
              ? `${Math.round(timing / 10) / 100}s`
              : `${Math.round(timing / 600) / 100}m`;
      }
      formatName(name) {
          const num = name === null ? 0 : name;
          const label = `YN${num.toString(10).padStart(4, `0`)}`;
          if (!this.json && name === null) {
              return this.configuration.format(label, `grey`);
          }
          else {
              return label;
          }
      }
      formatIndent() {
          return `│ `.repeat(this.indent);
      }
  }
  exports.StreamReport = StreamReport;


  /***/ }),
  /* 177 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const stream_1 = __webpack_require__(24);
  const string_decoder_1 = __webpack_require__(178);
  // The values in this enum should never be reassigned, even if some are removed
  // over time (it would mess up the search results, which are the whole point of
  // having this system)
  var MessageName;
  (function (MessageName) {
      MessageName[MessageName["UNNAMED"] = 0] = "UNNAMED";
      MessageName[MessageName["EXCEPTION"] = 1] = "EXCEPTION";
      MessageName[MessageName["MISSING_PEER_DEPENDENCY"] = 2] = "MISSING_PEER_DEPENDENCY";
      MessageName[MessageName["CYCLIC_DEPENDENCIES"] = 3] = "CYCLIC_DEPENDENCIES";
      MessageName[MessageName["DISABLED_BUILD_SCRIPTS"] = 4] = "DISABLED_BUILD_SCRIPTS";
      MessageName[MessageName["BUILD_DISABLED"] = 5] = "BUILD_DISABLED";
      MessageName[MessageName["SOFT_LINK_BUILD"] = 6] = "SOFT_LINK_BUILD";
      MessageName[MessageName["MUST_BUILD"] = 7] = "MUST_BUILD";
      MessageName[MessageName["MUST_REBUILD"] = 8] = "MUST_REBUILD";
      MessageName[MessageName["BUILD_FAILED"] = 9] = "BUILD_FAILED";
      MessageName[MessageName["RESOLVER_NOT_FOUND"] = 10] = "RESOLVER_NOT_FOUND";
      MessageName[MessageName["FETCHER_NOT_FOUND"] = 11] = "FETCHER_NOT_FOUND";
      MessageName[MessageName["LINKER_NOT_FOUND"] = 12] = "LINKER_NOT_FOUND";
      MessageName[MessageName["FETCH_NOT_CACHED"] = 13] = "FETCH_NOT_CACHED";
      MessageName[MessageName["YARN_IMPORT_FAILED"] = 14] = "YARN_IMPORT_FAILED";
      MessageName[MessageName["REMOTE_INVALID"] = 15] = "REMOTE_INVALID";
      MessageName[MessageName["REMOTE_NOT_FOUND"] = 16] = "REMOTE_NOT_FOUND";
      MessageName[MessageName["RESOLUTION_PACK"] = 17] = "RESOLUTION_PACK";
      MessageName[MessageName["CACHE_CHECKSUM_MISMATCH"] = 18] = "CACHE_CHECKSUM_MISMATCH";
      MessageName[MessageName["UNUSED_CACHE_ENTRY"] = 19] = "UNUSED_CACHE_ENTRY";
      MessageName[MessageName["MISSING_LOCKFILE_ENTRY"] = 20] = "MISSING_LOCKFILE_ENTRY";
      MessageName[MessageName["WORKSPACE_NOT_FOUND"] = 21] = "WORKSPACE_NOT_FOUND";
      MessageName[MessageName["TOO_MANY_MATCHING_WORKSPACES"] = 22] = "TOO_MANY_MATCHING_WORKSPACES";
      MessageName[MessageName["CONSTRAINTS_MISSING_DEPENDENCY"] = 23] = "CONSTRAINTS_MISSING_DEPENDENCY";
      MessageName[MessageName["CONSTRAINTS_INCOMPATIBLE_DEPENDENCY"] = 24] = "CONSTRAINTS_INCOMPATIBLE_DEPENDENCY";
      MessageName[MessageName["CONSTRAINTS_EXTRANEOUS_DEPENDENCY"] = 25] = "CONSTRAINTS_EXTRANEOUS_DEPENDENCY";
      MessageName[MessageName["CONSTRAINTS_INVALID_DEPENDENCY"] = 26] = "CONSTRAINTS_INVALID_DEPENDENCY";
      MessageName[MessageName["CANT_SUGGEST_RESOLUTIONS"] = 27] = "CANT_SUGGEST_RESOLUTIONS";
      MessageName[MessageName["FROZEN_LOCKFILE_EXCEPTION"] = 28] = "FROZEN_LOCKFILE_EXCEPTION";
      MessageName[MessageName["CROSS_DRIVE_VIRTUAL_LOCAL"] = 29] = "CROSS_DRIVE_VIRTUAL_LOCAL";
      MessageName[MessageName["FETCH_FAILED"] = 30] = "FETCH_FAILED";
      MessageName[MessageName["DANGEROUS_NODE_MODULES"] = 31] = "DANGEROUS_NODE_MODULES";
      MessageName[MessageName["NODE_GYP_INJECTED"] = 32] = "NODE_GYP_INJECTED";
      MessageName[MessageName["AUTHENTICATION_NOT_FOUND"] = 33] = "AUTHENTICATION_NOT_FOUND";
      MessageName[MessageName["INVALID_CONFIGURATION_KEY"] = 34] = "INVALID_CONFIGURATION_KEY";
      MessageName[MessageName["NETWORK_ERROR"] = 35] = "NETWORK_ERROR";
      MessageName[MessageName["LIFECYCLE_SCRIPT"] = 36] = "LIFECYCLE_SCRIPT";
      MessageName[MessageName["CONSTRAINTS_MISSING_FIELD"] = 37] = "CONSTRAINTS_MISSING_FIELD";
      MessageName[MessageName["CONSTRAINTS_INCOMPATIBLE_FIELD"] = 38] = "CONSTRAINTS_INCOMPATIBLE_FIELD";
      MessageName[MessageName["CONSTRAINTS_EXTRANEOUS_FIELD"] = 39] = "CONSTRAINTS_EXTRANEOUS_FIELD";
      MessageName[MessageName["CONSTRAINTS_INVALID_FIELD"] = 40] = "CONSTRAINTS_INVALID_FIELD";
      MessageName[MessageName["AUTHENTICATION_INVALID"] = 41] = "AUTHENTICATION_INVALID";
      MessageName[MessageName["PROLOG_UNKNOWN_ERROR"] = 42] = "PROLOG_UNKNOWN_ERROR";
      MessageName[MessageName["PROLOG_SYNTAX_ERROR"] = 43] = "PROLOG_SYNTAX_ERROR";
      MessageName[MessageName["PROLOG_EXISTENCE_ERROR"] = 44] = "PROLOG_EXISTENCE_ERROR";
      MessageName[MessageName["STACK_OVERFLOW_RESOLUTION"] = 45] = "STACK_OVERFLOW_RESOLUTION";
      MessageName[MessageName["AUTOMERGE_FAILED_TO_PARSE"] = 46] = "AUTOMERGE_FAILED_TO_PARSE";
      MessageName[MessageName["AUTOMERGE_IMMUTABLE"] = 47] = "AUTOMERGE_IMMUTABLE";
      MessageName[MessageName["AUTOMERGE_SUCCESS"] = 48] = "AUTOMERGE_SUCCESS";
      MessageName[MessageName["AUTOMERGE_REQUIRED"] = 49] = "AUTOMERGE_REQUIRED";
      MessageName[MessageName["DEPRECATED_CLI_SETTINGS"] = 50] = "DEPRECATED_CLI_SETTINGS";
      MessageName[MessageName["PLUGIN_NAME_NOT_FOUND"] = 51] = "PLUGIN_NAME_NOT_FOUND";
      MessageName[MessageName["INVALID_PLUGIN_REFERENCE"] = 52] = "INVALID_PLUGIN_REFERENCE";
      MessageName[MessageName["CONSTRAINTS_AMBIGUITY"] = 53] = "CONSTRAINTS_AMBIGUITY";
      MessageName[MessageName["CACHE_OUTSIDE_PROJECT"] = 54] = "CACHE_OUTSIDE_PROJECT";
      MessageName[MessageName["IMMUTABLE_INSTALL"] = 55] = "IMMUTABLE_INSTALL";
      MessageName[MessageName["IMMUTABLE_CACHE"] = 56] = "IMMUTABLE_CACHE";
      MessageName[MessageName["INVALID_MANIFEST"] = 57] = "INVALID_MANIFEST";
  })(MessageName = exports.MessageName || (exports.MessageName = {}));
  class ReportError extends Error {
      constructor(code, message) {
          super(message);
          this.reportCode = code;
      }
  }
  exports.ReportError = ReportError;
  function isReportError(error) {
      return typeof error.reportCode !== `undefined`;
  }
  exports.isReportError = isReportError;
  class Report {
      constructor() {
          this.reportedInfos = new Set();
          this.reportedWarnings = new Set();
          this.reportedErrors = new Set();
      }
      reportInfoOnce(name, text, opts) {
          const key = opts && opts.key ? opts.key : text;
          if (!this.reportedInfos.has(key)) {
              this.reportedInfos.add(key);
              this.reportInfo(name, text);
          }
      }
      reportWarningOnce(name, text, opts) {
          const key = opts && opts.key ? opts.key : text;
          if (!this.reportedWarnings.has(key)) {
              this.reportedWarnings.add(key);
              this.reportWarning(name, text);
          }
      }
      reportErrorOnce(name, text, opts) {
          const key = opts && opts.key ? opts.key : text;
          if (!this.reportedErrors.has(key)) {
              this.reportedErrors.add(key);
              this.reportError(name, text);
          }
      }
      reportExceptionOnce(error) {
          if (isReportError(error)) {
              this.reportErrorOnce(error.reportCode, error.message, { key: error });
          }
          else {
              this.reportErrorOnce(MessageName.EXCEPTION, error.stack || error.message, { key: error });
          }
      }
      createStreamReporter(prefix = null) {
          const stream = new stream_1.PassThrough();
          const decoder = new string_decoder_1.StringDecoder();
          let buffer = ``;
          stream.on(`data`, chunk => {
              let chunkStr = decoder.write(chunk);
              let lineIndex;
              do {
                  lineIndex = chunkStr.indexOf(`\n`);
                  if (lineIndex !== -1) {
                      const line = buffer + chunkStr.substr(0, lineIndex);
                      chunkStr = chunkStr.substr(lineIndex + 1);
                      buffer = ``;
                      if (prefix !== null) {
                          this.reportInfo(null, `${prefix} ${line}`);
                      }
                      else {
                          this.reportInfo(null, line);
                      }
                  }
              } while (lineIndex !== -1);
              buffer += chunkStr;
          });
          stream.on(`end`, () => {
              const last = decoder.end();
              if (last !== ``) {
                  if (prefix !== null) {
                      this.reportInfo(null, `${prefix} ${last}`);
                  }
                  else {
                      this.reportInfo(null, last);
                  }
              }
          });
          return stream;
      }
  }
  exports.Report = Report;


  /***/ }),
  /* 178 */
  /***/ (function(module, exports) {

  module.exports = require("string_decoder");

  /***/ }),
  /* 179 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const fslib_1 = __webpack_require__(5);
  const tar_1 = __webpack_require__(180);
  const tmp_1 = __webpack_require__(6);
  ;
  async function makeArchiveFromDirectory(source, { baseFs = new fslib_1.NodeFS(), prefixPath = fslib_1.PortablePath.root } = {}) {
      const zipFs = new fslib_1.ZipFS(fslib_1.NodeFS.toPortablePath(tmp_1.tmpNameSync()), { create: true });
      const target = fslib_1.ppath.resolve(fslib_1.PortablePath.root, prefixPath);
      await zipFs.copyPromise(target, source, { baseFs });
      return zipFs;
  }
  exports.makeArchiveFromDirectory = makeArchiveFromDirectory;
  ;
  async function makeArchive(tgz, { stripComponents = 0, prefixPath = fslib_1.PortablePath.dot } = {}) {
      const zipFs = new fslib_1.ZipFS(fslib_1.NodeFS.toPortablePath(tmp_1.tmpNameSync()), { create: true });
      // 1980-01-01, like Fedora
      const defaultTime = 315532800;
      // @ts-ignore: Typescript doesn't want me to use new
      const parser = new tar_1.Parse();
      function ignore(entry) {
          // Disallow absolute paths; might be malicious (ex: /etc/passwd)
          if (entry[0] === `/`)
              return true;
          const parts = entry.path.split(/\//g);
          // We also ignore paths that could lead to escaping outside the archive
          if (parts.some((part) => part === `..`))
              return true;
          if (parts.length <= stripComponents)
              return true;
          return false;
      }
      parser.on(`entry`, (entry) => {
          if (ignore(entry)) {
              entry.resume();
              return;
          }
          const parts = entry.path.split(/\//g);
          const mappedPath = fslib_1.ppath.join(prefixPath, parts.slice(stripComponents).join(`/`));
          const chunks = [];
          let mode = 0o644;
          // If a single executable bit is set, normalize so that all are
          if (entry.type === `Directory` || (entry.mode & 0o111) !== 0)
              mode |= 0o111;
          entry.on(`data`, (chunk) => {
              chunks.push(chunk);
          });
          entry.on(`end`, () => {
              switch (entry.type) {
                  case `Directory`:
                      {
                          zipFs.mkdirpSync(fslib_1.ppath.dirname(mappedPath), { chmod: 0o755, utimes: [defaultTime, defaultTime] });
                          zipFs.mkdirSync(mappedPath);
                          zipFs.chmodSync(mappedPath, mode);
                          zipFs.utimesSync(mappedPath, defaultTime, defaultTime);
                      }
                      break;
                  case `OldFile`:
                  case `File`:
                      {
                          zipFs.mkdirpSync(fslib_1.ppath.dirname(mappedPath), { chmod: 0o755, utimes: [defaultTime, defaultTime] });
                          zipFs.writeFileSync(mappedPath, Buffer.concat(chunks));
                          zipFs.chmodSync(mappedPath, mode);
                          zipFs.utimesSync(mappedPath, defaultTime, defaultTime);
                      }
                      break;
                  case `SymbolicLink`:
                      {
                          zipFs.mkdirpSync(fslib_1.ppath.dirname(mappedPath), { chmod: 0o755, utimes: [defaultTime, defaultTime] });
                          zipFs.symlinkSync(entry.linkpath, mappedPath);
                          zipFs.lutimesSync(mappedPath, defaultTime, defaultTime);
                      }
                      break;
              }
          });
      });
      return await new Promise((resolve, reject) => {
          parser.on(`error`, (error) => {
              reject(error);
          });
          parser.on(`close`, () => {
              resolve(zipFs);
          });
          parser.end(tgz);
      });
  }
  exports.makeArchive = makeArchive;


  /***/ }),
  /* 180 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  // high-level commands
  exports.c = exports.create = __webpack_require__(181)
  exports.r = exports.replace = __webpack_require__(203)
  exports.t = exports.list = __webpack_require__(201)
  exports.u = exports.update = __webpack_require__(204)
  exports.x = exports.extract = __webpack_require__(205)

  // classes
  exports.Pack = __webpack_require__(183)
  exports.Unpack = __webpack_require__(206)
  exports.Parse = __webpack_require__(202)
  exports.ReadEntry = __webpack_require__(191)
  exports.WriteEntry = __webpack_require__(193)
  exports.Header = __webpack_require__(195)
  exports.Pax = __webpack_require__(194)
  exports.types = __webpack_require__(192)


  /***/ }),
  /* 181 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  // tar -c
  const hlo = __webpack_require__(182)

  const Pack = __webpack_require__(183)
  const fs = __webpack_require__(7)
  const fsm = __webpack_require__(200)
  const t = __webpack_require__(201)
  const path = __webpack_require__(8)

  const c = module.exports = (opt_, files, cb) => {
    if (typeof files === 'function')
      cb = files

    if (Array.isArray(opt_))
      files = opt_, opt_ = {}

    if (!files || !Array.isArray(files) || !files.length)
      throw new TypeError('no files or directories specified')

    files = Array.from(files)

    const opt = hlo(opt_)

    if (opt.sync && typeof cb === 'function')
      throw new TypeError('callback not supported for sync tar functions')

    if (!opt.file && typeof cb === 'function')
      throw new TypeError('callback only supported with file option')

    return opt.file && opt.sync ? createFileSync(opt, files)
      : opt.file ? createFile(opt, files, cb)
      : opt.sync ? createSync(opt, files)
      : create(opt, files)
  }

  const createFileSync = (opt, files) => {
    const p = new Pack.Sync(opt)
    const stream = new fsm.WriteStreamSync(opt.file, {
      mode: opt.mode || 0o666
    })
    p.pipe(stream)
    addFilesSync(p, files)
  }

  const createFile = (opt, files, cb) => {
    const p = new Pack(opt)
    const stream = new fsm.WriteStream(opt.file, {
      mode: opt.mode || 0o666
    })
    p.pipe(stream)

    const promise = new Promise((res, rej) => {
      stream.on('error', rej)
      stream.on('close', res)
      p.on('error', rej)
    })

    addFilesAsync(p, files)

    return cb ? promise.then(cb, cb) : promise
  }

  const addFilesSync = (p, files) => {
    files.forEach(file => {
      if (file.charAt(0) === '@')
        t({
          file: path.resolve(p.cwd, file.substr(1)),
          sync: true,
          noResume: true,
          onentry: entry => p.add(entry)
        })
      else
        p.add(file)
    })
    p.end()
  }

  const addFilesAsync = (p, files) => {
    while (files.length) {
      const file = files.shift()
      if (file.charAt(0) === '@')
        return t({
          file: path.resolve(p.cwd, file.substr(1)),
          noResume: true,
          onentry: entry => p.add(entry)
        }).then(_ => addFilesAsync(p, files))
      else
        p.add(file)
    }
    p.end()
  }

  const createSync = (opt, files) => {
    const p = new Pack.Sync(opt)
    addFilesSync(p, files)
    return p
  }

  const create = (opt, files) => {
    const p = new Pack(opt)
    addFilesAsync(p, files)
    return p
  }


  /***/ }),
  /* 182 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  // turn tar(1) style args like `C` into the more verbose things like `cwd`

  const argmap = new Map([
    ['C', 'cwd'],
    ['f', 'file'],
    ['z', 'gzip'],
    ['P', 'preservePaths'],
    ['U', 'unlink'],
    ['strip-components', 'strip'],
    ['stripComponents', 'strip'],
    ['keep-newer', 'newer'],
    ['keepNewer', 'newer'],
    ['keep-newer-files', 'newer'],
    ['keepNewerFiles', 'newer'],
    ['k', 'keep'],
    ['keep-existing', 'keep'],
    ['keepExisting', 'keep'],
    ['m', 'noMtime'],
    ['no-mtime', 'noMtime'],
    ['p', 'preserveOwner'],
    ['L', 'follow'],
    ['h', 'follow']
  ])

  const parse = module.exports = opt => opt ? Object.keys(opt).map(k => [
    argmap.has(k) ? argmap.get(k) : k, opt[k]
  ]).reduce((set, kv) => (set[kv[0]] = kv[1], set), Object.create(null)) : {}


  /***/ }),
  /* 183 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const Buffer = __webpack_require__(184)

  // A readable tar stream creator
  // Technically, this is a transform stream that you write paths into,
  // and tar format comes out of.
  // The `add()` method is like `write()` but returns this,
  // and end() return `this` as well, so you can
  // do `new Pack(opt).add('files').add('dir').end().pipe(output)
  // You could also do something like:
  // streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))

  class PackJob {
    constructor (path, absolute) {
      this.path = path || './'
      this.absolute = absolute
      this.entry = null
      this.stat = null
      this.readdir = null
      this.pending = false
      this.ignore = false
      this.piped = false
    }
  }

  const MiniPass = __webpack_require__(186)
  const zlib = __webpack_require__(189)
  const ReadEntry = __webpack_require__(191)
  const WriteEntry = __webpack_require__(193)
  const WriteEntrySync = WriteEntry.Sync
  const WriteEntryTar = WriteEntry.Tar
  const Yallist = __webpack_require__(187)
  const EOF = Buffer.alloc(1024)
  const ONSTAT = Symbol('onStat')
  const ENDED = Symbol('ended')
  const QUEUE = Symbol('queue')
  const CURRENT = Symbol('current')
  const PROCESS = Symbol('process')
  const PROCESSING = Symbol('processing')
  const PROCESSJOB = Symbol('processJob')
  const JOBS = Symbol('jobs')
  const JOBDONE = Symbol('jobDone')
  const ADDFSENTRY = Symbol('addFSEntry')
  const ADDTARENTRY = Symbol('addTarEntry')
  const STAT = Symbol('stat')
  const READDIR = Symbol('readdir')
  const ONREADDIR = Symbol('onreaddir')
  const PIPE = Symbol('pipe')
  const ENTRY = Symbol('entry')
  const ENTRYOPT = Symbol('entryOpt')
  const WRITEENTRYCLASS = Symbol('writeEntryClass')
  const WRITE = Symbol('write')
  const ONDRAIN = Symbol('ondrain')

  const fs = __webpack_require__(7)
  const path = __webpack_require__(8)
  const warner = __webpack_require__(197)

  const Pack = warner(class Pack extends MiniPass {
    constructor (opt) {
      super(opt)
      opt = opt || Object.create(null)
      this.opt = opt
      this.cwd = opt.cwd || process.cwd()
      this.maxReadSize = opt.maxReadSize
      this.preservePaths = !!opt.preservePaths
      this.strict = !!opt.strict
      this.noPax = !!opt.noPax
      this.prefix = (opt.prefix || '').replace(/(\\|\/)+$/, '')
      this.linkCache = opt.linkCache || new Map()
      this.statCache = opt.statCache || new Map()
      this.readdirCache = opt.readdirCache || new Map()

      this[WRITEENTRYCLASS] = WriteEntry
      if (typeof opt.onwarn === 'function')
        this.on('warn', opt.onwarn)

      this.zip = null
      if (opt.gzip) {
        if (typeof opt.gzip !== 'object')
          opt.gzip = {}
        this.zip = new zlib.Gzip(opt.gzip)
        this.zip.on('data', chunk => super.write(chunk))
        this.zip.on('end', _ => super.end())
        this.zip.on('drain', _ => this[ONDRAIN]())
        this.on('resume', _ => this.zip.resume())
      } else
        this.on('drain', this[ONDRAIN])

      this.portable = !!opt.portable
      this.noDirRecurse = !!opt.noDirRecurse
      this.follow = !!opt.follow
      this.noMtime = !!opt.noMtime
      this.mtime = opt.mtime || null

      this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true

      this[QUEUE] = new Yallist
      this[JOBS] = 0
      this.jobs = +opt.jobs || 4
      this[PROCESSING] = false
      this[ENDED] = false
    }

    [WRITE] (chunk) {
      return super.write(chunk)
    }

    add (path) {
      this.write(path)
      return this
    }

    end (path) {
      if (path)
        this.write(path)
      this[ENDED] = true
      this[PROCESS]()
      return this
    }

    write (path) {
      if (this[ENDED])
        throw new Error('write after end')

      if (path instanceof ReadEntry)
        this[ADDTARENTRY](path)
      else
        this[ADDFSENTRY](path)
      return this.flowing
    }

    [ADDTARENTRY] (p) {
      const absolute = path.resolve(this.cwd, p.path)
      if (this.prefix)
        p.path = this.prefix + '/' + p.path.replace(/^\.(\/+|$)/, '')

      // in this case, we don't have to wait for the stat
      if (!this.filter(p.path, p))
        p.resume()
      else {
        const job = new PackJob(p.path, absolute, false)
        job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))
        job.entry.on('end', _ => this[JOBDONE](job))
        this[JOBS] += 1
        this[QUEUE].push(job)
      }

      this[PROCESS]()
    }

    [ADDFSENTRY] (p) {
      const absolute = path.resolve(this.cwd, p)
      if (this.prefix)
        p = this.prefix + '/' + p.replace(/^\.(\/+|$)/, '')

      this[QUEUE].push(new PackJob(p, absolute))
      this[PROCESS]()
    }

    [STAT] (job) {
      job.pending = true
      this[JOBS] += 1
      const stat = this.follow ? 'stat' : 'lstat'
      fs[stat](job.absolute, (er, stat) => {
        job.pending = false
        this[JOBS] -= 1
        if (er)
          this.emit('error', er)
        else
          this[ONSTAT](job, stat)
      })
    }

    [ONSTAT] (job, stat) {
      this.statCache.set(job.absolute, stat)
      job.stat = stat

      // now we have the stat, we can filter it.
      if (!this.filter(job.path, stat))
        job.ignore = true

      this[PROCESS]()
    }

    [READDIR] (job) {
      job.pending = true
      this[JOBS] += 1
      fs.readdir(job.absolute, (er, entries) => {
        job.pending = false
        this[JOBS] -= 1
        if (er)
          return this.emit('error', er)
        this[ONREADDIR](job, entries)
      })
    }

    [ONREADDIR] (job, entries) {
      this.readdirCache.set(job.absolute, entries)
      job.readdir = entries
      this[PROCESS]()
    }

    [PROCESS] () {
      if (this[PROCESSING])
        return

      this[PROCESSING] = true
      for (let w = this[QUEUE].head;
           w !== null && this[JOBS] < this.jobs;
           w = w.next) {
        this[PROCESSJOB](w.value)
        if (w.value.ignore) {
          const p = w.next
          this[QUEUE].removeNode(w)
          w.next = p
        }
      }

      this[PROCESSING] = false

      if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {
        if (this.zip)
          this.zip.end(EOF)
        else {
          super.write(EOF)
          super.end()
        }
      }
    }

    get [CURRENT] () {
      return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value
    }

    [JOBDONE] (job) {
      this[QUEUE].shift()
      this[JOBS] -= 1
      this[PROCESS]()
    }

    [PROCESSJOB] (job) {
      if (job.pending)
        return

      if (job.entry) {
        if (job === this[CURRENT] && !job.piped)
          this[PIPE](job)
        return
      }

      if (!job.stat) {
        if (this.statCache.has(job.absolute))
          this[ONSTAT](job, this.statCache.get(job.absolute))
        else
          this[STAT](job)
      }
      if (!job.stat)
        return

      // filtered out!
      if (job.ignore)
        return

      if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
        if (this.readdirCache.has(job.absolute))
          this[ONREADDIR](job, this.readdirCache.get(job.absolute))
        else
          this[READDIR](job)
        if (!job.readdir)
          return
      }

      // we know it doesn't have an entry, because that got checked above
      job.entry = this[ENTRY](job)
      if (!job.entry) {
        job.ignore = true
        return
      }

      if (job === this[CURRENT] && !job.piped)
        this[PIPE](job)
    }

    [ENTRYOPT] (job) {
      return {
        onwarn: (msg, data) => {
          this.warn(msg, data)
        },
        noPax: this.noPax,
        cwd: this.cwd,
        absolute: job.absolute,
        preservePaths: this.preservePaths,
        maxReadSize: this.maxReadSize,
        strict: this.strict,
        portable: this.portable,
        linkCache: this.linkCache,
        statCache: this.statCache,
        noMtime: this.noMtime,
        mtime: this.mtime
      }
    }

    [ENTRY] (job) {
      this[JOBS] += 1
      try {
        return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))
          .on('end', () => this[JOBDONE](job))
          .on('error', er => this.emit('error', er))
      } catch (er) {
        this.emit('error', er)
      }
    }

    [ONDRAIN] () {
      if (this[CURRENT] && this[CURRENT].entry)
        this[CURRENT].entry.resume()
    }

    // like .pipe() but using super, because our write() is special
    [PIPE] (job) {
      job.piped = true

      if (job.readdir)
        job.readdir.forEach(entry => {
          const p = this.prefix ?
            job.path.slice(this.prefix.length + 1) || './'
            : job.path

          const base = p === './' ? '' : p.replace(/\/*$/, '/')
          this[ADDFSENTRY](base + entry)
        })

      const source = job.entry
      const zip = this.zip

      if (zip)
        source.on('data', chunk => {
          if (!zip.write(chunk))
            source.pause()
        })
      else
        source.on('data', chunk => {
          if (!super.write(chunk))
            source.pause()
        })
    }

    pause () {
      if (this.zip)
        this.zip.pause()
      return super.pause()
    }
  })

  class PackSync extends Pack {
    constructor (opt) {
      super(opt)
      this[WRITEENTRYCLASS] = WriteEntrySync
    }

    // pause/resume are no-ops in sync streams.
    pause () {}
    resume () {}

    [STAT] (job) {
      const stat = this.follow ? 'statSync' : 'lstatSync'
      this[ONSTAT](job, fs[stat](job.absolute))
    }

    [READDIR] (job, stat) {
      this[ONREADDIR](job, fs.readdirSync(job.absolute))
    }

    // gotta get it all in this tick
    [PIPE] (job) {
      const source = job.entry
      const zip = this.zip

      if (job.readdir)
        job.readdir.forEach(entry => {
          const p = this.prefix ?
            job.path.slice(this.prefix.length + 1) || './'
            : job.path

          const base = p === './' ? '' : p.replace(/\/*$/, '/')
          this[ADDFSENTRY](base + entry)
        })

      if (zip)
        source.on('data', chunk => {
          zip.write(chunk)
        })
      else
        source.on('data', chunk => {
          super[WRITE](chunk)
        })
    }
  }

  Pack.Sync = PackSync

  module.exports = Pack


  /***/ }),
  /* 184 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  // Buffer in node 4.x < 4.5.0 doesn't have working Buffer.from
  // or Buffer.alloc, and Buffer in node 10 deprecated the ctor.
  // .M, this is fine .\^/M..
  let B = Buffer
  /* istanbul ignore next */
  if (!B.alloc) {
    B = __webpack_require__(185).Buffer
  }
  module.exports = B


  /***/ }),
  /* 185 */
  /***/ (function(module, exports, __webpack_require__) {

  /* eslint-disable node/no-deprecated-api */
  var buffer = __webpack_require__(160)
  var Buffer = buffer.Buffer

  // alternative to using Object.keys for old browsers
  function copyProps (src, dst) {
    for (var key in src) {
      dst[key] = src[key]
    }
  }
  if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer
  } else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports)
    exports.Buffer = SafeBuffer
  }

  function SafeBuffer (arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length)
  }

  SafeBuffer.prototype = Object.create(Buffer.prototype)

  // Copy static methods from Buffer
  copyProps(Buffer, SafeBuffer)

  SafeBuffer.from = function (arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
      throw new TypeError('Argument must not be a number')
    }
    return Buffer(arg, encodingOrOffset, length)
  }

  SafeBuffer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number')
    }
    var buf = Buffer(size)
    if (fill !== undefined) {
      if (typeof encoding === 'string') {
        buf.fill(fill, encoding)
      } else {
        buf.fill(fill)
      }
    } else {
      buf.fill(0)
    }
    return buf
  }

  SafeBuffer.allocUnsafe = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number')
    }
    return Buffer(size)
  }

  SafeBuffer.allocUnsafeSlow = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number')
    }
    return buffer.SlowBuffer(size)
  }


  /***/ }),
  /* 186 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const EE = __webpack_require__(67)
  const Yallist = __webpack_require__(187)
  const EOF = Symbol('EOF')
  const MAYBE_EMIT_END = Symbol('maybeEmitEnd')
  const EMITTED_END = Symbol('emittedEnd')
  const CLOSED = Symbol('closed')
  const READ = Symbol('read')
  const FLUSH = Symbol('flush')
  const doIter = process.env._MP_NO_ITERATOR_SYMBOLS_  !== '1'
  const ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol('asyncIterator not implemented')
  const ITERATOR = doIter && Symbol.iterator || Symbol('iterator not implemented')
  const FLUSHCHUNK = Symbol('flushChunk')
  const SD = __webpack_require__(178).StringDecoder
  const ENCODING = Symbol('encoding')
  const DECODER = Symbol('decoder')
  const FLOWING = Symbol('flowing')
  const RESUME = Symbol('resume')
  const BUFFERLENGTH = Symbol('bufferLength')
  const BUFFERPUSH = Symbol('bufferPush')
  const BUFFERSHIFT = Symbol('bufferShift')
  const OBJECTMODE = Symbol('objectMode')

  // Buffer in node 4.x < 4.5.0 doesn't have working Buffer.from
  // or Buffer.alloc, and Buffer in node 10 deprecated the ctor.
  // .M, this is fine .\^/M..
  let B = Buffer
  /* istanbul ignore next */
  if (!B.alloc) {
    B = __webpack_require__(185).Buffer
  }

  module.exports = class MiniPass extends EE {
    constructor (options) {
      super()
      this[FLOWING] = false
      this.pipes = new Yallist()
      this.buffer = new Yallist()
      this[OBJECTMODE] = options && options.objectMode || false
      if (this[OBJECTMODE])
        this[ENCODING] = null
      else
        this[ENCODING] = options && options.encoding || null
      if (this[ENCODING] === 'buffer')
        this[ENCODING] = null
      this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null
      this[EOF] = false
      this[EMITTED_END] = false
      this[CLOSED] = false
      this.writable = true
      this.readable = true
      this[BUFFERLENGTH] = 0
    }

    get bufferLength () { return this[BUFFERLENGTH] }

    get encoding () { return this[ENCODING] }
    set encoding (enc) {
      if (this[OBJECTMODE])
        throw new Error('cannot set encoding in objectMode')

      if (this[ENCODING] && enc !== this[ENCODING] &&
          (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
        throw new Error('cannot change encoding')

      if (this[ENCODING] !== enc) {
        this[DECODER] = enc ? new SD(enc) : null
        if (this.buffer.length)
          this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))
      }

      this[ENCODING] = enc
    }

    setEncoding (enc) {
      this.encoding = enc
    }

    write (chunk, encoding, cb) {
      if (this[EOF])
        throw new Error('write after end')

      if (typeof encoding === 'function')
        cb = encoding, encoding = 'utf8'

      if (!encoding)
        encoding = 'utf8'

      // fast-path writing strings of same encoding to a stream with
      // an empty buffer, skipping the buffer/decoder dance
      if (typeof chunk === 'string' && !this[OBJECTMODE] &&
          // unless it is a string already ready for us to use
          !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
        chunk = B.from(chunk, encoding)
      }

      if (B.isBuffer(chunk) && this[ENCODING])
        chunk = this[DECODER].write(chunk)

      try {
        return this.flowing
          ? (this.emit('data', chunk), this.flowing)
          : (this[BUFFERPUSH](chunk), false)
      } finally {
        this.emit('readable')
        if (cb)
          cb()
      }
    }

    read (n) {
      try {
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH])
          return null

        if (this[OBJECTMODE])
          n = null

        if (this.buffer.length > 1 && !this[OBJECTMODE]) {
          if (this.encoding)
            this.buffer = new Yallist([
              Array.from(this.buffer).join('')
            ])
          else
            this.buffer = new Yallist([
              B.concat(Array.from(this.buffer), this[BUFFERLENGTH])
            ])
        }

        return this[READ](n || null, this.buffer.head.value)
      } finally {
        this[MAYBE_EMIT_END]()
      }
    }

    [READ] (n, chunk) {
      if (n === chunk.length || n === null)
        this[BUFFERSHIFT]()
      else {
        this.buffer.head.value = chunk.slice(n)
        chunk = chunk.slice(0, n)
        this[BUFFERLENGTH] -= n
      }

      this.emit('data', chunk)

      if (!this.buffer.length && !this[EOF])
        this.emit('drain')

      return chunk
    }

    end (chunk, encoding, cb) {
      if (typeof chunk === 'function')
        cb = chunk, chunk = null
      if (typeof encoding === 'function')
        cb = encoding, encoding = 'utf8'
      if (chunk)
        this.write(chunk, encoding)
      if (cb)
        this.once('end', cb)
      this[EOF] = true
      this.writable = false
      if (this.flowing)
        this[MAYBE_EMIT_END]()
      return this
    }

    // don't let the internal resume be overwritten
    [RESUME] () {
      this[FLOWING] = true
      this.emit('resume')
      if (this.buffer.length)
        this[FLUSH]()
      else if (this[EOF])
        this[MAYBE_EMIT_END]()
      else
        this.emit('drain')
    }

    resume () {
      return this[RESUME]()
    }

    pause () {
      this[FLOWING] = false
    }

    get flowing () {
      return this[FLOWING]
    }

    [BUFFERPUSH] (chunk) {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] += 1
      else
        this[BUFFERLENGTH] += chunk.length
      return this.buffer.push(chunk)
    }

    [BUFFERSHIFT] () {
      if (this.buffer.length) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] -= 1
        else
          this[BUFFERLENGTH] -= this.buffer.head.value.length
      }
      return this.buffer.shift()
    }

    [FLUSH] () {
      do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))

      if (!this.buffer.length && !this[EOF])
        this.emit('drain')
    }

    [FLUSHCHUNK] (chunk) {
      return chunk ? (this.emit('data', chunk), this.flowing) : false
    }

    pipe (dest, opts) {
      if (dest === process.stdout || dest === process.stderr)
        (opts = opts || {}).end = false
      const p = { dest: dest, opts: opts, ondrain: _ => this[RESUME]() }
      this.pipes.push(p)

      dest.on('drain', p.ondrain)
      this[RESUME]()
      return dest
    }

    addListener (ev, fn) {
      return this.on(ev, fn)
    }

    on (ev, fn) {
      try {
        return super.on(ev, fn)
      } finally {
        if (ev === 'data' && !this.pipes.length && !this.flowing)
          this[RESUME]()
        else if (ev === 'end' && this[EMITTED_END]) {
          super.emit('end')
          this.removeAllListeners('end')
        }
      }
    }

    get emittedEnd () {
      return this[EMITTED_END]
    }

    [MAYBE_EMIT_END] () {
      if (!this[EMITTED_END] && this.buffer.length === 0 && this[EOF]) {
        this.emit('end')
        this.emit('prefinish')
        this.emit('finish')
        if (this[CLOSED])
          this.emit('close')
      }
    }

    emit (ev, data) {
      if (ev === 'data') {
        if (!data)
          return

        if (this.pipes.length)
          this.pipes.forEach(p => p.dest.write(data) || this.pause())
      } else if (ev === 'end') {
        if (this[EMITTED_END] === true)
          return

        this[EMITTED_END] = true
        this.readable = false

        if (this[DECODER]) {
          data = this[DECODER].end()
          if (data) {
            this.pipes.forEach(p => p.dest.write(data))
            super.emit('data', data)
          }
        }

        this.pipes.forEach(p => {
          p.dest.removeListener('drain', p.ondrain)
          if (!p.opts || p.opts.end !== false)
            p.dest.end()
        })
      } else if (ev === 'close') {
        this[CLOSED] = true
        // don't emit close before 'end' and 'finish'
        if (!this[EMITTED_END])
          return
      }

      const args = new Array(arguments.length)
      args[0] = ev
      args[1] = data
      if (arguments.length > 2) {
        for (let i = 2; i < arguments.length; i++) {
          args[i] = arguments[i]
        }
      }

      try {
        return super.emit.apply(this, args)
      } finally {
        if (ev !== 'end')
          this[MAYBE_EMIT_END]()
        else
          this.removeAllListeners('end')
      }
    }

    // const all = await stream.collect()
    collect () {
      return new Promise((resolve, reject) => {
        const buf = []
        this.on('data', c => buf.push(c))
        this.on('end', () => resolve(buf))
        this.on('error', er => reject(er))
      })
    }

    // const data = await stream.concat()
    concat () {
      return this.collect().then(chunks =>
        this[ENCODING] ? chunks.join('') : Buffer.concat(chunks))
    }

    // for await (let chunk of stream)
    [ASYNCITERATOR] () {
      const next = () => {
        const res = this.read()
        if (res !== null)
          return Promise.resolve({ done: false, value: res })

        if (this[EOF])
          return Promise.resolve({ done: true })

        let resolve = null
        let reject = null
        const onerr = er => {
          this.removeListener('data', ondata)
          this.removeListener('end', onend)
          reject(er)
        }
        const ondata = value => {
          this.removeListener('error', onerr)
          this.removeListener('end', onend)
          this.pause()
          resolve({ value: value, done: !!this[EOF] })
        }
        const onend = () => {
          this.removeListener('error', onerr)
          this.removeListener('data', ondata)
          resolve({ done: true })
        }
        return new Promise((res, rej) => {
          reject = rej
          resolve = res
          this.once('error', onerr)
          this.once('end', onend)
          this.once('data', ondata)
        })
      }

      return { next }
    }

    // for (let chunk of stream)
    [ITERATOR] () {
      const next = () => {
        const value = this.read()
        const done = value === null
        return { value, done }
      }
      return { next }
    }
  }


  /***/ }),
  /* 187 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  module.exports = Yallist

  Yallist.Node = Node
  Yallist.create = Yallist

  function Yallist (list) {
    var self = this
    if (!(self instanceof Yallist)) {
      self = new Yallist()
    }

    self.tail = null
    self.head = null
    self.length = 0

    if (list && typeof list.forEach === 'function') {
      list.forEach(function (item) {
        self.push(item)
      })
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length; i < l; i++) {
        self.push(arguments[i])
      }
    }

    return self
  }

  Yallist.prototype.removeNode = function (node) {
    if (node.list !== this) {
      throw new Error('removing node which does not belong to this list')
    }

    var next = node.next
    var prev = node.prev

    if (next) {
      next.prev = prev
    }

    if (prev) {
      prev.next = next
    }

    if (node === this.head) {
      this.head = next
    }
    if (node === this.tail) {
      this.tail = prev
    }

    node.list.length--
    node.next = null
    node.prev = null
    node.list = null
  }

  Yallist.prototype.unshiftNode = function (node) {
    if (node === this.head) {
      return
    }

    if (node.list) {
      node.list.removeNode(node)
    }

    var head = this.head
    node.list = this
    node.next = head
    if (head) {
      head.prev = node
    }

    this.head = node
    if (!this.tail) {
      this.tail = node
    }
    this.length++
  }

  Yallist.prototype.pushNode = function (node) {
    if (node === this.tail) {
      return
    }

    if (node.list) {
      node.list.removeNode(node)
    }

    var tail = this.tail
    node.list = this
    node.prev = tail
    if (tail) {
      tail.next = node
    }

    this.tail = node
    if (!this.head) {
      this.head = node
    }
    this.length++
  }

  Yallist.prototype.push = function () {
    for (var i = 0, l = arguments.length; i < l; i++) {
      push(this, arguments[i])
    }
    return this.length
  }

  Yallist.prototype.unshift = function () {
    for (var i = 0, l = arguments.length; i < l; i++) {
      unshift(this, arguments[i])
    }
    return this.length
  }

  Yallist.prototype.pop = function () {
    if (!this.tail) {
      return undefined
    }

    var res = this.tail.value
    this.tail = this.tail.prev
    if (this.tail) {
      this.tail.next = null
    } else {
      this.head = null
    }
    this.length--
    return res
  }

  Yallist.prototype.shift = function () {
    if (!this.head) {
      return undefined
    }

    var res = this.head.value
    this.head = this.head.next
    if (this.head) {
      this.head.prev = null
    } else {
      this.tail = null
    }
    this.length--
    return res
  }

  Yallist.prototype.forEach = function (fn, thisp) {
    thisp = thisp || this
    for (var walker = this.head, i = 0; walker !== null; i++) {
      fn.call(thisp, walker.value, i, this)
      walker = walker.next
    }
  }

  Yallist.prototype.forEachReverse = function (fn, thisp) {
    thisp = thisp || this
    for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
      fn.call(thisp, walker.value, i, this)
      walker = walker.prev
    }
  }

  Yallist.prototype.get = function (n) {
    for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
      // abort out of the list early if we hit a cycle
      walker = walker.next
    }
    if (i === n && walker !== null) {
      return walker.value
    }
  }

  Yallist.prototype.getReverse = function (n) {
    for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
      // abort out of the list early if we hit a cycle
      walker = walker.prev
    }
    if (i === n && walker !== null) {
      return walker.value
    }
  }

  Yallist.prototype.map = function (fn, thisp) {
    thisp = thisp || this
    var res = new Yallist()
    for (var walker = this.head; walker !== null;) {
      res.push(fn.call(thisp, walker.value, this))
      walker = walker.next
    }
    return res
  }

  Yallist.prototype.mapReverse = function (fn, thisp) {
    thisp = thisp || this
    var res = new Yallist()
    for (var walker = this.tail; walker !== null;) {
      res.push(fn.call(thisp, walker.value, this))
      walker = walker.prev
    }
    return res
  }

  Yallist.prototype.reduce = function (fn, initial) {
    var acc
    var walker = this.head
    if (arguments.length > 1) {
      acc = initial
    } else if (this.head) {
      walker = this.head.next
      acc = this.head.value
    } else {
      throw new TypeError('Reduce of empty list with no initial value')
    }

    for (var i = 0; walker !== null; i++) {
      acc = fn(acc, walker.value, i)
      walker = walker.next
    }

    return acc
  }

  Yallist.prototype.reduceReverse = function (fn, initial) {
    var acc
    var walker = this.tail
    if (arguments.length > 1) {
      acc = initial
    } else if (this.tail) {
      walker = this.tail.prev
      acc = this.tail.value
    } else {
      throw new TypeError('Reduce of empty list with no initial value')
    }

    for (var i = this.length - 1; walker !== null; i--) {
      acc = fn(acc, walker.value, i)
      walker = walker.prev
    }

    return acc
  }

  Yallist.prototype.toArray = function () {
    var arr = new Array(this.length)
    for (var i = 0, walker = this.head; walker !== null; i++) {
      arr[i] = walker.value
      walker = walker.next
    }
    return arr
  }

  Yallist.prototype.toArrayReverse = function () {
    var arr = new Array(this.length)
    for (var i = 0, walker = this.tail; walker !== null; i++) {
      arr[i] = walker.value
      walker = walker.prev
    }
    return arr
  }

  Yallist.prototype.slice = function (from, to) {
    to = to || this.length
    if (to < 0) {
      to += this.length
    }
    from = from || 0
    if (from < 0) {
      from += this.length
    }
    var ret = new Yallist()
    if (to < from || to < 0) {
      return ret
    }
    if (from < 0) {
      from = 0
    }
    if (to > this.length) {
      to = this.length
    }
    for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
      walker = walker.next
    }
    for (; walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value)
    }
    return ret
  }

  Yallist.prototype.sliceReverse = function (from, to) {
    to = to || this.length
    if (to < 0) {
      to += this.length
    }
    from = from || 0
    if (from < 0) {
      from += this.length
    }
    var ret = new Yallist()
    if (to < from || to < 0) {
      return ret
    }
    if (from < 0) {
      from = 0
    }
    if (to > this.length) {
      to = this.length
    }
    for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
      walker = walker.prev
    }
    for (; walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value)
    }
    return ret
  }

  Yallist.prototype.reverse = function () {
    var head = this.head
    var tail = this.tail
    for (var walker = head; walker !== null; walker = walker.prev) {
      var p = walker.prev
      walker.prev = walker.next
      walker.next = p
    }
    this.head = tail
    this.tail = head
    return this
  }

  function push (self, item) {
    self.tail = new Node(item, self.tail, null, self)
    if (!self.head) {
      self.head = self.tail
    }
    self.length++
  }

  function unshift (self, item) {
    self.head = new Node(item, null, self.head, self)
    if (!self.tail) {
      self.tail = self.head
    }
    self.length++
  }

  function Node (value, prev, next, list) {
    if (!(this instanceof Node)) {
      return new Node(value, prev, next, list)
    }

    this.list = list
    this.value = value

    if (prev) {
      prev.next = this
      this.prev = prev
    } else {
      this.prev = null
    }

    if (next) {
      next.prev = this
      this.next = next
    } else {
      this.next = null
    }
  }

  try {
    // add if support for Symbol.iterator is present
    __webpack_require__(188)(Yallist)
  } catch (er) {}


  /***/ }),
  /* 188 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  module.exports = function (Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) {
        yield walker.value
      }
    }
  }


  /***/ }),
  /* 189 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const assert = __webpack_require__(127)
  const Buffer = __webpack_require__(160).Buffer
  const realZlib = __webpack_require__(94)

  const constants = exports.constants = __webpack_require__(190)
  const MiniPass = __webpack_require__(186)

  const OriginalBufferConcat = Buffer.concat

  class ZlibError extends Error {
    constructor (msg, errno) {
      super('zlib: ' + msg)
      this.errno = errno
      this.code = codes.get(errno)
    }

    get name () {
      return 'ZlibError'
    }
  }

  // translation table for return codes.
  const codes = new Map([
    [constants.Z_OK, 'Z_OK'],
    [constants.Z_STREAM_END, 'Z_STREAM_END'],
    [constants.Z_NEED_DICT, 'Z_NEED_DICT'],
    [constants.Z_ERRNO, 'Z_ERRNO'],
    [constants.Z_STREAM_ERROR, 'Z_STREAM_ERROR'],
    [constants.Z_DATA_ERROR, 'Z_DATA_ERROR'],
    [constants.Z_MEM_ERROR, 'Z_MEM_ERROR'],
    [constants.Z_BUF_ERROR, 'Z_BUF_ERROR'],
    [constants.Z_VERSION_ERROR, 'Z_VERSION_ERROR']
  ])

  const validFlushFlags = new Set([
    constants.Z_NO_FLUSH,
    constants.Z_PARTIAL_FLUSH,
    constants.Z_SYNC_FLUSH,
    constants.Z_FULL_FLUSH,
    constants.Z_FINISH,
    constants.Z_BLOCK
  ])

  const strategies = new Set([
    constants.Z_FILTERED,
    constants.Z_HUFFMAN_ONLY,
    constants.Z_RLE,
    constants.Z_FIXED,
    constants.Z_DEFAULT_STRATEGY
  ])

  // the Zlib class they all inherit from
  // This thing manages the queue of requests, and returns
  // true or false if there is anything in the queue when
  // you call the .write() method.
  const _opts = Symbol('opts')
  const _flushFlag = Symbol('flushFlag')
  const _finishFlush = Symbol('finishFlush')
  const _handle = Symbol('handle')
  const _onError = Symbol('onError')
  const _level = Symbol('level')
  const _strategy = Symbol('strategy')
  const _ended = Symbol('ended')

  class Zlib extends MiniPass {
    constructor (opts, mode) {
      super(opts)
      this[_ended] = false
      this[_opts] = opts = opts || {}
      if (opts.flush && !validFlushFlags.has(opts.flush)) {
        throw new TypeError('Invalid flush flag: ' + opts.flush)
      }
      if (opts.finishFlush && !validFlushFlags.has(opts.finishFlush)) {
        throw new TypeError('Invalid flush flag: ' + opts.finishFlush)
      }

      this[_flushFlag] = opts.flush || constants.Z_NO_FLUSH
      this[_finishFlush] = typeof opts.finishFlush !== 'undefined' ?
        opts.finishFlush : constants.Z_FINISH

      if (opts.chunkSize) {
        if (opts.chunkSize < constants.Z_MIN_CHUNK) {
          throw new RangeError('Invalid chunk size: ' + opts.chunkSize)
        }
      }

      if (opts.windowBits) {
        if (opts.windowBits < constants.Z_MIN_WINDOWBITS ||
            opts.windowBits > constants.Z_MAX_WINDOWBITS) {
          throw new RangeError('Invalid windowBits: ' + opts.windowBits)
        }
      }

      if (opts.level) {
        if (opts.level < constants.Z_MIN_LEVEL ||
            opts.level > constants.Z_MAX_LEVEL) {
          throw new RangeError('Invalid compression level: ' + opts.level)
        }
      }

      if (opts.memLevel) {
        if (opts.memLevel < constants.Z_MIN_MEMLEVEL ||
            opts.memLevel > constants.Z_MAX_MEMLEVEL) {
          throw new RangeError('Invalid memLevel: ' + opts.memLevel)
        }
      }

      if (opts.strategy && !(strategies.has(opts.strategy)))
        throw new TypeError('Invalid strategy: ' + opts.strategy)

      if (opts.dictionary) {
        if (!(opts.dictionary instanceof Buffer)) {
          throw new TypeError('Invalid dictionary: it should be a Buffer instance')
        }
      }

      this[_handle] = new realZlib[mode](opts)

      this[_onError] = (err) => {
        // there is no way to cleanly recover.
        // continuing only obscures problems.
        this.close()

        const error = new ZlibError(err.message, err.errno)
        this.emit('error', error)
      }
      this[_handle].on('error', this[_onError])

      const level = typeof opts.level === 'number' ? opts.level
                  : constants.Z_DEFAULT_COMPRESSION

      var strategy = typeof opts.strategy === 'number' ? opts.strategy
                   : constants.Z_DEFAULT_STRATEGY

      // API changed in node v9
      /* istanbul ignore next */

      this[_level] = level
      this[_strategy] = strategy

      this.once('end', this.close)
    }

    close () {
      if (this[_handle]) {
        this[_handle].close()
        this[_handle] = null
        this.emit('close')
      }
    }

    params (level, strategy) {
      if (!this[_handle])
        throw new Error('cannot switch params when binding is closed')

      // no way to test this without also not supporting params at all
      /* istanbul ignore if */
      if (!this[_handle].params)
        throw new Error('not supported in this implementation')

      if (level < constants.Z_MIN_LEVEL ||
          level > constants.Z_MAX_LEVEL) {
        throw new RangeError('Invalid compression level: ' + level)
      }

      if (!(strategies.has(strategy)))
        throw new TypeError('Invalid strategy: ' + strategy)

      if (this[_level] !== level || this[_strategy] !== strategy) {
        this.flush(constants.Z_SYNC_FLUSH)
        assert(this[_handle], 'zlib binding closed')
        // .params() calls .flush(), but the latter is always async in the
        // core zlib. We override .flush() temporarily to intercept that and
        // flush synchronously.
        const origFlush = this[_handle].flush
        this[_handle].flush = (flushFlag, cb) => {
          this[_handle].flush = origFlush
          this.flush(flushFlag)
          cb()
        }
        this[_handle].params(level, strategy)
        /* istanbul ignore else */
        if (this[_handle]) {
          this[_level] = level
          this[_strategy] = strategy
        }
      }
    }

    reset () {
      assert(this[_handle], 'zlib binding closed')
      return this[_handle].reset()
    }

    flush (kind) {
      if (kind === undefined)
        kind = constants.Z_FULL_FLUSH

      if (this.ended)
        return

      const flushFlag = this[_flushFlag]
      this[_flushFlag] = kind
      this.write(Buffer.alloc(0))
      this[_flushFlag] = flushFlag
    }

    end (chunk, encoding, cb) {
      if (chunk)
        this.write(chunk, encoding)
      this.flush(this[_finishFlush])
      this[_ended] = true
      return super.end(null, null, cb)
    }

    get ended () {
      return this[_ended]
    }

    write (chunk, encoding, cb) {
      // process the chunk using the sync process
      // then super.write() all the outputted chunks
      if (typeof encoding === 'function')
        cb = encoding, encoding = 'utf8'

      if (typeof chunk === 'string')
        chunk = Buffer.from(chunk, encoding)

      assert(this[_handle], 'zlib binding closed')

      // _processChunk tries to .close() the native handle after it's done, so we
      // intercept that by temporarily making it a no-op.
      const nativeHandle = this[_handle]._handle
      const originalNativeClose = nativeHandle.close
      nativeHandle.close = () => {}
      const originalClose = this[_handle].close
      this[_handle].close = () => {}
      // It also calls `Buffer.concat()` at the end, which may be convenient
      // for some, but which we are not interested in as it slows us down.
      Buffer.concat = (args) => args
      let result
      try {
        result = this[_handle]._processChunk(chunk, this[_flushFlag])
      } catch (err) {
        this[_onError](err)
      } finally {
        Buffer.concat = OriginalBufferConcat
        if (this[_handle]) {
          // Core zlib resets `_handle` to null after attempting to close the
          // native handle. Our no-op handler prevented actual closure, but we
          // need to restore the `._handle` property.
          this[_handle]._handle = nativeHandle
          nativeHandle.close = originalNativeClose
          this[_handle].close = originalClose
          // `_processChunk()` adds an 'error' listener. If we don't remove it
          // after each call, these handlers start piling up.
          this[_handle].removeAllListeners('error')
        }
      }

      let writeReturn
      if (result) {
        if (Array.isArray(result) && result.length > 0) {
          // The first buffer is always `handle._outBuffer`, which would be
          // re-used for later invocations; so, we always have to copy that one.
          writeReturn = super.write(Buffer.from(result[0]))
          for (let i = 1; i < result.length; i++) {
            writeReturn = super.write(result[i])
          }
        } else {
          writeReturn = super.write(Buffer.from(result))
        }
      }

      if (cb)
        cb()
      return writeReturn
    }
  }

  // minimal 2-byte header
  class Deflate extends Zlib {
    constructor (opts) {
      super(opts, 'Deflate')
    }
  }

  class Inflate extends Zlib {
    constructor (opts) {
      super(opts, 'Inflate')
    }
  }

  // gzip - bigger header, same deflate compression
  class Gzip extends Zlib {
    constructor (opts) {
      super(opts, 'Gzip')
    }
  }

  class Gunzip extends Zlib {
    constructor (opts) {
      super(opts, 'Gunzip')
    }
  }

  // raw - no header
  class DeflateRaw extends Zlib {
    constructor (opts) {
      super(opts, 'DeflateRaw')
    }
  }

  class InflateRaw extends Zlib {
    constructor (opts) {
      super(opts, 'InflateRaw')
    }
  }

  // auto-detect header.
  class Unzip extends Zlib {
    constructor (opts) {
      super(opts, 'Unzip')
    }
  }

  exports.Deflate = Deflate
  exports.Inflate = Inflate
  exports.Gzip = Gzip
  exports.Gunzip = Gunzip
  exports.DeflateRaw = DeflateRaw
  exports.InflateRaw = InflateRaw
  exports.Unzip = Unzip


  /***/ }),
  /* 190 */
  /***/ (function(module, exports) {

  module.exports = Object.freeze({
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    ZLIB_VERNUM: 4736,
    DEFLATE: 1,
    INFLATE: 2,
    GZIP: 3,
    GUNZIP: 4,
    DEFLATERAW: 5,
    INFLATERAW: 6,
    UNZIP: 7,
    Z_MIN_WINDOWBITS: 8,
    Z_MAX_WINDOWBITS: 15,
    Z_DEFAULT_WINDOWBITS: 15,
    Z_MIN_CHUNK: 64,
    Z_MAX_CHUNK: Infinity,
    Z_DEFAULT_CHUNK: 16384,
    Z_MIN_MEMLEVEL: 1,
    Z_MAX_MEMLEVEL: 9,
    Z_DEFAULT_MEMLEVEL: 8,
    Z_MIN_LEVEL: -1,
    Z_MAX_LEVEL: 9,
    Z_DEFAULT_LEVEL: -1
  })


  /***/ }),
  /* 191 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const types = __webpack_require__(192)
  const MiniPass = __webpack_require__(186)

  const SLURP = Symbol('slurp')
  module.exports = class ReadEntry extends MiniPass {
    constructor (header, ex, gex) {
      super()
      this.extended = ex
      this.globalExtended = gex
      this.header = header
      this.startBlockSize = 512 * Math.ceil(header.size / 512)
      this.blockRemain = this.startBlockSize
      this.remain = header.size
      this.type = header.type
      this.meta = false
      this.ignore = false
      switch (this.type) {
        case 'File':
        case 'OldFile':
        case 'Link':
        case 'SymbolicLink':
        case 'CharacterDevice':
        case 'BlockDevice':
        case 'Directory':
        case 'FIFO':
        case 'ContiguousFile':
        case 'GNUDumpDir':
          break

        case 'NextFileHasLongLinkpath':
        case 'NextFileHasLongPath':
        case 'OldGnuLongPath':
        case 'GlobalExtendedHeader':
        case 'ExtendedHeader':
        case 'OldExtendedHeader':
          this.meta = true
          break

        // NOTE: gnutar and bsdtar treat unrecognized types as 'File'
        // it may be worth doing the same, but with a warning.
        default:
          this.ignore = true
      }

      this.path = header.path
      this.mode = header.mode
      if (this.mode)
        this.mode = this.mode & 0o7777
      this.uid = header.uid
      this.gid = header.gid
      this.uname = header.uname
      this.gname = header.gname
      this.size = header.size
      this.mtime = header.mtime
      this.atime = header.atime
      this.ctime = header.ctime
      this.linkpath = header.linkpath
      this.uname = header.uname
      this.gname = header.gname

      if (ex) this[SLURP](ex)
      if (gex) this[SLURP](gex, true)
    }

    write (data) {
      const writeLen = data.length
      if (writeLen > this.blockRemain)
        throw new Error('writing more to entry than is appropriate')

      const r = this.remain
      const br = this.blockRemain
      this.remain = Math.max(0, r - writeLen)
      this.blockRemain = Math.max(0, br - writeLen)
      if (this.ignore)
        return true

      if (r >= writeLen)
        return super.write(data)

      // r < writeLen
      return super.write(data.slice(0, r))
    }

    [SLURP] (ex, global) {
      for (let k in ex) {
        // we slurp in everything except for the path attribute in
        // a global extended header, because that's weird.
        if (ex[k] !== null && ex[k] !== undefined &&
            !(global && k === 'path'))
          this[k] = ex[k]
      }
    }
  }


  /***/ }),
  /* 192 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  // map types from key to human-friendly name
  exports.name = new Map([
    ['0', 'File'],
    // same as File
    ['', 'OldFile'],
    ['1', 'Link'],
    ['2', 'SymbolicLink'],
    // Devices and FIFOs aren't fully supported
    // they are parsed, but skipped when unpacking
    ['3', 'CharacterDevice'],
    ['4', 'BlockDevice'],
    ['5', 'Directory'],
    ['6', 'FIFO'],
    // same as File
    ['7', 'ContiguousFile'],
    // pax headers
    ['g', 'GlobalExtendedHeader'],
    ['x', 'ExtendedHeader'],
    // vendor-specific stuff
    // skip
    ['A', 'SolarisACL'],
    // like 5, but with data, which should be skipped
    ['D', 'GNUDumpDir'],
    // metadata only, skip
    ['I', 'Inode'],
    // data = link path of next file
    ['K', 'NextFileHasLongLinkpath'],
    // data = path of next file
    ['L', 'NextFileHasLongPath'],
    // skip
    ['M', 'ContinuationFile'],
    // like L
    ['N', 'OldGnuLongPath'],
    // skip
    ['S', 'SparseFile'],
    // skip
    ['V', 'TapeVolumeHeader'],
    // like x
    ['X', 'OldExtendedHeader']
  ])

  // map the other direction
  exports.code = new Map(Array.from(exports.name).map(kv => [kv[1], kv[0]]))


  /***/ }),
  /* 193 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const Buffer = __webpack_require__(184)
  const MiniPass = __webpack_require__(186)
  const Pax = __webpack_require__(194)
  const Header = __webpack_require__(195)
  const ReadEntry = __webpack_require__(191)
  const fs = __webpack_require__(7)
  const path = __webpack_require__(8)

  const types = __webpack_require__(192)
  const maxReadSize = 16 * 1024 * 1024
  const PROCESS = Symbol('process')
  const FILE = Symbol('file')
  const DIRECTORY = Symbol('directory')
  const SYMLINK = Symbol('symlink')
  const HARDLINK = Symbol('hardlink')
  const HEADER = Symbol('header')
  const READ = Symbol('read')
  const LSTAT = Symbol('lstat')
  const ONLSTAT = Symbol('onlstat')
  const ONREAD = Symbol('onread')
  const ONREADLINK = Symbol('onreadlink')
  const OPENFILE = Symbol('openfile')
  const ONOPENFILE = Symbol('onopenfile')
  const CLOSE = Symbol('close')
  const MODE = Symbol('mode')
  const warner = __webpack_require__(197)
  const winchars = __webpack_require__(198)

  const modeFix = __webpack_require__(199)

  const WriteEntry = warner(class WriteEntry extends MiniPass {
    constructor (p, opt) {
      opt = opt || {}
      super(opt)
      if (typeof p !== 'string')
        throw new TypeError('path is required')
      this.path = p
      // suppress atime, ctime, uid, gid, uname, gname
      this.portable = !!opt.portable
      // until node has builtin pwnam functions, this'll have to do
      this.myuid = process.getuid && process.getuid()
      this.myuser = process.env.USER || ''
      this.maxReadSize = opt.maxReadSize || maxReadSize
      this.linkCache = opt.linkCache || new Map()
      this.statCache = opt.statCache || new Map()
      this.preservePaths = !!opt.preservePaths
      this.cwd = opt.cwd || process.cwd()
      this.strict = !!opt.strict
      this.noPax = !!opt.noPax
      this.noMtime = !!opt.noMtime
      this.mtime = opt.mtime || null

      if (typeof opt.onwarn === 'function')
        this.on('warn', opt.onwarn)

      if (!this.preservePaths && path.win32.isAbsolute(p)) {
        // absolutes on posix are also absolutes on win32
        // so we only need to test this one to get both
        const parsed = path.win32.parse(p)
        this.warn('stripping ' + parsed.root + ' from absolute path', p)
        this.path = p.substr(parsed.root.length)
      }

      this.win32 = !!opt.win32 || process.platform === 'win32'
      if (this.win32) {
        this.path = winchars.decode(this.path.replace(/\\/g, '/'))
        p = p.replace(/\\/g, '/')
      }

      this.absolute = opt.absolute || path.resolve(this.cwd, p)

      if (this.path === '')
        this.path = './'

      if (this.statCache.has(this.absolute))
        this[ONLSTAT](this.statCache.get(this.absolute))
      else
        this[LSTAT]()
    }

    [LSTAT] () {
      fs.lstat(this.absolute, (er, stat) => {
        if (er)
          return this.emit('error', er)
        this[ONLSTAT](stat)
      })
    }

    [ONLSTAT] (stat) {
      this.statCache.set(this.absolute, stat)
      this.stat = stat
      if (!stat.isFile())
        stat.size = 0
      this.type = getType(stat)
      this.emit('stat', stat)
      this[PROCESS]()
    }

    [PROCESS] () {
      switch (this.type) {
        case 'File': return this[FILE]()
        case 'Directory': return this[DIRECTORY]()
        case 'SymbolicLink': return this[SYMLINK]()
        // unsupported types are ignored.
        default: return this.end()
      }
    }

    [MODE] (mode) {
      return modeFix(mode, this.type === 'Directory')
    }

    [HEADER] () {
      if (this.type === 'Directory' && this.portable)
        this.noMtime = true

      this.header = new Header({
        path: this.path,
        linkpath: this.linkpath,
        // only the permissions and setuid/setgid/sticky bitflags
        // not the higher-order bits that specify file type
        mode: this[MODE](this.stat.mode),
        uid: this.portable ? null : this.stat.uid,
        gid: this.portable ? null : this.stat.gid,
        size: this.stat.size,
        mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
        type: this.type,
        uname: this.portable ? null :
          this.stat.uid === this.myuid ? this.myuser : '',
        atime: this.portable ? null : this.stat.atime,
        ctime: this.portable ? null : this.stat.ctime
      })

      if (this.header.encode() && !this.noPax)
        this.write(new Pax({
          atime: this.portable ? null : this.header.atime,
          ctime: this.portable ? null : this.header.ctime,
          gid: this.portable ? null : this.header.gid,
          mtime: this.noMtime ? null : this.mtime || this.header.mtime,
          path: this.path,
          linkpath: this.linkpath,
          size: this.header.size,
          uid: this.portable ? null : this.header.uid,
          uname: this.portable ? null : this.header.uname,
          dev: this.portable ? null : this.stat.dev,
          ino: this.portable ? null : this.stat.ino,
          nlink: this.portable ? null : this.stat.nlink
        }).encode())
      this.write(this.header.block)
    }

    [DIRECTORY] () {
      if (this.path.substr(-1) !== '/')
        this.path += '/'
      this.stat.size = 0
      this[HEADER]()
      this.end()
    }

    [SYMLINK] () {
      fs.readlink(this.absolute, (er, linkpath) => {
        if (er)
          return this.emit('error', er)
        this[ONREADLINK](linkpath)
      })
    }

    [ONREADLINK] (linkpath) {
      this.linkpath = linkpath
      this[HEADER]()
      this.end()
    }

    [HARDLINK] (linkpath) {
      this.type = 'Link'
      this.linkpath = path.relative(this.cwd, linkpath)
      this.stat.size = 0
      this[HEADER]()
      this.end()
    }

    [FILE] () {
      if (this.stat.nlink > 1) {
        const linkKey = this.stat.dev + ':' + this.stat.ino
        if (this.linkCache.has(linkKey)) {
          const linkpath = this.linkCache.get(linkKey)
          if (linkpath.indexOf(this.cwd) === 0)
            return this[HARDLINK](linkpath)
        }
        this.linkCache.set(linkKey, this.absolute)
      }

      this[HEADER]()
      if (this.stat.size === 0)
        return this.end()

      this[OPENFILE]()
    }

    [OPENFILE] () {
      fs.open(this.absolute, 'r', (er, fd) => {
        if (er)
          return this.emit('error', er)
        this[ONOPENFILE](fd)
      })
    }

    [ONOPENFILE] (fd) {
      const blockLen = 512 * Math.ceil(this.stat.size / 512)
      const bufLen = Math.min(blockLen, this.maxReadSize)
      const buf = Buffer.allocUnsafe(bufLen)
      this[READ](fd, buf, 0, buf.length, 0, this.stat.size, blockLen)
    }

    [READ] (fd, buf, offset, length, pos, remain, blockRemain) {
      fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {
        if (er)
          return this[CLOSE](fd, _ => this.emit('error', er))
        this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead)
      })
    }

    [CLOSE] (fd, cb) {
      fs.close(fd, cb)
    }

    [ONREAD] (fd, buf, offset, length, pos, remain, blockRemain, bytesRead) {
      if (bytesRead <= 0 && remain > 0) {
        const er = new Error('encountered unexpected EOF')
        er.path = this.absolute
        er.syscall = 'read'
        er.code = 'EOF'
        this[CLOSE](fd)
        return this.emit('error', er)
      }

      if (bytesRead > remain) {
        const er = new Error('did not encounter expected EOF')
        er.path = this.absolute
        er.syscall = 'read'
        er.code = 'EOF'
        this[CLOSE](fd)
        return this.emit('error', er)
      }

      // null out the rest of the buffer, if we could fit the block padding
      if (bytesRead === remain) {
        for (let i = bytesRead; i < length && bytesRead < blockRemain; i++) {
          buf[i + offset] = 0
          bytesRead ++
          remain ++
        }
      }

      const writeBuf = offset === 0 && bytesRead === buf.length ?
        buf : buf.slice(offset, offset + bytesRead)
      remain -= bytesRead
      blockRemain -= bytesRead
      pos += bytesRead
      offset += bytesRead

      this.write(writeBuf)

      if (!remain) {
        if (blockRemain)
          this.write(Buffer.alloc(blockRemain))
        this.end()
        this[CLOSE](fd, _ => _)
        return
      }

      if (offset >= length) {
        buf = Buffer.allocUnsafe(length)
        offset = 0
      }
      length = buf.length - offset
      this[READ](fd, buf, offset, length, pos, remain, blockRemain)
    }
  })

  class WriteEntrySync extends WriteEntry {
    constructor (path, opt) {
      super(path, opt)
    }

    [LSTAT] () {
      this[ONLSTAT](fs.lstatSync(this.absolute))
    }

    [SYMLINK] () {
      this[ONREADLINK](fs.readlinkSync(this.absolute))
    }

    [OPENFILE] () {
      this[ONOPENFILE](fs.openSync(this.absolute, 'r'))
    }

    [READ] (fd, buf, offset, length, pos, remain, blockRemain) {
      let threw = true
      try {
        const bytesRead = fs.readSync(fd, buf, offset, length, pos)
        this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead)
        threw = false
      } finally {
        if (threw)
          try { this[CLOSE](fd) } catch (er) {}
      }
    }

    [CLOSE] (fd) {
      fs.closeSync(fd)
    }
  }

  const WriteEntryTar = warner(class WriteEntryTar extends MiniPass {
    constructor (readEntry, opt) {
      opt = opt || {}
      super(opt)
      this.preservePaths = !!opt.preservePaths
      this.portable = !!opt.portable
      this.strict = !!opt.strict
      this.noPax = !!opt.noPax
      this.noMtime = !!opt.noMtime

      this.readEntry = readEntry
      this.type = readEntry.type
      if (this.type === 'Directory' && this.portable)
        this.noMtime = true

      this.path = readEntry.path
      this.mode = this[MODE](readEntry.mode)
      this.uid = this.portable ? null : readEntry.uid
      this.gid = this.portable ? null : readEntry.gid
      this.uname = this.portable ? null : readEntry.uname
      this.gname = this.portable ? null : readEntry.gname
      this.size = readEntry.size
      this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime
      this.atime = this.portable ? null : readEntry.atime
      this.ctime = this.portable ? null : readEntry.ctime
      this.linkpath = readEntry.linkpath

      if (typeof opt.onwarn === 'function')
        this.on('warn', opt.onwarn)

      if (path.isAbsolute(this.path) && !this.preservePaths) {
        const parsed = path.parse(this.path)
        this.warn(
          'stripping ' + parsed.root + ' from absolute path',
          this.path
        )
        this.path = this.path.substr(parsed.root.length)
      }

      this.remain = readEntry.size
      this.blockRemain = readEntry.startBlockSize

      this.header = new Header({
        path: this.path,
        linkpath: this.linkpath,
        // only the permissions and setuid/setgid/sticky bitflags
        // not the higher-order bits that specify file type
        mode: this.mode,
        uid: this.portable ? null : this.uid,
        gid: this.portable ? null : this.gid,
        size: this.size,
        mtime: this.noMtime ? null : this.mtime,
        type: this.type,
        uname: this.portable ? null : this.uname,
        atime: this.portable ? null : this.atime,
        ctime: this.portable ? null : this.ctime
      })

      if (this.header.encode() && !this.noPax)
        super.write(new Pax({
          atime: this.portable ? null : this.atime,
          ctime: this.portable ? null : this.ctime,
          gid: this.portable ? null : this.gid,
          mtime: this.noMtime ? null : this.mtime,
          path: this.path,
          linkpath: this.linkpath,
          size: this.size,
          uid: this.portable ? null : this.uid,
          uname: this.portable ? null : this.uname,
          dev: this.portable ? null : this.readEntry.dev,
          ino: this.portable ? null : this.readEntry.ino,
          nlink: this.portable ? null : this.readEntry.nlink
        }).encode())

      super.write(this.header.block)
      readEntry.pipe(this)
    }

    [MODE] (mode) {
      return modeFix(mode, this.type === 'Directory')
    }

    write (data) {
      const writeLen = data.length
      if (writeLen > this.blockRemain)
        throw new Error('writing more to entry than is appropriate')
      this.blockRemain -= writeLen
      return super.write(data)
    }

    end () {
      if (this.blockRemain)
        this.write(Buffer.alloc(this.blockRemain))
      return super.end()
    }
  })

  WriteEntry.Sync = WriteEntrySync
  WriteEntry.Tar = WriteEntryTar

  const getType = stat =>
    stat.isFile() ? 'File'
    : stat.isDirectory() ? 'Directory'
    : stat.isSymbolicLink() ? 'SymbolicLink'
    : 'Unsupported'

  module.exports = WriteEntry


  /***/ }),
  /* 194 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const Buffer = __webpack_require__(184)
  const Header = __webpack_require__(195)
  const path = __webpack_require__(8)

  class Pax {
    constructor (obj, global) {
      this.atime = obj.atime || null
      this.charset = obj.charset || null
      this.comment = obj.comment || null
      this.ctime = obj.ctime || null
      this.gid = obj.gid || null
      this.gname = obj.gname || null
      this.linkpath = obj.linkpath || null
      this.mtime = obj.mtime || null
      this.path = obj.path || null
      this.size = obj.size || null
      this.uid = obj.uid || null
      this.uname = obj.uname || null
      this.dev = obj.dev || null
      this.ino = obj.ino || null
      this.nlink = obj.nlink || null
      this.global = global || false
    }

    encode () {
      const body = this.encodeBody()
      if (body === '')
        return null

      const bodyLen = Buffer.byteLength(body)
      // round up to 512 bytes
      // add 512 for header
      const bufLen = 512 * Math.ceil(1 + bodyLen / 512)
      const buf = Buffer.allocUnsafe(bufLen)

      // 0-fill the header section, it might not hit every field
      for (let i = 0; i < 512; i++) {
        buf[i] = 0
      }

      new Header({
        // XXX split the path
        // then the path should be PaxHeader + basename, but less than 99,
        // prepend with the dirname
        path: ('PaxHeader/' + path.basename(this.path)).slice(0, 99),
        mode: this.mode || 0o644,
        uid: this.uid || null,
        gid: this.gid || null,
        size: bodyLen,
        mtime: this.mtime || null,
        type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',
        linkpath: '',
        uname: this.uname || '',
        gname: this.gname || '',
        devmaj: 0,
        devmin: 0,
        atime: this.atime || null,
        ctime: this.ctime || null
      }).encode(buf)

      buf.write(body, 512, bodyLen, 'utf8')

      // null pad after the body
      for (let i = bodyLen + 512; i < buf.length; i++) {
        buf[i] = 0
      }

      return buf
    }

    encodeBody () {
      return (
        this.encodeField('path') +
        this.encodeField('ctime') +
        this.encodeField('atime') +
        this.encodeField('dev') +
        this.encodeField('ino') +
        this.encodeField('nlink') +
        this.encodeField('charset') +
        this.encodeField('comment') +
        this.encodeField('gid') +
        this.encodeField('gname') +
        this.encodeField('linkpath') +
        this.encodeField('mtime') +
        this.encodeField('size') +
        this.encodeField('uid') +
        this.encodeField('uname')
      )
    }

    encodeField (field) {
      if (this[field] === null || this[field] === undefined)
        return ''
      const v = this[field] instanceof Date ? this[field].getTime() / 1000
        : this[field]
      const s = ' ' +
        (field === 'dev' || field === 'ino' || field === 'nlink'
         ? 'SCHILY.' : '') +
        field + '=' + v + '\n'
      const byteLen = Buffer.byteLength(s)
      // the digits includes the length of the digits in ascii base-10
      // so if it's 9 characters, then adding 1 for the 9 makes it 10
      // which makes it 11 chars.
      let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1
      if (byteLen + digits >= Math.pow(10, digits))
        digits += 1
      const len = digits + byteLen
      return len + s
    }
  }

  Pax.parse = (string, ex, g) => new Pax(merge(parseKV(string), ex), g)

  const merge = (a, b) =>
    b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a

  const parseKV = string =>
    string
      .replace(/\n$/, '')
      .split('\n')
      .reduce(parseKVLine, Object.create(null))

  const parseKVLine = (set, line) => {
    const n = parseInt(line, 10)

    // XXX Values with \n in them will fail this.
    // Refactor to not be a naive line-by-line parse.
    if (n !== Buffer.byteLength(line) + 1)
      return set

    line = line.substr((n + ' ').length)
    const kv = line.split('=')
    const k = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, '$1')
    if (!k)
      return set

    const v = kv.join('=')
    set[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k)
      ?  new Date(v * 1000)
      : /^[0-9]+$/.test(v) ? +v
      : v
    return set
  }

  module.exports = Pax


  /***/ }),
  /* 195 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  // parse a 512-byte header block to a data object, or vice-versa
  // encode returns `true` if a pax extended header is needed, because
  // the data could not be faithfully encoded in a simple header.
  // (Also, check header.needPax to see if it needs a pax header.)

  const Buffer = __webpack_require__(184)
  const types = __webpack_require__(192)
  const pathModule = __webpack_require__(8).posix
  const large = __webpack_require__(196)

  const SLURP = Symbol('slurp')
  const TYPE = Symbol('type')

  class Header {
    constructor (data, off, ex, gex) {
      this.cksumValid = false
      this.needPax = false
      this.nullBlock = false

      this.block = null
      this.path = null
      this.mode = null
      this.uid = null
      this.gid = null
      this.size = null
      this.mtime = null
      this.cksum = null
      this[TYPE] = '0'
      this.linkpath = null
      this.uname = null
      this.gname = null
      this.devmaj = 0
      this.devmin = 0
      this.atime = null
      this.ctime = null

      if (Buffer.isBuffer(data))
        this.decode(data, off || 0, ex, gex)
      else if (data)
        this.set(data)
    }

    decode (buf, off, ex, gex) {
      if (!off)
        off = 0

      if (!buf || !(buf.length >= off + 512))
        throw new Error('need 512 bytes for header')

      this.path = decString(buf, off, 100)
      this.mode = decNumber(buf, off + 100, 8)
      this.uid = decNumber(buf, off + 108, 8)
      this.gid = decNumber(buf, off + 116, 8)
      this.size = decNumber(buf, off + 124, 12)
      this.mtime = decDate(buf, off + 136, 12)
      this.cksum = decNumber(buf, off + 148, 12)

      // if we have extended or global extended headers, apply them now
      // See https://github.com/npm/node-tar/pull/187
      this[SLURP](ex)
      this[SLURP](gex, true)

      // old tar versions marked dirs as a file with a trailing /
      this[TYPE] = decString(buf, off + 156, 1)
      if (this[TYPE] === '')
        this[TYPE] = '0'
      if (this[TYPE] === '0' && this.path.substr(-1) === '/')
        this[TYPE] = '5'

      // tar implementations sometimes incorrectly put the stat(dir).size
      // as the size in the tarball, even though Directory entries are
      // not able to have any body at all.  In the very rare chance that
      // it actually DOES have a body, we weren't going to do anything with
      // it anyway, and it'll just be a warning about an invalid header.
      if (this[TYPE] === '5')
        this.size = 0

      this.linkpath = decString(buf, off + 157, 100)
      if (buf.slice(off + 257, off + 265).toString() === 'ustar\u000000') {
        this.uname = decString(buf, off + 265, 32)
        this.gname = decString(buf, off + 297, 32)
        this.devmaj = decNumber(buf, off + 329, 8)
        this.devmin = decNumber(buf, off + 337, 8)
        if (buf[off + 475] !== 0) {
          // definitely a prefix, definitely >130 chars.
          const prefix = decString(buf, off + 345, 155)
          this.path = prefix + '/' + this.path
        } else {
          const prefix = decString(buf, off + 345, 130)
          if (prefix)
            this.path = prefix + '/' + this.path
          this.atime = decDate(buf, off + 476, 12)
          this.ctime = decDate(buf, off + 488, 12)
        }
      }

      let sum = 8 * 0x20
      for (let i = off; i < off + 148; i++) {
        sum += buf[i]
      }
      for (let i = off + 156; i < off + 512; i++) {
        sum += buf[i]
      }
      this.cksumValid = sum === this.cksum
      if (this.cksum === null && sum === 8 * 0x20)
        this.nullBlock = true
    }

    [SLURP] (ex, global) {
      for (let k in ex) {
        // we slurp in everything except for the path attribute in
        // a global extended header, because that's weird.
        if (ex[k] !== null && ex[k] !== undefined &&
            !(global && k === 'path'))
          this[k] = ex[k]
      }
    }

    encode (buf, off) {
      if (!buf) {
        buf = this.block = Buffer.alloc(512)
        off = 0
      }

      if (!off)
        off = 0

      if (!(buf.length >= off + 512))
        throw new Error('need 512 bytes for header')

      const prefixSize = this.ctime || this.atime ? 130 : 155
      const split = splitPrefix(this.path || '', prefixSize)
      const path = split[0]
      const prefix = split[1]
      this.needPax = split[2]

      this.needPax = encString(buf, off, 100, path) || this.needPax
      this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax
      this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax
      this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax
      this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax
      this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax
      buf[off + 156] = this[TYPE].charCodeAt(0)
      this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax
      buf.write('ustar\u000000', off + 257, 8)
      this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax
      this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax
      this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax
      this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax
      this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax
      if (buf[off + 475] !== 0)
        this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax
      else {
        this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax
        this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax
        this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax
      }

      let sum = 8 * 0x20
      for (let i = off; i < off + 148; i++) {
        sum += buf[i]
      }
      for (let i = off + 156; i < off + 512; i++) {
        sum += buf[i]
      }
      this.cksum = sum
      encNumber(buf, off + 148, 8, this.cksum)
      this.cksumValid = true

      return this.needPax
    }

    set (data) {
      for (let i in data) {
        if (data[i] !== null && data[i] !== undefined)
          this[i] = data[i]
      }
    }

    get type () {
      return types.name.get(this[TYPE]) || this[TYPE]
    }

    get typeKey () {
      return this[TYPE]
    }

    set type (type) {
      if (types.code.has(type))
        this[TYPE] = types.code.get(type)
      else
        this[TYPE] = type
    }
  }

  const splitPrefix = (p, prefixSize) => {
    const pathSize = 100
    let pp = p
    let prefix = ''
    let ret
    const root = pathModule.parse(p).root || '.'

    if (Buffer.byteLength(pp) < pathSize)
      ret = [pp, prefix, false]
    else {
      // first set prefix to the dir, and path to the base
      prefix = pathModule.dirname(pp)
      pp = pathModule.basename(pp)

      do {
        // both fit!
        if (Buffer.byteLength(pp) <= pathSize &&
            Buffer.byteLength(prefix) <= prefixSize)
          ret = [pp, prefix, false]

        // prefix fits in prefix, but path doesn't fit in path
        else if (Buffer.byteLength(pp) > pathSize &&
            Buffer.byteLength(prefix) <= prefixSize)
          ret = [pp.substr(0, pathSize - 1), prefix, true]

        else {
          // make path take a bit from prefix
          pp = pathModule.join(pathModule.basename(prefix), pp)
          prefix = pathModule.dirname(prefix)
        }
      } while (prefix !== root && !ret)

      // at this point, found no resolution, just truncate
      if (!ret)
        ret = [p.substr(0, pathSize - 1), '', true]
    }
    return ret
  }

  const decString = (buf, off, size) =>
    buf.slice(off, off + size).toString('utf8').replace(/\0.*/, '')

  const decDate = (buf, off, size) =>
    numToDate(decNumber(buf, off, size))

  const numToDate = num => num === null ? null : new Date(num * 1000)

  const decNumber = (buf, off, size) =>
    buf[off] & 0x80 ? large.parse(buf.slice(off, off + size))
      : decSmallNumber(buf, off, size)

  const nanNull = value => isNaN(value) ? null : value

  const decSmallNumber = (buf, off, size) =>
    nanNull(parseInt(
      buf.slice(off, off + size)
        .toString('utf8').replace(/\0.*$/, '').trim(), 8))

  // the maximum encodable as a null-terminated octal, by field size
  const MAXNUM = {
    12: 0o77777777777,
    8 : 0o7777777
  }

  const encNumber = (buf, off, size, number) =>
    number === null ? false :
    number > MAXNUM[size] || number < 0
      ? (large.encode(number, buf.slice(off, off + size)), true)
      : (encSmallNumber(buf, off, size, number), false)

  const encSmallNumber = (buf, off, size, number) =>
    buf.write(octalString(number, size), off, size, 'ascii')

  const octalString = (number, size) =>
    padOctal(Math.floor(number).toString(8), size)

  const padOctal = (string, size) =>
    (string.length === size - 1 ? string
    : new Array(size - string.length - 1).join('0') + string + ' ') + '\0'

  const encDate = (buf, off, size, date) =>
    date === null ? false :
    encNumber(buf, off, size, date.getTime() / 1000)

  // enough to fill the longest string we've got
  const NULLS = new Array(156).join('\0')
  // pad with nulls, return true if it's longer or non-ascii
  const encString = (buf, off, size, string) =>
    string === null ? false :
    (buf.write(string + NULLS, off, size, 'utf8'),
     string.length !== Buffer.byteLength(string) || string.length > size)

  module.exports = Header


  /***/ }),
  /* 196 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  // Tar can encode large and negative numbers using a leading byte of
  // 0xff for negative, and 0x80 for positive.

  const encode = exports.encode = (num, buf) => {
    if (!Number.isSafeInteger(num))
      // The number is so large that javascript cannot represent it with integer
      // precision.
      throw TypeError('cannot encode number outside of javascript safe integer range')
    else if (num < 0)
      encodeNegative(num, buf)
    else
      encodePositive(num, buf)
    return buf
  }

  const encodePositive = (num, buf) => {
    buf[0] = 0x80

    for (var i = buf.length; i > 1; i--) {
      buf[i-1] = num & 0xff
      num = Math.floor(num / 0x100)
    }
  }

  const encodeNegative = (num, buf) => {
    buf[0] = 0xff
    var flipped = false
    num = num * -1
    for (var i = buf.length; i > 1; i--) {
      var byte = num & 0xff
      num = Math.floor(num / 0x100)
      if (flipped)
        buf[i-1] = onesComp(byte)
      else if (byte === 0)
        buf[i-1] = 0
      else {
        flipped = true
        buf[i-1] = twosComp(byte)
      }
    }
  }

  const parse = exports.parse = (buf) => {
    var post = buf[buf.length - 1]
    var pre = buf[0]
    var value;
    if (pre === 0x80)
      value = pos(buf.slice(1, buf.length))
    else if (pre === 0xff)
      value = twos(buf)
    else
      throw TypeError('invalid base256 encoding')

    if (!Number.isSafeInteger(value))
      // The number is so large that javascript cannot represent it with integer
      // precision.
      throw TypeError('parsed number outside of javascript safe integer range')

    return value
  }

  const twos = (buf) => {
    var len = buf.length
    var sum = 0
    var flipped = false
    for (var i = len - 1; i > -1; i--) {
      var byte = buf[i]
      var f
      if (flipped)
        f = onesComp(byte)
      else if (byte === 0)
        f = byte
      else {
        flipped = true
        f = twosComp(byte)
      }
      if (f !== 0)
        sum -= f * Math.pow(256, len - i - 1)
    }
    return sum
  }

  const pos = (buf) => {
    var len = buf.length
    var sum = 0
    for (var i = len - 1; i > -1; i--) {
      var byte = buf[i]
      if (byte !== 0)
        sum += byte * Math.pow(256, len - i - 1)
    }
    return sum
  }

  const onesComp = byte => (0xff ^ byte) & 0xff

  const twosComp = byte => ((0xff ^ byte) + 1) & 0xff


  /***/ }),
  /* 197 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  module.exports = Base => class extends Base {
    warn (msg, data) {
      if (!this.strict)
        this.emit('warn', msg, data)
      else if (data instanceof Error)
        this.emit('error', data)
      else {
        const er = new Error(msg)
        er.data = data
        this.emit('error', er)
      }
    }
  }


  /***/ }),
  /* 198 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  // When writing files on Windows, translate the characters to their
  // 0xf000 higher-encoded versions.

  const raw = [
    '|',
    '<',
    '>',
    '?',
    ':'
  ]

  const win = raw.map(char =>
    String.fromCharCode(0xf000 + char.charCodeAt(0)))

  const toWin = new Map(raw.map((char, i) => [char, win[i]]))
  const toRaw = new Map(win.map((char, i) => [char, raw[i]]))

  module.exports = {
    encode: s => raw.reduce((s, c) => s.split(c).join(toWin.get(c)), s),
    decode: s => win.reduce((s, c) => s.split(c).join(toRaw.get(c)), s)
  }


  /***/ }),
  /* 199 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  module.exports = (mode, isDir) => {
    mode &= 0o7777
    // if dirs are readable, then they should be listable
    if (isDir) {
      if (mode & 0o400)
        mode |= 0o100
      if (mode & 0o40)
        mode |= 0o10
      if (mode & 0o4)
        mode |= 0o1
    }
    return mode
  }


  /***/ }),
  /* 200 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const MiniPass = __webpack_require__(186)
  const EE = __webpack_require__(67).EventEmitter
  const fs = __webpack_require__(7)

  // for writev
  const binding = process.binding('fs')
  const writeBuffers = binding.writeBuffers
  const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback

  const _autoClose = Symbol('_autoClose')
  const _close = Symbol('_close')
  const _ended = Symbol('_ended')
  const _fd = Symbol('_fd')
  const _finished = Symbol('_finished')
  const _flags = Symbol('_flags')
  const _flush = Symbol('_flush')
  const _handleChunk = Symbol('_handleChunk')
  const _makeBuf = Symbol('_makeBuf')
  const _mode = Symbol('_mode')
  const _needDrain = Symbol('_needDrain')
  const _onerror = Symbol('_onerror')
  const _onopen = Symbol('_onopen')
  const _onread = Symbol('_onread')
  const _onwrite = Symbol('_onwrite')
  const _open = Symbol('_open')
  const _path = Symbol('_path')
  const _pos = Symbol('_pos')
  const _queue = Symbol('_queue')
  const _read = Symbol('_read')
  const _readSize = Symbol('_readSize')
  const _reading = Symbol('_reading')
  const _remain = Symbol('_remain')
  const _size = Symbol('_size')
  const _write = Symbol('_write')
  const _writing = Symbol('_writing')
  const _defaultFlag = Symbol('_defaultFlag')

  class ReadStream extends MiniPass {
    constructor (path, opt) {
      opt = opt || {}
      super(opt)

      this.writable = false

      if (typeof path !== 'string')
        throw new TypeError('path must be a string')

      this[_fd] = typeof opt.fd === 'number' ? opt.fd : null
      this[_path] = path
      this[_readSize] = opt.readSize || 16*1024*1024
      this[_reading] = false
      this[_size] = typeof opt.size === 'number' ? opt.size : Infinity
      this[_remain] = this[_size]
      this[_autoClose] = typeof opt.autoClose === 'boolean' ?
        opt.autoClose : true

      if (typeof this[_fd] === 'number')
        this[_read]()
      else
        this[_open]()
    }

    get fd () { return this[_fd] }
    get path () { return this[_path] }

    write () {
      throw new TypeError('this is a readable stream')
    }

    end () {
      throw new TypeError('this is a readable stream')
    }

    [_open] () {
      fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd))
    }

    [_onopen] (er, fd) {
      if (er)
        this[_onerror](er)
      else {
        this[_fd] = fd
        this.emit('open', fd)
        this[_read]()
      }
    }

    [_makeBuf] () {
      return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]))
    }

    [_read] () {
      if (!this[_reading]) {
        this[_reading] = true
        const buf = this[_makeBuf]()
        /* istanbul ignore if */
        if (buf.length === 0) return process.nextTick(() => this[_onread](null, 0, buf))
        fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf) =>
          this[_onread](er, br, buf))
      }
    }

    [_onread] (er, br, buf) {
      this[_reading] = false
      if (er)
        this[_onerror](er)
      else if (this[_handleChunk](br, buf))
        this[_read]()
    }

    [_close] () {
      if (this[_autoClose] && typeof this[_fd] === 'number') {
        fs.close(this[_fd], _ => this.emit('close'))
        this[_fd] = null
      }
    }

    [_onerror] (er) {
      this[_reading] = true
      this[_close]()
      this.emit('error', er)
    }

    [_handleChunk] (br, buf) {
      let ret = false
      // no effect if infinite
      this[_remain] -= br
      if (br > 0)
        ret = super.write(br < buf.length ? buf.slice(0, br) : buf)

      if (br === 0 || this[_remain] <= 0) {
        ret = false
        this[_close]()
        super.end()
      }

      return ret
    }

    emit (ev, data) {
      switch (ev) {
        case 'prefinish':
        case 'finish':
          break

        case 'drain':
          if (typeof this[_fd] === 'number')
            this[_read]()
          break

        default:
          return super.emit(ev, data)
      }
    }
  }

  class ReadStreamSync extends ReadStream {
    [_open] () {
      let threw = true
      try {
        this[_onopen](null, fs.openSync(this[_path], 'r'))
        threw = false
      } finally {
        if (threw)
          this[_close]()
      }
    }

    [_read] () {
      let threw = true
      try {
        if (!this[_reading]) {
          this[_reading] = true
          do {
            const buf = this[_makeBuf]()
            /* istanbul ignore next */
            const br = buf.length === 0 ? 0 : fs.readSync(this[_fd], buf, 0, buf.length, null)
            if (!this[_handleChunk](br, buf))
              break
          } while (true)
          this[_reading] = false
        }
        threw = false
      } finally {
        if (threw)
          this[_close]()
      }
    }

    [_close] () {
      if (this[_autoClose] && typeof this[_fd] === 'number') {
        try {
          fs.closeSync(this[_fd])
        } catch (er) {}
        this[_fd] = null
        this.emit('close')
      }
    }
  }

  class WriteStream extends EE {
    constructor (path, opt) {
      opt = opt || {}
      super(opt)
      this.readable = false
      this[_writing] = false
      this[_ended] = false
      this[_needDrain] = false
      this[_queue] = []
      this[_path] = path
      this[_fd] = typeof opt.fd === 'number' ? opt.fd : null
      this[_mode] = opt.mode === undefined ? 0o666 : opt.mode
      this[_pos] = typeof opt.start === 'number' ? opt.start : null
      this[_autoClose] = typeof opt.autoClose === 'boolean' ?
        opt.autoClose : true

      // truncating makes no sense when writing into the middle
      const defaultFlag = this[_pos] !== null ? 'r+' : 'w'
      this[_defaultFlag] = opt.flags === undefined
      this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags

      if (this[_fd] === null)
        this[_open]()
    }

    get fd () { return this[_fd] }
    get path () { return this[_path] }

    [_onerror] (er) {
      this[_close]()
      this[_writing] = true
      this.emit('error', er)
    }

    [_open] () {
      fs.open(this[_path], this[_flags], this[_mode],
        (er, fd) => this[_onopen](er, fd))
    }

    [_onopen] (er, fd) {
      if (this[_defaultFlag] &&
          this[_flags] === 'r+' &&
          er && er.code === 'ENOENT') {
        this[_flags] = 'w'
        this[_open]()
      } else if (er)
        this[_onerror](er)
      else {
        this[_fd] = fd
        this.emit('open', fd)
        this[_flush]()
      }
    }

    end (buf, enc) {
      if (buf)
        this.write(buf, enc)

      this[_ended] = true

      // synthetic after-write logic, where drain/finish live
      if (!this[_writing] && !this[_queue].length &&
          typeof this[_fd] === 'number')
        this[_onwrite](null, 0)
    }

    write (buf, enc) {
      if (typeof buf === 'string')
        buf = new Buffer(buf, enc)

      if (this[_ended]) {
        this.emit('error', new Error('write() after end()'))
        return false
      }

      if (this[_fd] === null || this[_writing] || this[_queue].length) {
        this[_queue].push(buf)
        this[_needDrain] = true
        return false
      }

      this[_writing] = true
      this[_write](buf)
      return true
    }

    [_write] (buf) {
      fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) =>
        this[_onwrite](er, bw))
    }

    [_onwrite] (er, bw) {
      if (er)
        this[_onerror](er)
      else {
        if (this[_pos] !== null)
          this[_pos] += bw
        if (this[_queue].length)
          this[_flush]()
        else {
          this[_writing] = false

          if (this[_ended] && !this[_finished]) {
            this[_finished] = true
            this[_close]()
            this.emit('finish')
          } else if (this[_needDrain]) {
            this[_needDrain] = false
            this.emit('drain')
          }
        }
      }
    }

    [_flush] () {
      if (this[_queue].length === 0) {
        if (this[_ended])
          this[_onwrite](null, 0)
      } else if (this[_queue].length === 1)
        this[_write](this[_queue].pop())
      else {
        const iovec = this[_queue]
        this[_queue] = []
        writev(this[_fd], iovec, this[_pos],
          (er, bw) => this[_onwrite](er, bw))
      }
    }

    [_close] () {
      if (this[_autoClose] && typeof this[_fd] === 'number') {
        fs.close(this[_fd], _ => this.emit('close'))
        this[_fd] = null
      }
    }
  }

  class WriteStreamSync extends WriteStream {
    [_open] () {
      let fd
      try {
        fd = fs.openSync(this[_path], this[_flags], this[_mode])
      } catch (er) {
        if (this[_defaultFlag] &&
            this[_flags] === 'r+' &&
            er && er.code === 'ENOENT') {
          this[_flags] = 'w'
          return this[_open]()
        } else
          throw er
      }
      this[_onopen](null, fd)
    }

    [_close] () {
      if (this[_autoClose] && typeof this[_fd] === 'number') {
        try {
          fs.closeSync(this[_fd])
        } catch (er) {}
        this[_fd] = null
        this.emit('close')
      }
    }

    [_write] (buf) {
      try {
        this[_onwrite](null,
          fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]))
      } catch (er) {
        this[_onwrite](er, 0)
      }
    }
  }

  const writev = (fd, iovec, pos, cb) => {
    const done = (er, bw) => cb(er, bw, iovec)
    const req = new FSReqWrap()
    req.oncomplete = done
    binding.writeBuffers(fd, iovec, pos, req)
  }

  exports.ReadStream = ReadStream
  exports.ReadStreamSync = ReadStreamSync

  exports.WriteStream = WriteStream
  exports.WriteStreamSync = WriteStreamSync


  /***/ }),
  /* 201 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const Buffer = __webpack_require__(184)

  // XXX: This shares a lot in common with extract.js
  // maybe some DRY opportunity here?

  // tar -t
  const hlo = __webpack_require__(182)
  const Parser = __webpack_require__(202)
  const fs = __webpack_require__(7)
  const fsm = __webpack_require__(200)
  const path = __webpack_require__(8)

  const t = module.exports = (opt_, files, cb) => {
    if (typeof opt_ === 'function')
      cb = opt_, files = null, opt_ = {}
    else if (Array.isArray(opt_))
      files = opt_, opt_ = {}

    if (typeof files === 'function')
      cb = files, files = null

    if (!files)
      files = []
    else
      files = Array.from(files)

    const opt = hlo(opt_)

    if (opt.sync && typeof cb === 'function')
      throw new TypeError('callback not supported for sync tar functions')

    if (!opt.file && typeof cb === 'function')
      throw new TypeError('callback only supported with file option')

    if (files.length)
      filesFilter(opt, files)

    if (!opt.noResume)
      onentryFunction(opt)

    return opt.file && opt.sync ? listFileSync(opt)
      : opt.file ? listFile(opt, cb)
      : list(opt)
  }

  const onentryFunction = opt => {
    const onentry = opt.onentry
    opt.onentry = onentry ? e => {
      onentry(e)
      e.resume()
    } : e => e.resume()
  }

  // construct a filter that limits the file entries listed
  // include child entries if a dir is included
  const filesFilter = (opt, files) => {
    const map = new Map(files.map(f => [f.replace(/\/+$/, ''), true]))
    const filter = opt.filter

    const mapHas = (file, r) => {
      const root = r || path.parse(file).root || '.'
      const ret = file === root ? false
        : map.has(file) ? map.get(file)
        : mapHas(path.dirname(file), root)

      map.set(file, ret)
      return ret
    }

    opt.filter = filter
      ? (file, entry) => filter(file, entry) && mapHas(file.replace(/\/+$/, ''))
      : file => mapHas(file.replace(/\/+$/, ''))
  }

  const listFileSync = opt => {
    const p = list(opt)
    const file = opt.file
    let threw = true
    let fd
    try {
      const stat = fs.statSync(file)
      const readSize = opt.maxReadSize || 16*1024*1024
      if (stat.size < readSize) {
        p.end(fs.readFileSync(file))
      } else {
        let pos = 0
        const buf = Buffer.allocUnsafe(readSize)
        fd = fs.openSync(file, 'r')
        while (pos < stat.size) {
          let bytesRead = fs.readSync(fd, buf, 0, readSize, pos)
          pos += bytesRead
          p.write(buf.slice(0, bytesRead))
        }
        p.end()
      }
      threw = false
    } finally {
      if (threw && fd)
        try { fs.closeSync(fd) } catch (er) {}
    }
  }

  const listFile = (opt, cb) => {
    const parse = new Parser(opt)
    const readSize = opt.maxReadSize || 16*1024*1024

    const file = opt.file
    const p = new Promise((resolve, reject) => {
      parse.on('error', reject)
      parse.on('end', resolve)

      fs.stat(file, (er, stat) => {
        if (er)
          reject(er)
        else {
          const stream = new fsm.ReadStream(file, {
            readSize: readSize,
            size: stat.size
          })
          stream.on('error', reject)
          stream.pipe(parse)
        }
      })
    })
    return cb ? p.then(cb, cb) : p
  }

  const list = opt => new Parser(opt)


  /***/ }),
  /* 202 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  // this[BUFFER] is the remainder of a chunk if we're waiting for
  // the full 512 bytes of a header to come in.  We will Buffer.concat()
  // it to the next write(), which is a mem copy, but a small one.
  //
  // this[QUEUE] is a Yallist of entries that haven't been emitted
  // yet this can only get filled up if the user keeps write()ing after
  // a write() returns false, or does a write() with more than one entry
  //
  // We don't buffer chunks, we always parse them and either create an
  // entry, or push it into the active entry.  The ReadEntry class knows
  // to throw data away if .ignore=true
  //
  // Shift entry off the buffer when it emits 'end', and emit 'entry' for
  // the next one in the list.
  //
  // At any time, we're pushing body chunks into the entry at WRITEENTRY,
  // and waiting for 'end' on the entry at READENTRY
  //
  // ignored entries get .resume() called on them straight away

  const warner = __webpack_require__(197)
  const path = __webpack_require__(8)
  const Header = __webpack_require__(195)
  const EE = __webpack_require__(67)
  const Yallist = __webpack_require__(187)
  const maxMetaEntrySize = 1024 * 1024
  const Entry = __webpack_require__(191)
  const Pax = __webpack_require__(194)
  const zlib = __webpack_require__(189)
  const Buffer = __webpack_require__(184)

  const gzipHeader = Buffer.from([0x1f, 0x8b])
  const STATE = Symbol('state')
  const WRITEENTRY = Symbol('writeEntry')
  const READENTRY = Symbol('readEntry')
  const NEXTENTRY = Symbol('nextEntry')
  const PROCESSENTRY = Symbol('processEntry')
  const EX = Symbol('extendedHeader')
  const GEX = Symbol('globalExtendedHeader')
  const META = Symbol('meta')
  const EMITMETA = Symbol('emitMeta')
  const BUFFER = Symbol('buffer')
  const QUEUE = Symbol('queue')
  const ENDED = Symbol('ended')
  const EMITTEDEND = Symbol('emittedEnd')
  const EMIT = Symbol('emit')
  const UNZIP = Symbol('unzip')
  const CONSUMECHUNK = Symbol('consumeChunk')
  const CONSUMECHUNKSUB = Symbol('consumeChunkSub')
  const CONSUMEBODY = Symbol('consumeBody')
  const CONSUMEMETA = Symbol('consumeMeta')
  const CONSUMEHEADER = Symbol('consumeHeader')
  const CONSUMING = Symbol('consuming')
  const BUFFERCONCAT = Symbol('bufferConcat')
  const MAYBEEND = Symbol('maybeEnd')
  const WRITING = Symbol('writing')
  const ABORTED = Symbol('aborted')
  const DONE = Symbol('onDone')

  const noop = _ => true

  module.exports = warner(class Parser extends EE {
    constructor (opt) {
      opt = opt || {}
      super(opt)

      if (opt.ondone)
        this.on(DONE, opt.ondone)
      else
        this.on(DONE, _ => {
          this.emit('prefinish')
          this.emit('finish')
          this.emit('end')
          this.emit('close')
        })

      this.strict = !!opt.strict
      this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize
      this.filter = typeof opt.filter === 'function' ? opt.filter : noop

      // have to set this so that streams are ok piping into it
      this.writable = true
      this.readable = false

      this[QUEUE] = new Yallist()
      this[BUFFER] = null
      this[READENTRY] = null
      this[WRITEENTRY] = null
      this[STATE] = 'begin'
      this[META] = ''
      this[EX] = null
      this[GEX] = null
      this[ENDED] = false
      this[UNZIP] = null
      this[ABORTED] = false
      if (typeof opt.onwarn === 'function')
        this.on('warn', opt.onwarn)
      if (typeof opt.onentry === 'function')
        this.on('entry', opt.onentry)
    }

    [CONSUMEHEADER] (chunk, position) {
      const header = new Header(chunk, position, this[EX], this[GEX])

      if (header.nullBlock)
        this[EMIT]('nullBlock')
      else if (!header.cksumValid)
        this.warn('invalid entry', header)
      else if (!header.path)
        this.warn('invalid: path is required', header)
      else {
        const type = header.type
        if (/^(Symbolic)?Link$/.test(type) && !header.linkpath)
          this.warn('invalid: linkpath required', header)
        else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath)
          this.warn('invalid: linkpath forbidden', header)
        else {
          const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX])

          if (entry.meta) {
            if (entry.size > this.maxMetaEntrySize) {
              entry.ignore = true
              this[EMIT]('ignoredEntry', entry)
              this[STATE] = 'ignore'
            } else if (entry.size > 0) {
              this[META] = ''
              entry.on('data', c => this[META] += c)
              this[STATE] = 'meta'
            }
          } else {

            this[EX] = null
            entry.ignore = entry.ignore || !this.filter(entry.path, entry)
            if (entry.ignore) {
              this[EMIT]('ignoredEntry', entry)
              this[STATE] = entry.remain ? 'ignore' : 'begin'
            } else {
              if (entry.remain)
                this[STATE] = 'body'
              else {
                this[STATE] = 'begin'
                entry.end()
              }

              if (!this[READENTRY]) {
                this[QUEUE].push(entry)
                this[NEXTENTRY]()
              } else
                this[QUEUE].push(entry)
            }
          }
        }
      }
    }

    [PROCESSENTRY] (entry) {
      let go = true

      if (!entry) {
        this[READENTRY] = null
        go = false
      } else if (Array.isArray(entry))
        this.emit.apply(this, entry)
      else {
        this[READENTRY] = entry
        this.emit('entry', entry)
        if (!entry.emittedEnd) {
          entry.on('end', _ => this[NEXTENTRY]())
          go = false
        }
      }

      return go
    }

    [NEXTENTRY] () {
      do {} while (this[PROCESSENTRY](this[QUEUE].shift()))

      if (!this[QUEUE].length) {
        // At this point, there's nothing in the queue, but we may have an
        // entry which is being consumed (readEntry).
        // If we don't, then we definitely can handle more data.
        // If we do, and either it's flowing, or it has never had any data
        // written to it, then it needs more.
        // The only other possibility is that it has returned false from a
        // write() call, so we wait for the next drain to continue.
        const re = this[READENTRY]
        const drainNow = !re || re.flowing || re.size === re.remain
        if (drainNow) {
          if (!this[WRITING])
            this.emit('drain')
        } else
          re.once('drain', _ => this.emit('drain'))
       }
    }

    [CONSUMEBODY] (chunk, position) {
      // write up to but no  more than writeEntry.blockRemain
      const entry = this[WRITEENTRY]
      const br = entry.blockRemain
      const c = (br >= chunk.length && position === 0) ? chunk
        : chunk.slice(position, position + br)

      entry.write(c)

      if (!entry.blockRemain) {
        this[STATE] = 'begin'
        this[WRITEENTRY] = null
        entry.end()
      }

      return c.length
    }

    [CONSUMEMETA] (chunk, position) {
      const entry = this[WRITEENTRY]
      const ret = this[CONSUMEBODY](chunk, position)

      // if we finished, then the entry is reset
      if (!this[WRITEENTRY])
        this[EMITMETA](entry)

      return ret
    }

    [EMIT] (ev, data, extra) {
      if (!this[QUEUE].length && !this[READENTRY])
        this.emit(ev, data, extra)
      else
        this[QUEUE].push([ev, data, extra])
    }

    [EMITMETA] (entry) {
      this[EMIT]('meta', this[META])
      switch (entry.type) {
        case 'ExtendedHeader':
        case 'OldExtendedHeader':
          this[EX] = Pax.parse(this[META], this[EX], false)
          break

        case 'GlobalExtendedHeader':
          this[GEX] = Pax.parse(this[META], this[GEX], true)
          break

        case 'NextFileHasLongPath':
        case 'OldGnuLongPath':
          this[EX] = this[EX] || Object.create(null)
          this[EX].path = this[META].replace(/\0.*/, '')
          break

        case 'NextFileHasLongLinkpath':
          this[EX] = this[EX] || Object.create(null)
          this[EX].linkpath = this[META].replace(/\0.*/, '')
          break

        /* istanbul ignore next */
        default: throw new Error('unknown meta: ' + entry.type)
      }
    }

    abort (msg, error) {
      this[ABORTED] = true
      this.warn(msg, error)
      this.emit('abort', error)
      this.emit('error', error)
    }

    write (chunk) {
      if (this[ABORTED])
        return

      // first write, might be gzipped
      if (this[UNZIP] === null && chunk) {
        if (this[BUFFER]) {
          chunk = Buffer.concat([this[BUFFER], chunk])
          this[BUFFER] = null
        }
        if (chunk.length < gzipHeader.length) {
          this[BUFFER] = chunk
          return true
        }
        for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {
          if (chunk[i] !== gzipHeader[i])
            this[UNZIP] = false
        }
        if (this[UNZIP] === null) {
          const ended = this[ENDED]
          this[ENDED] = false
          this[UNZIP] = new zlib.Unzip()
          this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk))
          this[UNZIP].on('error', er =>
            this.abort(er.message, er))
          this[UNZIP].on('end', _ => {
            this[ENDED] = true
            this[CONSUMECHUNK]()
          })
          this[WRITING] = true
          const ret = this[UNZIP][ended ? 'end' : 'write' ](chunk)
          this[WRITING] = false
          return ret
        }
      }

      this[WRITING] = true
      if (this[UNZIP])
        this[UNZIP].write(chunk)
      else
        this[CONSUMECHUNK](chunk)
      this[WRITING] = false

      // return false if there's a queue, or if the current entry isn't flowing
      const ret =
        this[QUEUE].length ? false :
        this[READENTRY] ? this[READENTRY].flowing :
        true

      // if we have no queue, then that means a clogged READENTRY
      if (!ret && !this[QUEUE].length)
        this[READENTRY].once('drain', _ => this.emit('drain'))

      return ret
    }

    [BUFFERCONCAT] (c) {
      if (c && !this[ABORTED])
        this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c
    }

    [MAYBEEND] () {
      if (this[ENDED] &&
          !this[EMITTEDEND] &&
          !this[ABORTED] &&
          !this[CONSUMING]) {
        this[EMITTEDEND] = true
        const entry = this[WRITEENTRY]
        if (entry && entry.blockRemain) {
          const have = this[BUFFER] ? this[BUFFER].length : 0
          this.warn('Truncated input (needed ' + entry.blockRemain +
                    ' more bytes, only ' + have + ' available)', entry)
          if (this[BUFFER])
            entry.write(this[BUFFER])
          entry.end()
        }
        this[EMIT](DONE)
      }
    }

    [CONSUMECHUNK] (chunk) {
      if (this[CONSUMING]) {
        this[BUFFERCONCAT](chunk)
      } else if (!chunk && !this[BUFFER]) {
        this[MAYBEEND]()
      } else {
        this[CONSUMING] = true
        if (this[BUFFER]) {
          this[BUFFERCONCAT](chunk)
          const c = this[BUFFER]
          this[BUFFER] = null
          this[CONSUMECHUNKSUB](c)
        } else {
          this[CONSUMECHUNKSUB](chunk)
        }

        while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED]) {
          const c = this[BUFFER]
          this[BUFFER] = null
          this[CONSUMECHUNKSUB](c)
        }
        this[CONSUMING] = false
      }

      if (!this[BUFFER] || this[ENDED])
        this[MAYBEEND]()
    }

    [CONSUMECHUNKSUB] (chunk) {
      // we know that we are in CONSUMING mode, so anything written goes into
      // the buffer.  Advance the position and put any remainder in the buffer.
      let position = 0
      let length = chunk.length
      while (position + 512 <= length && !this[ABORTED]) {
        switch (this[STATE]) {
          case 'begin':
            this[CONSUMEHEADER](chunk, position)
            position += 512
            break

          case 'ignore':
          case 'body':
            position += this[CONSUMEBODY](chunk, position)
            break

          case 'meta':
            position += this[CONSUMEMETA](chunk, position)
            break

          /* istanbul ignore next */
          default:
            throw new Error('invalid state: ' + this[STATE])
        }
      }

      if (position < length) {
        if (this[BUFFER])
          this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]])
        else
          this[BUFFER] = chunk.slice(position)
      }
    }

    end (chunk) {
      if (!this[ABORTED]) {
        if (this[UNZIP])
          this[UNZIP].end(chunk)
        else {
          this[ENDED] = true
          this.write(chunk)
        }
      }
    }
  })


  /***/ }),
  /* 203 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const Buffer = __webpack_require__(184)

  // tar -r
  const hlo = __webpack_require__(182)
  const Pack = __webpack_require__(183)
  const Parse = __webpack_require__(202)
  const fs = __webpack_require__(7)
  const fsm = __webpack_require__(200)
  const t = __webpack_require__(201)
  const path = __webpack_require__(8)

  // starting at the head of the file, read a Header
  // If the checksum is invalid, that's our position to start writing
  // If it is, jump forward by the specified size (round up to 512)
  // and try again.
  // Write the new Pack stream starting there.

  const Header = __webpack_require__(195)

  const r = module.exports = (opt_, files, cb) => {
    const opt = hlo(opt_)

    if (!opt.file)
      throw new TypeError('file is required')

    if (opt.gzip)
      throw new TypeError('cannot append to compressed archives')

    if (!files || !Array.isArray(files) || !files.length)
      throw new TypeError('no files or directories specified')

    files = Array.from(files)

    return opt.sync ? replaceSync(opt, files)
      : replace(opt, files, cb)
  }

  const replaceSync = (opt, files) => {
    const p = new Pack.Sync(opt)

    let threw = true
    let fd
    let position

    try {
      try {
        fd = fs.openSync(opt.file, 'r+')
      } catch (er) {
        if (er.code === 'ENOENT')
          fd = fs.openSync(opt.file, 'w+')
        else
          throw er
      }

      const st = fs.fstatSync(fd)
      const headBuf = Buffer.alloc(512)

      POSITION: for (position = 0; position < st.size; position += 512) {
        for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {
          bytes = fs.readSync(
            fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos
          )

          if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)
            throw new Error('cannot append to compressed archives')

          if (!bytes)
            break POSITION
        }

        let h = new Header(headBuf)
        if (!h.cksumValid)
          break
        let entryBlockSize = 512 * Math.ceil(h.size / 512)
        if (position + entryBlockSize + 512 > st.size)
          break
        // the 512 for the header we just parsed will be added as well
        // also jump ahead all the blocks for the body
        position += entryBlockSize
        if (opt.mtimeCache)
          opt.mtimeCache.set(h.path, h.mtime)
      }
      threw = false

      streamSync(opt, p, position, fd, files)
    } finally {
      if (threw)
        try { fs.closeSync(fd) } catch (er) {}
    }
  }

  const streamSync = (opt, p, position, fd, files) => {
    const stream = new fsm.WriteStreamSync(opt.file, {
      fd: fd,
      start: position
    })
    p.pipe(stream)
    addFilesSync(p, files)
  }

  const replace = (opt, files, cb) => {
    files = Array.from(files)
    const p = new Pack(opt)

    const getPos = (fd, size, cb_) => {
      const cb = (er, pos) => {
        if (er)
          fs.close(fd, _ => cb_(er))
        else
          cb_(null, pos)
      }

      let position = 0
      if (size === 0)
        return cb(null, 0)

      let bufPos = 0
      const headBuf = Buffer.alloc(512)
      const onread = (er, bytes) => {
        if (er)
          return cb(er)
        bufPos += bytes
        if (bufPos < 512 && bytes)
          return fs.read(
            fd, headBuf, bufPos, headBuf.length - bufPos,
            position + bufPos, onread
          )

        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)
          return cb(new Error('cannot append to compressed archives'))

        // truncated header
        if (bufPos < 512)
          return cb(null, position)

        const h = new Header(headBuf)
        if (!h.cksumValid)
          return cb(null, position)

        const entryBlockSize = 512 * Math.ceil(h.size / 512)
        if (position + entryBlockSize + 512 > size)
          return cb(null, position)

        position += entryBlockSize + 512
        if (position >= size)
          return cb(null, position)

        if (opt.mtimeCache)
          opt.mtimeCache.set(h.path, h.mtime)
        bufPos = 0
        fs.read(fd, headBuf, 0, 512, position, onread)
      }
      fs.read(fd, headBuf, 0, 512, position, onread)
    }

    const promise = new Promise((resolve, reject) => {
      p.on('error', reject)
      let flag = 'r+'
      const onopen = (er, fd) => {
        if (er && er.code === 'ENOENT' && flag === 'r+') {
          flag = 'w+'
          return fs.open(opt.file, flag, onopen)
        }

        if (er)
          return reject(er)

        fs.fstat(fd, (er, st) => {
          if (er)
            return reject(er)
          getPos(fd, st.size, (er, position) => {
            if (er)
              return reject(er)
            const stream = new fsm.WriteStream(opt.file, {
              fd: fd,
              start: position
            })
            p.pipe(stream)
            stream.on('error', reject)
            stream.on('close', resolve)
            addFilesAsync(p, files)
          })
        })
      }
      fs.open(opt.file, flag, onopen)
    })

    return cb ? promise.then(cb, cb) : promise
  }

  const addFilesSync = (p, files) => {
    files.forEach(file => {
      if (file.charAt(0) === '@')
        t({
          file: path.resolve(p.cwd, file.substr(1)),
          sync: true,
          noResume: true,
          onentry: entry => p.add(entry)
        })
      else
        p.add(file)
    })
    p.end()
  }

  const addFilesAsync = (p, files) => {
    while (files.length) {
      const file = files.shift()
      if (file.charAt(0) === '@')
        return t({
          file: path.resolve(p.cwd, file.substr(1)),
          noResume: true,
          onentry: entry => p.add(entry)
        }).then(_ => addFilesAsync(p, files))
      else
        p.add(file)
    }
    p.end()
  }


  /***/ }),
  /* 204 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  // tar -u

  const hlo = __webpack_require__(182)
  const r = __webpack_require__(203)
  // just call tar.r with the filter and mtimeCache

  const u = module.exports = (opt_, files, cb) => {
    const opt = hlo(opt_)

    if (!opt.file)
      throw new TypeError('file is required')

    if (opt.gzip)
      throw new TypeError('cannot append to compressed archives')

    if (!files || !Array.isArray(files) || !files.length)
      throw new TypeError('no files or directories specified')

    files = Array.from(files)

    mtimeFilter(opt)
    return r(opt, files, cb)
  }

  const mtimeFilter = opt => {
    const filter = opt.filter

    if (!opt.mtimeCache)
      opt.mtimeCache = new Map()

    opt.filter = filter ? (path, stat) =>
      filter(path, stat) && !(opt.mtimeCache.get(path) > stat.mtime)
      : (path, stat) => !(opt.mtimeCache.get(path) > stat.mtime)
  }


  /***/ }),
  /* 205 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  // tar -x
  const hlo = __webpack_require__(182)
  const Unpack = __webpack_require__(206)
  const fs = __webpack_require__(7)
  const fsm = __webpack_require__(200)
  const path = __webpack_require__(8)

  const x = module.exports = (opt_, files, cb) => {
    if (typeof opt_ === 'function')
      cb = opt_, files = null, opt_ = {}
    else if (Array.isArray(opt_))
      files = opt_, opt_ = {}

    if (typeof files === 'function')
      cb = files, files = null

    if (!files)
      files = []
    else
      files = Array.from(files)

    const opt = hlo(opt_)

    if (opt.sync && typeof cb === 'function')
      throw new TypeError('callback not supported for sync tar functions')

    if (!opt.file && typeof cb === 'function')
      throw new TypeError('callback only supported with file option')

    if (files.length)
      filesFilter(opt, files)

    return opt.file && opt.sync ? extractFileSync(opt)
      : opt.file ? extractFile(opt, cb)
      : opt.sync ? extractSync(opt)
      : extract(opt)
  }

  // construct a filter that limits the file entries listed
  // include child entries if a dir is included
  const filesFilter = (opt, files) => {
    const map = new Map(files.map(f => [f.replace(/\/+$/, ''), true]))
    const filter = opt.filter

    const mapHas = (file, r) => {
      const root = r || path.parse(file).root || '.'
      const ret = file === root ? false
        : map.has(file) ? map.get(file)
        : mapHas(path.dirname(file), root)

      map.set(file, ret)
      return ret
    }

    opt.filter = filter
      ? (file, entry) => filter(file, entry) && mapHas(file.replace(/\/+$/, ''))
      : file => mapHas(file.replace(/\/+$/, ''))
  }

  const extractFileSync = opt => {
    const u = new Unpack.Sync(opt)

    const file = opt.file
    let threw = true
    let fd
    const stat = fs.statSync(file)
    // This trades a zero-byte read() syscall for a stat
    // However, it will usually result in less memory allocation
    const readSize = opt.maxReadSize || 16*1024*1024
    const stream = new fsm.ReadStreamSync(file, {
      readSize: readSize,
      size: stat.size
    })
    stream.pipe(u)
  }

  const extractFile = (opt, cb) => {
    const u = new Unpack(opt)
    const readSize = opt.maxReadSize || 16*1024*1024

    const file = opt.file
    const p = new Promise((resolve, reject) => {
      u.on('error', reject)
      u.on('close', resolve)

      // This trades a zero-byte read() syscall for a stat
      // However, it will usually result in less memory allocation
      fs.stat(file, (er, stat) => {
        if (er)
          reject(er)
        else {
          const stream = new fsm.ReadStream(file, {
            readSize: readSize,
            size: stat.size
          })
          stream.on('error', reject)
          stream.pipe(u)
        }
      })
    })
    return cb ? p.then(cb, cb) : p
  }

  const extractSync = opt => {
    return new Unpack.Sync(opt)
  }

  const extract = opt => {
    return new Unpack(opt)
  }


  /***/ }),
  /* 206 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const assert = __webpack_require__(127)
  const EE = __webpack_require__(67).EventEmitter
  const Parser = __webpack_require__(202)
  const fs = __webpack_require__(7)
  const fsm = __webpack_require__(200)
  const path = __webpack_require__(8)
  const mkdir = __webpack_require__(207)
  const mkdirSync = mkdir.sync
  const wc = __webpack_require__(198)

  const ONENTRY = Symbol('onEntry')
  const CHECKFS = Symbol('checkFs')
  const ISREUSABLE = Symbol('isReusable')
  const MAKEFS = Symbol('makeFs')
  const FILE = Symbol('file')
  const DIRECTORY = Symbol('directory')
  const LINK = Symbol('link')
  const SYMLINK = Symbol('symlink')
  const HARDLINK = Symbol('hardlink')
  const UNSUPPORTED = Symbol('unsupported')
  const UNKNOWN = Symbol('unknown')
  const CHECKPATH = Symbol('checkPath')
  const MKDIR = Symbol('mkdir')
  const ONERROR = Symbol('onError')
  const PENDING = Symbol('pending')
  const PEND = Symbol('pend')
  const UNPEND = Symbol('unpend')
  const ENDED = Symbol('ended')
  const MAYBECLOSE = Symbol('maybeClose')
  const SKIP = Symbol('skip')
  const DOCHOWN = Symbol('doChown')
  const UID = Symbol('uid')
  const GID = Symbol('gid')
  const crypto = __webpack_require__(9)

  // Unlinks on Windows are not atomic.
  //
  // This means that if you have a file entry, followed by another
  // file entry with an identical name, and you cannot re-use the file
  // (because it's a hardlink, or because unlink:true is set, or it's
  // Windows, which does not have useful nlink values), then the unlink
  // will be committed to the disk AFTER the new file has been written
  // over the old one, deleting the new file.
  //
  // To work around this, on Windows systems, we rename the file and then
  // delete the renamed file.  It's a sloppy kludge, but frankly, I do not
  // know of a better way to do this, given windows' non-atomic unlink
  // semantics.
  //
  // See: https://github.com/npm/node-tar/issues/183
  /* istanbul ignore next */
  const unlinkFile = (path, cb) => {
    if (process.platform !== 'win32')
      return fs.unlink(path, cb)

    const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')
    fs.rename(path, name, er => {
      if (er)
        return cb(er)
      fs.unlink(name, cb)
    })
  }

  /* istanbul ignore next */
  const unlinkFileSync = path => {
    if (process.platform !== 'win32')
      return fs.unlinkSync(path)

    const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')
    fs.renameSync(path, name)
    fs.unlinkSync(name)
  }

  // this.gid, entry.gid, this.processUid
  const uint32 = (a, b, c) =>
    a === a >>> 0 ? a
    : b === b >>> 0 ? b
    : c

  class Unpack extends Parser {
    constructor (opt) {
      if (!opt)
        opt = {}

      opt.ondone = _ => {
        this[ENDED] = true
        this[MAYBECLOSE]()
      }

      super(opt)

      this.transform = typeof opt.transform === 'function' ? opt.transform : null

      this.writable = true
      this.readable = false

      this[PENDING] = 0
      this[ENDED] = false

      this.dirCache = opt.dirCache || new Map()

      if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {
        // need both or neither
        if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number')
          throw new TypeError('cannot set owner without number uid and gid')
        if (opt.preserveOwner)
          throw new TypeError(
            'cannot preserve owner in archive and also set owner explicitly')
        this.uid = opt.uid
        this.gid = opt.gid
        this.setOwner = true
      } else {
        this.uid = null
        this.gid = null
        this.setOwner = false
      }

      // default true for root
      if (opt.preserveOwner === undefined && typeof opt.uid !== 'number')
        this.preserveOwner = process.getuid && process.getuid() === 0
      else
        this.preserveOwner = !!opt.preserveOwner

      this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ?
        process.getuid() : null
      this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ?
        process.getgid() : null

      // mostly just for testing, but useful in some cases.
      // Forcibly trigger a chown on every entry, no matter what
      this.forceChown = opt.forceChown === true

      // turn ><?| in filenames into 0xf000-higher encoded forms
      this.win32 = !!opt.win32 || process.platform === 'win32'

      // do not unpack over files that are newer than what's in the archive
      this.newer = !!opt.newer

      // do not unpack over ANY files
      this.keep = !!opt.keep

      // do not set mtime/atime of extracted entries
      this.noMtime = !!opt.noMtime

      // allow .., absolute path entries, and unpacking through symlinks
      // without this, warn and skip .., relativize absolutes, and error
      // on symlinks in extraction path
      this.preservePaths = !!opt.preservePaths

      // unlink files and links before writing. This breaks existing hard
      // links, and removes symlink directories rather than erroring
      this.unlink = !!opt.unlink

      this.cwd = path.resolve(opt.cwd || process.cwd())
      this.strip = +opt.strip || 0
      this.processUmask = process.umask()
      this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask
      // default mode for dirs created as parents
      this.dmode = opt.dmode || (0o0777 & (~this.umask))
      this.fmode = opt.fmode || (0o0666 & (~this.umask))
      this.on('entry', entry => this[ONENTRY](entry))
    }

    [MAYBECLOSE] () {
      if (this[ENDED] && this[PENDING] === 0) {
        this.emit('prefinish')
        this.emit('finish')
        this.emit('end')
        this.emit('close')
      }
    }

    [CHECKPATH] (entry) {
      if (this.strip) {
        const parts = entry.path.split(/\/|\\/)
        if (parts.length < this.strip)
          return false
        entry.path = parts.slice(this.strip).join('/')

        if (entry.type === 'Link') {
          const linkparts = entry.linkpath.split(/\/|\\/)
          if (linkparts.length >= this.strip)
            entry.linkpath = linkparts.slice(this.strip).join('/')
        }
      }

      if (!this.preservePaths) {
        const p = entry.path
        if (p.match(/(^|\/|\\)\.\.(\\|\/|$)/)) {
          this.warn('path contains \'..\'', p)
          return false
        }

        // absolutes on posix are also absolutes on win32
        // so we only need to test this one to get both
        if (path.win32.isAbsolute(p)) {
          const parsed = path.win32.parse(p)
          this.warn('stripping ' + parsed.root + ' from absolute path', p)
          entry.path = p.substr(parsed.root.length)
        }
      }

      // only encode : chars that aren't drive letter indicators
      if (this.win32) {
        const parsed = path.win32.parse(entry.path)
        entry.path = parsed.root === '' ? wc.encode(entry.path)
          : parsed.root + wc.encode(entry.path.substr(parsed.root.length))
      }

      if (path.isAbsolute(entry.path))
        entry.absolute = entry.path
      else
        entry.absolute = path.resolve(this.cwd, entry.path)

      return true
    }

    [ONENTRY] (entry) {
      if (!this[CHECKPATH](entry))
        return entry.resume()

      assert.equal(typeof entry.absolute, 'string')

      switch (entry.type) {
        case 'Directory':
        case 'GNUDumpDir':
          if (entry.mode)
            entry.mode = entry.mode | 0o700

        case 'File':
        case 'OldFile':
        case 'ContiguousFile':
        case 'Link':
        case 'SymbolicLink':
          return this[CHECKFS](entry)

        case 'CharacterDevice':
        case 'BlockDevice':
        case 'FIFO':
          return this[UNSUPPORTED](entry)
      }
    }

    [ONERROR] (er, entry) {
      // Cwd has to exist, or else nothing works. That's serious.
      // Other errors are warnings, which raise the error in strict
      // mode, but otherwise continue on.
      if (er.name === 'CwdError')
        this.emit('error', er)
      else {
        this.warn(er.message, er)
        this[UNPEND]()
        entry.resume()
      }
    }

    [MKDIR] (dir, mode, cb) {
      mkdir(dir, {
        uid: this.uid,
        gid: this.gid,
        processUid: this.processUid,
        processGid: this.processGid,
        umask: this.processUmask,
        preserve: this.preservePaths,
        unlink: this.unlink,
        cache: this.dirCache,
        cwd: this.cwd,
        mode: mode
      }, cb)
    }

    [DOCHOWN] (entry) {
      // in preserve owner mode, chown if the entry doesn't match process
      // in set owner mode, chown if setting doesn't match process
      return this.forceChown ||
        this.preserveOwner &&
        ( typeof entry.uid === 'number' && entry.uid !== this.processUid ||
          typeof entry.gid === 'number' && entry.gid !== this.processGid )
        ||
        ( typeof this.uid === 'number' && this.uid !== this.processUid ||
          typeof this.gid === 'number' && this.gid !== this.processGid )
    }

    [UID] (entry) {
      return uint32(this.uid, entry.uid, this.processUid)
    }

    [GID] (entry) {
      return uint32(this.gid, entry.gid, this.processGid)
    }

    [FILE] (entry) {
      const mode = entry.mode & 0o7777 || this.fmode
      const stream = new fsm.WriteStream(entry.absolute, {
        mode: mode,
        autoClose: false
      })
      stream.on('error', er => this[ONERROR](er, entry))

      let actions = 1
      const done = er => {
        if (er)
          return this[ONERROR](er, entry)

        if (--actions === 0)
          fs.close(stream.fd, _ => this[UNPEND]())
      }

      stream.on('finish', _ => {
        // if futimes fails, try utimes
        // if utimes fails, fail with the original error
        // same for fchown/chown
        const abs = entry.absolute
        const fd = stream.fd

        if (entry.mtime && !this.noMtime) {
          actions++
          const atime = entry.atime || new Date()
          const mtime = entry.mtime
          fs.futimes(fd, atime, mtime, er =>
            er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er))
            : done())
        }

        if (this[DOCHOWN](entry)) {
          actions++
          const uid = this[UID](entry)
          const gid = this[GID](entry)
          fs.fchown(fd, uid, gid, er =>
            er ? fs.chown(abs, uid, gid, er2 => done(er2 && er))
            : done())
        }

        done()
      })

      const tx = this.transform ? this.transform(entry) || entry : entry
      if (tx !== entry) {
        tx.on('error', er => this[ONERROR](er, entry))
        entry.pipe(tx)
      }
      tx.pipe(stream)
    }

    [DIRECTORY] (entry) {
      const mode = entry.mode & 0o7777 || this.dmode
      this[MKDIR](entry.absolute, mode, er => {
        if (er)
          return this[ONERROR](er, entry)

        let actions = 1
        const done = _ => {
          if (--actions === 0) {
            this[UNPEND]()
            entry.resume()
          }
        }

        if (entry.mtime && !this.noMtime) {
          actions++
          fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done)
        }

        if (this[DOCHOWN](entry)) {
          actions++
          fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done)
        }

        done()
      })
    }

    [UNSUPPORTED] (entry) {
      this.warn('unsupported entry type: ' + entry.type, entry)
      entry.resume()
    }

    [SYMLINK] (entry) {
      this[LINK](entry, entry.linkpath, 'symlink')
    }

    [HARDLINK] (entry) {
      this[LINK](entry, path.resolve(this.cwd, entry.linkpath), 'link')
    }

    [PEND] () {
      this[PENDING]++
    }

    [UNPEND] () {
      this[PENDING]--
      this[MAYBECLOSE]()
    }

    [SKIP] (entry) {
      this[UNPEND]()
      entry.resume()
    }

    // Check if we can reuse an existing filesystem entry safely and
    // overwrite it, rather than unlinking and recreating
    // Windows doesn't report a useful nlink, so we just never reuse entries
    [ISREUSABLE] (entry, st) {
      return entry.type === 'File' &&
        !this.unlink &&
        st.isFile() &&
        st.nlink <= 1 &&
        process.platform !== 'win32'
    }

    // check if a thing is there, and if so, try to clobber it
    [CHECKFS] (entry) {
      this[PEND]()
      this[MKDIR](path.dirname(entry.absolute), this.dmode, er => {
        if (er)
          return this[ONERROR](er, entry)
        fs.lstat(entry.absolute, (er, st) => {
          if (st && (this.keep || this.newer && st.mtime > entry.mtime))
            this[SKIP](entry)
          else if (er || this[ISREUSABLE](entry, st))
            this[MAKEFS](null, entry)
          else if (st.isDirectory()) {
            if (entry.type === 'Directory') {
              if (!entry.mode || (st.mode & 0o7777) === entry.mode)
                this[MAKEFS](null, entry)
              else
                fs.chmod(entry.absolute, entry.mode, er => this[MAKEFS](er, entry))
            } else
              fs.rmdir(entry.absolute, er => this[MAKEFS](er, entry))
          } else
            unlinkFile(entry.absolute, er => this[MAKEFS](er, entry))
        })
      })
    }

    [MAKEFS] (er, entry) {
      if (er)
        return this[ONERROR](er, entry)

      switch (entry.type) {
        case 'File':
        case 'OldFile':
        case 'ContiguousFile':
          return this[FILE](entry)

        case 'Link':
          return this[HARDLINK](entry)

        case 'SymbolicLink':
          return this[SYMLINK](entry)

        case 'Directory':
        case 'GNUDumpDir':
          return this[DIRECTORY](entry)
      }
    }

    [LINK] (entry, linkpath, link) {
      // XXX: get the type ('file' or 'dir') for windows
      fs[link](linkpath, entry.absolute, er => {
        if (er)
          return this[ONERROR](er, entry)
        this[UNPEND]()
        entry.resume()
      })
    }
  }

  class UnpackSync extends Unpack {
    constructor (opt) {
      super(opt)
    }

    [CHECKFS] (entry) {
      const er = this[MKDIR](path.dirname(entry.absolute), this.dmode)
      if (er)
        return this[ONERROR](er, entry)
      try {
        const st = fs.lstatSync(entry.absolute)
        if (this.keep || this.newer && st.mtime > entry.mtime)
          return this[SKIP](entry)
        else if (this[ISREUSABLE](entry, st))
          return this[MAKEFS](null, entry)
        else {
          try {
            if (st.isDirectory()) {
              if (entry.type === 'Directory') {
                if (entry.mode && (st.mode & 0o7777) !== entry.mode)
                  fs.chmodSync(entry.absolute, entry.mode)
              } else
                fs.rmdirSync(entry.absolute)
            } else
              unlinkFileSync(entry.absolute)
            return this[MAKEFS](null, entry)
          } catch (er) {
            return this[ONERROR](er, entry)
          }
        }
      } catch (er) {
        return this[MAKEFS](null, entry)
      }
    }

    [FILE] (entry) {
      const mode = entry.mode & 0o7777 || this.fmode

      const oner = er => {
        try { fs.closeSync(fd) } catch (_) {}
        if (er)
          this[ONERROR](er, entry)
      }

      let stream
      let fd
      try {
        fd = fs.openSync(entry.absolute, 'w', mode)
      } catch (er) {
        return oner(er)
      }
      const tx = this.transform ? this.transform(entry) || entry : entry
      if (tx !== entry) {
        tx.on('error', er => this[ONERROR](er, entry))
        entry.pipe(tx)
      }

      tx.on('data', chunk => {
        try {
          fs.writeSync(fd, chunk, 0, chunk.length)
        } catch (er) {
          oner(er)
        }
      })

      tx.on('end', _ => {
        let er = null
        // try both, falling futimes back to utimes
        // if either fails, handle the first error
        if (entry.mtime && !this.noMtime) {
          const atime = entry.atime || new Date()
          const mtime = entry.mtime
          try {
            fs.futimesSync(fd, atime, mtime)
          } catch (futimeser) {
            try {
              fs.utimesSync(entry.absolute, atime, mtime)
            } catch (utimeser) {
              er = futimeser
            }
          }
        }

        if (this[DOCHOWN](entry)) {
          const uid = this[UID](entry)
          const gid = this[GID](entry)

          try {
            fs.fchownSync(fd, uid, gid)
          } catch (fchowner) {
            try {
              fs.chownSync(entry.absolute, uid, gid)
            } catch (chowner) {
              er = er || fchowner
            }
          }
        }

        oner(er)
      })
    }

    [DIRECTORY] (entry) {
      const mode = entry.mode & 0o7777 || this.dmode
      const er = this[MKDIR](entry.absolute, mode)
      if (er)
        return this[ONERROR](er, entry)
      if (entry.mtime && !this.noMtime) {
        try {
          fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime)
        } catch (er) {}
      }
      if (this[DOCHOWN](entry)) {
        try {
          fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry))
        } catch (er) {}
      }
      entry.resume()
    }

    [MKDIR] (dir, mode) {
      try {
        return mkdir.sync(dir, {
          uid: this.uid,
          gid: this.gid,
          processUid: this.processUid,
          processGid: this.processGid,
          umask: this.processUmask,
          preserve: this.preservePaths,
          unlink: this.unlink,
          cache: this.dirCache,
          cwd: this.cwd,
          mode: mode
        })
      } catch (er) {
        return er
      }
    }

    [LINK] (entry, linkpath, link) {
      try {
        fs[link + 'Sync'](linkpath, entry.absolute)
        entry.resume()
      } catch (er) {
        return this[ONERROR](er, entry)
      }
    }
  }

  Unpack.Sync = UnpackSync
  module.exports = Unpack


  /***/ }),
  /* 207 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  // wrapper around mkdirp for tar's needs.

  // TODO: This should probably be a class, not functionally
  // passing around state in a gazillion args.

  const mkdirp = __webpack_require__(208)
  const fs = __webpack_require__(7)
  const path = __webpack_require__(8)
  const chownr = __webpack_require__(209)

  class SymlinkError extends Error {
    constructor (symlink, path) {
      super('Cannot extract through symbolic link')
      this.path = path
      this.symlink = symlink
    }

    get name () {
      return 'SylinkError'
    }
  }

  class CwdError extends Error {
    constructor (path, code) {
      super(code + ': Cannot cd into \'' + path + '\'')
      this.path = path
      this.code = code
    }

    get name () {
      return 'CwdError'
    }
  }

  const mkdir = module.exports = (dir, opt, cb) => {
    // if there's any overlap between mask and mode,
    // then we'll need an explicit chmod
    const umask = opt.umask
    const mode = opt.mode | 0o0700
    const needChmod = (mode & umask) !== 0

    const uid = opt.uid
    const gid = opt.gid
    const doChown = typeof uid === 'number' &&
      typeof gid === 'number' &&
      ( uid !== opt.processUid || gid !== opt.processGid )

    const preserve = opt.preserve
    const unlink = opt.unlink
    const cache = opt.cache
    const cwd = opt.cwd

    const done = (er, created) => {
      if (er)
        cb(er)
      else {
        cache.set(dir, true)
        if (created && doChown)
          chownr(created, uid, gid, er => done(er))
        else if (needChmod)
          fs.chmod(dir, mode, cb)
        else
          cb()
      }
    }

    if (cache && cache.get(dir) === true)
      return done()

    if (dir === cwd)
      return fs.stat(dir, (er, st) => {
        if (er || !st.isDirectory())
          er = new CwdError(dir, er && er.code || 'ENOTDIR')
        done(er)
      })

    if (preserve)
      return mkdirp(dir, mode, done)

    const sub = path.relative(cwd, dir)
    const parts = sub.split(/\/|\\/)
    mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done)
  }

  const mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {
    if (!parts.length)
      return cb(null, created)
    const p = parts.shift()
    const part = base + '/' + p
    if (cache.get(part))
      return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)
    fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))
  }

  const onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {
    if (er) {
      if (er.path && path.dirname(er.path) === cwd &&
          (er.code === 'ENOTDIR' || er.code === 'ENOENT'))
        return cb(new CwdError(cwd, er.code))

      fs.lstat(part, (statEr, st) => {
        if (statEr)
          cb(statEr)
        else if (st.isDirectory())
          mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)
        else if (unlink)
          fs.unlink(part, er => {
            if (er)
              return cb(er)
            fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))
          })
        else if (st.isSymbolicLink())
          return cb(new SymlinkError(part, part + '/' + parts.join('/')))
        else
          cb(er)
      })
    } else {
      created = created || part
      mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)
    }
  }

  const mkdirSync = module.exports.sync = (dir, opt) => {
    // if there's any overlap between mask and mode,
    // then we'll need an explicit chmod
    const umask = opt.umask
    const mode = opt.mode | 0o0700
    const needChmod = (mode & umask) !== 0

    const uid = opt.uid
    const gid = opt.gid
    const doChown = typeof uid === 'number' &&
      typeof gid === 'number' &&
      ( uid !== opt.processUid || gid !== opt.processGid )

    const preserve = opt.preserve
    const unlink = opt.unlink
    const cache = opt.cache
    const cwd = opt.cwd

    const done = (created) => {
      cache.set(dir, true)
      if (created && doChown)
        chownr.sync(created, uid, gid)
      if (needChmod)
        fs.chmodSync(dir, mode)
    }

    if (cache && cache.get(dir) === true)
      return done()

    if (dir === cwd) {
      let ok = false
      let code = 'ENOTDIR'
      try {
        ok = fs.statSync(dir).isDirectory()
      } catch (er) {
        code = er.code
      } finally {
        if (!ok)
          throw new CwdError(dir, code)
      }
      done()
      return
    }

    if (preserve)
      return done(mkdirp.sync(dir, mode))

    const sub = path.relative(cwd, dir)
    const parts = sub.split(/\/|\\/)
    let created = null
    for (let p = parts.shift(), part = cwd;
         p && (part += '/' + p);
         p = parts.shift()) {

      if (cache.get(part))
        continue

      try {
        fs.mkdirSync(part, mode)
        created = created || part
        cache.set(part, true)
      } catch (er) {
        if (er.path && path.dirname(er.path) === cwd &&
            (er.code === 'ENOTDIR' || er.code === 'ENOENT'))
          return new CwdError(cwd, er.code)

        const st = fs.lstatSync(part)
        if (st.isDirectory()) {
          cache.set(part, true)
          continue
        } else if (unlink) {
          fs.unlinkSync(part)
          fs.mkdirSync(part, mode)
          created = created || part
          cache.set(part, true)
          continue
        } else if (st.isSymbolicLink())
          return new SymlinkError(part, part + '/' + parts.join('/'))
      }
    }

    return done(created)
  }


  /***/ }),
  /* 208 */
  /***/ (function(module, exports, __webpack_require__) {

  var path = __webpack_require__(8);
  var fs = __webpack_require__(7);
  var _0777 = parseInt('0777', 8);

  module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

  function mkdirP (p, opts, f, made) {
      if (typeof opts === 'function') {
          f = opts;
          opts = {};
      }
      else if (!opts || typeof opts !== 'object') {
          opts = { mode: opts };
      }

      var mode = opts.mode;
      var xfs = opts.fs || fs;

      if (mode === undefined) {
          mode = _0777 & (~process.umask());
      }
      if (!made) made = null;

      var cb = f || function () {};
      p = path.resolve(p);

      xfs.mkdir(p, mode, function (er) {
          if (!er) {
              made = made || p;
              return cb(null, made);
          }
          switch (er.code) {
              case 'ENOENT':
                  mkdirP(path.dirname(p), opts, function (er, made) {
                      if (er) cb(er, made);
                      else mkdirP(p, opts, cb, made);
                  });
                  break;

              // In the case of any other error, just see if there's a dir
              // there already.  If so, then hooray!  If not, then something
              // is borked.
              default:
                  xfs.stat(p, function (er2, stat) {
                      // if the stat fails, then that's super weird.
                      // let the original error be the failure reason.
                      if (er2 || !stat.isDirectory()) cb(er, made)
                      else cb(null, made);
                  });
                  break;
          }
      });
  }

  mkdirP.sync = function sync (p, opts, made) {
      if (!opts || typeof opts !== 'object') {
          opts = { mode: opts };
      }

      var mode = opts.mode;
      var xfs = opts.fs || fs;

      if (mode === undefined) {
          mode = _0777 & (~process.umask());
      }
      if (!made) made = null;

      p = path.resolve(p);

      try {
          xfs.mkdirSync(p, mode);
          made = made || p;
      }
      catch (err0) {
          switch (err0.code) {
              case 'ENOENT' :
                  made = sync(path.dirname(p), opts, made);
                  sync(p, opts, made);
                  break;

              // In the case of any other error, just see if there's a dir
              // there already.  If so, then hooray!  If not, then something
              // is borked.
              default:
                  var stat;
                  try {
                      stat = xfs.statSync(p);
                  }
                  catch (err1) {
                      throw err0;
                  }
                  if (!stat.isDirectory()) throw err0;
                  break;
          }
      }

      return made;
  };


  /***/ }),
  /* 209 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const fs = __webpack_require__(7)
  const path = __webpack_require__(8)

  /* istanbul ignore next */
  const LCHOWN = fs.lchown ? 'lchown' : 'chown'
  /* istanbul ignore next */
  const LCHOWNSYNC = fs.lchownSync ? 'lchownSync' : 'chownSync'

  const needEISDIRHandled = fs.lchown &&
    !process.version.match(/v1[1-9]+\./) &&
    !process.version.match(/v10\.[6-9]/)

  /* istanbul ignore next */
  const handleEISDIR =
    needEISDIRHandled ? (path, uid, gid, cb) => er => {
      // Node prior to v10 had a very questionable implementation of
      // fs.lchown, which would always try to call fs.open on a directory
      // Fall back to fs.chown in those cases.
      if (!er || er.code !== 'EISDIR')
        cb(er)
      else
        fs.chown(path, uid, gid, cb)
    }
    : (_, __, ___, cb) => cb

  /* istanbul ignore next */
  const handleEISDirSync =
    needEISDIRHandled ? (path, uid, gid) => {
      try {
        return fs[LCHOWNSYNC](path, uid, gid)
      } catch (er) {
        if (er.code !== 'EISDIR')
          throw er
        fs.chownSync(path, uid, gid)
      }
    }
    : fs[LCHOWNSYNC]

  // fs.readdir could only accept an options object as of node v6
  const nodeVersion = process.version
  let readdir = (path, options, cb) => fs.readdir(path, options, cb)
  let readdirSync = (path, options) => fs.readdirSync(path, options)
  /* istanbul ignore next */
  if (/^v4\./.test(nodeVersion))
    readdir = (path, options, cb) => fs.readdir(path, cb)

  const chownrKid = (p, child, uid, gid, cb) => {
    if (typeof child === 'string')
      return fs.lstat(path.resolve(p, child), (er, stats) => {
        if (er)
          return cb(er)
        stats.name = child
        chownrKid(p, stats, uid, gid, cb)
      })

    if (child.isDirectory()) {
      chownr(path.resolve(p, child.name), uid, gid, er => {
        if (er)
          return cb(er)
        const cpath = path.resolve(p, child.name)
        fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, cb))
      })
    } else {
      const cpath = path.resolve(p, child.name)
      fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, cb))
    }
  }


  const chownr = (p, uid, gid, cb) => {
    readdir(p, { withFileTypes: true }, (er, children) => {
      // any error other than ENOTDIR or ENOTSUP means it's not readable,
      // or doesn't exist.  give up.
      if (er && er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP')
        return cb(er)
      if (er || !children.length)
        return fs[LCHOWN](p, uid, gid, handleEISDIR(p, uid, gid, cb))

      let len = children.length
      let errState = null
      const then = er => {
        if (errState)
          return
        if (er)
          return cb(errState = er)
        if (-- len === 0)
          return fs[LCHOWN](p, uid, gid, handleEISDIR(p, uid, gid, cb))
      }

      children.forEach(child => chownrKid(p, child, uid, gid, then))
    })
  }

  const chownrKidSync = (p, child, uid, gid) => {
    if (typeof child === 'string') {
      const stats = fs.lstatSync(path.resolve(p, child))
      stats.name = child
      child = stats
    }

    if (child.isDirectory())
      chownrSync(path.resolve(p, child.name), uid, gid)

    handleEISDirSync(path.resolve(p, child.name), uid, gid)
  }

  const chownrSync = (p, uid, gid) => {
    let children
    try {
      children = readdirSync(p, { withFileTypes: true })
    } catch (er) {
      if (er && er.code === 'ENOTDIR' && er.code !== 'ENOTSUP')
        return handleEISDirSync(p, uid, gid)
      throw er
    }

    if (children.length)
      children.forEach(child => chownrKidSync(p, child, uid, gid))

    return handleEISDirSync(p, uid, gid)
  }

  module.exports = chownr
  chownr.sync = chownrSync


  /***/ }),
  /* 210 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      result["default"] = mod;
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const fslib_1 = __webpack_require__(5);
  const fslib_2 = __webpack_require__(5);
  const Report_1 = __webpack_require__(177);
  const hashUtils = __importStar(__webpack_require__(175));
  const structUtils = __importStar(__webpack_require__(173));
  class Cache {
      constructor(cacheCwd, { configuration, immutable = configuration.get(`enableImmutableCache`), check = false }) {
          // Contains the list of cache files that got accessed since the last time
          // you cleared the variable. Useful to know which files aren't needed
          // anymore when used in conjunction with fetchEverything.
          this.markedFiles = new Set();
          this.mutexes = new Map();
          this.configuration = configuration;
          this.cwd = cacheCwd;
          this.immutable = immutable;
          this.check = check;
      }
      static async find(configuration, { immutable, check } = {}) {
          const cache = new Cache(configuration.get(`cacheFolder`), { configuration, immutable, check });
          await cache.setup();
          return cache;
      }
      getLocatorFilename(locator) {
          return `${structUtils.slugifyLocator(locator)}.zip`;
      }
      getLocatorPath(locator) {
          return fslib_2.ppath.resolve(this.cwd, this.getLocatorFilename(locator));
      }
      async setup() {
          await fslib_2.xfs.mkdirpPromise(this.cwd);
          const gitignorePath = fslib_2.ppath.resolve(this.cwd, fslib_2.toFilename(`.gitignore`));
          const gitignoreExists = await fslib_2.xfs.existsPromise(gitignorePath);
          if (!gitignoreExists) {
              await fslib_2.xfs.writeFilePromise(gitignorePath, `/.gitignore\n*.lock\n`);
          }
      }
      async fetchPackageFromCache(locator, expectedChecksum, loader) {
          const cachePath = this.getLocatorPath(locator);
          const baseFs = new fslib_1.NodeFS();
          this.markedFiles.add(cachePath);
          const validateFile = async (path, refetchPath = null) => {
              const actualChecksum = await hashUtils.checksumFile(path);
              if (refetchPath !== null) {
                  const previousChecksum = await hashUtils.checksumFile(refetchPath);
                  if (actualChecksum !== previousChecksum) {
                      throw new Report_1.ReportError(Report_1.MessageName.CACHE_CHECKSUM_MISMATCH, `${structUtils.prettyLocator(this.configuration, locator)} doesn't resolve to an archive that matches what's stored in the cache - has the cache been tampered?`);
                  }
              }
              if (expectedChecksum !== null && actualChecksum !== expectedChecksum) {
                  // Using --check-cache overrides any preconfigured checksum behavior
                  const checksumBehavior = !this.check
                      ? this.configuration.get(`checksumBehavior`)
                      : `throw`;
                  switch (checksumBehavior) {
                      case `ignore`:
                          return expectedChecksum;
                      case `update`:
                          return actualChecksum;
                      default:
                      case `throw`:
                          {
                              throw new Report_1.ReportError(Report_1.MessageName.CACHE_CHECKSUM_MISMATCH, `${structUtils.prettyLocator(this.configuration, locator)} doesn't resolve to an archive that matches the expected checksum`);
                          }
                          break;
                  }
              }
              return actualChecksum;
          };
          const validateFileAgainstRemote = async (cachePath) => {
              if (!loader)
                  throw new Error(`Cache check required but no loader configured for ${structUtils.prettyLocator(this.configuration, locator)}`);
              const zipFs = await loader();
              const refetchPath = zipFs.getRealPath();
              zipFs.saveAndClose();
              await fslib_2.xfs.chmodPromise(refetchPath, 0o644);
              return await validateFile(cachePath, refetchPath);
          };
          const loadPackage = async () => {
              if (!loader)
                  throw new Error(`Cache entry required but missing for ${structUtils.prettyLocator(this.configuration, locator)}`);
              if (this.immutable)
                  throw new Report_1.ReportError(Report_1.MessageName.IMMUTABLE_CACHE, `Cache entry required but missing for ${structUtils.prettyLocator(this.configuration, locator)}`);
              return await this.writeFileIntoCache(cachePath, async () => {
                  const zipFs = await loader();
                  const originalPath = zipFs.getRealPath();
                  zipFs.saveAndClose();
                  await fslib_2.xfs.chmodPromise(originalPath, 0o644);
                  // Do this before moving the file so that we don't pollute the cache with corrupted archives
                  const checksum = await validateFile(originalPath);
                  // Doing a move is important to ensure atomic writes (todo: cross-drive?)
                  await fslib_2.xfs.movePromise(originalPath, cachePath);
                  return checksum;
              });
          };
          const loadPackageThroughMutex = async () => {
              const mutex = loadPackage();
              this.mutexes.set(locator.locatorHash, mutex);
              try {
                  return await mutex;
              }
              finally {
                  this.mutexes.delete(locator.locatorHash);
              }
          };
          for (let mutex; mutex = this.mutexes.get(locator.locatorHash);)
              await mutex;
          const checksum = !baseFs.existsSync(cachePath)
              ? await loadPackageThroughMutex()
              : this.check
                  ? await validateFileAgainstRemote(cachePath)
                  : await validateFile(cachePath);
          let zipFs = null;
          const lazyFs = new fslib_1.LazyFS(() => {
              try {
                  return zipFs = new fslib_1.ZipFS(cachePath, { readOnly: true, baseFs });
              }
              catch (error) {
                  error.message = `Failed to open the cache entry for ${structUtils.prettyLocator(this.configuration, locator)}: ${error.message}`;
                  throw error;
              }
          }, fslib_2.ppath);
          const releaseFs = () => {
              if (zipFs !== null) {
                  zipFs.discardAndClose();
              }
          };
          return [lazyFs, releaseFs, checksum];
      }
      async writeFileIntoCache(file, generator) {
          return await fslib_2.xfs.lockPromise(`${file}.lock`, async () => {
              return await generator(file);
          });
      }
  }
  exports.Cache = Cache;


  /***/ }),
  /* 211 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importDefault = (this && this.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      result["default"] = mod;
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const fslib_1 = __webpack_require__(5);
  const parsers_1 = __webpack_require__(132);
  const camelcase_1 = __importDefault(__webpack_require__(212));
  const chalk_1 = __importDefault(__webpack_require__(213));
  const clipanion_1 = __webpack_require__(224);
  const supports_color_1 = __importDefault(__webpack_require__(221));
  const MultiFetcher_1 = __webpack_require__(231);
  const MultiResolver_1 = __webpack_require__(232);
  const SemverResolver_1 = __webpack_require__(233);
  const TagResolver_1 = __webpack_require__(234);
  const VirtualFetcher_1 = __webpack_require__(235);
  const VirtualResolver_1 = __webpack_require__(236);
  const WorkspaceFetcher_1 = __webpack_require__(237);
  const WorkspaceResolver_1 = __webpack_require__(238);
  const folderUtils = __importStar(__webpack_require__(43));
  const miscUtils = __importStar(__webpack_require__(128));
  const nodeUtils = __importStar(__webpack_require__(240));
  const structUtils = __importStar(__webpack_require__(173));
  // @ts-ignore
  const ctx = new chalk_1.default.constructor({ enabled: true });
  const IGNORED_ENV_VARIABLES = new Set([
      // "binFolder" is the magic location where the parent process stored the current binaries; not an actual configuration settings
      `binFolder`,
      // "version" is set by Docker: https://github.com/nodejs/docker-node/blob/5a6a5e91999358c5b04fddd6c22a9a4eb0bf3fbf/10/alpine/Dockerfile#L51
      `version`,
      // "flags" is set by Netlify; they use it to specify the flags to send to the CLI when running the automatic `yarn install`
      `flags`,
  ]);
  const LEGACY_NAMES = new Set([
      `networkConcurrency`,
      `childConcurrency`,
      `networkTimeout`,
      `proxy`,
      `strictSsl`,
      `ca`,
      `cert`,
      `key`,
      `lastUpdateCheck`,
      `plugnplayOverride`,
      `plugnplayShebang`,
      `plugnplayBlacklist`,
      `workspacesExperimental`,
      `workspacesNohoistExperimental`,
      `offlineCacheFolder`,
      `yarnOfflineMirrorPruning`,
      `enableMetaFolder`,
      `yarnEnableLockfileVersions`,
      `yarnLinkFileDependencies`,
      `experimentalPackScriptPackagesInMirror`,
      `unsafeDisableIntegrityMigration`,
      `production`,
      `noProgress`,
      `registry`,
      `versionCommitHooks`,
      `versionGitTag`,
      `versionGitMessage`,
      `versionSignGitTag`,
      `versionTagPrefix`,
      `savePrefix`,
      `saveExact`,
      `initAuthorName`,
      `initAuthorEmail`,
      `initAuthorUrl`,
      `initVersion`,
      `initLicense`,
      `initPrivate`,
      `ignoreScripts`,
      `ignorePlatform`,
      `ignoreEngines`,
      `ignoreOptional`,
      `force`,
      `disableSelfUpdateCheck`,
      `username`,
      `email`,
  ]);
  exports.ENVIRONMENT_PREFIX = `yarn_`;
  exports.DEFAULT_RC_FILENAME = fslib_1.toFilename(`.yarnrc.yml`);
  exports.DEFAULT_LOCK_FILENAME = fslib_1.toFilename(`yarn.lock`);
  var SettingsType;
  (function (SettingsType) {
      SettingsType["BOOLEAN"] = "BOOLEAN";
      SettingsType["ABSOLUTE_PATH"] = "ABSOLUTE_PATH";
      SettingsType["LOCATOR"] = "LOCATOR";
      SettingsType["LOCATOR_LOOSE"] = "LOCATOR_LOOSE";
      SettingsType["STRING"] = "STRING";
      SettingsType["SECRET"] = "SECRET";
      SettingsType["SHAPE"] = "SHAPE";
      SettingsType["MAP"] = "MAP";
  })(SettingsType = exports.SettingsType || (exports.SettingsType = {}));
  ;
  // General rules:
  //
  // - filenames that don't accept actual paths must end with the "Filename" suffix
  //   prefer to use absolute paths instead, since they are automatically resolved
  //   ex: lockfileFilename
  //
  // - folders must end with the "Folder" suffix
  //   ex: cacheFolder, pnpVirtualFolder
  //
  // - actual paths to a file must end with the "Path" suffix
  //   ex: pnpPath
  //
  // - options that tweaks the strictness must begin with the "allow" prefix
  //   ex: allowInvalidChecksums
  //
  // - options that enable a feature must begin with the "enable" prefix
  //   ex: enableEmojis, enableColors
  exports.coreDefinitions = {
      // Not implemented for now, but since it's part of all Yarn installs we want to declare it in order to improve drop-in compatibility
      lastUpdateCheck: {
          description: `Last timestamp we checked whether new Yarn versions were available`,
          type: SettingsType.STRING,
          default: null,
      },
      // Settings related to proxying all Yarn calls to a specific executable
      yarnPath: {
          description: `Path to the local executable that must be used over the global one`,
          type: SettingsType.ABSOLUTE_PATH,
          default: null,
      },
      ignorePath: {
          description: `If true, the local executable will be ignored when using the global one`,
          type: SettingsType.BOOLEAN,
          default: false,
      },
      // Settings related to the package manager internal names
      globalFolder: {
          description: `Folder where are stored the system-wide settings`,
          type: SettingsType.ABSOLUTE_PATH,
          default: folderUtils.getDefaultGlobalFolder(),
      },
      cacheFolder: {
          description: `Folder where the cache files must be written`,
          type: SettingsType.ABSOLUTE_PATH,
          default: `./.yarn/cache`,
      },
      virtualFolder: {
          description: `Folder where the virtual packages (cf doc) will be mapped on the disk`,
          type: SettingsType.ABSOLUTE_PATH,
          default: `./.yarn/virtual`,
      },
      bstatePath: {
          description: `Path of the file where the current state of the built packages must be stored`,
          type: SettingsType.ABSOLUTE_PATH,
          default: `./.yarn/build-state.yml`,
      },
      lockfileFilename: {
          description: `Name of the files where the Yarn dependency tree entries must be stored`,
          type: SettingsType.STRING,
          default: exports.DEFAULT_LOCK_FILENAME,
      },
      rcFilename: {
          description: `Name of the files where the configuration can be found`,
          type: SettingsType.STRING,
          default: getRcFilename(),
      },
      enableGlobalCache: {
          description: `If true, the system-wide cache folder will be used regardless of \`cache-folder\``,
          type: SettingsType.BOOLEAN,
          default: false,
      },
      enableAbsoluteVirtuals: {
          description: `If true, the virtual symlinks will use absolute paths if required [non portable!!]`,
          type: SettingsType.BOOLEAN,
          default: false,
      },
      // Settings related to the output style
      enableColors: {
          description: `If true, the CLI is allowed to use colors in its output`,
          type: SettingsType.BOOLEAN,
          default: !!supports_color_1.default.stdout,
          defaultText: `<dynamic>`,
      },
      enableInlineBuilds: {
          description: `If true, the CLI will print the build output on the command line`,
          type: SettingsType.BOOLEAN,
          default: false,
      },
      enableTimers: {
          description: `If true, the CLI is allowed to print the time spent executing commands`,
          type: SettingsType.BOOLEAN,
          default: true,
      },
      preferInteractive: {
          description: `If true, the CLI will automatically use the interactive mode when called from a TTY`,
          type: SettingsType.BOOLEAN,
          default: false,
      },
      // Settings related to how packages are interpreted by default
      defaultLanguageName: {
          description: `Default language mode that should be used when a package doesn't offer any insight`,
          type: SettingsType.STRING,
          default: `node`,
      },
      defaultProtocol: {
          description: `Default resolution protocol used when resolving pure semver and tag ranges`,
          type: SettingsType.STRING,
          default: `npm:`,
      },
      // Settings related to network access
      enableNetwork: {
          description: `If false, the package manager will refuse to use the network if required to`,
          type: SettingsType.BOOLEAN,
          default: true,
      },
      httpProxy: {
          description: `URL of the http proxy that must be used for outgoing http requests`,
          type: SettingsType.STRING,
          default: null,
      },
      httpsProxy: {
          description: `URL of the http proxy that must be used for outgoing https requests`,
          type: SettingsType.STRING,
          default: null,
      },
      unsafeHttpWhitelist: {
          description: `List of the hostnames for which http queries are allowed (glob patterns are supported)`,
          type: SettingsType.STRING,
          default: [],
          isArray: true,
      },
      // Settings related to security
      enableScripts: {
          description: `If true, packages are allowed to have install scripts by default`,
          type: SettingsType.BOOLEAN,
          default: true,
      },
      enableImmutableCache: {
          description: `If true, the cache is reputed immutable and actions that would modify it will throw`,
          type: SettingsType.BOOLEAN,
          default: false,
      },
      checksumBehavior: {
          description: `Enumeration defining what to do when a checksum doesn't match expectations`,
          type: SettingsType.STRING,
          default: `throw`,
      },
  };
  function parseBoolean(value) {
      switch (value) {
          case `true`:
          case `1`:
          case 1:
          case true:
              {
                  return true;
              }
              break;
          case `false`:
          case `0`:
          case 0:
          case false:
              {
                  return false;
              }
              break;
          default:
              {
                  throw new Error(`Couldn't parse "${value}" as a boolean`);
              }
              break;
      }
  }
  function parseValue(configuration, path, value, definition, folder) {
      if (definition.isArray) {
          if (!Array.isArray(value)) {
              return [parseSingleValue(configuration, path, value, definition, folder)];
          }
          else {
              return value.map((sub, i) => parseSingleValue(configuration, `${path}[${i}]`, sub, definition, folder));
          }
      }
      else {
          if (Array.isArray(value)) {
              throw new Error(`Non-array configuration settings "${path}" cannot be an array`);
          }
          else {
              return parseSingleValue(configuration, path, value, definition, folder);
          }
      }
  }
  function parseSingleValue(configuration, path, value, definition, folder) {
      switch (definition.type) {
          case SettingsType.SHAPE:
              return parseShape(configuration, path, value, definition, folder);
          case SettingsType.MAP:
              return parseMap(configuration, path, value, definition, folder);
      }
      if (value === null && !definition.isNullable && definition.default !== null)
          throw new Error(`Non-nullable configuration settings "${path}" cannot be set to null`);
      if (definition.type === SettingsType.BOOLEAN)
          return parseBoolean(value);
      if (typeof value !== `string`)
          throw new Error(`Expected value to be a string`);
      switch (definition.type) {
          case SettingsType.ABSOLUTE_PATH:
              return fslib_1.ppath.resolve(folder, fslib_1.NodeFS.toPortablePath(value));
          case SettingsType.LOCATOR_LOOSE:
              return structUtils.parseLocator(value, false);
          case SettingsType.LOCATOR:
              return structUtils.parseLocator(value);
          default:
              return value;
      }
  }
  function parseShape(configuration, path, value, definition, folder) {
      if (typeof value !== `object` || Array.isArray(value))
          throw new clipanion_1.UsageError(`Object configuration settings "${path}" must be an object`);
      const result = getDefaultValue(configuration, definition);
      if (value === null)
          return result;
      for (const [propKey, propValue] of Object.entries(value)) {
          const subPath = `${path}.${propKey}`;
          const subDefinition = definition.properties[propKey];
          if (!subDefinition)
              throw new clipanion_1.UsageError(`Unrecognized configuration settings found: ${path}.${propKey} - run "yarn config -v" to see the list of settings supported in Yarn`);
          result.set(propKey, parseValue(configuration, subPath, propValue, definition.properties[propKey], folder));
      }
      return result;
  }
  function parseMap(configuration, path, value, definition, folder) {
      const result = new Map();
      if (typeof value !== 'object' || Array.isArray(value))
          throw new clipanion_1.UsageError(`Map configuration settings "${path}" must be an object`);
      if (value === null)
          return result;
      for (const [propKey, propValue] of Object.entries(value)) {
          const subPath = `${path}['${propKey}']`;
          result.set(propKey, parseValue(configuration, subPath, propValue, definition.valueDefinition, folder));
      }
      return result;
  }
  function getDefaultValue(configuration, definition) {
      switch (definition.type) {
          case SettingsType.SHAPE: {
              const result = new Map();
              for (const [propKey, propDefinition] of Object.entries(definition.properties))
                  result.set(propKey, getDefaultValue(configuration, propDefinition));
              return result;
          }
          case SettingsType.MAP:
              return new Map();
          case SettingsType.ABSOLUTE_PATH: {
              if (definition.default === null)
                  return null;
              if (configuration.projectCwd === null) {
                  if (fslib_1.ppath.isAbsolute(definition.default)) {
                      return fslib_1.ppath.normalize(definition.default);
                  }
                  else if (definition.isNullable || definition.default === null) {
                      return null;
                  }
              }
              else {
                  if (Array.isArray(definition.default)) {
                      return definition.default.map((entry) => fslib_1.ppath.resolve(configuration.projectCwd, entry));
                  }
                  else {
                      return fslib_1.ppath.resolve(configuration.projectCwd, definition.default);
                  }
              }
          }
          default:
              return definition.default;
      }
  }
  function getEnvironmentSettings() {
      const environmentSettings = {};
      for (let [key, value] of Object.entries(process.env)) {
          key = key.toLowerCase();
          if (!key.startsWith(exports.ENVIRONMENT_PREFIX))
              continue;
          key = camelcase_1.default(key.slice(exports.ENVIRONMENT_PREFIX.length));
          environmentSettings[key] = value;
      }
      return environmentSettings;
  }
  function getRcFilename() {
      const rcKey = `${exports.ENVIRONMENT_PREFIX}rc_filename`;
      for (const [key, value] of Object.entries(process.env))
          if (key.toLowerCase() === rcKey)
              return value;
      return exports.DEFAULT_RC_FILENAME;
  }
  class Configuration {
      constructor(startingCwd, projectCwd, plugins) {
          this.plugins = new Map();
          this.settings = new Map();
          this.values = new Map();
          this.sources = new Map();
          this.invalid = new Map();
          this.startingCwd = startingCwd;
          this.projectCwd = projectCwd;
          this.plugins = plugins;
          const importSettings = (definitions) => {
              for (const [name, definition] of Object.entries(definitions)) {
                  if (this.settings.has(name))
                      throw new Error(`Cannot redefine settings "${name}"`);
                  else if (name in this)
                      throw new Error(`Settings named "${name}" conflicts with an actual property`);
                  this.settings.set(name, definition);
                  this.values.set(name, getDefaultValue(this, definition));
              }
          };
          importSettings(exports.coreDefinitions);
          for (const plugin of this.plugins.values()) {
              if (plugin.configuration) {
                  importSettings(plugin.configuration);
              }
          }
      }
      /**
       * Instantiate a new configuration object exposing the configuration obtained
       * from reading the various rc files and the environment settings.
       *
       * The `pluginConfiguration` parameter is expected to indicate:
       *
       * 1. which modules should be made available to plugins when they require a
       *    package (this is the dynamic linking part - for example we want all the
       *    plugins to use the exact same version of @yarnpkg/core, which also is the
       *    version used by the running Yarn instance).
       *
       * 2. which of those modules are actually plugins that need to be injected
       *    within the configuration.
       *
       * Note that some extra plugins will be automatically added based on the
       * content of the rc files - with the rc plugins taking precedence over
       * the other ones.
       *
       * One particularity: the plugin initialization order is quite strict, with
       * plugins listed in /foo/bar/.yarnrc.yml taking precedence over plugins
       * listed in /foo/.yarnrc.yml and /.yarnrc.yml. Additionally, while plugins
       * can depend on one another, they can only depend on plugins that have been
       * instantiated before them (so a plugin listed in /foo/.yarnrc.yml can
       * depend on another one listed on /foo/bar/.yarnrc.yml, but not the other
       * way around).
       */
      static async find(startingCwd, pluginConfiguration, { strict = true, useRc = true } = {}) {
          const environmentSettings = getEnvironmentSettings();
          delete environmentSettings.rcFilename;
          const rcFiles = await Configuration.findRcFiles(startingCwd);
          const plugins = new Map();
          if (pluginConfiguration !== null) {
              for (const request of pluginConfiguration.plugins.keys())
                  plugins.set(request, pluginConfiguration.modules.get(request).default);
              const requireEntries = new Map();
              for (const request of nodeUtils.builtinModules())
                  requireEntries.set(request, () => nodeUtils.dynamicRequire(request));
              for (const [request, embedModule] of pluginConfiguration.modules)
                  requireEntries.set(request, () => embedModule);
              const dynamicPlugins = new Set();
              for (const { path, cwd, data } of rcFiles) {
                  if (!useRc)
                      continue;
                  if (!Array.isArray(data.plugins))
                      continue;
                  for (const userProvidedPath of data.plugins) {
                      const pluginPath = fslib_1.ppath.resolve(cwd, fslib_1.NodeFS.toPortablePath(userProvidedPath));
                      const { factory, name } = nodeUtils.dynamicRequire(fslib_1.NodeFS.fromPortablePath(pluginPath));
                      // Prevent plugin redefinition so that the ones declared deeper in the
                      // filesystem always have precedence over the ones below.
                      if (dynamicPlugins.has(name))
                          continue;
                      const pluginRequireEntries = new Map(requireEntries);
                      const pluginRequire = (request) => {
                          if (pluginRequireEntries.has(request)) {
                              return pluginRequireEntries.get(request)();
                          }
                          else {
                              throw new clipanion_1.UsageError(`This plugin cannot access the package referenced via ${request} which is neither a builtin, nor an exposed entry`);
                          }
                      };
                      const plugin = miscUtils.prettifySyncErrors(() => {
                          return factory(pluginRequire).default;
                      }, message => {
                          return `${message} (when initializing ${name}, defined in ${path})`;
                      });
                      requireEntries.set(name, () => plugin);
                      dynamicPlugins.add(name);
                      plugins.set(name, plugin);
                  }
              }
          }
          let lockfileFilename = exports.DEFAULT_LOCK_FILENAME;
          // We need to know the project root before being able to truly instantiate
          // our configuration, and to know that we need to know the lockfile name
          if (environmentSettings.lockfileFilename) {
              lockfileFilename = environmentSettings.lockfileFilename;
          }
          else {
              for (const { data } of rcFiles) {
                  if (data.lockfileFilename) {
                      lockfileFilename = data.lockfileFilename;
                      break;
                  }
              }
          }
          const projectCwd = await Configuration.findProjectCwd(startingCwd, lockfileFilename);
          const configuration = new Configuration(startingCwd, projectCwd, plugins);
          configuration.useWithSource(`<environment>`, environmentSettings, startingCwd, { strict });
          for (const { path, cwd, data } of rcFiles)
              configuration.useWithSource(path, data, cwd, { strict });
          const rcFilename = configuration.get(`rcFilename`);
          const homeRcFile = await Configuration.findHomeRcFile(rcFilename);
          if (homeRcFile)
              configuration.useWithSource(homeRcFile.path, homeRcFile.data, homeRcFile.cwd, { strict });
          if (configuration.get(`enableGlobalCache`)) {
              configuration.values.set(`cacheFolder`, `${configuration.get(`globalFolder`)}/cache`);
              configuration.sources.set(`cacheFolder`, `<internal>`);
          }
          return configuration;
      }
      static async findRcFiles(startingCwd) {
          const rcFilename = getRcFilename();
          const rcFiles = [];
          let nextCwd = startingCwd;
          let currentCwd = null;
          while (nextCwd !== currentCwd) {
              currentCwd = nextCwd;
              const rcPath = fslib_1.ppath.join(currentCwd, rcFilename);
              if (fslib_1.xfs.existsSync(rcPath)) {
                  const content = await fslib_1.xfs.readFilePromise(rcPath, `utf8`);
                  let data;
                  try {
                      data = parsers_1.parseSyml(content);
                  }
                  catch (error) {
                      let tip = ``;
                      if (content.match(/^\s+(?!-)[^:]+\s+\S+/m))
                          tip = ` (in particular, make sure you list the colons after each key name)`;
                      throw new clipanion_1.UsageError(`Parse error when loading ${rcPath}; please check it's proper Yaml${tip}`);
                  }
                  rcFiles.push({ path: rcPath, cwd: currentCwd, data });
              }
              nextCwd = fslib_1.ppath.dirname(currentCwd);
          }
          return rcFiles;
      }
      static async findHomeRcFile(rcFilename) {
          const homeFolder = folderUtils.getHomeFolder();
          const homeRcFilePath = fslib_1.ppath.join(homeFolder, rcFilename);
          if (fslib_1.xfs.existsSync(homeRcFilePath)) {
              const content = await fslib_1.xfs.readFilePromise(homeRcFilePath, `utf8`);
              const data = parsers_1.parseSyml(content);
              return { path: homeRcFilePath, cwd: homeFolder, data };
          }
          return null;
      }
      static async findProjectCwd(startingCwd, lockfileFilename) {
          let projectCwd = null;
          let nextCwd = startingCwd;
          let currentCwd = null;
          while (nextCwd !== currentCwd) {
              currentCwd = nextCwd;
              if (fslib_1.xfs.existsSync(fslib_1.ppath.join(currentCwd, fslib_1.toFilename(`package.json`))))
                  projectCwd = currentCwd;
              if (fslib_1.xfs.existsSync(fslib_1.ppath.join(currentCwd, lockfileFilename)))
                  break;
              nextCwd = fslib_1.ppath.dirname(currentCwd);
          }
          return projectCwd;
      }
      static async updateConfiguration(cwd, patch) {
          const rcFilename = getRcFilename();
          const configurationPath = fslib_1.ppath.join(cwd, rcFilename);
          const current = fslib_1.xfs.existsSync(configurationPath)
              ? parsers_1.parseSyml(await fslib_1.xfs.readFilePromise(configurationPath, `utf8`))
              : {};
          let patched = false;
          if (typeof patch === `function`)
              patch = patch(current);
          for (const key of Object.keys(patch)) {
              const currentValue = current[key];
              const nextValue = typeof patch[key] === `function`
                  ? patch[key](currentValue)
                  : patch[key];
              if (currentValue === nextValue)
                  continue;
              current[key] = nextValue;
              patched = true;
          }
          if (!patched)
              return;
          await fslib_1.xfs.changeFilePromise(configurationPath, parsers_1.stringifySyml(current));
      }
      static async updateHomeConfiguration(patch) {
          const homeFolder = folderUtils.getHomeFolder();
          return await Configuration.updateConfiguration(homeFolder, patch);
      }
      extend(data) {
          const newConfiguration = Object.create(Configuration.prototype);
          newConfiguration.startingCwd = this.startingCwd;
          newConfiguration.projectCwd = this.projectCwd;
          newConfiguration.plugins = new Map(this.plugins);
          newConfiguration.settings = new Map(this.settings);
          newConfiguration.values = new Map(this.values);
          newConfiguration.sources = new Map(this.sources);
          newConfiguration.invalid = new Map(this.invalid);
          newConfiguration.useWithSource(`<internal override>`, data, this.startingCwd, { override: true });
          return newConfiguration;
      }
      useWithSource(source, data, folder, { strict = true, overwrite = false }) {
          try {
              this.use(source, data, folder, { strict, overwrite });
          }
          catch (error) {
              error.message += ` (in ${source})`;
              throw error;
          }
      }
      use(source, data, folder, { strict = true, overwrite = false }) {
          for (const key of Object.keys(data)) {
              // The plugins have already been loaded at this point
              if (key === `plugins`)
                  continue;
              // Some environment variables should be ignored when applying the configuration
              if (source === `<environment>` && IGNORED_ENV_VARIABLES.has(key))
                  continue;
              // It wouldn't make much sense, would it?
              if (key === `rcFilename`)
                  throw new clipanion_1.UsageError(`The rcFilename settings can only be set via ${`${exports.ENVIRONMENT_PREFIX}RC_FILENAME`.toUpperCase()}, not via a rc file`);
              const definition = this.settings.get(key);
              if (!definition) {
                  if (strict) {
                      throw new clipanion_1.UsageError(`${LEGACY_NAMES.has(key) ? `Legacy` : `Unrecognized`} configuration settings found: ${key} - run "yarn config -v" to see the list of settings supported in Yarn`);
                  }
                  else {
                      this.invalid.set(key, source);
                      continue;
                  }
              }
              if (this.sources.has(key) && !overwrite)
                  continue;
              this.values.set(key, parseValue(this, key, data[key], definition, folder));
              this.sources.set(key, source);
          }
      }
      get(key) {
          if (!this.values.has(key))
              throw new Error(`Invalid configuration key "${key}"`);
          return this.values.get(key);
      }
      makeResolver() {
          const pluginResolvers = [];
          for (const plugin of this.plugins.values())
              for (const resolver of plugin.resolvers || [])
                  pluginResolvers.push(new resolver());
          return new MultiResolver_1.MultiResolver([
              new VirtualResolver_1.VirtualResolver(),
              new WorkspaceResolver_1.WorkspaceResolver(),
              new SemverResolver_1.SemverResolver(),
              new TagResolver_1.TagResolver(),
              ...pluginResolvers,
          ]);
      }
      makeFetcher() {
          const pluginFetchers = [];
          for (const plugin of this.plugins.values())
              for (const fetcher of plugin.fetchers || [])
                  pluginFetchers.push(new fetcher());
          return new MultiFetcher_1.MultiFetcher([
              new VirtualFetcher_1.VirtualFetcher(),
              new WorkspaceFetcher_1.WorkspaceFetcher(),
              ...pluginFetchers,
          ]);
      }
      getLinkers() {
          const linkers = [];
          for (const plugin of this.plugins.values())
              for (const linker of plugin.linkers || [])
                  linkers.push(new linker());
          return linkers;
      }
      async triggerHook(get, ...args) {
          for (const plugin of this.plugins.values()) {
              const hooks = plugin.hooks;
              if (!hooks)
                  continue;
              const hook = get(hooks);
              if (!hook)
                  continue;
              await hook(...args);
          }
      }
      async triggerMultipleHooks(get, argsList) {
          for (const args of argsList) {
              await this.triggerHook(get, ...args);
          }
      }
      async reduceHook(get, initialValue, ...args) {
          let value = initialValue;
          for (const plugin of this.plugins.values()) {
              const hooks = plugin.hooks;
              if (!hooks)
                  continue;
              const hook = get(hooks);
              if (!hook)
                  continue;
              value = await hook(value, ...args);
          }
          return value;
      }
      format(text, color) {
          if (this.get(`enableColors`)) {
              if (color.charAt(0) === `#`) {
                  return ctx.hex(color)(text);
              }
              else {
                  return ctx[color](text);
              }
          }
          else {
              return text;
          }
      }
  }
  exports.Configuration = Configuration;


  /***/ }),
  /* 212 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const preserveCamelCase = string => {
  	let isLastCharLower = false;
  	let isLastCharUpper = false;
  	let isLastLastCharUpper = false;

  	for (let i = 0; i < string.length; i++) {
  		const character = string[i];

  		if (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {
  			string = string.slice(0, i) + '-' + string.slice(i);
  			isLastCharLower = false;
  			isLastLastCharUpper = isLastCharUpper;
  			isLastCharUpper = true;
  			i++;
  		} else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {
  			string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
  			isLastLastCharUpper = isLastCharUpper;
  			isLastCharUpper = false;
  			isLastCharLower = true;
  		} else {
  			isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
  			isLastLastCharUpper = isLastCharUpper;
  			isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
  		}
  	}

  	return string;
  };

  const camelCase = (input, options) => {
  	if (!(typeof input === 'string' || Array.isArray(input))) {
  		throw new TypeError('Expected the input to be `string | string[]`');
  	}

  	options = Object.assign({
  		pascalCase: false
  	}, options);

  	const postProcess = x => options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;

  	if (Array.isArray(input)) {
  		input = input.map(x => x.trim())
  			.filter(x => x.length)
  			.join('-');
  	} else {
  		input = input.trim();
  	}

  	if (input.length === 0) {
  		return '';
  	}

  	if (input.length === 1) {
  		return options.pascalCase ? input.toUpperCase() : input.toLowerCase();
  	}

  	const hasUpperCase = input !== input.toLowerCase();

  	if (hasUpperCase) {
  		input = preserveCamelCase(input);
  	}

  	input = input
  		.replace(/^[_.\- ]+/, '')
  		.toLowerCase()
  		.replace(/[_.\- ]+(\w|$)/g, (_, p1) => p1.toUpperCase())
  		.replace(/\d+(\w|$)/g, m => m.toUpperCase());

  	return postProcess(input);
  };

  module.exports = camelCase;
  // TODO: Remove this for the next major release
  module.exports.default = camelCase;


  /***/ }),
  /* 213 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const escapeStringRegexp = __webpack_require__(214);
  const ansiStyles = __webpack_require__(215);
  const stdoutColor = __webpack_require__(221).stdout;

  const template = __webpack_require__(223);

  const isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm');

  // `supportsColor.level` → `ansiStyles.color[name]` mapping
  const levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];

  // `color-convert` models to exclude from the Chalk API due to conflicts and such
  const skipModels = new Set(['gray']);

  const styles = Object.create(null);

  function applyOptions(obj, options) {
  	options = options || {};

  	// Detect level if not set manually
  	const scLevel = stdoutColor ? stdoutColor.level : 0;
  	obj.level = options.level === undefined ? scLevel : options.level;
  	obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;
  }

  function Chalk(options) {
  	// We check for this.template here since calling `chalk.constructor()`
  	// by itself will have a `this` of a previously constructed chalk object
  	if (!this || !(this instanceof Chalk) || this.template) {
  		const chalk = {};
  		applyOptions(chalk, options);

  		chalk.template = function () {
  			const args = [].slice.call(arguments);
  			return chalkTag.apply(null, [chalk.template].concat(args));
  		};

  		Object.setPrototypeOf(chalk, Chalk.prototype);
  		Object.setPrototypeOf(chalk.template, chalk);

  		chalk.template.constructor = Chalk;

  		return chalk.template;
  	}

  	applyOptions(this, options);
  }

  // Use bright blue on Windows as the normal blue color is illegible
  if (isSimpleWindowsTerm) {
  	ansiStyles.blue.open = '\u001B[94m';
  }

  for (const key of Object.keys(ansiStyles)) {
  	ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

  	styles[key] = {
  		get() {
  			const codes = ansiStyles[key];
  			return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
  		}
  	};
  }

  styles.visible = {
  	get() {
  		return build.call(this, this._styles || [], true, 'visible');
  	}
  };

  ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');
  for (const model of Object.keys(ansiStyles.color.ansi)) {
  	if (skipModels.has(model)) {
  		continue;
  	}

  	styles[model] = {
  		get() {
  			const level = this.level;
  			return function () {
  				const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
  				const codes = {
  					open,
  					close: ansiStyles.color.close,
  					closeRe: ansiStyles.color.closeRe
  				};
  				return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
  			};
  		}
  	};
  }

  ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');
  for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
  	if (skipModels.has(model)) {
  		continue;
  	}

  	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
  	styles[bgModel] = {
  		get() {
  			const level = this.level;
  			return function () {
  				const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
  				const codes = {
  					open,
  					close: ansiStyles.bgColor.close,
  					closeRe: ansiStyles.bgColor.closeRe
  				};
  				return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
  			};
  		}
  	};
  }

  const proto = Object.defineProperties(() => {}, styles);

  function build(_styles, _empty, key) {
  	const builder = function () {
  		return applyStyle.apply(builder, arguments);
  	};

  	builder._styles = _styles;
  	builder._empty = _empty;

  	const self = this;

  	Object.defineProperty(builder, 'level', {
  		enumerable: true,
  		get() {
  			return self.level;
  		},
  		set(level) {
  			self.level = level;
  		}
  	});

  	Object.defineProperty(builder, 'enabled', {
  		enumerable: true,
  		get() {
  			return self.enabled;
  		},
  		set(enabled) {
  			self.enabled = enabled;
  		}
  	});

  	// See below for fix regarding invisible grey/dim combination on Windows
  	builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey';

  	// `__proto__` is used because we must return a function, but there is
  	// no way to create a function with a different prototype
  	builder.__proto__ = proto; // eslint-disable-line no-proto

  	return builder;
  }

  function applyStyle() {
  	// Support varags, but simply cast to string in case there's only one arg
  	const args = arguments;
  	const argsLen = args.length;
  	let str = String(arguments[0]);

  	if (argsLen === 0) {
  		return '';
  	}

  	if (argsLen > 1) {
  		// Don't slice `arguments`, it prevents V8 optimizations
  		for (let a = 1; a < argsLen; a++) {
  			str += ' ' + args[a];
  		}
  	}

  	if (!this.enabled || this.level <= 0 || !str) {
  		return this._empty ? '' : str;
  	}

  	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
  	// see https://github.com/chalk/chalk/issues/58
  	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
  	const originalDim = ansiStyles.dim.open;
  	if (isSimpleWindowsTerm && this.hasGrey) {
  		ansiStyles.dim.open = '';
  	}

  	for (const code of this._styles.slice().reverse()) {
  		// Replace any instances already present with a re-opening code
  		// otherwise only the part of the string until said closing code
  		// will be colored, and the rest will simply be 'plain'.
  		str = code.open + str.replace(code.closeRe, code.open) + code.close;

  		// Close the styling before a linebreak and reopen
  		// after next line to fix a bleed issue on macOS
  		// https://github.com/chalk/chalk/pull/92
  		str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
  	}

  	// Reset the original `dim` if we changed it to work around the Windows dimmed gray issue
  	ansiStyles.dim.open = originalDim;

  	return str;
  }

  function chalkTag(chalk, strings) {
  	if (!Array.isArray(strings)) {
  		// If chalk() was called by itself or with a string,
  		// return the string itself as a string.
  		return [].slice.call(arguments, 1).join(' ');
  	}

  	const args = [].slice.call(arguments, 2);
  	const parts = [strings.raw[0]];

  	for (let i = 1; i < strings.length; i++) {
  		parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'));
  		parts.push(String(strings.raw[i]));
  	}

  	return template(chalk, parts.join(''));
  }

  Object.defineProperties(Chalk.prototype, styles);

  module.exports = Chalk(); // eslint-disable-line new-cap
  module.exports.supportsColor = stdoutColor;
  module.exports.default = module.exports; // For TypeScript


  /***/ }),
  /* 214 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

  module.exports = function (str) {
  	if (typeof str !== 'string') {
  		throw new TypeError('Expected a string');
  	}

  	return str.replace(matchOperatorsRe, '\\$&');
  };


  /***/ }),
  /* 215 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /* WEBPACK VAR INJECTION */(function(module) {
  const colorConvert = __webpack_require__(217);

  const wrapAnsi16 = (fn, offset) => function () {
  	const code = fn.apply(colorConvert, arguments);
  	return `\u001B[${code + offset}m`;
  };

  const wrapAnsi256 = (fn, offset) => function () {
  	const code = fn.apply(colorConvert, arguments);
  	return `\u001B[${38 + offset};5;${code}m`;
  };

  const wrapAnsi16m = (fn, offset) => function () {
  	const rgb = fn.apply(colorConvert, arguments);
  	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };

  function assembleStyles() {
  	const codes = new Map();
  	const styles = {
  		modifier: {
  			reset: [0, 0],
  			// 21 isn't widely supported and 22 does the same thing
  			bold: [1, 22],
  			dim: [2, 22],
  			italic: [3, 23],
  			underline: [4, 24],
  			inverse: [7, 27],
  			hidden: [8, 28],
  			strikethrough: [9, 29]
  		},
  		color: {
  			black: [30, 39],
  			red: [31, 39],
  			green: [32, 39],
  			yellow: [33, 39],
  			blue: [34, 39],
  			magenta: [35, 39],
  			cyan: [36, 39],
  			white: [37, 39],
  			gray: [90, 39],

  			// Bright color
  			redBright: [91, 39],
  			greenBright: [92, 39],
  			yellowBright: [93, 39],
  			blueBright: [94, 39],
  			magentaBright: [95, 39],
  			cyanBright: [96, 39],
  			whiteBright: [97, 39]
  		},
  		bgColor: {
  			bgBlack: [40, 49],
  			bgRed: [41, 49],
  			bgGreen: [42, 49],
  			bgYellow: [43, 49],
  			bgBlue: [44, 49],
  			bgMagenta: [45, 49],
  			bgCyan: [46, 49],
  			bgWhite: [47, 49],

  			// Bright color
  			bgBlackBright: [100, 49],
  			bgRedBright: [101, 49],
  			bgGreenBright: [102, 49],
  			bgYellowBright: [103, 49],
  			bgBlueBright: [104, 49],
  			bgMagentaBright: [105, 49],
  			bgCyanBright: [106, 49],
  			bgWhiteBright: [107, 49]
  		}
  	};

  	// Fix humans
  	styles.color.grey = styles.color.gray;

  	for (const groupName of Object.keys(styles)) {
  		const group = styles[groupName];

  		for (const styleName of Object.keys(group)) {
  			const style = group[styleName];

  			styles[styleName] = {
  				open: `\u001B[${style[0]}m`,
  				close: `\u001B[${style[1]}m`
  			};

  			group[styleName] = styles[styleName];

  			codes.set(style[0], style[1]);
  		}

  		Object.defineProperty(styles, groupName, {
  			value: group,
  			enumerable: false
  		});

  		Object.defineProperty(styles, 'codes', {
  			value: codes,
  			enumerable: false
  		});
  	}

  	const ansi2ansi = n => n;
  	const rgb2rgb = (r, g, b) => [r, g, b];

  	styles.color.close = '\u001B[39m';
  	styles.bgColor.close = '\u001B[49m';

  	styles.color.ansi = {
  		ansi: wrapAnsi16(ansi2ansi, 0)
  	};
  	styles.color.ansi256 = {
  		ansi256: wrapAnsi256(ansi2ansi, 0)
  	};
  	styles.color.ansi16m = {
  		rgb: wrapAnsi16m(rgb2rgb, 0)
  	};

  	styles.bgColor.ansi = {
  		ansi: wrapAnsi16(ansi2ansi, 10)
  	};
  	styles.bgColor.ansi256 = {
  		ansi256: wrapAnsi256(ansi2ansi, 10)
  	};
  	styles.bgColor.ansi16m = {
  		rgb: wrapAnsi16m(rgb2rgb, 10)
  	};

  	for (let key of Object.keys(colorConvert)) {
  		if (typeof colorConvert[key] !== 'object') {
  			continue;
  		}

  		const suite = colorConvert[key];

  		if (key === 'ansi16') {
  			key = 'ansi';
  		}

  		if ('ansi16' in suite) {
  			styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
  			styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
  		}

  		if ('ansi256' in suite) {
  			styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
  			styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
  		}

  		if ('rgb' in suite) {
  			styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
  			styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
  		}
  	}

  	return styles;
  }

  // Make the export immutable
  Object.defineProperty(module, 'exports', {
  	enumerable: true,
  	get: assembleStyles
  });

  /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(216)(module)))

  /***/ }),
  /* 216 */
  /***/ (function(module, exports) {

  module.exports = function(module) {
  	if (!module.webpackPolyfill) {
  		module.deprecate = function() {};
  		module.paths = [];
  		// module.parent = undefined by default
  		if (!module.children) module.children = [];
  		Object.defineProperty(module, "loaded", {
  			enumerable: true,
  			get: function() {
  				return module.l;
  			}
  		});
  		Object.defineProperty(module, "id", {
  			enumerable: true,
  			get: function() {
  				return module.i;
  			}
  		});
  		module.webpackPolyfill = 1;
  	}
  	return module;
  };


  /***/ }),
  /* 217 */
  /***/ (function(module, exports, __webpack_require__) {

  var conversions = __webpack_require__(218);
  var route = __webpack_require__(220);

  var convert = {};

  var models = Object.keys(conversions);

  function wrapRaw(fn) {
  	var wrappedFn = function (args) {
  		if (args === undefined || args === null) {
  			return args;
  		}

  		if (arguments.length > 1) {
  			args = Array.prototype.slice.call(arguments);
  		}

  		return fn(args);
  	};

  	// preserve .conversion property if there is one
  	if ('conversion' in fn) {
  		wrappedFn.conversion = fn.conversion;
  	}

  	return wrappedFn;
  }

  function wrapRounded(fn) {
  	var wrappedFn = function (args) {
  		if (args === undefined || args === null) {
  			return args;
  		}

  		if (arguments.length > 1) {
  			args = Array.prototype.slice.call(arguments);
  		}

  		var result = fn(args);

  		// we're assuming the result is an array here.
  		// see notice in conversions.js; don't use box types
  		// in conversion functions.
  		if (typeof result === 'object') {
  			for (var len = result.length, i = 0; i < len; i++) {
  				result[i] = Math.round(result[i]);
  			}
  		}

  		return result;
  	};

  	// preserve .conversion property if there is one
  	if ('conversion' in fn) {
  		wrappedFn.conversion = fn.conversion;
  	}

  	return wrappedFn;
  }

  models.forEach(function (fromModel) {
  	convert[fromModel] = {};

  	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
  	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

  	var routes = route(fromModel);
  	var routeModels = Object.keys(routes);

  	routeModels.forEach(function (toModel) {
  		var fn = routes[toModel];

  		convert[fromModel][toModel] = wrapRounded(fn);
  		convert[fromModel][toModel].raw = wrapRaw(fn);
  	});
  });

  module.exports = convert;


  /***/ }),
  /* 218 */
  /***/ (function(module, exports, __webpack_require__) {

  /* MIT license */
  var cssKeywords = __webpack_require__(219);

  // NOTE: conversions should only return primitive values (i.e. arrays, or
  //       values that give correct `typeof` results).
  //       do not use box values types (i.e. Number(), String(), etc.)

  var reverseKeywords = {};
  for (var key in cssKeywords) {
  	if (cssKeywords.hasOwnProperty(key)) {
  		reverseKeywords[cssKeywords[key]] = key;
  	}
  }

  var convert = module.exports = {
  	rgb: {channels: 3, labels: 'rgb'},
  	hsl: {channels: 3, labels: 'hsl'},
  	hsv: {channels: 3, labels: 'hsv'},
  	hwb: {channels: 3, labels: 'hwb'},
  	cmyk: {channels: 4, labels: 'cmyk'},
  	xyz: {channels: 3, labels: 'xyz'},
  	lab: {channels: 3, labels: 'lab'},
  	lch: {channels: 3, labels: 'lch'},
  	hex: {channels: 1, labels: ['hex']},
  	keyword: {channels: 1, labels: ['keyword']},
  	ansi16: {channels: 1, labels: ['ansi16']},
  	ansi256: {channels: 1, labels: ['ansi256']},
  	hcg: {channels: 3, labels: ['h', 'c', 'g']},
  	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
  	gray: {channels: 1, labels: ['gray']}
  };

  // hide .channels and .labels properties
  for (var model in convert) {
  	if (convert.hasOwnProperty(model)) {
  		if (!('channels' in convert[model])) {
  			throw new Error('missing channels property: ' + model);
  		}

  		if (!('labels' in convert[model])) {
  			throw new Error('missing channel labels property: ' + model);
  		}

  		if (convert[model].labels.length !== convert[model].channels) {
  			throw new Error('channel and label counts mismatch: ' + model);
  		}

  		var channels = convert[model].channels;
  		var labels = convert[model].labels;
  		delete convert[model].channels;
  		delete convert[model].labels;
  		Object.defineProperty(convert[model], 'channels', {value: channels});
  		Object.defineProperty(convert[model], 'labels', {value: labels});
  	}
  }

  convert.rgb.hsl = function (rgb) {
  	var r = rgb[0] / 255;
  	var g = rgb[1] / 255;
  	var b = rgb[2] / 255;
  	var min = Math.min(r, g, b);
  	var max = Math.max(r, g, b);
  	var delta = max - min;
  	var h;
  	var s;
  	var l;

  	if (max === min) {
  		h = 0;
  	} else if (r === max) {
  		h = (g - b) / delta;
  	} else if (g === max) {
  		h = 2 + (b - r) / delta;
  	} else if (b === max) {
  		h = 4 + (r - g) / delta;
  	}

  	h = Math.min(h * 60, 360);

  	if (h < 0) {
  		h += 360;
  	}

  	l = (min + max) / 2;

  	if (max === min) {
  		s = 0;
  	} else if (l <= 0.5) {
  		s = delta / (max + min);
  	} else {
  		s = delta / (2 - max - min);
  	}

  	return [h, s * 100, l * 100];
  };

  convert.rgb.hsv = function (rgb) {
  	var rdif;
  	var gdif;
  	var bdif;
  	var h;
  	var s;

  	var r = rgb[0] / 255;
  	var g = rgb[1] / 255;
  	var b = rgb[2] / 255;
  	var v = Math.max(r, g, b);
  	var diff = v - Math.min(r, g, b);
  	var diffc = function (c) {
  		return (v - c) / 6 / diff + 1 / 2;
  	};

  	if (diff === 0) {
  		h = s = 0;
  	} else {
  		s = diff / v;
  		rdif = diffc(r);
  		gdif = diffc(g);
  		bdif = diffc(b);

  		if (r === v) {
  			h = bdif - gdif;
  		} else if (g === v) {
  			h = (1 / 3) + rdif - bdif;
  		} else if (b === v) {
  			h = (2 / 3) + gdif - rdif;
  		}
  		if (h < 0) {
  			h += 1;
  		} else if (h > 1) {
  			h -= 1;
  		}
  	}

  	return [
  		h * 360,
  		s * 100,
  		v * 100
  	];
  };

  convert.rgb.hwb = function (rgb) {
  	var r = rgb[0];
  	var g = rgb[1];
  	var b = rgb[2];
  	var h = convert.rgb.hsl(rgb)[0];
  	var w = 1 / 255 * Math.min(r, Math.min(g, b));

  	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

  	return [h, w * 100, b * 100];
  };

  convert.rgb.cmyk = function (rgb) {
  	var r = rgb[0] / 255;
  	var g = rgb[1] / 255;
  	var b = rgb[2] / 255;
  	var c;
  	var m;
  	var y;
  	var k;

  	k = Math.min(1 - r, 1 - g, 1 - b);
  	c = (1 - r - k) / (1 - k) || 0;
  	m = (1 - g - k) / (1 - k) || 0;
  	y = (1 - b - k) / (1 - k) || 0;

  	return [c * 100, m * 100, y * 100, k * 100];
  };

  /**
   * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
   * */
  function comparativeDistance(x, y) {
  	return (
  		Math.pow(x[0] - y[0], 2) +
  		Math.pow(x[1] - y[1], 2) +
  		Math.pow(x[2] - y[2], 2)
  	);
  }

  convert.rgb.keyword = function (rgb) {
  	var reversed = reverseKeywords[rgb];
  	if (reversed) {
  		return reversed;
  	}

  	var currentClosestDistance = Infinity;
  	var currentClosestKeyword;

  	for (var keyword in cssKeywords) {
  		if (cssKeywords.hasOwnProperty(keyword)) {
  			var value = cssKeywords[keyword];

  			// Compute comparative distance
  			var distance = comparativeDistance(rgb, value);

  			// Check if its less, if so set as closest
  			if (distance < currentClosestDistance) {
  				currentClosestDistance = distance;
  				currentClosestKeyword = keyword;
  			}
  		}
  	}

  	return currentClosestKeyword;
  };

  convert.keyword.rgb = function (keyword) {
  	return cssKeywords[keyword];
  };

  convert.rgb.xyz = function (rgb) {
  	var r = rgb[0] / 255;
  	var g = rgb[1] / 255;
  	var b = rgb[2] / 255;

  	// assume sRGB
  	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
  	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
  	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

  	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
  	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
  	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

  	return [x * 100, y * 100, z * 100];
  };

  convert.rgb.lab = function (rgb) {
  	var xyz = convert.rgb.xyz(rgb);
  	var x = xyz[0];
  	var y = xyz[1];
  	var z = xyz[2];
  	var l;
  	var a;
  	var b;

  	x /= 95.047;
  	y /= 100;
  	z /= 108.883;

  	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
  	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
  	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

  	l = (116 * y) - 16;
  	a = 500 * (x - y);
  	b = 200 * (y - z);

  	return [l, a, b];
  };

  convert.hsl.rgb = function (hsl) {
  	var h = hsl[0] / 360;
  	var s = hsl[1] / 100;
  	var l = hsl[2] / 100;
  	var t1;
  	var t2;
  	var t3;
  	var rgb;
  	var val;

  	if (s === 0) {
  		val = l * 255;
  		return [val, val, val];
  	}

  	if (l < 0.5) {
  		t2 = l * (1 + s);
  	} else {
  		t2 = l + s - l * s;
  	}

  	t1 = 2 * l - t2;

  	rgb = [0, 0, 0];
  	for (var i = 0; i < 3; i++) {
  		t3 = h + 1 / 3 * -(i - 1);
  		if (t3 < 0) {
  			t3++;
  		}
  		if (t3 > 1) {
  			t3--;
  		}

  		if (6 * t3 < 1) {
  			val = t1 + (t2 - t1) * 6 * t3;
  		} else if (2 * t3 < 1) {
  			val = t2;
  		} else if (3 * t3 < 2) {
  			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
  		} else {
  			val = t1;
  		}

  		rgb[i] = val * 255;
  	}

  	return rgb;
  };

  convert.hsl.hsv = function (hsl) {
  	var h = hsl[0];
  	var s = hsl[1] / 100;
  	var l = hsl[2] / 100;
  	var smin = s;
  	var lmin = Math.max(l, 0.01);
  	var sv;
  	var v;

  	l *= 2;
  	s *= (l <= 1) ? l : 2 - l;
  	smin *= lmin <= 1 ? lmin : 2 - lmin;
  	v = (l + s) / 2;
  	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

  	return [h, sv * 100, v * 100];
  };

  convert.hsv.rgb = function (hsv) {
  	var h = hsv[0] / 60;
  	var s = hsv[1] / 100;
  	var v = hsv[2] / 100;
  	var hi = Math.floor(h) % 6;

  	var f = h - Math.floor(h);
  	var p = 255 * v * (1 - s);
  	var q = 255 * v * (1 - (s * f));
  	var t = 255 * v * (1 - (s * (1 - f)));
  	v *= 255;

  	switch (hi) {
  		case 0:
  			return [v, t, p];
  		case 1:
  			return [q, v, p];
  		case 2:
  			return [p, v, t];
  		case 3:
  			return [p, q, v];
  		case 4:
  			return [t, p, v];
  		case 5:
  			return [v, p, q];
  	}
  };

  convert.hsv.hsl = function (hsv) {
  	var h = hsv[0];
  	var s = hsv[1] / 100;
  	var v = hsv[2] / 100;
  	var vmin = Math.max(v, 0.01);
  	var lmin;
  	var sl;
  	var l;

  	l = (2 - s) * v;
  	lmin = (2 - s) * vmin;
  	sl = s * vmin;
  	sl /= (lmin <= 1) ? lmin : 2 - lmin;
  	sl = sl || 0;
  	l /= 2;

  	return [h, sl * 100, l * 100];
  };

  // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
  convert.hwb.rgb = function (hwb) {
  	var h = hwb[0] / 360;
  	var wh = hwb[1] / 100;
  	var bl = hwb[2] / 100;
  	var ratio = wh + bl;
  	var i;
  	var v;
  	var f;
  	var n;

  	// wh + bl cant be > 1
  	if (ratio > 1) {
  		wh /= ratio;
  		bl /= ratio;
  	}

  	i = Math.floor(6 * h);
  	v = 1 - bl;
  	f = 6 * h - i;

  	if ((i & 0x01) !== 0) {
  		f = 1 - f;
  	}

  	n = wh + f * (v - wh); // linear interpolation

  	var r;
  	var g;
  	var b;
  	switch (i) {
  		default:
  		case 6:
  		case 0: r = v; g = n; b = wh; break;
  		case 1: r = n; g = v; b = wh; break;
  		case 2: r = wh; g = v; b = n; break;
  		case 3: r = wh; g = n; b = v; break;
  		case 4: r = n; g = wh; b = v; break;
  		case 5: r = v; g = wh; b = n; break;
  	}

  	return [r * 255, g * 255, b * 255];
  };

  convert.cmyk.rgb = function (cmyk) {
  	var c = cmyk[0] / 100;
  	var m = cmyk[1] / 100;
  	var y = cmyk[2] / 100;
  	var k = cmyk[3] / 100;
  	var r;
  	var g;
  	var b;

  	r = 1 - Math.min(1, c * (1 - k) + k);
  	g = 1 - Math.min(1, m * (1 - k) + k);
  	b = 1 - Math.min(1, y * (1 - k) + k);

  	return [r * 255, g * 255, b * 255];
  };

  convert.xyz.rgb = function (xyz) {
  	var x = xyz[0] / 100;
  	var y = xyz[1] / 100;
  	var z = xyz[2] / 100;
  	var r;
  	var g;
  	var b;

  	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
  	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
  	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

  	// assume sRGB
  	r = r > 0.0031308
  		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
  		: r * 12.92;

  	g = g > 0.0031308
  		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
  		: g * 12.92;

  	b = b > 0.0031308
  		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
  		: b * 12.92;

  	r = Math.min(Math.max(0, r), 1);
  	g = Math.min(Math.max(0, g), 1);
  	b = Math.min(Math.max(0, b), 1);

  	return [r * 255, g * 255, b * 255];
  };

  convert.xyz.lab = function (xyz) {
  	var x = xyz[0];
  	var y = xyz[1];
  	var z = xyz[2];
  	var l;
  	var a;
  	var b;

  	x /= 95.047;
  	y /= 100;
  	z /= 108.883;

  	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
  	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
  	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

  	l = (116 * y) - 16;
  	a = 500 * (x - y);
  	b = 200 * (y - z);

  	return [l, a, b];
  };

  convert.lab.xyz = function (lab) {
  	var l = lab[0];
  	var a = lab[1];
  	var b = lab[2];
  	var x;
  	var y;
  	var z;

  	y = (l + 16) / 116;
  	x = a / 500 + y;
  	z = y - b / 200;

  	var y2 = Math.pow(y, 3);
  	var x2 = Math.pow(x, 3);
  	var z2 = Math.pow(z, 3);
  	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
  	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
  	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

  	x *= 95.047;
  	y *= 100;
  	z *= 108.883;

  	return [x, y, z];
  };

  convert.lab.lch = function (lab) {
  	var l = lab[0];
  	var a = lab[1];
  	var b = lab[2];
  	var hr;
  	var h;
  	var c;

  	hr = Math.atan2(b, a);
  	h = hr * 360 / 2 / Math.PI;

  	if (h < 0) {
  		h += 360;
  	}

  	c = Math.sqrt(a * a + b * b);

  	return [l, c, h];
  };

  convert.lch.lab = function (lch) {
  	var l = lch[0];
  	var c = lch[1];
  	var h = lch[2];
  	var a;
  	var b;
  	var hr;

  	hr = h / 360 * 2 * Math.PI;
  	a = c * Math.cos(hr);
  	b = c * Math.sin(hr);

  	return [l, a, b];
  };

  convert.rgb.ansi16 = function (args) {
  	var r = args[0];
  	var g = args[1];
  	var b = args[2];
  	var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

  	value = Math.round(value / 50);

  	if (value === 0) {
  		return 30;
  	}

  	var ansi = 30
  		+ ((Math.round(b / 255) << 2)
  		| (Math.round(g / 255) << 1)
  		| Math.round(r / 255));

  	if (value === 2) {
  		ansi += 60;
  	}

  	return ansi;
  };

  convert.hsv.ansi16 = function (args) {
  	// optimization here; we already know the value and don't need to get
  	// it converted for us.
  	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };

  convert.rgb.ansi256 = function (args) {
  	var r = args[0];
  	var g = args[1];
  	var b = args[2];

  	// we use the extended greyscale palette here, with the exception of
  	// black and white. normal palette only has 4 greyscale shades.
  	if (r === g && g === b) {
  		if (r < 8) {
  			return 16;
  		}

  		if (r > 248) {
  			return 231;
  		}

  		return Math.round(((r - 8) / 247) * 24) + 232;
  	}

  	var ansi = 16
  		+ (36 * Math.round(r / 255 * 5))
  		+ (6 * Math.round(g / 255 * 5))
  		+ Math.round(b / 255 * 5);

  	return ansi;
  };

  convert.ansi16.rgb = function (args) {
  	var color = args % 10;

  	// handle greyscale
  	if (color === 0 || color === 7) {
  		if (args > 50) {
  			color += 3.5;
  		}

  		color = color / 10.5 * 255;

  		return [color, color, color];
  	}

  	var mult = (~~(args > 50) + 1) * 0.5;
  	var r = ((color & 1) * mult) * 255;
  	var g = (((color >> 1) & 1) * mult) * 255;
  	var b = (((color >> 2) & 1) * mult) * 255;

  	return [r, g, b];
  };

  convert.ansi256.rgb = function (args) {
  	// handle greyscale
  	if (args >= 232) {
  		var c = (args - 232) * 10 + 8;
  		return [c, c, c];
  	}

  	args -= 16;

  	var rem;
  	var r = Math.floor(args / 36) / 5 * 255;
  	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
  	var b = (rem % 6) / 5 * 255;

  	return [r, g, b];
  };

  convert.rgb.hex = function (args) {
  	var integer = ((Math.round(args[0]) & 0xFF) << 16)
  		+ ((Math.round(args[1]) & 0xFF) << 8)
  		+ (Math.round(args[2]) & 0xFF);

  	var string = integer.toString(16).toUpperCase();
  	return '000000'.substring(string.length) + string;
  };

  convert.hex.rgb = function (args) {
  	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
  	if (!match) {
  		return [0, 0, 0];
  	}

  	var colorString = match[0];

  	if (match[0].length === 3) {
  		colorString = colorString.split('').map(function (char) {
  			return char + char;
  		}).join('');
  	}

  	var integer = parseInt(colorString, 16);
  	var r = (integer >> 16) & 0xFF;
  	var g = (integer >> 8) & 0xFF;
  	var b = integer & 0xFF;

  	return [r, g, b];
  };

  convert.rgb.hcg = function (rgb) {
  	var r = rgb[0] / 255;
  	var g = rgb[1] / 255;
  	var b = rgb[2] / 255;
  	var max = Math.max(Math.max(r, g), b);
  	var min = Math.min(Math.min(r, g), b);
  	var chroma = (max - min);
  	var grayscale;
  	var hue;

  	if (chroma < 1) {
  		grayscale = min / (1 - chroma);
  	} else {
  		grayscale = 0;
  	}

  	if (chroma <= 0) {
  		hue = 0;
  	} else
  	if (max === r) {
  		hue = ((g - b) / chroma) % 6;
  	} else
  	if (max === g) {
  		hue = 2 + (b - r) / chroma;
  	} else {
  		hue = 4 + (r - g) / chroma + 4;
  	}

  	hue /= 6;
  	hue %= 1;

  	return [hue * 360, chroma * 100, grayscale * 100];
  };

  convert.hsl.hcg = function (hsl) {
  	var s = hsl[1] / 100;
  	var l = hsl[2] / 100;
  	var c = 1;
  	var f = 0;

  	if (l < 0.5) {
  		c = 2.0 * s * l;
  	} else {
  		c = 2.0 * s * (1.0 - l);
  	}

  	if (c < 1.0) {
  		f = (l - 0.5 * c) / (1.0 - c);
  	}

  	return [hsl[0], c * 100, f * 100];
  };

  convert.hsv.hcg = function (hsv) {
  	var s = hsv[1] / 100;
  	var v = hsv[2] / 100;

  	var c = s * v;
  	var f = 0;

  	if (c < 1.0) {
  		f = (v - c) / (1 - c);
  	}

  	return [hsv[0], c * 100, f * 100];
  };

  convert.hcg.rgb = function (hcg) {
  	var h = hcg[0] / 360;
  	var c = hcg[1] / 100;
  	var g = hcg[2] / 100;

  	if (c === 0.0) {
  		return [g * 255, g * 255, g * 255];
  	}

  	var pure = [0, 0, 0];
  	var hi = (h % 1) * 6;
  	var v = hi % 1;
  	var w = 1 - v;
  	var mg = 0;

  	switch (Math.floor(hi)) {
  		case 0:
  			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
  		case 1:
  			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
  		case 2:
  			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
  		case 3:
  			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
  		case 4:
  			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
  		default:
  			pure[0] = 1; pure[1] = 0; pure[2] = w;
  	}

  	mg = (1.0 - c) * g;

  	return [
  		(c * pure[0] + mg) * 255,
  		(c * pure[1] + mg) * 255,
  		(c * pure[2] + mg) * 255
  	];
  };

  convert.hcg.hsv = function (hcg) {
  	var c = hcg[1] / 100;
  	var g = hcg[2] / 100;

  	var v = c + g * (1.0 - c);
  	var f = 0;

  	if (v > 0.0) {
  		f = c / v;
  	}

  	return [hcg[0], f * 100, v * 100];
  };

  convert.hcg.hsl = function (hcg) {
  	var c = hcg[1] / 100;
  	var g = hcg[2] / 100;

  	var l = g * (1.0 - c) + 0.5 * c;
  	var s = 0;

  	if (l > 0.0 && l < 0.5) {
  		s = c / (2 * l);
  	} else
  	if (l >= 0.5 && l < 1.0) {
  		s = c / (2 * (1 - l));
  	}

  	return [hcg[0], s * 100, l * 100];
  };

  convert.hcg.hwb = function (hcg) {
  	var c = hcg[1] / 100;
  	var g = hcg[2] / 100;
  	var v = c + g * (1.0 - c);
  	return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };

  convert.hwb.hcg = function (hwb) {
  	var w = hwb[1] / 100;
  	var b = hwb[2] / 100;
  	var v = 1 - b;
  	var c = v - w;
  	var g = 0;

  	if (c < 1) {
  		g = (v - c) / (1 - c);
  	}

  	return [hwb[0], c * 100, g * 100];
  };

  convert.apple.rgb = function (apple) {
  	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
  };

  convert.rgb.apple = function (rgb) {
  	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
  };

  convert.gray.rgb = function (args) {
  	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };

  convert.gray.hsl = convert.gray.hsv = function (args) {
  	return [0, 0, args[0]];
  };

  convert.gray.hwb = function (gray) {
  	return [0, 100, gray[0]];
  };

  convert.gray.cmyk = function (gray) {
  	return [0, 0, 0, gray[0]];
  };

  convert.gray.lab = function (gray) {
  	return [gray[0], 0, 0];
  };

  convert.gray.hex = function (gray) {
  	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
  	var integer = (val << 16) + (val << 8) + val;

  	var string = integer.toString(16).toUpperCase();
  	return '000000'.substring(string.length) + string;
  };

  convert.rgb.gray = function (rgb) {
  	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
  	return [val / 255 * 100];
  };


  /***/ }),
  /* 219 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  
  
  module.exports = {
  	"aliceblue": [240, 248, 255],
  	"antiquewhite": [250, 235, 215],
  	"aqua": [0, 255, 255],
  	"aquamarine": [127, 255, 212],
  	"azure": [240, 255, 255],
  	"beige": [245, 245, 220],
  	"bisque": [255, 228, 196],
  	"black": [0, 0, 0],
  	"blanchedalmond": [255, 235, 205],
  	"blue": [0, 0, 255],
  	"blueviolet": [138, 43, 226],
  	"brown": [165, 42, 42],
  	"burlywood": [222, 184, 135],
  	"cadetblue": [95, 158, 160],
  	"chartreuse": [127, 255, 0],
  	"chocolate": [210, 105, 30],
  	"coral": [255, 127, 80],
  	"cornflowerblue": [100, 149, 237],
  	"cornsilk": [255, 248, 220],
  	"crimson": [220, 20, 60],
  	"cyan": [0, 255, 255],
  	"darkblue": [0, 0, 139],
  	"darkcyan": [0, 139, 139],
  	"darkgoldenrod": [184, 134, 11],
  	"darkgray": [169, 169, 169],
  	"darkgreen": [0, 100, 0],
  	"darkgrey": [169, 169, 169],
  	"darkkhaki": [189, 183, 107],
  	"darkmagenta": [139, 0, 139],
  	"darkolivegreen": [85, 107, 47],
  	"darkorange": [255, 140, 0],
  	"darkorchid": [153, 50, 204],
  	"darkred": [139, 0, 0],
  	"darksalmon": [233, 150, 122],
  	"darkseagreen": [143, 188, 143],
  	"darkslateblue": [72, 61, 139],
  	"darkslategray": [47, 79, 79],
  	"darkslategrey": [47, 79, 79],
  	"darkturquoise": [0, 206, 209],
  	"darkviolet": [148, 0, 211],
  	"deeppink": [255, 20, 147],
  	"deepskyblue": [0, 191, 255],
  	"dimgray": [105, 105, 105],
  	"dimgrey": [105, 105, 105],
  	"dodgerblue": [30, 144, 255],
  	"firebrick": [178, 34, 34],
  	"floralwhite": [255, 250, 240],
  	"forestgreen": [34, 139, 34],
  	"fuchsia": [255, 0, 255],
  	"gainsboro": [220, 220, 220],
  	"ghostwhite": [248, 248, 255],
  	"gold": [255, 215, 0],
  	"goldenrod": [218, 165, 32],
  	"gray": [128, 128, 128],
  	"green": [0, 128, 0],
  	"greenyellow": [173, 255, 47],
  	"grey": [128, 128, 128],
  	"honeydew": [240, 255, 240],
  	"hotpink": [255, 105, 180],
  	"indianred": [205, 92, 92],
  	"indigo": [75, 0, 130],
  	"ivory": [255, 255, 240],
  	"khaki": [240, 230, 140],
  	"lavender": [230, 230, 250],
  	"lavenderblush": [255, 240, 245],
  	"lawngreen": [124, 252, 0],
  	"lemonchiffon": [255, 250, 205],
  	"lightblue": [173, 216, 230],
  	"lightcoral": [240, 128, 128],
  	"lightcyan": [224, 255, 255],
  	"lightgoldenrodyellow": [250, 250, 210],
  	"lightgray": [211, 211, 211],
  	"lightgreen": [144, 238, 144],
  	"lightgrey": [211, 211, 211],
  	"lightpink": [255, 182, 193],
  	"lightsalmon": [255, 160, 122],
  	"lightseagreen": [32, 178, 170],
  	"lightskyblue": [135, 206, 250],
  	"lightslategray": [119, 136, 153],
  	"lightslategrey": [119, 136, 153],
  	"lightsteelblue": [176, 196, 222],
  	"lightyellow": [255, 255, 224],
  	"lime": [0, 255, 0],
  	"limegreen": [50, 205, 50],
  	"linen": [250, 240, 230],
  	"magenta": [255, 0, 255],
  	"maroon": [128, 0, 0],
  	"mediumaquamarine": [102, 205, 170],
  	"mediumblue": [0, 0, 205],
  	"mediumorchid": [186, 85, 211],
  	"mediumpurple": [147, 112, 219],
  	"mediumseagreen": [60, 179, 113],
  	"mediumslateblue": [123, 104, 238],
  	"mediumspringgreen": [0, 250, 154],
  	"mediumturquoise": [72, 209, 204],
  	"mediumvioletred": [199, 21, 133],
  	"midnightblue": [25, 25, 112],
  	"mintcream": [245, 255, 250],
  	"mistyrose": [255, 228, 225],
  	"moccasin": [255, 228, 181],
  	"navajowhite": [255, 222, 173],
  	"navy": [0, 0, 128],
  	"oldlace": [253, 245, 230],
  	"olive": [128, 128, 0],
  	"olivedrab": [107, 142, 35],
  	"orange": [255, 165, 0],
  	"orangered": [255, 69, 0],
  	"orchid": [218, 112, 214],
  	"palegoldenrod": [238, 232, 170],
  	"palegreen": [152, 251, 152],
  	"paleturquoise": [175, 238, 238],
  	"palevioletred": [219, 112, 147],
  	"papayawhip": [255, 239, 213],
  	"peachpuff": [255, 218, 185],
  	"peru": [205, 133, 63],
  	"pink": [255, 192, 203],
  	"plum": [221, 160, 221],
  	"powderblue": [176, 224, 230],
  	"purple": [128, 0, 128],
  	"rebeccapurple": [102, 51, 153],
  	"red": [255, 0, 0],
  	"rosybrown": [188, 143, 143],
  	"royalblue": [65, 105, 225],
  	"saddlebrown": [139, 69, 19],
  	"salmon": [250, 128, 114],
  	"sandybrown": [244, 164, 96],
  	"seagreen": [46, 139, 87],
  	"seashell": [255, 245, 238],
  	"sienna": [160, 82, 45],
  	"silver": [192, 192, 192],
  	"skyblue": [135, 206, 235],
  	"slateblue": [106, 90, 205],
  	"slategray": [112, 128, 144],
  	"slategrey": [112, 128, 144],
  	"snow": [255, 250, 250],
  	"springgreen": [0, 255, 127],
  	"steelblue": [70, 130, 180],
  	"tan": [210, 180, 140],
  	"teal": [0, 128, 128],
  	"thistle": [216, 191, 216],
  	"tomato": [255, 99, 71],
  	"turquoise": [64, 224, 208],
  	"violet": [238, 130, 238],
  	"wheat": [245, 222, 179],
  	"white": [255, 255, 255],
  	"whitesmoke": [245, 245, 245],
  	"yellow": [255, 255, 0],
  	"yellowgreen": [154, 205, 50]
  };


  /***/ }),
  /* 220 */
  /***/ (function(module, exports, __webpack_require__) {

  var conversions = __webpack_require__(218);

  /*
  	this function routes a model to all other models.

  	all functions that are routed have a property `.conversion` attached
  	to the returned synthetic function. This property is an array
  	of strings, each with the steps in between the 'from' and 'to'
  	color models (inclusive).

  	conversions that are not possible simply are not included.
  */

  function buildGraph() {
  	var graph = {};
  	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
  	var models = Object.keys(conversions);

  	for (var len = models.length, i = 0; i < len; i++) {
  		graph[models[i]] = {
  			// http://jsperf.com/1-vs-infinity
  			// micro-opt, but this is simple.
  			distance: -1,
  			parent: null
  		};
  	}

  	return graph;
  }

  // https://en.wikipedia.org/wiki/Breadth-first_search
  function deriveBFS(fromModel) {
  	var graph = buildGraph();
  	var queue = [fromModel]; // unshift -> queue -> pop

  	graph[fromModel].distance = 0;

  	while (queue.length) {
  		var current = queue.pop();
  		var adjacents = Object.keys(conversions[current]);

  		for (var len = adjacents.length, i = 0; i < len; i++) {
  			var adjacent = adjacents[i];
  			var node = graph[adjacent];

  			if (node.distance === -1) {
  				node.distance = graph[current].distance + 1;
  				node.parent = current;
  				queue.unshift(adjacent);
  			}
  		}
  	}

  	return graph;
  }

  function link(from, to) {
  	return function (args) {
  		return to(from(args));
  	};
  }

  function wrapConversion(toModel, graph) {
  	var path = [graph[toModel].parent, toModel];
  	var fn = conversions[graph[toModel].parent][toModel];

  	var cur = graph[toModel].parent;
  	while (graph[cur].parent) {
  		path.unshift(graph[cur].parent);
  		fn = link(conversions[graph[cur].parent][cur], fn);
  		cur = graph[cur].parent;
  	}

  	fn.conversion = path;
  	return fn;
  }

  module.exports = function (fromModel) {
  	var graph = deriveBFS(fromModel);
  	var conversion = {};

  	var models = Object.keys(graph);
  	for (var len = models.length, i = 0; i < len; i++) {
  		var toModel = models[i];
  		var node = graph[toModel];

  		if (node.parent === null) {
  			// no possible conversion, or this node is the source model.
  			continue;
  		}

  		conversion[toModel] = wrapConversion(toModel, graph);
  	}

  	return conversion;
  };



  /***/ }),
  /* 221 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const os = __webpack_require__(44);
  const hasFlag = __webpack_require__(222);

  const env = process.env;

  let forceColor;
  if (hasFlag('no-color') ||
  	hasFlag('no-colors') ||
  	hasFlag('color=false')) {
  	forceColor = false;
  } else if (hasFlag('color') ||
  	hasFlag('colors') ||
  	hasFlag('color=true') ||
  	hasFlag('color=always')) {
  	forceColor = true;
  }
  if ('FORCE_COLOR' in env) {
  	forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
  }

  function translateLevel(level) {
  	if (level === 0) {
  		return false;
  	}

  	return {
  		level,
  		hasBasic: true,
  		has256: level >= 2,
  		has16m: level >= 3
  	};
  }

  function supportsColor(stream) {
  	if (forceColor === false) {
  		return 0;
  	}

  	if (hasFlag('color=16m') ||
  		hasFlag('color=full') ||
  		hasFlag('color=truecolor')) {
  		return 3;
  	}

  	if (hasFlag('color=256')) {
  		return 2;
  	}

  	if (stream && !stream.isTTY && forceColor !== true) {
  		return 0;
  	}

  	const min = forceColor ? 1 : 0;

  	if (process.platform === 'win32') {
  		// Node.js 7.5.0 is the first version of Node.js to include a patch to
  		// libuv that enables 256 color output on Windows. Anything earlier and it
  		// won't work. However, here we target Node.js 8 at minimum as it is an LTS
  		// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
  		// release that supports 256 colors. Windows 10 build 14931 is the first release
  		// that supports 16m/TrueColor.
  		const osRelease = os.release().split('.');
  		if (
  			Number(process.versions.node.split('.')[0]) >= 8 &&
  			Number(osRelease[0]) >= 10 &&
  			Number(osRelease[2]) >= 10586
  		) {
  			return Number(osRelease[2]) >= 14931 ? 3 : 2;
  		}

  		return 1;
  	}

  	if ('CI' in env) {
  		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
  			return 1;
  		}

  		return min;
  	}

  	if ('TEAMCITY_VERSION' in env) {
  		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  	}

  	if (env.COLORTERM === 'truecolor') {
  		return 3;
  	}

  	if ('TERM_PROGRAM' in env) {
  		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

  		switch (env.TERM_PROGRAM) {
  			case 'iTerm.app':
  				return version >= 3 ? 3 : 2;
  			case 'Apple_Terminal':
  				return 2;
  			// No default
  		}
  	}

  	if (/-256(color)?$/i.test(env.TERM)) {
  		return 2;
  	}

  	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
  		return 1;
  	}

  	if ('COLORTERM' in env) {
  		return 1;
  	}

  	if (env.TERM === 'dumb') {
  		return min;
  	}

  	return min;
  }

  function getSupportLevel(stream) {
  	const level = supportsColor(stream);
  	return translateLevel(level);
  }

  module.exports = {
  	supportsColor: getSupportLevel,
  	stdout: getSupportLevel(process.stdout),
  	stderr: getSupportLevel(process.stderr)
  };


  /***/ }),
  /* 222 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  module.exports = (flag, argv) => {
  	argv = argv || process.argv;
  	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
  	const pos = argv.indexOf(prefix + flag);
  	const terminatorPos = argv.indexOf('--');
  	return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };


  /***/ }),
  /* 223 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  const ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;

  const ESCAPES = new Map([
  	['n', '\n'],
  	['r', '\r'],
  	['t', '\t'],
  	['b', '\b'],
  	['f', '\f'],
  	['v', '\v'],
  	['0', '\0'],
  	['\\', '\\'],
  	['e', '\u001B'],
  	['a', '\u0007']
  ]);

  function unescape(c) {
  	if ((c[0] === 'u' && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
  		return String.fromCharCode(parseInt(c.slice(1), 16));
  	}

  	return ESCAPES.get(c) || c;
  }

  function parseArguments(name, args) {
  	const results = [];
  	const chunks = args.trim().split(/\s*,\s*/g);
  	let matches;

  	for (const chunk of chunks) {
  		if (!isNaN(chunk)) {
  			results.push(Number(chunk));
  		} else if ((matches = chunk.match(STRING_REGEX))) {
  			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
  		} else {
  			throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
  		}
  	}

  	return results;
  }

  function parseStyle(style) {
  	STYLE_REGEX.lastIndex = 0;

  	const results = [];
  	let matches;

  	while ((matches = STYLE_REGEX.exec(style)) !== null) {
  		const name = matches[1];

  		if (matches[2]) {
  			const args = parseArguments(name, matches[2]);
  			results.push([name].concat(args));
  		} else {
  			results.push([name]);
  		}
  	}

  	return results;
  }

  function buildStyle(chalk, styles) {
  	const enabled = {};

  	for (const layer of styles) {
  		for (const style of layer.styles) {
  			enabled[style[0]] = layer.inverse ? null : style.slice(1);
  		}
  	}

  	let current = chalk;
  	for (const styleName of Object.keys(enabled)) {
  		if (Array.isArray(enabled[styleName])) {
  			if (!(styleName in current)) {
  				throw new Error(`Unknown Chalk style: ${styleName}`);
  			}

  			if (enabled[styleName].length > 0) {
  				current = current[styleName].apply(current, enabled[styleName]);
  			} else {
  				current = current[styleName];
  			}
  		}
  	}

  	return current;
  }

  module.exports = (chalk, tmp) => {
  	const styles = [];
  	const chunks = [];
  	let chunk = [];

  	// eslint-disable-next-line max-params
  	tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
  		if (escapeChar) {
  			chunk.push(unescape(escapeChar));
  		} else if (style) {
  			const str = chunk.join('');
  			chunk = [];
  			chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
  			styles.push({inverse, styles: parseStyle(style)});
  		} else if (close) {
  			if (styles.length === 0) {
  				throw new Error('Found extraneous } in Chalk template literal');
  			}

  			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
  			chunk = [];
  			styles.pop();
  		} else {
  			chunk.push(chr);
  		}
  	});

  	chunks.push(chunk.join(''));

  	if (styles.length > 0) {
  		const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
  		throw new Error(errMsg);
  	}

  	return chunks.join('');
  };


  /***/ }),
  /* 224 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  var Cli_1 = __webpack_require__(225);
  exports.Cli = Cli_1.Cli;
  var Command_1 = __webpack_require__(230);
  exports.Command = Command_1.Command;
  var errors_1 = __webpack_require__(227);
  exports.UsageError = errors_1.UsageError;


  /***/ }),
  /* 225 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importDefault = (this && this.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const chalk_1 = __importDefault(__webpack_require__(213));
  const core_1 = __webpack_require__(226);
  const core_2 = __webpack_require__(226);
  const format_1 = __webpack_require__(228);
  const HelpCommand_1 = __webpack_require__(229);
  class Cli {
      constructor({ binaryLabel, binaryName = `...`, binaryVersion } = {}) {
          this.registrations = new Map();
          this.builder = new core_2.CliBuilder({ binaryName });
          this.binaryLabel = binaryLabel;
          this.binaryName = binaryName;
          this.binaryVersion = binaryVersion;
      }
      static from(commandClasses) {
          const cli = new Cli();
          for (const commandClass of commandClasses)
              cli.register(commandClass);
          return cli;
      }
      register(commandClass) {
          const commandBuilder = this.builder.command();
          this.registrations.set(commandClass, commandBuilder.cliIndex);
          const { definitions } = commandClass.resolveMeta(commandClass.prototype);
          for (const definition of definitions)
              definition(commandBuilder);
          commandBuilder.setContext({
              commandClass,
          });
      }
      process(input) {
          const { contexts, process } = this.builder.compile();
          const state = process(input);
          switch (state.selectedIndex) {
              case core_1.HELP_COMMAND_INDEX:
                  {
                      return HelpCommand_1.HelpCommand.from(state, this, contexts);
                  }
                  break;
              default:
                  {
                      const { commandClass } = contexts[state.selectedIndex];
                      const command = new commandClass();
                      command.path = state.path;
                      const { transformers } = commandClass.resolveMeta(commandClass.prototype);
                      for (const transformer of transformers)
                          transformer(state, command);
                      return command;
                  }
                  break;
          }
      }
      async run(input, context) {
          let command;
          if (!Array.isArray(input)) {
              command = input;
          }
          else {
              try {
                  command = this.process(input);
              }
              catch (error) {
                  context.stdout.write(this.error(error));
                  return 1;
              }
          }
          if (command.help) {
              context.stdout.write(this.usage(command, { detailed: true }));
              return 0;
          }
          command.context = context;
          command.cli = {
              definitions: () => this.definitions(),
              error: (error, opts) => this.error(error, opts),
              process: input => this.process(input),
              run: (input, subContext) => this.run(input, Object.assign({}, context, subContext)),
              usage: (command, opts) => this.usage(command, opts),
          };
          let exitCode;
          try {
              exitCode = await command.validateAndExecute();
          }
          catch (error) {
              context.stdout.write(this.error(error, { command }));
              return 1;
          }
          return exitCode;
      }
      async runExit(input, context) {
          process.exitCode = await this.run(input, context);
      }
      definitions() {
          const data = [];
          for (const [commandClass, number] of this.registrations) {
              if (typeof commandClass.usage === `undefined`)
                  continue;
              const path = this.getUsageByIndex(number, { detailed: false });
              const usage = this.getUsageByIndex(number, { detailed: true });
              const category = typeof commandClass.usage.category !== `undefined`
                  ? format_1.formatMarkdownish(commandClass.usage.category, false)
                  : undefined;
              const description = typeof commandClass.usage.description !== `undefined`
                  ? format_1.formatMarkdownish(commandClass.usage.description, false)
                  : undefined;
              const details = typeof commandClass.usage.details !== `undefined`
                  ? format_1.formatMarkdownish(commandClass.usage.details, true)
                  : undefined;
              const examples = typeof commandClass.usage.examples !== `undefined`
                  ? commandClass.usage.examples.map(([label, cli]) => [format_1.formatMarkdownish(label, false), format_1.formatMarkdownish(cli, false)])
                  : undefined;
              data.push({ path, usage, category, description, details, examples });
          }
          return data;
      }
      usage(command = null, { detailed = false, prefix = `$ ` } = {}) {
          // @ts-ignore
          const commandClass = command !== null && typeof command.getMeta === `undefined`
              ? command.constructor
              : command;
          let result = ``;
          if (!commandClass) {
              const commandsByCategories = new Map();
              for (const [commandClass, number] of this.registrations.entries()) {
                  if (typeof commandClass.usage === `undefined`)
                      continue;
                  const category = typeof commandClass.usage.category !== `undefined`
                      ? format_1.formatMarkdownish(commandClass.usage.category, false)
                      : null;
                  let categoryCommands = commandsByCategories.get(category);
                  if (typeof categoryCommands === `undefined`)
                      commandsByCategories.set(category, categoryCommands = []);
                  const usage = this.getUsageByIndex(number);
                  categoryCommands.push({ commandClass, usage });
              }
              const categoryNames = Array.from(commandsByCategories.keys()).sort((a, b) => {
                  if (a === null)
                      return -1;
                  if (b === null)
                      return +1;
                  return a.localeCompare(b, `en`, { usage: `sort`, caseFirst: `upper` });
              });
              const hasLabel = typeof this.binaryLabel !== `undefined`;
              const hasVersion = typeof this.binaryVersion !== `undefined`;
              if (hasLabel || hasVersion) {
                  if (hasLabel && hasVersion)
                      result += `${chalk_1.default.bold(`${this.binaryLabel} - ${this.binaryVersion}`)}\n\n`;
                  else if (hasLabel)
                      result += `${chalk_1.default.bold(`${this.binaryLabel}`)}\n`;
                  else
                      result += `${chalk_1.default.bold(`${this.binaryVersion}`)}\n`;
                  result += `  ${chalk_1.default.bold(prefix)}${this.binaryName} <command>\n`;
              }
              else {
                  result += `${chalk_1.default.bold(prefix)}${this.binaryName} <command>\n`;
              }
              for (let categoryName of categoryNames) {
                  const commands = commandsByCategories.get(categoryName).slice().sort((a, b) => {
                      return a.usage.localeCompare(b.usage, `en`, { usage: `sort`, caseFirst: `upper` });
                  });
                  const header = categoryName !== null
                      ? categoryName.trim()
                      : `Where <command> is one of`;
                  result += `\n`;
                  result += `${chalk_1.default.bold(`${header}:`)}\n`;
                  for (let { commandClass, usage } of commands) {
                      const doc = commandClass.usage.description || `undocumented`;
                      result += `\n`;
                      result += `  ${chalk_1.default.bold(usage)}\n`;
                      result += `    ${format_1.formatMarkdownish(doc, false)}`;
                  }
              }
              result += `\n`;
              result += format_1.formatMarkdownish(`You can also print more details about any of these commands by calling them after adding the \`-h,--help\` flag right after the command name.`, true);
          }
          else {
              if (!detailed) {
                  result += `${chalk_1.default.bold(prefix)}${this.getUsageByRegistration(commandClass)}\n`;
              }
              else {
                  const { description = ``, details = ``, examples = [], } = commandClass.usage || {};
                  if (description !== ``) {
                      result += format_1.formatMarkdownish(description, false).replace(/^./, $0 => $0.toUpperCase());
                      result += `\n`;
                  }
                  if (details !== `` || examples.length > 0) {
                      result += `${chalk_1.default.bold(`Usage:`)}\n`;
                      result += `\n`;
                  }
                  result += `${chalk_1.default.bold(prefix)}${this.getUsageByRegistration(commandClass)}\n`;
                  if (details !== ``) {
                      result += `\n`;
                      result += `${chalk_1.default.bold(`Details:`)}\n`;
                      result += `\n`;
                      result += format_1.formatMarkdownish(details, true);
                  }
                  if (examples.length > 0) {
                      result += `\n`;
                      result += `${chalk_1.default.bold(`Examples:`)}\n`;
                      for (let [description, example] of examples) {
                          result += `\n`;
                          result += format_1.formatMarkdownish(description, false);
                          result += [].concat(example.replace(/^/m, `  ${chalk_1.default.bold(prefix)}${this.binaryName} `)).join(`\n`) + `\n`;
                      }
                  }
              }
          }
          return result;
      }
      error(error, { command = null } = {}) {
          let result = ``;
          let name = error.name.replace(/([a-z])([A-Z])/g, `$1 $2`);
          if (name === `Error`)
              name = `Internal Error`;
          result += `${chalk_1.default.red.bold(name)}: ${error.message}\n`;
          // @ts-ignore
          const meta = error.clipanion;
          if (typeof meta !== `undefined`) {
              if (meta.type === `usage`) {
                  result += `\n`;
                  result += this.usage(command);
              }
          }
          else {
              if (error.stack) {
                  result += `${error.stack.replace(/^.*\n/, ``)}\n`;
              }
          }
          return result;
      }
      getUsageByRegistration(klass, opts) {
          const index = this.registrations.get(klass);
          if (typeof index === `undefined`)
              throw new Error(`Assertion failed: Unregistered command`);
          return this.getUsageByIndex(index, opts);
      }
      getUsageByIndex(n, opts) {
          return this.builder.getBuilderByIndex(n).usage(opts);
      }
  }
  exports.Cli = Cli;


  /***/ }),
  /* 226 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      result["default"] = mod;
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const errors = __importStar(__webpack_require__(227));
  exports.NODE_INITIAL = 0;
  exports.NODE_SUCCESS = 1;
  exports.NODE_ERRORED = 2;
  exports.START_OF_INPUT = `\u0001`;
  exports.END_OF_INPUT = `\u0000`;
  exports.HELP_COMMAND_INDEX = -1;
  exports.HELP_REGEX = /^(-h|--help)(?:=([0-9]+))?$/;
  exports.OPTION_REGEX = /^(--[a-z]+(-[a-z]+)*|-[a-zA-Z]+)$/;
  exports.BATCH_REGEX = /^-[a-zA-Z]{2,}$/;
  // ------------------------------------------------------------------------
  exports.DEBUG = process.env.DEBUG_CLI === `1`;
  function debug(str) {
      if (exports.DEBUG) {
          console.log(str);
      }
  }
  exports.debug = debug;
  function makeStateMachine() {
      return {
          nodes: [makeNode(), makeNode(), makeNode()],
      };
  }
  exports.makeStateMachine = makeStateMachine;
  function makeAnyOfMachine(inputs) {
      const output = makeStateMachine();
      const heads = [];
      let offset = output.nodes.length;
      for (const input of inputs) {
          heads.push(offset);
          for (let t = 0; t < input.nodes.length; ++t)
              if (!isTerminalNode(t))
                  output.nodes.push(cloneNode(input.nodes[t], offset));
          offset += input.nodes.length - 2;
      }
      for (const head of heads)
          registerShortcut(output, exports.NODE_INITIAL, head);
      return output;
  }
  exports.makeAnyOfMachine = makeAnyOfMachine;
  function injectNode(machine, node) {
      machine.nodes.push(node);
      return machine.nodes.length - 1;
  }
  exports.injectNode = injectNode;
  function simplifyMachine(input) {
      const visited = new Set();
      const process = (node) => {
          if (visited.has(node))
              return;
          visited.add(node);
          const nodeDef = input.nodes[node];
          for (const transitions of Object.values(nodeDef.statics))
              for (const { to } of transitions)
                  process(to);
          for (const [, { to }] of nodeDef.dynamics)
              process(to);
          for (const { to } of nodeDef.shortcuts)
              process(to);
          const shortcuts = new Set(nodeDef.shortcuts.map(({ to }) => to));
          while (nodeDef.shortcuts.length > 0) {
              const { to } = nodeDef.shortcuts.shift();
              const toDef = input.nodes[to];
              for (const [segment, transitions] of Object.entries(toDef.statics)) {
                  let store = !Object.prototype.hasOwnProperty.call(nodeDef.statics, segment)
                      ? nodeDef.statics[segment] = []
                      : nodeDef.statics[segment];
                  for (const transition of transitions) {
                      if (!store.some(({ to }) => transition.to === to)) {
                          store.push(transition);
                      }
                  }
              }
              for (const [test, transition] of toDef.dynamics)
                  if (!nodeDef.dynamics.some(([otherTest, { to }]) => test === otherTest && transition.to === to))
                      nodeDef.dynamics.push([test, transition]);
              for (const transition of toDef.shortcuts) {
                  if (!shortcuts.has(transition.to)) {
                      nodeDef.shortcuts.push(transition);
                      shortcuts.add(transition.to);
                  }
              }
          }
      };
      process(exports.NODE_INITIAL);
  }
  exports.simplifyMachine = simplifyMachine;
  function debugMachine(machine, { prefix = `` } = {}) {
      debug(`${prefix}Nodes are:`);
      for (let t = 0; t < machine.nodes.length; ++t) {
          debug(`${prefix}  ${t}: ${JSON.stringify(machine.nodes[t])}`);
      }
  }
  exports.debugMachine = debugMachine;
  function runMachine(machine, input) {
      debug(`Running a vm on ${JSON.stringify(input)}`);
      let branches = [{ node: exports.NODE_INITIAL, state: {
                  candidateUsage: null,
                  errorMessage: null,
                  ignoreOptions: false,
                  options: [],
                  path: [],
                  positionals: [],
                  selectedIndex: null,
              } }];
      debugMachine(machine, { prefix: `  ` });
      for (const segment of [exports.START_OF_INPUT, ...input, exports.END_OF_INPUT]) {
          debug(`  Processing ${JSON.stringify(segment)}`);
          const nextBranches = [];
          for (const { node, state } of branches) {
              debug(`    Current node is ${node}`);
              const nodeDef = machine.nodes[node];
              if (node === exports.NODE_ERRORED) {
                  nextBranches.push({ node, state });
                  continue;
              }
              console.assert(nodeDef.shortcuts.length === 0, `Shortcuts should have been eliminated by now`);
              if (Object.prototype.hasOwnProperty.call(nodeDef.statics, segment)) {
                  const transitions = nodeDef.statics[segment];
                  for (const { to, reducer } of transitions) {
                      nextBranches.push({ node: to, state: typeof reducer !== `undefined` ? execute(exports.reducers, reducer, state, segment) : state });
                      debug(`      Static transition to ${to} found`);
                  }
              }
              else {
                  debug(`      No static transition found`);
              }
              if (segment !== exports.END_OF_INPUT) {
                  for (const [test, { to, reducer }] of nodeDef.dynamics) {
                      if (execute(exports.tests, test, state, segment)) {
                          nextBranches.push({ node: to, state: typeof reducer !== `undefined` ? execute(exports.reducers, reducer, state, segment) : state });
                          debug(`      Dynamic transition to ${to} found (via ${test})`);
                      }
                  }
              }
          }
          if (nextBranches.length === 0) {
              throw new errors.UnknownSyntaxError(branches.filter(({ node }) => {
                  return node !== exports.NODE_ERRORED;
              }).map(({ state }) => {
                  return { usage: state.candidateUsage, reason: null };
              }));
          }
          if (nextBranches.every(({ node }) => node === exports.NODE_ERRORED)) {
              throw new errors.UnknownSyntaxError(nextBranches.map(({ state }) => {
                  return { usage: state.candidateUsage, reason: state.errorMessage };
              }));
          }
          branches = trimSmallerBranches(nextBranches);
      }
      if (branches.length > 0) {
          debug(`  Results:`);
          for (const branch of branches) {
              debug(`    - ${branch.node} -> ${JSON.stringify(branch.state)}`);
          }
      }
      else {
          debug(`  No results`);
      }
      return selectBestState(branches.map(({ state }) => {
          return state;
      }));
  }
  exports.runMachine = runMachine;
  function trimSmallerBranches(branches) {
      let maxPathSize = 0;
      for (const { state } of branches)
          if (state.path.length > maxPathSize)
              maxPathSize = state.path.length;
      return branches.filter(({ state }) => {
          return state.path.length === maxPathSize;
      });
  }
  exports.trimSmallerBranches = trimSmallerBranches;
  function selectBestState(states) {
      const terminalStates = states.filter(state => {
          return state.selectedIndex !== null;
      });
      if (terminalStates.length === 0)
          throw new Error();
      let maxPathSize = 0;
      for (const state of terminalStates)
          if (state.path.length > maxPathSize)
              maxPathSize = state.path.length;
      const bestPathBranches = terminalStates.filter(state => {
          return state.path.length === maxPathSize;
      });
      const getPositionalCount = (state) => state.positionals.filter(({ extra }) => {
          return !extra;
      }).length + state.options.length;
      const statesWithPositionalCount = bestPathBranches.map(state => {
          return { state, positionalCount: getPositionalCount(state) };
      });
      let maxPositionalCount = 0;
      for (const { positionalCount } of statesWithPositionalCount)
          if (positionalCount > maxPositionalCount)
              maxPositionalCount = positionalCount;
      const bestPositionalStates = statesWithPositionalCount.filter(({ positionalCount }) => {
          return positionalCount === maxPositionalCount;
      }).map(({ state }) => {
          return state;
      });
      const fixedStates = aggregateHelpStates(bestPositionalStates);
      if (fixedStates.length > 1)
          throw new Error();
      return fixedStates[0];
  }
  exports.selectBestState = selectBestState;
  function aggregateHelpStates(states) {
      const notHelps = [];
      const helps = [];
      for (const state of states) {
          if (state.selectedIndex === exports.HELP_COMMAND_INDEX) {
              helps.push(...state.options);
          }
          else {
              notHelps.push(state);
          }
      }
      if (helps.length > 0) {
          notHelps.push({
              candidateUsage: null,
              errorMessage: null,
              ignoreOptions: false,
              path: [],
              positionals: [],
              options: helps,
              selectedIndex: exports.HELP_COMMAND_INDEX,
          });
      }
      return notHelps;
  }
  exports.aggregateHelpStates = aggregateHelpStates;
  function makeNode() {
      return {
          dynamics: [],
          shortcuts: [],
          statics: {},
      };
  }
  exports.makeNode = makeNode;
  function isTerminalNode(node) {
      return node === exports.NODE_SUCCESS || node === exports.NODE_ERRORED;
  }
  exports.isTerminalNode = isTerminalNode;
  function cloneTransition(input, offset = 0) {
      return {
          to: !isTerminalNode(input.to) ? input.to > 2 ? input.to + offset - 2 : input.to + offset : input.to,
          reducer: input.reducer,
      };
  }
  exports.cloneTransition = cloneTransition;
  function cloneNode(input, offset = 0) {
      const output = makeNode();
      for (const [test, transition] of input.dynamics)
          output.dynamics.push([test, cloneTransition(transition, offset)]);
      for (const transition of input.shortcuts)
          output.shortcuts.push(cloneTransition(transition, offset));
      for (const [segment, transitions] of Object.entries(input.statics))
          output.statics[segment] = transitions.map(transition => cloneTransition(transition, offset));
      return output;
  }
  exports.cloneNode = cloneNode;
  function registerDynamic(machine, from, test, to, reducer) {
      machine.nodes[from].dynamics.push([test, { to, reducer }]);
  }
  exports.registerDynamic = registerDynamic;
  function registerShortcut(machine, from, to, reducer) {
      machine.nodes[from].shortcuts.push({ to, reducer });
  }
  exports.registerShortcut = registerShortcut;
  function registerStatic(machine, from, test, to, reducer) {
      let store = !Object.prototype.hasOwnProperty.call(machine.nodes[from].statics, test)
          ? machine.nodes[from].statics[test] = []
          : machine.nodes[from].statics[test];
      store.push({ to, reducer });
  }
  exports.registerStatic = registerStatic;
  function execute(store, callback, state, segment) {
      if (Array.isArray(callback)) {
          const [name, ...args] = callback;
          return store[name](state, segment, ...args);
      }
      else {
          return store[callback](state, segment);
      }
  }
  exports.execute = execute;
  exports.tests = {
      always: () => {
          return true;
      },
      isNotOptionLike: (state, segment) => {
          return state.ignoreOptions || !segment.startsWith(`-`);
      },
      isOption: (state, segment, name) => {
          return !state.ignoreOptions && segment === name;
      },
      isBatchOption: (state, segment, names) => {
          return !state.ignoreOptions && exports.BATCH_REGEX.test(segment) && [...segment.slice(1)].every(name => names.includes(`-${name}`));
      },
      isNegatedOption: (state, segment, name) => {
          return !state.ignoreOptions && segment === `--no-${name.slice(2)}`;
      },
      isHelp: (state, segment) => {
          return !state.ignoreOptions && exports.HELP_REGEX.test(segment);
      },
      isUnsupportedOption: (state, segment, names) => {
          return !state.ignoreOptions && segment.startsWith(`-`) && exports.OPTION_REGEX.test(segment) && !names.includes(segment);
      },
      isInvalidOption: (state, segment) => {
          return !state.ignoreOptions && segment.startsWith(`-`) && !exports.OPTION_REGEX.test(segment);
      },
  };
  exports.reducers = {
      setCandidateUsage: (state, segment, usage) => {
          return Object.assign({}, state, { candidateUsage: usage });
      },
      setSelectedIndex: (state, segment, index) => {
          return Object.assign({}, state, { selectedIndex: index });
      },
      pushBatch: (state, segment) => {
          return Object.assign({}, state, { options: state.options.concat([...segment.slice(1)].map(name => ({ name: `-${name}`, value: true }))) });
      },
      pushPath: (state, segment) => {
          return Object.assign({}, state, { path: state.path.concat(segment) });
      },
      pushPositional: (state, segment) => {
          return Object.assign({}, state, { positionals: state.positionals.concat({ value: segment, extra: false }) });
      },
      pushExtra: (state, segment) => {
          return Object.assign({}, state, { positionals: state.positionals.concat({ value: segment, extra: true }) });
      },
      pushTrue: (state, segment, name = segment) => {
          return Object.assign({}, state, { options: state.options.concat({ name: segment, value: true }) });
      },
      pushFalse: (state, segment, name = segment) => {
          return Object.assign({}, state, { options: state.options.concat({ name, value: false }) });
      },
      pushUndefined: (state, segment) => {
          return Object.assign({}, state, { options: state.options.concat({ name: segment, value: undefined }) });
      },
      setStringValue: (state, segment) => {
          return Object.assign({}, state, { options: state.options.slice(0, -1).concat(Object.assign({}, state.options[state.options.length - 1], { value: segment })) });
      },
      inhibateOptions: (state) => {
          return Object.assign({}, state, { ignoreOptions: true });
      },
      useHelp: (state, segment, command) => {
          const [, name, index] = segment.match(exports.HELP_REGEX);
          if (typeof index !== `undefined`) {
              return Object.assign({}, state, { options: [{ name: `-c`, value: String(command) }, { name: `-i`, value: index }] });
          }
          else {
              return Object.assign({}, state, { options: [{ name: `-c`, value: String(command) }] });
          }
      },
      setError: (state, segment, errorMessage) => {
          if (segment === exports.END_OF_INPUT) {
              return Object.assign({}, state, { errorMessage: `${errorMessage}.` });
          }
          else {
              return Object.assign({}, state, { errorMessage: `${errorMessage} ("${segment}").` });
          }
      },
  };
  // ------------------------------------------------------------------------
  exports.NoLimits = Symbol();
  class CommandBuilder {
      constructor(cliIndex, cliOpts) {
          this.allOptionNames = [];
          this.arity = { leading: [], trailing: [], extra: [], proxy: false };
          this.options = [];
          this.paths = [];
          this.cliIndex = cliIndex;
          this.cliOpts = cliOpts;
      }
      addPath(path) {
          this.paths.push(path);
      }
      setArity({ leading = this.arity.leading, trailing = this.arity.trailing, extra = this.arity.extra, proxy = this.arity.proxy }) {
          Object.assign(this.arity, { leading, trailing, extra, proxy });
      }
      addPositional({ name = 'arg', required = true } = {}) {
          if (!required && this.arity.extra === exports.NoLimits)
              throw new Error(`Optional parameters cannot be declared when using .rest() or .proxy()`);
          if (!required && this.arity.trailing.length > 0)
              throw new Error(`Optional parameters cannot be declared after the required trailing positional arguments`);
          if (!required && this.arity.extra !== exports.NoLimits) {
              this.arity.extra.push(name);
          }
          else if (this.arity.extra !== exports.NoLimits && this.arity.extra.length === 0) {
              this.arity.leading.push(name);
          }
          else {
              this.arity.trailing.push(name);
          }
      }
      addRest({ name = 'arg', required = 0 } = {}) {
          if (this.arity.extra === exports.NoLimits)
              throw new Error(`Infinite lists cannot be declared multiple times in the same command`);
          if (this.arity.trailing.length > 0)
              throw new Error(`Infinite lists cannot be declared after the required trailing positional arguments`);
          for (let t = 0; t < required; ++t)
              this.addPositional({ name });
          this.arity.extra = exports.NoLimits;
      }
      addProxy() {
          this.addRest();
          this.arity.proxy = true;
      }
      addOption({ names, arity = 0, hidden = false }) {
          this.allOptionNames.push(...names);
          this.options.push({ names, arity, hidden });
      }
      setContext(context) {
          this.context = context;
      }
      usage({ detailed = true } = {}) {
          const segments = [this.cliOpts.binaryName];
          if (this.paths.length > 0)
              segments.push(...this.paths[0]);
          if (detailed) {
              for (const { names, arity, hidden } of this.options) {
                  if (hidden)
                      continue;
                  const args = [];
                  for (let t = 0; t < arity; ++t)
                      args.push(` #${t}`);
                  segments.push(`[${names.join(`,`)}${args.join(``)}]`);
              }
              segments.push(...this.arity.leading.map(name => `<${name}>`));
              if (this.arity.extra === exports.NoLimits)
                  segments.push(`...`);
              else
                  segments.push(...this.arity.extra.map(name => `[${name}]`));
              segments.push(...this.arity.trailing.map(name => `<${name}>`));
          }
          return segments.join(` `);
      }
      compile() {
          if (typeof this.context === `undefined`)
              throw new Error(`Assertion failed: No context attached`);
          const machine = makeStateMachine();
          let firstNode = exports.NODE_INITIAL;
          firstNode = injectNode(machine, makeNode());
          registerStatic(machine, exports.NODE_INITIAL, exports.START_OF_INPUT, firstNode, [`setCandidateUsage`, this.usage()]);
          const positionalArgument = this.arity.proxy
              ? `always`
              : `isNotOptionLike`;
          const paths = this.paths.length > 0
              ? this.paths
              : [[]];
          for (const path of paths) {
              let lastPathNode = firstNode;
              for (let t = 0; t < path.length; ++t) {
                  const nextPathNode = injectNode(machine, makeNode());
                  registerStatic(machine, lastPathNode, path[t], nextPathNode, `pushPath`);
                  lastPathNode = nextPathNode;
              }
              if (this.arity.leading.length > 0 || !this.arity.proxy) {
                  const helpNode = injectNode(machine, makeNode());
                  registerDynamic(machine, lastPathNode, `isHelp`, helpNode, [`useHelp`, this.cliIndex]);
                  registerStatic(machine, helpNode, exports.END_OF_INPUT, exports.NODE_SUCCESS, [`setSelectedIndex`, exports.HELP_COMMAND_INDEX]);
              }
              this.registerOptions(machine, lastPathNode);
              if (this.arity.leading.length > 0)
                  registerStatic(machine, lastPathNode, exports.END_OF_INPUT, exports.NODE_ERRORED, [`setError`, `Not enough positional arguments`]);
              let lastLeadingNode = lastPathNode;
              for (let t = 0; t < this.arity.leading.length; ++t) {
                  const nextLeadingNode = injectNode(machine, makeNode());
                  this.registerOptions(machine, nextLeadingNode);
                  if (this.arity.trailing.length > 0 || t + 1 !== this.arity.leading.length)
                      registerStatic(machine, nextLeadingNode, exports.END_OF_INPUT, exports.NODE_ERRORED, [`setError`, `Not enough positional arguments`]);
                  registerDynamic(machine, lastLeadingNode, `isNotOptionLike`, nextLeadingNode, `pushPositional`);
                  lastLeadingNode = nextLeadingNode;
              }
              let lastExtraNode = lastLeadingNode;
              if (this.arity.extra === exports.NoLimits || this.arity.extra.length > 0) {
                  const extraShortcutNode = injectNode(machine, makeNode());
                  registerShortcut(machine, lastLeadingNode, extraShortcutNode);
                  if (this.arity.extra === exports.NoLimits) {
                      const extraNode = injectNode(machine, makeNode());
                      this.registerOptions(machine, extraNode);
                      registerDynamic(machine, lastLeadingNode, positionalArgument, extraNode, `pushExtra`);
                      registerDynamic(machine, extraNode, positionalArgument, extraNode, `pushExtra`);
                      registerShortcut(machine, extraNode, extraShortcutNode);
                  }
                  else {
                      for (let t = 0; t < this.arity.extra.length; ++t) {
                          const nextExtraNode = injectNode(machine, makeNode());
                          this.registerOptions(machine, nextExtraNode);
                          registerDynamic(machine, lastExtraNode, positionalArgument, nextExtraNode, `pushExtra`);
                          registerShortcut(machine, nextExtraNode, extraShortcutNode);
                          lastExtraNode = nextExtraNode;
                      }
                  }
                  lastExtraNode = extraShortcutNode;
              }
              if (this.arity.trailing.length > 0)
                  registerStatic(machine, lastExtraNode, exports.END_OF_INPUT, exports.NODE_ERRORED, [`setError`, `Not enough positional arguments`]);
              let lastTrailingNode = lastExtraNode;
              for (let t = 0; t < this.arity.trailing.length; ++t) {
                  const nextTrailingNode = injectNode(machine, makeNode());
                  this.registerOptions(machine, nextTrailingNode);
                  if (t + 1 < this.arity.trailing.length)
                      registerStatic(machine, nextTrailingNode, exports.END_OF_INPUT, exports.NODE_ERRORED, [`setError`, `Not enough positional arguments`]);
                  registerDynamic(machine, lastTrailingNode, `isNotOptionLike`, nextTrailingNode, `pushPositional`);
                  lastTrailingNode = nextTrailingNode;
              }
              registerDynamic(machine, lastTrailingNode, positionalArgument, exports.NODE_ERRORED, [`setError`, `Extraneous positional argument`]);
              registerStatic(machine, lastTrailingNode, exports.END_OF_INPUT, exports.NODE_SUCCESS, [`setSelectedIndex`, this.cliIndex]);
          }
          return {
              machine,
              context: this.context,
          };
      }
      registerOptions(machine, node) {
          registerDynamic(machine, node, [`isOption`, `--`], node, `inhibateOptions`);
          registerDynamic(machine, node, [`isBatchOption`, this.allOptionNames], node, `pushBatch`);
          registerDynamic(machine, node, [`isUnsupportedOption`, this.allOptionNames], exports.NODE_ERRORED, [`setError`, `Unsupported option name`]);
          registerDynamic(machine, node, [`isInvalidOption`], exports.NODE_ERRORED, [`setError`, `Invalid option name`]);
          for (const option of this.options) {
              if (option.arity === 0) {
                  for (const name of option.names) {
                      registerDynamic(machine, node, [`isOption`, name], node, `pushTrue`);
                      if (name.startsWith(`--`)) {
                          registerDynamic(machine, node, [`isNegatedOption`, name], node, [`pushFalse`, name]);
                      }
                  }
              }
              else if (option.arity === 1) {
                  const argNode = injectNode(machine, makeNode());
                  registerDynamic(machine, argNode, `isNotOptionLike`, node, `setStringValue`);
                  for (const name of option.names) {
                      registerDynamic(machine, node, [`isOption`, name], argNode, `pushUndefined`);
                  }
              }
              else {
                  throw new Error(`Unsupported option arity (${option.arity})`);
              }
          }
      }
  }
  exports.CommandBuilder = CommandBuilder;
  class CliBuilder {
      constructor({ binaryName = `...` } = {}) {
          this.builders = [];
          this.opts = { binaryName };
      }
      static build(cbs, opts = {}) {
          return new CliBuilder(opts).commands(cbs).compile();
      }
      getBuilderByIndex(n) {
          if (!(n >= 0 && n < this.builders.length))
              throw new Error(`Assertion failed: Out-of-bound command index (${n})`);
          return this.builders[n];
      }
      commands(cbs) {
          for (const cb of cbs)
              cb(this.command());
          return this;
      }
      command() {
          const builder = new CommandBuilder(this.builders.length, this.opts);
          this.builders.push(builder);
          return builder;
      }
      compile() {
          const machines = [];
          const contexts = [];
          for (const builder of this.builders) {
              const { machine, context } = builder.compile();
              machines.push(machine);
              contexts.push(context);
          }
          const machine = makeAnyOfMachine(machines);
          simplifyMachine(machine);
          return { machine, contexts, process: (input) => {
                  return runMachine(machine, input);
              } };
      }
  }
  exports.CliBuilder = CliBuilder;


  /***/ }),
  /* 227 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  class UsageError extends Error {
      constructor(message) {
          super(message);
          this.clipanion = { type: `usage` };
          this.name = `UsageError`;
      }
  }
  exports.UsageError = UsageError;
  class UnknownSyntaxError extends Error {
      constructor(candidates) {
          super();
          this.candidates = candidates;
          this.clipanion = { type: `none` };
          this.name = `UnknownSyntaxError`;
          if (this.candidates.length === 0) {
              this.message = `Command not found, but we're not sure what's the alternative.`;
          }
          else if (this.candidates.length === 1 && this.candidates[0].reason !== null) {
              const [{ usage, reason }] = this.candidates;
              this.message = `${reason}\n\n$ ${usage}`;
          }
          else if (this.candidates.length === 1) {
              const [{ usage }] = this.candidates;
              this.message = `Command not found; did you mean:\n\n$ ${usage}`;
          }
          else {
              this.message = `Command not found; did you mean one of:\n\n${this.candidates.map(({ usage }, index) => {
                  return `${`${index}.`.padStart(4)} ${usage}`;
              }).join(`\n`)}`;
          }
      }
  }
  exports.UnknownSyntaxError = UnknownSyntaxError;
  class AmbiguousSyntaxError extends Error {
      constructor(usages) {
          super();
          this.usages = usages;
          this.clipanion = { type: `none` };
          this.name = `AmbiguousSyntaxError`;
          this.message = `Cannot find who to pick amongst the following alternatives:\n\n${this.usages.map((usage, index) => {
              return `${`${index}.`.padStart(4)} ${usage}`;
          }).join(`\n`)}`;
      }
  }
  exports.AmbiguousSyntaxError = AmbiguousSyntaxError;


  /***/ }),
  /* 228 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importDefault = (this && this.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const chalk_1 = __importDefault(__webpack_require__(213));
  function formatMarkdownish(text, paragraphs) {
      // Enforce \n as newline character
      text = text.replace(/\r\n?/g, `\n`);
      // Remove the indentation, since it got messed up with the JS indentation
      text = text.replace(/^[\t ]+|[\t ]+$/gm, ``);
      // Remove surrounding newlines, since they got added for JS formatting
      text = text.replace(/^\n+|\n+$/g, ``);
      // List items always end with at least two newlines (in order to not be collapsed)
      text = text.replace(/^-([^\n]*?)\n+/gm, `-$1\n\n`);
      // Single newlines are removed; larger than that are collapsed into one
      text = text.replace(/\n(\n)?\n*/g, `$1`);
      if (paragraphs) {
          text = text.split(/\n/).map(function (paragraph) {
              // Does the paragraph starts with a list?
              let bulletMatch = paragraph.match(/^[*-][\t ]+(.*)/);
              if (!bulletMatch)
                  // No, cut the paragraphs into segments of 80 characters
                  return paragraph.match(/(.{1,80})(?: |$)/g).join('\n');
              // Yes, cut the paragraphs into segments of 78 characters (to account for the prefix)
              return bulletMatch[1].match(/(.{1,78})(?: |$)/g).map((line, index) => {
                  return (index === 0 ? `- ` : `  `) + line;
              }).join(`\n`);
          }).join(`\n\n`);
      }
      // Highlight the code segments
      text = text.replace(/(`+)((?:.|[\n])*?)\1/g, function ($0, $1, $2) {
          return chalk_1.default.cyan($1 + $2 + $1);
      });
      return text ? text + `\n` : ``;
  }
  exports.formatMarkdownish = formatMarkdownish;


  /***/ }),
  /* 229 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const Command_1 = __webpack_require__(230);
  class HelpCommand extends Command_1.Command {
      constructor(realCli, contexts) {
          super();
          this.realCli = realCli;
          this.contexts = contexts;
          this.commands = [];
      }
      static from(state, realCli, contexts) {
          const command = new HelpCommand(realCli, contexts);
          for (const opt of state.options) {
              switch (opt.name) {
                  case `-c`:
                      {
                          command.commands.push(Number(opt.value));
                      }
                      break;
                  case `-i`:
                      {
                          command.index = Number(opt.value);
                      }
                      break;
              }
          }
          return command;
      }
      async execute() {
          let commands = this.commands;
          if (typeof this.index !== `undefined` && this.index >= 0 && this.index < commands.length)
              commands = [commands[this.index]];
          if (commands.length === 1) {
              this.context.stdout.write(this.realCli.usage(this.contexts[commands[0]].commandClass, { detailed: true }));
          }
          else if (commands.length > 1) {
              this.context.stdout.write(`Multiple commands match your selection:\n`);
              this.context.stdout.write(`\n`);
              let index = 0;
              for (const command of this.commands)
                  this.context.stdout.write(this.realCli.usage(this.contexts[command].commandClass, { prefix: `${index++}. `.padStart(5) }));
              this.context.stdout.write(`\n`);
              this.context.stdout.write(`Run again with -h=<index> to see the longer details of any of those commands.\n`);
          }
      }
  }
  exports.HelpCommand = HelpCommand;


  /***/ }),
  /* 230 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  class Command {
      constructor() {
          /**
           * Predefined that will be set to true if `-h,--help` has been used, in which case `Command#execute` shouldn't be called.
           */
          this.help = false;
      }
      static getMeta(prototype) {
          const base = prototype.constructor;
          return base.meta = Object.prototype.hasOwnProperty.call(base, `meta`) ? base.meta : {
              definitions: [],
              transformers: [
                  (state, command) => {
                      for (const { name, value } of state.options) {
                          if (name === `-h` || name === `--help`) {
                              // @ts-ignore: The property is meant to have been defined by the child class
                              command.help = value;
                          }
                      }
                  },
              ],
          };
      }
      static resolveMeta(prototype) {
          const definitions = [];
          const transformers = [];
          for (let proto = prototype; proto instanceof Command; proto = proto.__proto__) {
              const meta = this.getMeta(proto);
              for (const definition of meta.definitions)
                  definitions.push(definition);
              for (const transformer of meta.transformers) {
                  transformers.push(transformer);
              }
          }
          return {
              definitions,
              transformers,
          };
      }
      static registerDefinition(prototype, definition) {
          this.getMeta(prototype).definitions.push(definition);
      }
      static registerTransformer(prototype, transformer) {
          this.getMeta(prototype).transformers.push(transformer);
      }
      static addPath(...path) {
          this.Path(...path)(this.prototype, `execute`);
      }
      static addOption(name, builder) {
          builder(this.prototype, name);
      }
      /**
       * Wrap the specified command to be attached to the given path on the command line.
       * The first path thus attached will be considered the "main" one, and all others will be aliases.
       * @param path The command path.
       */
      static Path(...path) {
          return (prototype, propertyName) => {
              this.registerDefinition(prototype, command => {
                  command.addPath(path);
              });
          };
      }
      /**
       * Register a boolean listener for the given option names. When Clipanion detects that this argument is present, the value will be set to false. The value won't be set unless the option is found, so you must remember to set it to an appropriate default value.
       * @param descriptor the option names.
       */
      static Boolean(descriptor, { hidden = false } = {}) {
          return (prototype, propertyName) => {
              const optNames = descriptor.split(`,`);
              this.registerDefinition(prototype, command => {
                  command.addOption({ names: optNames, arity: 0, hidden });
              });
              this.registerTransformer(prototype, (state, command) => {
                  for (const { name, value } of state.options) {
                      if (optNames.includes(name)) {
                          // @ts-ignore: The property is meant to have been defined by the child class
                          command[propertyName] = value;
                      }
                  }
              });
          };
      }
      static String(descriptor = { required: true }, { hidden = false } = {}) {
          return (prototype, propertyName) => {
              if (typeof descriptor === `string`) {
                  const optNames = descriptor.split(`,`);
                  this.registerDefinition(prototype, command => {
                      command.addOption({ names: optNames, arity: 1, hidden });
                  });
                  this.registerTransformer(prototype, (state, command) => {
                      for (const { name, value } of state.options) {
                          if (optNames.includes(name)) {
                              // @ts-ignore: The property is meant to have been defined by the child class
                              command[propertyName] = value;
                          }
                      }
                  });
              }
              else {
                  this.registerDefinition(prototype, command => {
                      command.addPositional({ name: propertyName, required: descriptor.required });
                  });
                  this.registerTransformer(prototype, (state, command) => {
                      if (state.positionals.length > 0) {
                          // @ts-ignore: The property is meant to have been defined by the child class
                          command[propertyName] = state.positionals.shift().value;
                      }
                  });
              }
          };
      }
      /**
       * Register a listener that looks for an option and its followup argument. When Clipanion detects that this argument is present, the value will be pushed into the array represented in the property.
       */
      static Array(descriptor, { hidden = false } = {}) {
          return (prototype, propertyName) => {
              const optNames = descriptor.split(`,`);
              this.registerDefinition(prototype, command => {
                  command.addOption({ names: optNames, arity: 1, hidden });
              });
              this.registerTransformer(prototype, (state, command) => {
                  for (const { name, value } of state.options) {
                      if (optNames.includes(name)) {
                          // @ts-ignore: The property is meant to have been defined by the child class
                          command[propertyName] = command[propertyName] || [];
                          // @ts-ignore: The property is meant to have been defined by the child class
                          command[propertyName].push(value);
                      }
                  }
              });
          };
      }
      static Rest({ required = 0 } = {}) {
          return (prototype, propertyName) => {
              this.registerDefinition(prototype, command => {
                  command.addRest({ name: propertyName, required });
              });
              this.registerTransformer(prototype, (state, command) => {
                  // @ts-ignore: The property is meant to have been defined by the child class
                  command[propertyName] = state.positionals.map(({ value }) => value);
              });
          };
      }
      /**
       * Register a listener that takes all the arguments remaining (including options and such) and store them into the selected property.
       * Note that all methods affecting positional arguments are evaluated in the definition order; don't mess with it (for example sorting your properties in ascendent order might have adverse results).
       */
      static Proxy() {
          return (prototype, propertyName) => {
              this.registerDefinition(prototype, command => {
                  command.addProxy();
              });
              this.registerTransformer(prototype, (state, command) => {
                  // @ts-ignore: The property is meant to have been defined by the child class
                  command[propertyName] = state.positionals.map(({ value }) => value);
              });
          };
      }
      /**
       * Defines the usage information for the given command.
       * @param usage
       */
      static Usage(usage) {
          return usage;
      }
      async validateAndExecute() {
          const commandClass = this.constructor;
          const schema = commandClass.schema;
          if (typeof schema !== `undefined`) {
              try {
                  await schema.validate(this);
              }
              catch (error) {
                  if (error.name === `ValidationError`)
                      error.clipanion = { type: `usage` };
                  throw error;
              }
          }
          const exitCode = await this.execute();
          if (typeof exitCode !== `undefined`) {
              return exitCode;
          }
          else {
              return 0;
          }
      }
  }
  exports.Command = Command;


  /***/ }),
  /* 231 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      result["default"] = mod;
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const Report_1 = __webpack_require__(177);
  const structUtils = __importStar(__webpack_require__(173));
  class MultiFetcher {
      constructor(fetchers) {
          this.fetchers = fetchers;
      }
      supports(locator, opts) {
          if (!this.tryFetcher(locator, opts))
              return false;
          return true;
      }
      getLocalPath(locator, opts) {
          const fetcher = this.getFetcher(locator, opts);
          return fetcher.getLocalPath(locator, opts);
      }
      async fetch(locator, opts) {
          const fetcher = this.getFetcher(locator, opts);
          return await fetcher.fetch(locator, opts);
      }
      tryFetcher(locator, opts) {
          const fetcher = this.fetchers.find(fetcher => fetcher.supports(locator, opts));
          if (!fetcher)
              return null;
          return fetcher;
      }
      getFetcher(locator, opts) {
          const fetcher = this.fetchers.find(fetcher => fetcher.supports(locator, opts));
          if (!fetcher)
              throw new Report_1.ReportError(Report_1.MessageName.FETCHER_NOT_FOUND, `${structUtils.prettyLocator(opts.project.configuration, locator)} isn't supported by any available fetcher`);
          return fetcher;
      }
  }
  exports.MultiFetcher = MultiFetcher;


  /***/ }),
  /* 232 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      result["default"] = mod;
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const Report_1 = __webpack_require__(177);
  const structUtils = __importStar(__webpack_require__(173));
  class MultiResolver {
      constructor(resolvers) {
          this.resolvers = resolvers.filter(resolver => resolver);
      }
      supportsDescriptor(descriptor, opts) {
          const resolver = this.tryResolverByDescriptor(descriptor, opts);
          return resolver ? true : false;
      }
      supportsLocator(locator, opts) {
          const resolver = this.tryResolverByLocator(locator, opts);
          return resolver ? true : false;
      }
      shouldPersistResolution(locator, opts) {
          const resolver = this.getResolverByLocator(locator, opts);
          return resolver.shouldPersistResolution(locator, opts);
      }
      bindDescriptor(descriptor, fromLocator, opts) {
          const resolver = this.getResolverByDescriptor(descriptor, opts);
          return resolver.bindDescriptor(descriptor, fromLocator, opts);
      }
      async getCandidates(descriptor, opts) {
          const resolver = this.getResolverByDescriptor(descriptor, opts);
          return await resolver.getCandidates(descriptor, opts);
      }
      async resolve(locator, opts) {
          const resolver = this.getResolverByLocator(locator, opts);
          return await resolver.resolve(locator, opts);
      }
      tryResolverByDescriptor(descriptor, opts) {
          const resolver = this.resolvers.find(resolver => resolver.supportsDescriptor(descriptor, opts));
          if (!resolver)
              return null;
          return resolver;
      }
      getResolverByDescriptor(descriptor, opts) {
          const resolver = this.resolvers.find(resolver => resolver.supportsDescriptor(descriptor, opts));
          if (!resolver)
              throw new Report_1.ReportError(Report_1.MessageName.RESOLVER_NOT_FOUND, `${structUtils.prettyDescriptor(opts.project.configuration, descriptor)} isn't supported by any available resolver`);
          return resolver;
      }
      tryResolverByLocator(locator, opts) {
          const resolver = this.resolvers.find(resolver => resolver.supportsLocator(locator, opts));
          if (!resolver)
              return null;
          return resolver;
      }
      getResolverByLocator(locator, opts) {
          const resolver = this.resolvers.find(resolver => resolver.supportsLocator(locator, opts));
          if (!resolver)
              throw new Report_1.ReportError(Report_1.MessageName.RESOLVER_NOT_FOUND, `${structUtils.prettyLocator(opts.project.configuration, locator)} isn't supported by any available resolver`);
          return resolver;
      }
  }
  exports.MultiResolver = MultiResolver;


  /***/ }),
  /* 233 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importDefault = (this && this.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      result["default"] = mod;
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const semver_1 = __importDefault(__webpack_require__(41));
  const structUtils = __importStar(__webpack_require__(173));
  class SemverResolver {
      supportsDescriptor(descriptor, opts) {
          if (!semver_1.default.validRange(descriptor.range))
              return false;
          return true;
      }
      supportsLocator(locator, opts) {
          if (!semver_1.default.valid(locator.reference))
              return false;
          return true;
      }
      shouldPersistResolution(locator, opts) {
          return opts.resolver.shouldPersistResolution(this.forwardLocator(locator, opts), opts);
      }
      bindDescriptor(descriptor, fromLocator, opts) {
          return opts.resolver.bindDescriptor(this.forwardDescriptor(descriptor, opts), fromLocator, opts);
      }
      async getCandidates(descriptor, opts) {
          return await opts.resolver.getCandidates(this.forwardDescriptor(descriptor, opts), opts);
      }
      async resolve(locator, opts) {
          const pkg = await opts.resolver.resolve(this.forwardLocator(locator, opts), opts);
          return structUtils.renamePackage(pkg, locator);
      }
      forwardDescriptor(descriptor, opts) {
          return structUtils.makeDescriptor(descriptor, `${opts.project.configuration.get(`defaultProtocol`)}${descriptor.range}`);
      }
      forwardLocator(locator, opts) {
          return structUtils.makeLocator(locator, `${opts.project.configuration.get(`defaultProtocol`)}${locator.reference}`);
      }
  }
  exports.SemverResolver = SemverResolver;


  /***/ }),
  /* 234 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      result["default"] = mod;
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const structUtils = __importStar(__webpack_require__(173));
  exports.TAG_REGEXP = /^[a-z]+$/;
  class TagResolver {
      supportsDescriptor(descriptor, opts) {
          if (!exports.TAG_REGEXP.test(descriptor.range))
              return false;
          return true;
      }
      supportsLocator(locator, opts) {
          if (!exports.TAG_REGEXP.test(locator.reference))
              return false;
          return true;
      }
      shouldPersistResolution(locator, opts) {
          return opts.resolver.shouldPersistResolution(this.forwardLocator(locator, opts), opts);
      }
      bindDescriptor(descriptor, fromLocator, opts) {
          return opts.resolver.bindDescriptor(this.forwardDescriptor(descriptor, opts), fromLocator, opts);
      }
      async getCandidates(descriptor, opts) {
          return await opts.resolver.getCandidates(this.forwardDescriptor(descriptor, opts), opts);
      }
      async resolve(locator, opts) {
          const pkg = await opts.resolver.resolve(this.forwardLocator(locator, opts), opts);
          return structUtils.renamePackage(pkg, locator);
      }
      forwardDescriptor(descriptor, opts) {
          return structUtils.makeDescriptor(descriptor, `${opts.project.configuration.get(`defaultProtocol`)}${descriptor.range}`);
      }
      forwardLocator(locator, opts) {
          return structUtils.makeLocator(locator, `${opts.project.configuration.get(`defaultProtocol`)}${locator.reference}`);
      }
  }
  exports.TagResolver = TagResolver;


  /***/ }),
  /* 235 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      result["default"] = mod;
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const fslib_1 = __webpack_require__(5);
  const structUtils = __importStar(__webpack_require__(173));
  class VirtualFetcher {
      supports(locator) {
          if (!locator.reference.startsWith(`virtual:`))
              return false;
          return true;
      }
      getLocalPath(locator, opts) {
          const splitPoint = locator.reference.indexOf(`#`);
          if (splitPoint === -1)
              throw new Error(`Invalid virtual package reference`);
          const nextReference = locator.reference.slice(splitPoint + 1);
          const nextLocator = structUtils.makeLocator(locator, nextReference);
          return opts.fetcher.getLocalPath(nextLocator, opts);
      }
      async fetch(locator, opts) {
          const splitPoint = locator.reference.indexOf(`#`);
          if (splitPoint === -1)
              throw new Error(`Invalid virtual package reference`);
          const nextReference = locator.reference.slice(splitPoint + 1);
          const nextLocator = structUtils.makeLocator(locator, nextReference);
          const parentFetch = await opts.fetcher.fetch(nextLocator, opts);
          return await this.ensureVirtualLink(locator, parentFetch, opts);
      }
      getLocatorFilename(locator) {
          return structUtils.slugifyLocator(locator);
      }
      async ensureVirtualLink(locator, sourceFetch, opts) {
          const to = sourceFetch.packageFs.getRealPath();
          const virtualFolder = opts.project.configuration.get(`virtualFolder`);
          const virtualName = this.getLocatorFilename(locator);
          const virtualPath = fslib_1.VirtualFS.makeVirtualPath(virtualFolder, virtualName, to);
          // We then use an alias to tell anyone that asks us that we're operating within the virtual folder, while still using the same old fs
          const aliasFs = new fslib_1.AliasFS(virtualPath, { baseFs: sourceFetch.packageFs, pathUtils: fslib_1.ppath });
          return Object.assign({}, sourceFetch, { packageFs: aliasFs });
      }
  }
  exports.VirtualFetcher = VirtualFetcher;


  /***/ }),
  /* 236 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  class VirtualResolver {
      static isVirtualDescriptor(descriptor) {
          if (!descriptor.range.startsWith(VirtualResolver.protocol))
              return false;
          return true;
      }
      static isVirtualLocator(locator) {
          if (!locator.reference.startsWith(VirtualResolver.protocol))
              return false;
          return true;
      }
      supportsDescriptor(descriptor, opts) {
          return VirtualResolver.isVirtualDescriptor(descriptor);
      }
      supportsLocator(locator, opts) {
          return VirtualResolver.isVirtualLocator(locator);
      }
      shouldPersistResolution(locator, opts) {
          return false;
      }
      bindDescriptor(descriptor, locator, opts) {
          // It's unsupported because packages inside the dependency tree should
          // only become virtual AFTER they have all been resolved, by which point
          // you shouldn't need to call `bindDescriptor` anymore.
          throw new Error(`Assertion failed: calling "bindDescriptor" on a virtual descriptor is unsupported`);
      }
      async getCandidates(descriptor, opts) {
          // It's unsupported because packages inside the dependency tree should
          // only become virtual AFTER they have all been resolved, by which point
          // you shouldn't need to call `getCandidates` anymore.
          throw new Error(`Assertion failed: calling "getCandidates" on a virtual descriptor is unsupported`);
      }
      async resolve(locator, opts) {
          // It's unsupported because packages inside the dependency tree should
          // only become virtual AFTER they have all been resolved, by which point
          // you shouldn't need to call `resolve` anymore.
          throw new Error(`Assertion failed: calling "resolve" on a virtual locator is unsupported`);
      }
  }
  VirtualResolver.protocol = `virtual:`;
  exports.VirtualResolver = VirtualResolver;


  /***/ }),
  /* 237 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const fslib_1 = __webpack_require__(5);
  const WorkspaceResolver_1 = __webpack_require__(238);
  class WorkspaceFetcher {
      supports(locator) {
          if (!locator.reference.startsWith(WorkspaceResolver_1.WorkspaceResolver.protocol))
              return false;
          return true;
      }
      getLocalPath(locator, opts) {
          return this.getWorkspace(locator, opts).cwd;
      }
      async fetch(locator, opts) {
          const sourcePath = this.getWorkspace(locator, opts).cwd;
          return { packageFs: new fslib_1.JailFS(sourcePath), prefixPath: fslib_1.PortablePath.root, localPath: sourcePath };
      }
      getWorkspace(locator, opts) {
          return opts.project.getWorkspaceByCwd(locator.reference.slice(WorkspaceResolver_1.WorkspaceResolver.protocol.length));
      }
  }
  exports.WorkspaceFetcher = WorkspaceFetcher;


  /***/ }),
  /* 238 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const Report_1 = __webpack_require__(177);
  const types_1 = __webpack_require__(239);
  class WorkspaceResolver {
      supportsDescriptor(descriptor, opts) {
          if (descriptor.range.startsWith(WorkspaceResolver.protocol))
              return true;
          const matchingWorkspaces = opts.project.findWorkspacesByDescriptor(descriptor);
          if (matchingWorkspaces.length > 0)
              return true;
          return false;
      }
      supportsLocator(locator, opts) {
          if (!locator.reference.startsWith(WorkspaceResolver.protocol))
              return false;
          return true;
      }
      shouldPersistResolution(locator, opts) {
          return false;
      }
      bindDescriptor(descriptor, fromLocator, opts) {
          return descriptor;
      }
      async getCandidates(descriptor, opts) {
          const candidateWorkspaces = opts.project.findWorkspacesByDescriptor(descriptor);
          if (candidateWorkspaces.length < 1) {
              if (!opts.project.workspacesByIdent.has(descriptor.identHash)) {
                  throw new Report_1.ReportError(Report_1.MessageName.WORKSPACE_NOT_FOUND, `No local workspace found for this name`);
              }
              else {
                  throw new Report_1.ReportError(Report_1.MessageName.WORKSPACE_NOT_FOUND, `No local workspace found for this range`);
              }
          }
          if (candidateWorkspaces.length > 1)
              throw new Report_1.ReportError(Report_1.MessageName.TOO_MANY_MATCHING_WORKSPACES, `Too many workspaces match this range, please disambiguate`);
          return [candidateWorkspaces[0].anchoredLocator];
      }
      async resolve(locator, opts) {
          const workspace = opts.project.getWorkspaceByCwd(locator.reference.slice(WorkspaceResolver.protocol.length));
          return Object.assign({}, locator, { version: workspace.manifest.version || `0.0.0`, languageName: `unknown`, linkType: types_1.LinkType.SOFT, dependencies: new Map([...workspace.manifest.dependencies, ...workspace.manifest.devDependencies]), peerDependencies: new Map([...workspace.manifest.peerDependencies]), dependenciesMeta: workspace.manifest.dependenciesMeta, peerDependenciesMeta: workspace.manifest.peerDependenciesMeta, bin: workspace.manifest.bin });
      }
  }
  WorkspaceResolver.protocol = `workspace:`;
  exports.WorkspaceResolver = WorkspaceResolver;


  /***/ }),
  /* 239 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  ;
  ;
  ;
  var LinkType;
  (function (LinkType) {
      LinkType["HARD"] = "hard";
      LinkType["SOFT"] = "soft";
  })(LinkType = exports.LinkType || (exports.LinkType = {}));
  ;
  ;


  /***/ }),
  /* 240 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importDefault = (this && this.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const module_1 = __importDefault(__webpack_require__(241));
  function dynamicRequire(request) {
      const req = typeof require !== `undefined`
          ? require
          : __webpack_require__(129);
      return req(request);
  }
  exports.dynamicRequire = dynamicRequire;
  function builtinModules() {
      // @ts-ignore
      return new Set(module_1.default.builtinModules || Object.keys(process.binding('natives')));
  }
  exports.builtinModules = builtinModules;


  /***/ }),
  /* 241 */
  /***/ (function(module, exports) {

  module.exports = require("module");

  /***/ }),
  /* 242 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  var BuildType;
  (function (BuildType) {
      BuildType[BuildType["SCRIPT"] = 0] = "SCRIPT";
      BuildType[BuildType["SHELLCODE"] = 1] = "SHELLCODE";
  })(BuildType = exports.BuildType || (exports.BuildType = {}));
  ;
  ;


  /***/ }),
  /* 243 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const Report_1 = __webpack_require__(177);
  class LightReport extends Report_1.Report {
      constructor({ configuration, stdout, suggestInstall = true }) {
          super();
          this.errorCount = 0;
          this.configuration = configuration;
          this.stdout = stdout;
          this.suggestInstall = suggestInstall;
      }
      static async start(opts, cb) {
          const report = new this(opts);
          try {
              await cb(report);
          }
          catch (error) {
              report.reportExceptionOnce(error);
          }
          finally {
              await report.finalize();
          }
          return report;
      }
      hasErrors() {
          return this.errorCount > 0;
      }
      exitCode() {
          return this.hasErrors() ? 1 : 0;
      }
      reportCacheHit(locator) {
      }
      reportCacheMiss(locator) {
      }
      startTimerSync(what, cb) {
          return cb();
      }
      async startTimerPromise(what, cb) {
          return await cb();
      }
      reportSeparator() {
      }
      reportInfo(name, text) {
      }
      reportWarning(name, text) {
      }
      reportError(name, text) {
          this.errorCount += 1;
          this.stdout.write(`${this.configuration.format(`➤`, `redBright`)} ${this.formatName(name)}: ${text}\n`);
      }
      reportJson(data) {
          // Just ignore the json output
      }
      async finalize() {
          if (this.errorCount > 0) {
              this.stdout.write(`${this.configuration.format(`➤`, `redBright`)} Errors happened when preparing the environment required to run this command.\n`);
              if (this.suggestInstall) {
                  this.stdout.write(`${this.configuration.format(`➤`, `redBright`)} This might be caused by packages being missing from the lockfile, in which case running "yarn install" might help.\n`);
              }
          }
      }
      formatName(name) {
          return `BR${name.toString(10).padStart(4, `0`)}`;
      }
  }
  exports.LightReport = LightReport;


  /***/ }),
  /* 244 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importDefault = (this && this.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      result["default"] = mod;
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const fslib_1 = __webpack_require__(5);
  const parsers_1 = __webpack_require__(132);
  const crypto_1 = __webpack_require__(9);
  // @ts-ignore
  const logic_solver_1 = __importDefault(__webpack_require__(245));
  const p_limit_1 = __importDefault(__webpack_require__(249));
  const semver_1 = __importDefault(__webpack_require__(41));
  const tmp_1 = __webpack_require__(6);
  const AliasResolver_1 = __webpack_require__(251);
  const Installer_1 = __webpack_require__(242);
  const LockfileResolver_1 = __webpack_require__(252);
  const Manifest_1 = __webpack_require__(172);
  const MultiResolver_1 = __webpack_require__(232);
  const Report_1 = __webpack_require__(177);
  const RunInstallPleaseResolver_1 = __webpack_require__(253);
  const ThrowReport_1 = __webpack_require__(254);
  const Workspace_1 = __webpack_require__(255);
  const YarnResolver_1 = __webpack_require__(436);
  const folderUtils_1 = __webpack_require__(43);
  const miscUtils = __importStar(__webpack_require__(128));
  const scriptUtils = __importStar(__webpack_require__(130));
  const structUtils = __importStar(__webpack_require__(173));
  const types_1 = __webpack_require__(239);
  // When upgraded, the lockfile entries have to be resolved again (but the specific
  // versions are still pinned, no worry). Bump it when you change the fields within
  // the Package type; no more no less.
  const LOCKFILE_VERSION = 3;
  const MULTIPLE_KEYS_REGEXP = / *, */g;
  class Project {
      constructor(projectCwd, { configuration }) {
          // Is meant to be populated by the consumer. When the descriptor referenced by
          // the key should be resolved, the second one is resolved instead and its
          // result is used as final resolution for the first entry.
          this.resolutionAliases = new Map();
          this.workspaces = [];
          this.workspacesByCwd = new Map();
          this.workspacesByLocator = new Map();
          this.workspacesByIdent = new Map();
          this.storedResolutions = new Map();
          this.storedDescriptors = new Map();
          this.storedPackages = new Map();
          this.storedChecksums = new Map();
          this.optionalBuilds = new Set();
          this.configuration = configuration;
          this.cwd = projectCwd;
      }
      static async find(configuration, startingCwd) {
          if (!configuration.projectCwd)
              throw new Error(`No project found in the initial directory`);
          let packageCwd = null;
          let nextCwd = startingCwd;
          let currentCwd = null;
          while (currentCwd !== configuration.projectCwd) {
              currentCwd = nextCwd;
              if (fslib_1.xfs.existsSync(fslib_1.ppath.join(currentCwd, fslib_1.toFilename(`package.json`))))
                  if (!packageCwd)
                      packageCwd = currentCwd;
              nextCwd = fslib_1.ppath.dirname(currentCwd);
          }
          if (!packageCwd)
              throw new Error(`Assertion failed: No manifest found in the project`);
          const project = new Project(configuration.projectCwd, { configuration });
          await project.setupResolutions();
          await project.setupWorkspaces();
          applyVirtualResolutionMutations({
              project,
              allDescriptors: project.storedDescriptors,
              allResolutions: project.storedResolutions,
              allPackages: project.storedPackages,
              report: null,
              tolerateMissingPackages: true,
          });
          // If we're in a workspace, no need to go any further to find which package we're in
          const workspace = project.tryWorkspaceByCwd(packageCwd);
          if (workspace)
              return { project, workspace, locator: workspace.anchoredLocator };
          // Otherwise, we need to ask the project (which will in turn ask the linkers for help)
          // Note: the trailing slash is caused by a quirk in the PnP implementation that requires folders to end with a trailing slash to disambiguate them from regular files
          const locator = await project.findLocatorForLocation(`${packageCwd}/`);
          if (locator)
              return { project, locator, workspace: null };
          throw new Error(`Assertion failed: The package should have been detected as part of the project`);
      }
      async setupResolutions() {
          this.storedResolutions = new Map();
          this.storedDescriptors = new Map();
          this.storedPackages = new Map();
          const lockfilePath = fslib_1.ppath.join(this.cwd, this.configuration.get(`lockfileFilename`));
          const defaultLanguageName = this.configuration.get(`defaultLanguageName`);
          if (fslib_1.xfs.existsSync(lockfilePath)) {
              const content = await fslib_1.xfs.readFilePromise(lockfilePath, `utf8`);
              const parsed = parsers_1.parseSyml(content);
              // Protects against v1 lockfiles
              if (parsed.__metadata) {
                  const lockfileVersion = parsed.__metadata.version;
                  for (const key of Object.keys(parsed)) {
                      if (key === `__metadata`)
                          continue;
                      const data = parsed[key];
                      const locator = structUtils.parseLocator(data.resolution, true);
                      const manifest = new Manifest_1.Manifest();
                      manifest.load(data);
                      const version = manifest.version;
                      const languageName = manifest.languageName || defaultLanguageName;
                      const linkType = data.linkType;
                      const dependencies = manifest.dependencies;
                      const peerDependencies = manifest.peerDependencies;
                      const dependenciesMeta = manifest.dependenciesMeta;
                      const peerDependenciesMeta = manifest.peerDependenciesMeta;
                      const bin = manifest.bin;
                      if (data.checksum != null)
                          this.storedChecksums.set(locator.locatorHash, data.checksum);
                      if (lockfileVersion >= LOCKFILE_VERSION) {
                          const pkg = Object.assign({}, locator, { version, languageName, linkType, dependencies, peerDependencies, dependenciesMeta, peerDependenciesMeta, bin });
                          this.storedPackages.set(pkg.locatorHash, pkg);
                      }
                      for (const entry of key.split(MULTIPLE_KEYS_REGEXP)) {
                          const descriptor = structUtils.parseDescriptor(entry);
                          this.storedDescriptors.set(descriptor.descriptorHash, descriptor);
                          if (lockfileVersion >= LOCKFILE_VERSION) {
                              // If the lockfile is up-to-date, we can simply register the
                              // resolution as a done deal.
                              this.storedResolutions.set(descriptor.descriptorHash, locator.locatorHash);
                          }
                          else {
                              // But if it isn't, then we instead setup an alias so that the
                              // descriptor will be re-resolved (so that we get to retrieve the
                              // new fields) while still resolving to the same locators.
                              const resolutionDescriptor = structUtils.convertLocatorToDescriptor(locator);
                              if (resolutionDescriptor.descriptorHash !== descriptor.descriptorHash) {
                                  this.storedDescriptors.set(resolutionDescriptor.descriptorHash, resolutionDescriptor);
                                  this.resolutionAliases.set(descriptor.descriptorHash, resolutionDescriptor.descriptorHash);
                              }
                          }
                      }
                  }
              }
          }
      }
      async setupWorkspaces({ force = false } = {}) {
          this.workspaces = [];
          this.workspacesByCwd = new Map();
          this.workspacesByLocator = new Map();
          this.workspacesByIdent = new Map();
          let workspaceCwds = [this.cwd];
          while (workspaceCwds.length > 0) {
              const passCwds = workspaceCwds;
              workspaceCwds = [];
              for (const workspaceCwd of passCwds) {
                  if (this.workspacesByCwd.has(workspaceCwd))
                      continue;
                  const workspace = await this.addWorkspace(workspaceCwd);
                  const workspacePkg = this.storedPackages.get(workspace.anchoredLocator.locatorHash);
                  if (workspacePkg)
                      workspace.dependencies = workspacePkg.dependencies;
                  for (const workspaceCwd of workspace.workspacesCwds) {
                      workspaceCwds.push(workspaceCwd);
                  }
              }
          }
      }
      async addWorkspace(workspaceCwd) {
          const workspace = new Workspace_1.Workspace(workspaceCwd, { project: this });
          await workspace.setup();
          this.workspaces.push(workspace);
          this.workspacesByCwd.set(workspaceCwd, workspace);
          this.workspacesByLocator.set(workspace.anchoredLocator.locatorHash, workspace);
          let byIdent = this.workspacesByIdent.get(workspace.locator.identHash);
          if (!byIdent)
              this.workspacesByIdent.set(workspace.locator.identHash, byIdent = []);
          byIdent.push(workspace);
          return workspace;
      }
      get topLevelWorkspace() {
          return this.getWorkspaceByCwd(this.cwd);
      }
      tryWorkspaceByCwd(workspaceCwd) {
          if (!fslib_1.ppath.isAbsolute(workspaceCwd))
              workspaceCwd = fslib_1.ppath.resolve(this.cwd, workspaceCwd);
          const workspace = this.workspacesByCwd.get(workspaceCwd);
          if (!workspace)
              return null;
          return workspace;
      }
      getWorkspaceByCwd(workspaceCwd) {
          const workspace = this.tryWorkspaceByCwd(workspaceCwd);
          if (!workspace)
              throw new Error(`Workspace not found (${workspaceCwd})`);
          return workspace;
      }
      getWorkspaceByFilePath(filePath) {
          let bestWorkspace = null;
          for (const workspace of this.workspaces) {
              const rel = fslib_1.ppath.relative(workspace.cwd, filePath);
              if (rel.startsWith(`../`))
                  continue;
              if (bestWorkspace && bestWorkspace.cwd.length >= workspace.cwd.length)
                  continue;
              bestWorkspace = workspace;
          }
          if (!bestWorkspace) {
              for (const workspace of this.workspaces)
                  console.log(workspace.cwd);
              throw new Error(`Workspace not found (${filePath})`);
          }
          return bestWorkspace;
      }
      tryWorkspaceByLocator(locator) {
          if (structUtils.isVirtualLocator(locator))
              locator = structUtils.devirtualizeLocator(locator);
          const workspace = this.workspacesByLocator.get(locator.locatorHash);
          if (!workspace)
              return null;
          return workspace;
      }
      getWorkspaceByLocator(locator) {
          const workspace = this.tryWorkspaceByLocator(locator);
          if (!workspace)
              throw new Error(`Workspace not found (${structUtils.prettyLocator(this.configuration, locator)})`);
          return workspace;
      }
      findWorkspacesByDescriptor(descriptor) {
          const candidateWorkspaces = this.workspacesByIdent.get(descriptor.identHash);
          if (!candidateWorkspaces)
              return [];
          return candidateWorkspaces.filter(workspace => {
              return workspace.accepts(descriptor.range);
          });
      }
      forgetTransientResolutions() {
          const resolver = this.configuration.makeResolver();
          const forgottenPackages = new Set();
          for (const pkg of this.storedPackages.values()) {
              if (!resolver.shouldPersistResolution(pkg, { project: this, resolver })) {
                  this.storedPackages.delete(pkg.locatorHash);
                  forgottenPackages.add(pkg.locatorHash);
              }
          }
          for (const [descriptorHash, locatorHash] of this.storedResolutions) {
              if (forgottenPackages.has(locatorHash)) {
                  this.storedResolutions.delete(descriptorHash);
                  this.storedDescriptors.delete(descriptorHash);
              }
          }
      }
      forgetVirtualResolutions() {
          for (const pkg of this.storedPackages.values()) {
              for (const [dependencyHash, dependency] of pkg.dependencies) {
                  if (structUtils.isVirtualDescriptor(dependency)) {
                      pkg.dependencies.set(dependencyHash, structUtils.devirtualizeDescriptor(dependency));
                  }
              }
          }
      }
      getDependencyMeta(ident, version) {
          const dependencyMeta = {};
          const dependenciesMeta = this.topLevelWorkspace.manifest.dependenciesMeta;
          const dependencyMetaSet = dependenciesMeta.get(structUtils.stringifyIdent(ident));
          if (!dependencyMetaSet)
              return dependencyMeta;
          const defaultMeta = dependencyMetaSet.get(null);
          if (defaultMeta)
              Object.assign(dependencyMeta, defaultMeta);
          if (version === null || !semver_1.default.valid(version))
              return dependencyMeta;
          for (const [range, meta] of dependencyMetaSet)
              if (range !== null && range === version)
                  Object.assign(dependencyMeta, meta);
          return dependencyMeta;
      }
      async findLocatorForLocation(cwd) {
          const report = new ThrowReport_1.ThrowReport();
          const linkers = this.configuration.getLinkers();
          const linkerOptions = { project: this, report };
          for (const linker of linkers) {
              const locator = await linker.findPackageLocator(cwd, linkerOptions);
              if (locator) {
                  return locator;
              }
          }
          return null;
      }
      async resolveEverything({ cache, report, lockfileOnly }) {
          if (!this.workspacesByCwd || !this.workspacesByIdent)
              throw new Error(`Workspaces must have been setup before calling this function`);
          // Reverts the changes that have been applied to the tree because of any previous virtual resolution pass
          this.forgetVirtualResolutions();
          // Ensures that we notice it when dependencies are added / removed from all sources coming from the filesystem
          if (!lockfileOnly)
              await this.forgetTransientResolutions();
          // Note that the resolution process is "offline" until everything has been
          // successfully resolved; all the processing is expected to have zero side
          // effects until we're ready to set all the variables at once (the one
          // exception being when a resolver needs to fetch a package, in which case
          // we might need to populate the cache).
          //
          // This makes it possible to use the same Project instance for multiple
          // purposes at the same time (since `resolveEverything` is async, it might
          // happen that we want to do something while waiting for it to end; if we
          // were to mutate the project then it would end up in a partial state that
          // could lead to hard-to-debug issues).
          const yarnResolver = new YarnResolver_1.YarnResolver();
          await yarnResolver.setup(this, { report });
          const realResolver = this.configuration.makeResolver();
          const resolver = lockfileOnly
              ? new MultiResolver_1.MultiResolver([new LockfileResolver_1.LockfileResolver(), new RunInstallPleaseResolver_1.RunInstallPleaseResolver(realResolver)])
              : new AliasResolver_1.AliasResolver(new MultiResolver_1.MultiResolver([new LockfileResolver_1.LockfileResolver(), yarnResolver, realResolver]));
          const fetcher = this.configuration.makeFetcher();
          const resolverOptions = { checksums: this.storedChecksums, project: this, cache, fetcher, report, resolver };
          const allDescriptors = new Map();
          const allPackages = new Map();
          const allResolutions = new Map();
          const haveBeenAliased = new Set();
          let mustBeResolved = new Set();
          for (const workspace of this.workspaces) {
              const workspaceDescriptor = workspace.anchoredDescriptor;
              allDescriptors.set(workspaceDescriptor.descriptorHash, workspaceDescriptor);
              mustBeResolved.add(workspaceDescriptor.descriptorHash);
          }
          while (mustBeResolved.size !== 0) {
              // We remove from the "mustBeResolved" list all packages that have
              // already been resolved previously.
              for (const descriptorHash of mustBeResolved)
                  if (allResolutions.has(descriptorHash))
                      mustBeResolved.delete(descriptorHash);
              // Then we request the resolvers for the list of possible references that
              // match the given ranges. That will give us a set of candidate references
              // for each descriptor.
              const passCandidates = new Map(await Promise.all(Array.from(mustBeResolved).map(async (descriptorHash) => {
                  const descriptor = allDescriptors.get(descriptorHash);
                  if (!descriptor)
                      throw new Error(`Assertion failed: The descriptor should have been registered`);
                  let candidateLocators;
                  try {
                      candidateLocators = await resolver.getCandidates(descriptor, resolverOptions);
                  }
                  catch (error) {
                      error.message = `${structUtils.prettyDescriptor(this.configuration, descriptor)}: ${error.message}`;
                      throw error;
                  }
                  if (candidateLocators.length === 0)
                      throw new Error(`No candidate found for ${structUtils.prettyDescriptor(this.configuration, descriptor)}`);
                  return [descriptor.descriptorHash, candidateLocators];
              })));
              // That's where we'll store our resolutions until everything has been
              // resolved and can be injected into the various stores.
              //
              // The reason we're storing them in a temporary store instead of writing
              // them directly into the global ones is that otherwise we would end up
              // with different store orderings between dependency loaded from a
              // lockfiles and those who don't (when using a lockfile all descriptors
              // will fall into the next shortcut, but when no lockfile is there only
              // some of them will; since maps are sorted by insertion, it would affect
              // the way they would be ordered).
              const passResolutions = new Map();
              // We now make a pre-pass to automatically resolve the descriptors that
              // can only be satisfied by a single reference.
              for (const [descriptorHash, candidateLocators] of passCandidates) {
                  if (candidateLocators.length !== 1)
                      continue;
                  passResolutions.set(descriptorHash, candidateLocators[0]);
                  passCandidates.delete(descriptorHash);
              }
              // We make a second pre-pass to automatically resolve the descriptors
              // that can be satisfied by a package we're already using (deduplication).
              for (const [descriptorHash, candidateLocators] of passCandidates) {
                  const selectedLocator = candidateLocators.find(locator => allPackages.has(locator.locatorHash));
                  if (!selectedLocator)
                      continue;
                  passResolutions.set(descriptorHash, selectedLocator);
                  passCandidates.delete(descriptorHash);
              }
              // All entries that remain in "passCandidates" are from descriptors that
              // we haven't been able to resolve in the first place. We'll now configure
              // our SAT solver so that it can figure it out for us. To do this, we
              // simply add a constraint for each descriptor that lists all the
              // descriptors it would accept. We don't have to check whether the
              // locators obtained have already been selected, because if they were the
              // would have been resolved in the previous step (we never backtrace to
              // try to find better solutions, it would be a too expensive process - we
              // just want to get an acceptable solution, not the very best one).
              if (passCandidates.size > 0) {
                  const solver = new logic_solver_1.default.Solver();
                  for (const candidateLocators of passCandidates.values())
                      solver.require(logic_solver_1.default.or(...candidateLocators.map(locator => locator.locatorHash)));
                  let remainingSolutions = 100;
                  let solution;
                  let bestSolution = null;
                  let bestScore = Infinity;
                  while (remainingSolutions > 0 && (solution = solver.solve()) !== null) {
                      const trueVars = solution.getTrueVars();
                      solver.forbid(solution.getFormula());
                      if (trueVars.length < bestScore) {
                          bestSolution = trueVars;
                          bestScore = trueVars.length;
                      }
                      remainingSolutions -= 1;
                  }
                  if (!bestSolution)
                      throw new Error(`Assertion failed: No resolution found by the SAT solver`);
                  const solutionSet = new Set(bestSolution);
                  for (const [descriptorHash, candidateLocators] of passCandidates.entries()) {
                      const selectedLocator = candidateLocators.find(locator => solutionSet.has(locator.locatorHash));
                      if (!selectedLocator)
                          throw new Error(`Assertion failed: The descriptor should have been solved during the previous step`);
                      passResolutions.set(descriptorHash, selectedLocator);
                      passCandidates.delete(descriptorHash);
                  }
              }
              // We now iterate over the locators we've got and, for each of them that
              // hasn't been seen before, we fetch its dependency list and schedule
              // them for the next cycle.
              const newLocators = Array.from(passResolutions.values()).filter(locator => {
                  return !allPackages.has(locator.locatorHash);
              });
              const newPackages = new Map(await Promise.all(newLocators.map(async (locator) => {
                  let pkg = await miscUtils.prettifyAsyncErrors(async () => {
                      return await resolver.resolve(locator, resolverOptions);
                  }, message => {
                      return `${structUtils.prettyLocator(this.configuration, locator)}: ${message}`;
                  });
                  if (!structUtils.areLocatorsEqual(locator, pkg))
                      throw new Error(`Assertion failed: The locator cannot be changed by the resolver (went from ${structUtils.prettyLocator(this.configuration, locator)} to ${structUtils.prettyLocator(this.configuration, pkg)})`);
                  const rawDependencies = pkg.dependencies;
                  const rawPeerDependencies = pkg.peerDependencies;
                  const dependencies = pkg.dependencies = new Map();
                  const peerDependencies = pkg.peerDependencies = new Map();
                  for (const descriptor of miscUtils.sortMap(rawDependencies.values(), descriptor => structUtils.stringifyIdent(descriptor))) {
                      const normalizedDescriptor = resolver.bindDescriptor(descriptor, locator, resolverOptions);
                      dependencies.set(normalizedDescriptor.identHash, normalizedDescriptor);
                  }
                  for (const descriptor of miscUtils.sortMap(rawPeerDependencies.values(), descriptor => structUtils.stringifyIdent(descriptor)))
                      peerDependencies.set(descriptor.identHash, descriptor);
                  return [pkg.locatorHash, pkg];
              })));
              // Now that the resolution is finished, we can finally insert the data
              // stored inside our pass stores into the resolution ones (we now have
              // the guarantee that they'll always be inserted into in the same order,
              // since mustBeResolved is stable regardless of the order in which the
              // resolvers return)
              const haveBeenResolved = mustBeResolved;
              mustBeResolved = new Set();
              for (const descriptorHash of haveBeenResolved) {
                  const locator = passResolutions.get(descriptorHash);
                  if (!locator)
                      throw new Error(`Assertion failed: The locator should have been registered`);
                  allResolutions.set(descriptorHash, locator.locatorHash);
                  const pkg = newPackages.get(locator.locatorHash);
                  if (!pkg)
                      continue;
                  allPackages.set(pkg.locatorHash, pkg);
                  for (const descriptor of pkg.dependencies.values()) {
                      allDescriptors.set(descriptor.descriptorHash, descriptor);
                      mustBeResolved.add(descriptor.descriptorHash);
                      // We must check and make sure that the descriptor didn't get aliased
                      // to something else
                      const aliasHash = this.resolutionAliases.get(descriptor.descriptorHash);
                      if (aliasHash === undefined)
                          continue;
                      // It doesn't cost us much to support the case where a descriptor is
                      // equal to its own alias (which should mean "no alias")
                      if (descriptor.descriptorHash === aliasHash)
                          continue;
                      const alias = this.storedDescriptors.get(aliasHash);
                      if (!alias)
                          throw new Error(`Assertion failed: The alias should have been registered`);
                      // If it's already been "resolved" (in reality it will be the temporary
                      // resolution we've set in the next few lines) we simply must skip it
                      if (allResolutions.has(descriptor.descriptorHash))
                          continue;
                      // Temporarily set an invalid resolution so that it won't be resolved
                      // multiple times if it is found multiple times in the dependency
                      // tree (this is only temporary, we will replace it by the actual
                      // resolution after we've finished resolving everything)
                      allResolutions.set(descriptor.descriptorHash, `temporary`);
                      // We can now replace the descriptor by its alias in the list of
                      // descriptors that must be resolved
                      mustBeResolved.delete(descriptor.descriptorHash);
                      mustBeResolved.add(aliasHash);
                      allDescriptors.set(aliasHash, alias);
                      haveBeenAliased.add(descriptor.descriptorHash);
                  }
              }
          }
          // Each package that should have been resolved but was skipped because it
          // was aliased will now see the resolution for its alias propagated to it
          while (haveBeenAliased.size > 0) {
              let hasChanged = false;
              for (const descriptorHash of haveBeenAliased) {
                  const descriptor = allDescriptors.get(descriptorHash);
                  if (!descriptor)
                      throw new Error(`Assertion failed: The descriptor should have been registered`);
                  const aliasHash = this.resolutionAliases.get(descriptorHash);
                  if (aliasHash === undefined)
                      throw new Error(`Assertion failed: The descriptor should have an alias`);
                  const resolution = allResolutions.get(aliasHash);
                  if (resolution === undefined)
                      throw new Error(`Assertion failed: The resolution should have been registered`);
                  // The following can happen if a package gets aliased to another package
                  // that's itself aliased - in this case we just process all those we can
                  // do, then make new passes until everything is resolved
                  if (resolution === `temporary`)
                      continue;
                  haveBeenAliased.delete(descriptorHash);
                  allResolutions.set(descriptorHash, resolution);
                  hasChanged = true;
              }
              if (!hasChanged) {
                  throw new Error(`Alias loop detected`);
              }
          }
          // In this step we now create virtual packages for each package with at
          // least one peer dependency. We also use it to search for the alias
          // descriptors that aren't depended upon by anything and can be safely
          // pruned.
          const volatileDescriptors = new Set(this.resolutionAliases.values());
          const optionalBuilds = new Set(allPackages.keys());
          applyVirtualResolutionMutations({
              project: this,
              volatileDescriptors,
              optionalBuilds,
              allDescriptors,
              allResolutions,
              allPackages,
              report,
          });
          // All descriptors still referenced within the volatileDescriptors set are
          // descriptors that aren't depended upon by anything in the dependency tree.
          for (const descriptorHash of volatileDescriptors) {
              allDescriptors.delete(descriptorHash);
              allResolutions.delete(descriptorHash);
          }
          // Import the dependencies for each resolved workspaces into their own
          // Workspace instance.
          for (const workspace of this.workspaces) {
              const pkg = allPackages.get(workspace.anchoredLocator.locatorHash);
              if (!pkg)
                  throw new Error(`Assertion failed: Expected workspace to have been resolved`);
              workspace.dependencies = new Map(pkg.dependencies);
          }
          // Everything is done, we can now update our internal resolutions to
          // reference the new ones
          this.storedResolutions = allResolutions;
          this.storedDescriptors = allDescriptors;
          this.storedPackages = allPackages;
          this.optionalBuilds = optionalBuilds;
      }
      async fetchEverything({ cache, report, fetcher: userFetcher }) {
          const fetcher = userFetcher || this.configuration.makeFetcher();
          const fetcherOptions = { checksums: this.storedChecksums, project: this, cache, fetcher, report };
          const locatorHashes = miscUtils.sortMap(this.storedResolutions.values(), [(locatorHash) => {
                  const pkg = this.storedPackages.get(locatorHash);
                  if (!pkg)
                      throw new Error(`Assertion failed: The locator should have been registered`);
                  return structUtils.stringifyLocator(pkg);
              }]);
          const limit = p_limit_1.default(5);
          let firstError = false;
          await Promise.all(locatorHashes.map(locatorHash => limit(async () => {
              const pkg = this.storedPackages.get(locatorHash);
              if (!pkg)
                  throw new Error(`Assertion failed: The locator should have been registered`);
              let fetchResult;
              try {
                  fetchResult = await fetcher.fetch(pkg, fetcherOptions);
              }
              catch (error) {
                  error.message = `${structUtils.prettyLocator(this.configuration, pkg)}: ${error.message}`;
                  report.reportExceptionOnce(error);
                  firstError = error;
                  return;
              }
              if (fetchResult.checksum)
                  this.storedChecksums.set(pkg.locatorHash, fetchResult.checksum);
              else
                  this.storedChecksums.delete(pkg.locatorHash);
              if (fetchResult.releaseFs) {
                  fetchResult.releaseFs();
              }
          })));
          if (firstError) {
              throw firstError;
          }
      }
      async linkEverything({ cache, report, inlineBuilds = this.configuration.get(`enableInlineBuilds`) }) {
          const fetcher = this.configuration.makeFetcher();
          const fetcherOptions = { checksums: this.storedChecksums, project: this, cache, fetcher, report };
          const linkers = this.configuration.getLinkers();
          const linkerOptions = { project: this, report };
          const installers = new Map(linkers.map(linker => {
              return [linker, linker.makeInstaller(linkerOptions)];
          }));
          const packageLinkers = new Map();
          const packageLocations = new Map();
          const packageBuildDirectives = new Map();
          // Step 1: Installing the packages on the disk
          for (const pkg of this.storedPackages.values()) {
              const linker = linkers.find(linker => linker.supportsPackage(pkg, linkerOptions));
              if (!linker)
                  throw new Report_1.ReportError(Report_1.MessageName.LINKER_NOT_FOUND, `${structUtils.prettyLocator(this.configuration, pkg)} isn't supported by any available linker`);
              const installer = installers.get(linker);
              if (!installer)
                  throw new Error(`Assertion failed: The installer should have been registered`);
              const fetchResult = await fetcher.fetch(pkg, fetcherOptions);
              let installStatus;
              try {
                  installStatus = await installer.installPackage(pkg, fetchResult);
              }
              finally {
                  if (fetchResult.releaseFs) {
                      fetchResult.releaseFs();
                  }
              }
              packageLinkers.set(pkg.locatorHash, linker);
              packageLocations.set(pkg.locatorHash, installStatus.packageLocation);
              if (installStatus.buildDirective) {
                  packageBuildDirectives.set(pkg.locatorHash, installStatus.buildDirective);
              }
          }
          // Step 2: Link packages together
          const externalDependents = new Map();
          for (const pkg of this.storedPackages.values()) {
              const packageLinker = packageLinkers.get(pkg.locatorHash);
              if (!packageLinker)
                  throw new Error(`Assertion failed: The linker should have been found`);
              const installer = installers.get(packageLinker);
              if (!installer)
                  throw new Error(`Assertion failed: The installer should have been registered`);
              const packageLocation = packageLocations.get(pkg.locatorHash);
              if (!packageLocation)
                  throw new Error(`Assertion failed: The package (${structUtils.prettyLocator(this.configuration, pkg)}) should have been registered`);
              const internalDependencies = [];
              for (const descriptor of pkg.dependencies.values()) {
                  const resolution = this.storedResolutions.get(descriptor.descriptorHash);
                  if (!resolution)
                      throw new Error(`Assertion failed: The resolution (${structUtils.prettyDescriptor(this.configuration, descriptor)}) should have been registered`);
                  const dependency = this.storedPackages.get(resolution);
                  if (!dependency)
                      throw new Error(`Assertion failed: The package (${resolution}, resolved from ${structUtils.prettyDescriptor(this.configuration, descriptor)}) should have been registered`);
                  const dependencyLinker = packageLinkers.get(resolution);
                  if (!dependencyLinker)
                      throw new Error(`Assertion failed: The package (${resolution}, resolved from ${structUtils.prettyDescriptor(this.configuration, descriptor)}) should have been registered`);
                  if (dependencyLinker === packageLinker) {
                      internalDependencies.push([descriptor, dependency]);
                  }
                  else {
                      let externalEntry = externalDependents.get(resolution);
                      if (!externalEntry)
                          externalDependents.set(resolution, externalEntry = []);
                      externalEntry.push(packageLocation);
                  }
              }
              await installer.attachInternalDependencies(pkg, internalDependencies);
          }
          for (const [locatorHash, dependentPaths] of externalDependents) {
              const pkg = this.storedPackages.get(locatorHash);
              if (!pkg)
                  throw new Error(`Assertion failed: The package should have been registered`);
              const packageLinker = packageLinkers.get(pkg.locatorHash);
              if (!packageLinker)
                  throw new Error(`Assertion failed: The linker should have been found`);
              const installer = installers.get(packageLinker);
              if (!installer)
                  throw new Error(`Assertion failed: The installer should have been registered`);
              await installer.attachExternalDependents(pkg, dependentPaths);
          }
          // Step 3: Inform our linkers that they should have all the info needed
          for (const installer of installers.values())
              await installer.finalizeInstall();
          // Step 4: Build the packages in multiple steps
          const readyPackages = new Set(this.storedPackages.keys());
          const buildablePackages = new Set(packageBuildDirectives.keys());
          for (const locatorHash of buildablePackages)
              readyPackages.delete(locatorHash);
          // We'll use this function is order to compute a hash for each package
          // that exposes a build directive. If the hash changes compared to the
          // previous run, the package is rebuilt. This has the advantage of making
          // the rebuilds much more predictable than before, and to give us the tools
          // later to improve this further by explaining *why* a rebuild happened.
          const getBuildHash = (locator) => {
              const hash = crypto_1.createHmac(`sha512`, `berry`);
              const traverse = (locatorHash, seenPackages = new Set()) => {
                  hash.update(locatorHash);
                  if (!seenPackages.has(locatorHash))
                      seenPackages.add(locatorHash);
                  else
                      return;
                  const pkg = this.storedPackages.get(locatorHash);
                  if (!pkg)
                      throw new Error(`Assertion failed: The package should have been registered`);
                  for (const dependency of pkg.dependencies.values()) {
                      const resolution = this.storedResolutions.get(dependency.descriptorHash);
                      if (!resolution)
                          throw new Error(`Assertion failed: The resolution (${structUtils.prettyDescriptor(this.configuration, dependency)}) should have been registered`);
                      traverse(resolution, new Set(seenPackages));
                  }
              };
              traverse(locator.locatorHash);
              return hash.digest(`hex`);
          };
          const bstatePath = this.configuration.get(`bstatePath`);
          const bstate = fslib_1.xfs.existsSync(bstatePath)
              ? parsers_1.parseSyml(await fslib_1.xfs.readFilePromise(bstatePath, `utf8`))
              : {};
          // We reconstruct the build state from an empty object because we want to
          // remove the state from packages that got removed
          const nextBState = {};
          while (buildablePackages.size > 0) {
              const savedSize = buildablePackages.size;
              const buildPromises = [];
              for (const locatorHash of buildablePackages) {
                  const pkg = this.storedPackages.get(locatorHash);
                  if (!pkg)
                      throw new Error(`Assertion failed: The package should have been registered`);
                  let isBuildable = true;
                  for (const dependency of pkg.dependencies.values()) {
                      const resolution = this.storedResolutions.get(dependency.descriptorHash);
                      if (!resolution)
                          throw new Error(`Assertion failed: The resolution (${structUtils.prettyDescriptor(this.configuration, dependency)}) should have been registered`);
                      if (buildablePackages.has(resolution)) {
                          isBuildable = false;
                          break;
                      }
                  }
                  // Wait until all dependencies of the current package have been built
                  // before trying to build it (since it might need them to build itself)
                  if (!isBuildable)
                      continue;
                  buildablePackages.delete(locatorHash);
                  const buildHash = getBuildHash(pkg);
                  // No need to rebuild the package if its hash didn't change
                  if (Object.prototype.hasOwnProperty.call(bstate, pkg.locatorHash) && bstate[pkg.locatorHash] === buildHash) {
                      nextBState[pkg.locatorHash] = buildHash;
                      continue;
                  }
                  if (Object.prototype.hasOwnProperty.call(bstate, pkg.locatorHash))
                      report.reportInfo(Report_1.MessageName.MUST_REBUILD, `${structUtils.prettyLocator(this.configuration, pkg)} must be rebuilt because its dependency tree changed`);
                  else
                      report.reportInfo(Report_1.MessageName.MUST_BUILD, `${structUtils.prettyLocator(this.configuration, pkg)} must be built because it never did before or the last one failed`);
                  const buildDirective = packageBuildDirectives.get(pkg.locatorHash);
                  if (!buildDirective)
                      throw new Error(`Assertion failed: The build directive should have been registered`);
                  buildPromises.push((async () => {
                      for (const [buildType, scriptName] of buildDirective) {
                          const logFile = fslib_1.NodeFS.toPortablePath(tmp_1.tmpNameSync({
                              prefix: `buildfile-`,
                              postfix: `.log`,
                          }));
                          const stdin = null;
                          let stdout;
                          let stderr;
                          if (inlineBuilds) {
                              stdout = report.createStreamReporter(`${structUtils.prettyLocator(this.configuration, pkg)} ${this.configuration.format(`STDOUT`, `green`)}`);
                              stderr = report.createStreamReporter(`${structUtils.prettyLocator(this.configuration, pkg)} ${this.configuration.format(`STDERR`, `red`)}`);
                          }
                          else {
                              stdout = fslib_1.xfs.createWriteStream(logFile);
                              stderr = stdout;
                              stdout.write(`# This file contains the result of Yarn building a package (${structUtils.stringifyLocator(pkg)})\n`);
                              switch (buildType) {
                                  case Installer_1.BuildType.SCRIPT:
                                      {
                                          stdout.write(`# Script name: ${scriptName}\n`);
                                      }
                                      break;
                                  case Installer_1.BuildType.SHELLCODE:
                                      {
                                          stdout.write(`# Script code: ${scriptName}\n`);
                                      }
                                      break;
                              }
                              stdout.write(`\n`);
                          }
                          let exitCode;
                          try {
                              switch (buildType) {
                                  case Installer_1.BuildType.SCRIPT:
                                      {
                                          exitCode = await scriptUtils.executePackageScript(pkg, scriptName, [], { project: this, stdin, stdout, stderr });
                                      }
                                      break;
                                  case Installer_1.BuildType.SHELLCODE:
                                      {
                                          exitCode = await scriptUtils.executePackageShellcode(pkg, scriptName, [], { project: this, stdin, stdout, stderr });
                                      }
                                      break;
                              }
                          }
                          catch (error) {
                              stderr.write(error.stack);
                              exitCode = 1;
                          }
                          if (exitCode === 0) {
                              nextBState[pkg.locatorHash] = buildHash;
                              continue;
                          }
                          const buildMessage = `${structUtils.prettyLocator(this.configuration, pkg)} couldn't be built successfully (exit code ${exitCode}, logs can be found here: ${logFile})`;
                          if (!this.optionalBuilds.has(pkg.locatorHash)) {
                              report.reportError(Report_1.MessageName.BUILD_FAILED, buildMessage);
                              break;
                          }
                          nextBState[pkg.locatorHash] = buildHash;
                          report.reportInfo(Report_1.MessageName.BUILD_FAILED, buildMessage);
                      }
                  })());
              }
              await Promise.all(buildPromises);
              // If we reach this code, it means that we have circular dependencies
              // somewhere. Worst, it means that the circular dependencies both have
              // build scripts, making them unsatisfiable.
              if (savedSize === buildablePackages.size) {
                  const prettyLocators = Array.from(buildablePackages).map(locatorHash => {
                      const pkg = this.storedPackages.get(locatorHash);
                      if (!pkg)
                          throw new Error(`Assertion failed: The package should have been registered`);
                      return structUtils.prettyLocator(this.configuration, pkg);
                  }).join(`, `);
                  report.reportError(Report_1.MessageName.CYCLIC_DEPENDENCIES, `Some packages have circular dependencies that make their build order unsatisfiable - as a result they won't be built (affected packages are: ${prettyLocators})`);
                  break;
              }
          }
          // We can now generate the bstate file, which will allow us to "remember"
          // what's the dependency tree subset that we used to build a specific
          // package (and avoid rebuilding it later if it didn't change).
          const bstateData = Object.entries(nextBState).map(([hash, name]) => {
              const locatorHash = hash;
              const pkg = this.storedPackages.get(locatorHash);
              if (!pkg)
                  throw new Error(`Assertion failed: The package should have been registered`);
              return [structUtils.stringifyLocator(pkg), hash, name];
          });
          if (bstateData.length > 0) {
              let bstateFile = `# Warning: This file is automatically generated. Removing it is fine, but will\n# cause all your builds to become invalidated.\n`;
              for (const [locatorString, locatorHash, buildHash] of miscUtils.sortMap(bstateData, [d => d[0], d => d[1]])) {
                  bstateFile += `\n`;
                  bstateFile += `# ${locatorString}\n`;
                  bstateFile += `${JSON.stringify(locatorHash)}:\n`;
                  bstateFile += `  ${buildHash}\n`;
              }
              await fslib_1.xfs.mkdirpPromise(fslib_1.ppath.dirname(bstatePath));
              await fslib_1.xfs.changeFilePromise(bstatePath, bstateFile);
          }
          else {
              await fslib_1.xfs.removePromise(bstatePath);
          }
      }
      async install(opts) {
          const validationErrors = [];
          for (const workspace of this.workspaces) {
              for (const manifestError of workspace.manifest.errors) {
                  const workspaceName = structUtils.prettyWorkspace(this.configuration, workspace);
                  validationErrors.push(`${workspaceName}: ${manifestError.message}`);
              }
          }
          if (validationErrors.length > 0) {
              await opts.report.startTimerPromise(`Validation step`, async () => {
                  for (const validationError of validationErrors) {
                      opts.report.reportWarning(Report_1.MessageName.INVALID_MANIFEST, validationError);
                  }
              });
          }
          await opts.report.startTimerPromise(`Resolution step`, async () => {
              // If we operate with a frozen lockfile, we take a snapshot of it to later make sure it didn't change
              const initialLockfile = opts.immutable ? this.generateLockfile() : null;
              await this.resolveEverything(opts);
              if (opts.immutable && this.generateLockfile() !== initialLockfile) {
                  throw new Report_1.ReportError(Report_1.MessageName.FROZEN_LOCKFILE_EXCEPTION, `The lockfile would have been modified by this install, which is explicitly forbidden`);
              }
          });
          await opts.report.startTimerPromise(`Fetch step`, async () => {
              await this.fetchEverything(opts);
              await this.cacheCleanup(opts);
          });
          await this.persist();
          await opts.report.startTimerPromise(`Link step`, async () => {
              await this.linkEverything(opts);
          });
          await this.configuration.triggerHook(hooks => {
              return hooks.afterAllInstalled;
          }, this);
      }
      generateLockfile() {
          // We generate the data structure that will represent our lockfile. To do this, we create a
          // reverse lookup table, where the key will be the resolved locator and the value will be a set
          // of all the descriptors that resolved to it. Then we use it to construct an optimized version
          // if the final object.
          const reverseLookup = new Map();
          for (const [descriptorHash, locatorHash] of this.storedResolutions.entries()) {
              let descriptorHashes = reverseLookup.get(locatorHash);
              if (!descriptorHashes)
                  reverseLookup.set(locatorHash, descriptorHashes = new Set());
              descriptorHashes.add(descriptorHash);
          }
          const optimizedLockfile = {};
          optimizedLockfile[`__metadata`] = {
              version: LOCKFILE_VERSION,
          };
          for (const [locatorHash, descriptorHashes] of reverseLookup.entries()) {
              const pkg = this.storedPackages.get(locatorHash);
              if (!pkg)
                  throw new Error(`Assertion failed: The package should have been registered`);
              // Virtual packages are not persisted into the lockfile: they need to be
              // recomputed at runtime through "resolveEverything". We do this (instead
              // of "forgetting" them when reading the file like for "link:" locators
              // or workspaces) because it would otherwise be super annoying to manually
              // change the resolutions from a lockfile (since you'd need to also update
              // all its virtual instances). Also it would take a bunch of useless space.
              if (structUtils.isVirtualLocator(pkg))
                  continue;
              const descriptors = [];
              for (const descriptorHash of descriptorHashes) {
                  const descriptor = this.storedDescriptors.get(descriptorHash);
                  if (!descriptor)
                      throw new Error(`Assertion failed: The descriptor should have been registered`);
                  descriptors.push(descriptor);
              }
              const key = descriptors.map(descriptor => {
                  return structUtils.stringifyDescriptor(descriptor);
              }).sort().join(`, `);
              const manifest = new Manifest_1.Manifest();
              manifest.version = pkg.linkType === types_1.LinkType.HARD
                  ? pkg.version
                  : `0.0.0-use.local`;
              manifest.languageName = pkg.languageName;
              manifest.dependencies = new Map(pkg.dependencies);
              manifest.peerDependencies = new Map(pkg.peerDependencies);
              manifest.dependenciesMeta = new Map(pkg.dependenciesMeta);
              manifest.peerDependenciesMeta = new Map(pkg.peerDependenciesMeta);
              manifest.bin = new Map(pkg.bin);
              // Since we don't keep the virtual packages in the lockfile, we must make
              // sure we don't reference them within the dependencies of our packages
              for (const [identHash, descriptor] of manifest.dependencies)
                  if (structUtils.isVirtualDescriptor(descriptor))
                      manifest.dependencies.set(identHash, structUtils.devirtualizeDescriptor(descriptor));
              optimizedLockfile[key] = Object.assign({}, manifest.exportTo({}, {
                  compatibilityMode: false,
              }), { linkType: pkg.linkType, resolution: structUtils.stringifyLocator(pkg), checksum: this.storedChecksums.get(pkg.locatorHash) });
          }
          const header = `${[
              `# This file is generated by running "yarn install" inside your project.\n`,
              `# Manual changes might be lost - proceed with caution!\n`,
          ].join(``)}\n`;
          return header + parsers_1.stringifySyml(optimizedLockfile);
      }
      async persistLockfile() {
          const lockfilePath = fslib_1.ppath.join(this.cwd, this.configuration.get(`lockfileFilename`));
          const lockfileContent = this.generateLockfile();
          await fslib_1.xfs.changeFilePromise(lockfilePath, lockfileContent);
      }
      async persist() {
          await this.persistLockfile();
          for (const workspace of this.workspacesByCwd.values()) {
              await workspace.persistManifest();
          }
      }
      async cacheCleanup({ cache, report }) {
          const PRESERVED_FILES = new Set([
              `.gitignore`,
          ]);
          if (!fslib_1.xfs.existsSync(cache.cwd))
              return;
          if (!folderUtils_1.isFolderInside(cache.cwd, this.cwd))
              return;
          for (const entry of await fslib_1.xfs.readdirPromise(cache.cwd)) {
              if (PRESERVED_FILES.has(entry))
                  continue;
              const entryPath = fslib_1.ppath.resolve(cache.cwd, entry);
              if (cache.markedFiles.has(entryPath))
                  continue;
              if (cache.immutable) {
                  report.reportError(Report_1.MessageName.IMMUTABLE_CACHE, `${fslib_1.ppath.basename(entryPath)} appears to be unused and would marked for deletion, but the cache is immutable`);
              }
              else {
                  report.reportInfo(Report_1.MessageName.UNUSED_CACHE_ENTRY, `${fslib_1.ppath.basename(entryPath)} appears to be unused - removing`);
                  await fslib_1.xfs.unlinkPromise(entryPath);
              }
          }
          cache.markedFiles.clear();
      }
  }
  exports.Project = Project;
  /**
   * This function is worth some documentation. It takes a set of packages,
   * traverses them all, and generates virtual packages for each package that
   * lists peer dependencies.
   *
   * We also take advantage of the tree traversal to detect which packages are
   * actually used and which have disappeared, and to know which packages truly
   * have an optional build (since a package may be optional in one part of the
   * tree but not another).
   */
  function applyVirtualResolutionMutations({ project, allDescriptors, allResolutions, allPackages, optionalBuilds = new Set(), volatileDescriptors = new Set(), report, tolerateMissingPackages = false, }) {
      const hasBeenTraversed = new Set();
      const resolutionStack = [];
      const reportStackOverflow = () => {
          const logFile = fslib_1.NodeFS.toPortablePath(tmp_1.tmpNameSync({
              prefix: `stacktrace-`,
              postfix: `.log`,
          }));
          const maxSize = String(resolutionStack.length + 1).length;
          const content = resolutionStack.map((locator, index) => {
              const prefix = `${index + 1}.`.padStart(maxSize, ` `);
              return `${prefix} ${structUtils.stringifyLocator(locator)}\n`;
          }).join(``);
          fslib_1.xfs.writeFileSync(logFile, content);
          throw new Report_1.ReportError(Report_1.MessageName.STACK_OVERFLOW_RESOLUTION, `Encountered a stack overflow when resolving peer dependencies; cf ${logFile}`);
      };
      const resolvePeerDependencies = (parentLocator, first, optional) => {
          resolutionStack.push(parentLocator);
          const result = resolvePeerDependenciesImpl(parentLocator, first, optional);
          resolutionStack.pop();
          return result;
      };
      const resolvePeerDependenciesImpl = (parentLocator, first, optional) => {
          if (hasBeenTraversed.has(parentLocator.locatorHash))
              return;
          hasBeenTraversed.add(parentLocator.locatorHash);
          if (!optional)
              optionalBuilds.delete(parentLocator.locatorHash);
          const parentPackage = allPackages.get(parentLocator.locatorHash);
          if (!parentPackage) {
              if (tolerateMissingPackages) {
                  return;
              }
              else {
                  throw new Error(`Assertion failed: The package (${structUtils.prettyLocator(project.configuration, parentLocator)}) should have been registered`);
              }
          }
          const firstPass = [];
          const secondPass = [];
          const thirdPass = [];
          const fourthPass = [];
          // During this first pass we virtualize the descriptors. This allows us
          // to reference them from their sibling without being order-dependent,
          // which is required to solve cases where packages with peer dependencies
          // have peer dependencies themselves.
          for (const descriptor of Array.from(parentPackage.dependencies.values())) {
              // We shouldn't virtualize the package if it was obtained through a peer
              // dependency (which can't be the case for workspaces when resolved
              // through their top-level)
              if (parentPackage.peerDependencies.has(descriptor.identHash) && !first)
                  continue;
              // Mark this package as being used (won't be removed from the lockfile)
              volatileDescriptors.delete(descriptor.descriptorHash);
              // Detect whether this package is being required
              let isOptional = optional;
              if (!isOptional) {
                  const dependencyMetaSet = parentPackage.dependenciesMeta.get(structUtils.stringifyIdent(descriptor));
                  if (typeof dependencyMetaSet !== `undefined`) {
                      const dependencyMeta = dependencyMetaSet.get(null);
                      if (typeof dependencyMeta !== `undefined` && dependencyMeta.optional) {
                          isOptional = true;
                      }
                  }
              }
              const resolution = allResolutions.get(descriptor.descriptorHash);
              if (!resolution) {
                  if (tolerateMissingPackages) {
                      continue;
                  }
                  else {
                      throw new Error(`Assertion failed: The resolution (${structUtils.prettyDescriptor(project.configuration, descriptor)}) should have been registered`);
                  }
              }
              const pkg = allPackages.get(resolution);
              if (!pkg)
                  throw new Error(`Assertion failed: The package (${resolution}, resolved from ${structUtils.prettyDescriptor(project.configuration, descriptor)}) should have been registered`);
              if (pkg.peerDependencies.size === 0) {
                  resolvePeerDependencies(pkg, false, isOptional);
                  continue;
              }
              let virtualizedDescriptor;
              let virtualizedPackage;
              const missingPeerDependencies = new Set();
              firstPass.push(() => {
                  virtualizedDescriptor = structUtils.virtualizeDescriptor(descriptor, parentLocator.locatorHash);
                  virtualizedPackage = structUtils.virtualizePackage(pkg, parentLocator.locatorHash);
                  parentPackage.dependencies.delete(descriptor.identHash);
                  parentPackage.dependencies.set(virtualizedDescriptor.identHash, virtualizedDescriptor);
                  allResolutions.set(virtualizedDescriptor.descriptorHash, virtualizedPackage.locatorHash);
                  allDescriptors.set(virtualizedDescriptor.descriptorHash, virtualizedDescriptor);
                  allPackages.set(virtualizedPackage.locatorHash, virtualizedPackage);
              });
              secondPass.push(() => {
                  for (const peerRequest of virtualizedPackage.peerDependencies.values()) {
                      let peerDescriptor = parentPackage.dependencies.get(peerRequest.identHash);
                      if (!peerDescriptor && structUtils.areIdentsEqual(parentLocator, peerRequest)) {
                          peerDescriptor = structUtils.convertLocatorToDescriptor(parentLocator);
                          allDescriptors.set(peerDescriptor.descriptorHash, peerDescriptor);
                          allResolutions.set(peerDescriptor.descriptorHash, parentLocator.locatorHash);
                      }
                      if (!peerDescriptor) {
                          if (!parentPackage.peerDependencies.has(peerRequest.identHash)) {
                              const peerDependencyMeta = virtualizedPackage.peerDependenciesMeta.get(structUtils.stringifyIdent(peerRequest));
                              if (report !== null && (!peerDependencyMeta || !peerDependencyMeta.optional)) {
                                  report.reportWarning(Report_1.MessageName.MISSING_PEER_DEPENDENCY, `${structUtils.prettyLocator(project.configuration, parentLocator)} doesn't provide ${structUtils.prettyDescriptor(project.configuration, peerRequest)} requested by ${structUtils.prettyLocator(project.configuration, pkg)}`);
                              }
                          }
                          peerDescriptor = structUtils.makeDescriptor(peerRequest, `missing:`);
                      }
                      virtualizedPackage.dependencies.set(peerDescriptor.identHash, peerDescriptor);
                      if (peerDescriptor.range === `missing:`) {
                          missingPeerDependencies.add(peerDescriptor.identHash);
                      }
                  }
                  // Since we've had to add new dependencies we need to sort them all over again
                  virtualizedPackage.dependencies = new Map(miscUtils.sortMap(virtualizedPackage.dependencies, ([identHash, descriptor]) => {
                      return structUtils.stringifyIdent(descriptor);
                  }));
              });
              thirdPass.push(() => {
                  resolvePeerDependencies(virtualizedPackage, false, isOptional);
              });
              fourthPass.push(() => {
                  for (const missingPeerDependency of missingPeerDependencies) {
                      virtualizedPackage.dependencies.delete(missingPeerDependency);
                  }
              });
          }
          const allPasses = [
              ...firstPass,
              ...secondPass,
              ...thirdPass,
              ...fourthPass,
          ];
          for (const fn of allPasses) {
              fn();
          }
      };
      try {
          for (const workspace of project.workspaces) {
              resolvePeerDependencies(workspace.anchoredLocator, true, false);
          }
      }
      catch (error) {
          if (error.name === `RangeError` && error.message === `Maximum call stack size exceeded`) {
              reportStackOverflow();
          }
          else {
              throw error;
          }
      }
  }


  /***/ }),
  /* 245 */
  /***/ (function(module, exports, __webpack_require__) {

  var MiniSat = __webpack_require__(246);
  var _ = __webpack_require__(248);
  var Logic;
  Logic = {};

  ////////// TYPE TESTERS


  // Set the `description` property of a tester function and return the function.
  var withDescription = function (description, tester) {
    tester.description = description;
    return tester;
  };

  // Create a function (x) => (x instanceof constructor), but possibly before
  // constructor is available.  For example, if Logic.Formula hasn't been
  // assigned yet, passing Logic for `obj` and "Formula" for `constructorName`
  // will still work.
  var lazyInstanceofTester = function (description, obj, constructorName) {
    return withDescription(description, function (x) {
      return x instanceof obj[constructorName];
    });
  };


  ///// PUBLIC TYPE TESTERS

  // All variables have a name and a number.  The number is mainly used
  // internally, and it's what's given to MiniSat.  Names and numbers
  // are interchangeable, which is convenient for doing manipulation
  // of terms in a way that works before or after variable names are
  // converted to numbers.

  // Term: a variable name or variable number, optionally
  // negated (meaning "boolean not").  For example,
  // `1`, `-1`, `"foo"`, or `"-foo"`.  All variables have
  // internal numbers that start at 1, so "foo" might be
  // variable number 1, for example.  Any number of leading
  // "-" will be parsed in the string form, but we try to
  // keep it to either one or zero of them.

  Logic.isNumTerm = withDescription('a NumTerm (non-zero integer)',
                                    function (x) {
                                      // 32-bit integer, but not 0
                                      return (x === (x | 0)) && x !== 0;
                                    });

  // NameTerm must not be empty, or just `-` characters, or look like a
  // number.  Specifically, it can't be zero or more `-` followed by
  // zero or more digits.
  Logic.isNameTerm = withDescription('a NameTerm (string)',
                                     function (x) {
                                       return (typeof x === 'string') &&
                                         ! /^-*[0-9]*$/.test(x);
                                     });

  Logic.isTerm = withDescription('a Term (appropriate string or number)',
                                 function (x) {
                                   return Logic.isNumTerm(x) ||
                                     Logic.isNameTerm(x);
                                 });

  // WholeNumber: a non-negative integer (0 is allowed)
  Logic.isWholeNumber = withDescription('a whole number (integer >= 0)',
                                        function (x) {
                                          return (x === (x | 0)) && x >= 0;
                                        });

  Logic.isFormula = lazyInstanceofTester('a Formula', Logic, 'Formula');
  Logic.isClause = lazyInstanceofTester('a Clause', Logic, 'Clause');
  Logic.isBits = lazyInstanceofTester('a Bits', Logic, 'Bits');

  ///// UNDOCUMENTED TYPE TESTERS

  Logic._isInteger = withDescription(
    'an integer', function (x) { return x === (x | 0); });

  Logic._isFunction = withDescription(
    'a Function', function (x) { return typeof x === 'function'; });

  Logic._isString = withDescription(
    'a String', function (x) { return typeof x === 'string'; });

  Logic._isArrayWhere = function (tester) {
    var description = 'an array';
    if (tester.description) {
      description += ' of ' + tester.description;
    }
    return withDescription(description, function (x) {
      if (! _.isArray(x)) {
        return false;
      } else {
        for (var i = 0; i < x.length; i++) {
          if (! tester(x[i])) {
            return false;
          }
        }
        return true;
      }
    });
  };

  Logic._isFormulaOrTerm = withDescription('a Formula or Term',
                                           function (x) {
                                             return Logic.isFormula(x) ||
                                               Logic.isTerm(x);
                                           });


  Logic._isFormulaOrTermOrBits = withDescription('a Formula, Term, or Bits',
                                                 function (x) {
                                                   return Logic.isFormula(x) ||
                                                     Logic.isBits(x) ||
                                                     Logic.isTerm(x);
                                                 });
  Logic._MiniSat = MiniSat; // Expose for testing and poking around

  // import the private testers from types.js
  var isInteger = Logic._isInteger;
  var isFunction = Logic._isFunction;
  var isString = Logic._isString;
  var isArrayWhere = Logic._isArrayWhere;
  var isFormulaOrTerm = Logic._isFormulaOrTerm;
  var isFormulaOrTermOrBits = Logic._isFormulaOrTermOrBits;

  Logic._assert = function (value, tester, description) {
    if (! tester(value)) {
      var displayValue = (typeof value === 'string' ? JSON.stringify(value) :
                          value);
      throw new Error(displayValue + " is not " +
                      (tester.description || description));
    }
  };

  // Call this as `if (assert) assertNumArgs(...)`
  var assertNumArgs = function (actual, expected, funcName) {
    if (actual !== expected) {
      throw new Error("Expected " + expected + " args in " + funcName +
                      ", got " + actual);
    }
  };

  // Call `assert` as: `if (assert) assert(...)`.
  // This local variable temporarily set to `null` inside
  // `Logic.disablingAssertions`.
  var assert = Logic._assert;

  // Like `if (assert) assert(...)` but usable from other files in the package.
  Logic._assertIfEnabled = function (value, tester, description) {
    if (assert) assert(value, tester, description);
  };

  // Disabling runtime assertions speeds up clause generation.  Assertions
  // are disabled when the local variable `assert` is null instead of
  // `Logic._assert`.
  Logic.disablingAssertions = function (f) {
    var oldAssert = assert;
    try {
      assert = null;
      return f();
    } finally {
      assert = oldAssert;
    }
  };

  // Back-compat.
  Logic._disablingTypeChecks = Logic.disablingAssertions;

  ////////////////////

  // Takes a Formula or Term, returns a Formula or Term.
  // Unlike other operators, if you give it a Term,
  // you will get a Term back (of the same type, NameTerm
  // or NumTerm).
  Logic.not = function (operand) {
    if (assert) assert(operand, isFormulaOrTerm);

    if (operand instanceof Logic.Formula) {
      return new Logic.NotFormula(operand);
    } else {
      // Term
      if (typeof operand === 'number') {
        return -operand;
      } else if (operand.charAt(0) === '-') {
        return operand.slice(1);
      } else {
        return '-' + operand;
      }
    }
  };

  Logic.NAME_FALSE = "$F";
  Logic.NAME_TRUE = "$T";
  Logic.NUM_FALSE = 1;
  Logic.NUM_TRUE = 2;

  Logic.TRUE = Logic.NAME_TRUE;
  Logic.FALSE = Logic.NAME_FALSE;

  // Abstract base class.  Subclasses are created using _defineFormula.
  Logic.Formula = function () {};

  Logic._defineFormula = function (constructor, typeName, methods) {
    if (assert) assert(constructor, isFunction);
    if (assert) assert(typeName, isString);

    constructor.prototype = new Logic.Formula();
    constructor.prototype.type = typeName;
    if (methods) {
      _.extend(constructor.prototype, methods);
    }
  };

  // Returns a list of Clauses that together require the Formula to be
  // true, or false (depending on isTrue; both cases must be
  // implemented).  A single Clause may also be returned.  The
  // implementation should call the termifier to convert terms and
  // formulas to NumTerms specific to a solver instance, and use them to
  // construct a Logic.Clause.
  Logic.Formula.prototype.generateClauses = function (isTrue, termifier) {
    throw new Error("Cannot generate this Formula; it must be expanded");
  };
  // All Formulas have a globally-unique id so that Solvers can track them.
  // It is assigned lazily.
  Logic.Formula._nextGuid = 1;
  Logic.Formula.prototype._guid = null;
  Logic.Formula.prototype.guid = function () {
    if (this._guid === null) {
      this._guid = Logic.Formula._nextGuid++;
    }
    return this._guid;
  };

  // A "clause" is a disjunction of terms, e.g. "A or B or (not C)",
  // which we write "A v B v -C".  Logic.Clause is mainly an internal
  // Solver data structure, which is the final result of formula
  // generation and mapping variable names to numbers, before passing
  // the clauses to MiniSat.
  Logic.Clause = function (/*formulaOrArray, ...*/) {
    var terms = _.flatten(arguments);
    if (assert) assert(terms, isArrayWhere(Logic.isNumTerm));

    this.terms = terms; // immutable [NumTerm]
  };

  // Returns a new Clause with the extra term or terms appended
  Logic.Clause.prototype.append = function (/*formulaOrArray, ...*/) {
    return new Logic.Clause(this.terms.concat(_.flatten(arguments)));
  };

  var FormulaInfo = function () {
    // We generate a variable when a Formula is used.
    this.varName = null; // string name of variable
    this.varNum = null; // number of variable (always positive)

    // A formula variable that is used only in the positive or only
    // in the negative doesn't need the full set of clauses that
    // establish a bidirectional implication between the formula and the
    // variable.  For example, in the formula `Logic.or("A", "B")`, with the
    // formula variable `$or1`, the full set of clauses is `A v B v
    // -$or1; -A v $or1; -B v $or1`.  If both `$or1` and `-$or1` appear
    // elsewhere in the set of clauses, then all three of these clauses
    // are required.  However, somewhat surprisingly, if only `$or1` appears,
    // then only the first is necessary.  If only `-$or1` appears, then only
    // the second and third are necessary.
    //
    // Suppose the formula A v B is represented by the variable $or1,
    // and $or1 is only used positively. It's important that A v B being
    // false forces $or1 to be false, so that when $or1 is used it has
    // the appropriate effect. For example, if we have the clause $or1 v
    // C, then A v B being false should force $or1 to be false, which
    // forces C to be true. So we generate the clause A v B v
    // -$or1. (The implications of this clause are: If A v B is false,
    // $or1 must be false. If $or1 is true, A v B must be true.)
    //
    // However, in the case where A v B is true, we don't actually
    // need to insist that the solver set $or1 to true, as long as we
    // are ok with relaxing the relationship between A v B and $or1
    // and getting a "wrong" value for $or1 in the solution. Suppose
    // the solver goes to work and at some point determines A v B to
    // be true. It could set $or1 to true, satisfying all the clauses
    // where it appears, or it could set $or1 to false, which only
    // constrains the solution space and doesn't open up any new
    // solutions for other variables. If the solver happens to find a
    // solution where A v B is true and $or1 is false, we know there
    // is a similar solution that makes all the same assignments
    // except it assigns $or1 to true.
    //
    // If a formula is used only negatively, a similar argument applies
    // but with signs flipped, and if it is used both positively and
    // negatively, both kinds of clauses must be generated.
    //
    // See the mention of "polarity" in the MiniSat+ paper
    // (http://minisat.se/downloads/MiniSat+.pdf).
    //
    // These flags are set when generation has been done for the positive
    // case or the negative case, so that we only generate each one once.
    this.occursPositively = false;
    this.occursNegatively = false;

    // If a Formula has been directly required or forbidden, we can
    // replace it by TRUE or FALSE in subsequent clauses.  Track the
    // information here.
    this.isRequired = false;
    this.isForbidden = false;
  };


  // The "termifier" interface is provided to a Formula's
  // generateClauses method, which must use it to generate Clause
  // objects.
  //
  // The reason for this approach is that it gives the Formula control
  // over the clauses returned, but it gives the Solver control over
  // Formula generation.
  Logic.Termifier = function (solver) {
    this.solver = solver;
  };

  // The main entry point, the `clause` method takes a list of
  // FormulaOrTerms and converts it to a Clause containing NumTerms, *by
  // replacing Formulas with their variables*, creating the variable if
  // necessary.  For example, if an OrFormula is represented by the
  // variable `$or1`, it will be replaced by the numeric version of
  // `$or1` to make the Clause.  When the Clause is actually used, it
  // will trigger generation of the clauses that relate `$or1` to the
  // operands of the OrFormula.
  Logic.Termifier.prototype.clause = function (/*args*/) {
    var self = this;
    var formulas = _.flatten(arguments);
    if (assert) assert(formulas, isArrayWhere(isFormulaOrTerm));

    return new Logic.Clause(_.map(formulas, function (f) {
      return self.term(f);
    }));
  };

  // The `term` method performs the mapping from FormulaOrTerm to
  // NumTerm.  It's called by `clause` and could be called directly
  // from a Formula's generateClauses if it was useful for some
  // reason.
  Logic.Termifier.prototype.term = function (formula) {
    return this.solver._formulaToTerm(formula);
  };

  // The `generate` method generates clauses for a Formula (or
  // Term).  It should be used carefully, because it works quite
  // differently from passing a Formula into `clause`, which is the
  // normal way for one Formula to refer to another.  When you use a
  // Formula in `clause`, it is replaced by the Formula's variable,
  // and the Solver handles generating the Formula's clauses once.
  // When you use `generate`, this system is bypassed, and the
  // Formula's generateClauses method is called pretty much directly,
  // returning the array of Clauses.
  Logic.Termifier.prototype.generate = function (isTrue, formula) {
    return this.solver._generateFormula(isTrue, formula, this);
  };


  Logic.Solver = function () {
    var self = this;

    self.clauses = []; // mutable [Clause]
    self._num2name = [null]; // no 0th var
    self._name2num = {}; // (' '+vname) -> vnum

    // true and false
    var F = self.getVarNum(Logic.NAME_FALSE, false, true); // 1
    var T = self.getVarNum(Logic.NAME_TRUE, false, true); // 2
    if (F !== Logic.NUM_FALSE || T !== Logic.NUM_TRUE) {
      throw new Error("Assertion failure: $T and $F have wrong numeric value");
    }
    self._F_used = false;
    self._T_used = false;
    // It's important that these clauses are elements 0 and 1
    // of the clauses array, so that they can optionally be stripped
    // off.  For example, _clauseData takes advantage of this fact.
    self.clauses.push(new Logic.Clause(-Logic.NUM_FALSE));
    self.clauses.push(new Logic.Clause(Logic.NUM_TRUE));

    self._formulaInfo = {}; // Formula guid -> FormulaInfo
    // For generating formula variables like "$or1", "$or2", "$and1", "$and2"
    self._nextFormulaNumByType = {}; // Formula type -> next var id
    // Map of Formulas whose info has `false` for either
    // `occursPositively` or `occursNegatively`
    self._ungeneratedFormulas = {}; // varNum -> Formula

    self._numClausesAddedToMiniSat = 0;
    self._unsat = false; // once true, no solution henceforth
    self._minisat = new MiniSat(); // this takes some time

    self._termifier = new Logic.Termifier(self);
  };

  // Get a var number for vname, assigning it a number if it is new.
  // Setting "noCreate" to true causes the function to return 0 instead of
  // creating a new variable.
  // Setting "_createInternals" to true grants the ability to create $ variables.
  Logic.Solver.prototype.getVarNum = function (vname, noCreate, _createInternals) {
    var key = ' '+vname;
    if (_.has(this._name2num, key)) {
      return this._name2num[key];
    } else if (noCreate) {
      return 0;
    } else {
      if (vname.charAt(0) === "$" && ! _createInternals) {
        throw new Error("Only generated variable names can start with $");
      }
      var vnum = this._num2name.length;
      this._name2num[key] = vnum;
      this._num2name.push(vname);
      return vnum;
    }
  };

  Logic.Solver.prototype.getVarName = function (vnum) {
    if (assert) assert(vnum, isInteger);

    var num2name = this._num2name;
    if (vnum < 1 || vnum >= num2name.length) {
      throw new Error("Bad variable num: " + vnum);
    } else {
      return num2name[vnum];
    }
  };

  // Converts a Term to a NumTerm (if it isn't already).  This is done
  // when a Formula creates Clauses for a Solver, since Clauses require
  // NumTerms.  NumTerms stay the same, while a NameTerm like "-foo"
  // might become (say) the number -3.  If a NameTerm names a variable
  // that doesn't exist, it is automatically created, unless noCreate
  // is passed, in which case 0 is returned instead.
  Logic.Solver.prototype.toNumTerm = function (t, noCreate) {
    var self = this;

    if (assert) assert(t, Logic.isTerm);

    if (typeof t === 'number') {
      return t;
    } else { // string
      var not = false;
      while (t.charAt(0) === '-') {
        t = t.slice(1);
        not = ! not;
      }
      var n = self.getVarNum(t, noCreate);
      if (! n) {
        return 0; // must be the noCreate case
      } else {
        return (not ? -n : n);
      }
    }
  };

  // Converts a Term to a NameTerm (if it isn't already).
  Logic.Solver.prototype.toNameTerm = function (t) {
    var self = this;

    if (assert) assert(t, Logic.isTerm);

    if (typeof t === 'string') {
      // canonicalize, removing leading "--"
      while (t.slice(0, 2) === '--') {
        t = t.slice(2);
      }
      return t;
    } else { // number
      var not = false;
      if (t < 0) {
        not = true;
        t = -t;
      }
      t = self.getVarName(t);
      if (not) {
        t = '-' + t;
      }
      return t;
    }
  };

  Logic.Solver.prototype._addClause = function (cls, _extraTerms,
                                                _useTermOverride) {
    var self = this;

    if (assert) assert(cls, Logic.isClause);

    var extraTerms = null;
    if (_extraTerms) {
      extraTerms = _extraTerms;
      if (assert) assert(extraTerms, isArrayWhere(Logic.isNumTerm));
    }

    var usedF = false;
    var usedT = false;

    var numRealTerms = cls.terms.length;
    if (extraTerms) {
      // extraTerms are added to the clause as is.  Formula variables in
      // extraTerms do not cause Formula clause generation, which is
      // necessary to implement Formula clause generation.
      cls = cls.append(extraTerms);
    }

    for (var i = 0; i < cls.terms.length; i++) {
      var t = cls.terms[i];
      var v = (t < 0) ? -t : t;
      if (v === Logic.NUM_FALSE) {
        usedF = true;
      } else if (v === Logic.NUM_TRUE) {
        usedT = true;
      } else if (v < 1 || v >= self._num2name.length) {
        throw new Error("Bad variable number: " + v);
      } else if (i < numRealTerms) {
        if (_useTermOverride) {
          _useTermOverride(t);
        } else {
          self._useFormulaTerm(t);
        }
      }
    }

    this._F_used = (this._F_used || usedF);
    this._T_used = (this._T_used || usedT);

    this.clauses.push(cls);
  };

  // When we actually use a Formula variable, generate clauses for it,
  // based on whether the usage is positive or negative.  For example,
  // if the Formula `Logic.or("X", "Y")` is represented by `$or1`, which
  // is variable number 5, then when you actually use 5 or -5 in a clause,
  // the clauses "X v Y v -5" (when you use 5) or "-X v 5; -Y v 5"
  // (when you use -5) will be generated.  The clause "X v Y v -5"
  // is equivalent to "5 => X v Y" (or -(X v Y) => -5), while the clauses
  // "-X v 5; -Y v 5" are equivalent to "-5 => -X; -5 => -Y" (or
  // "X => 5; Y => 5").

  Logic.Solver.prototype._useFormulaTerm = function (t, _addClausesOverride) {
    var self = this;
    if (assert) assert(t, Logic.isNumTerm);
    var v = (t < 0) ? -t : t;

    if (! _.has(self._ungeneratedFormulas, v)) {
      return;
    }

    // using a Formula's var; maybe have to generate clauses
    // for the Formula
    var formula = self._ungeneratedFormulas[v];
    var info = self._getFormulaInfo(formula);
    var positive = t > 0;

    // To avoid overflowing the JS stack, defer calls to addClause.
    // The way we get overflows is when Formulas are deeply nested
    // (which happens naturally when you call Logic.sum or
    // Logic.weightedSum on a long list of terms), which causes
    // addClause to call useFormulaTerm to call addClause, and so
    // on.  Approach:  The outermost useFormulaTerm keeps a list
    // of clauses to add, and then adds them in a loop using a
    // special argument to addClause that passes a special argument
    // to useFormulaTerm that causes those clauses to go into the
    // list too.  Code outside of `_useFormulaTerm` and `_addClause(s)`
    // does not have to pass these special arguments to call them.
    var deferredAddClauses = null;
    var addClauses;
    if (! _addClausesOverride) {
      deferredAddClauses = [];
      addClauses = function (clauses, extraTerms) {
        deferredAddClauses.push({clauses: clauses,
                                 extraTerms: extraTerms});
      };
    } else {
      addClauses = _addClausesOverride;
    }

    if (positive && ! info.occursPositively) {
      // generate clauses for the formula.
      // Eg, if we use variable `X` which represents the formula
      // `A v B`, add the clause `A v B v -X`.
      // By using the extraTerms argument to addClauses, we avoid
      // treating this as a negative occurrence of X.
      info.occursPositively = true;
      var clauses = self._generateFormula(true, formula);
      addClauses(clauses, [-v]);
    } else if ((! positive) && ! info.occursNegatively) {
      // Eg, if we have the term `-X` where `X` represents the
      // formula `A v B`, add the clauses `-A v X` and `-B v X`.
      // By using the extraTerms argument to addClauses, we avoid
      // treating this as a positive occurrence of X.
      info.occursNegatively = true;
      var clauses = self._generateFormula(false, formula);
      addClauses(clauses, [v]);
    }
    if (info.occursPositively && info.occursNegatively) {
      delete self._ungeneratedFormulas[v];
    }

    if (! (deferredAddClauses && deferredAddClauses.length)) {
      return;
    }

    var useTerm = function (t) {
      self._useFormulaTerm(t, addClauses);
    };
    // This is the loop that turns recursion into iteration.
    // When addClauses calls useTerm, which calls useFormulaTerm,
    // the nested useFormulaTerm will add any clauses to our
    // own deferredAddClauses list.
    while (deferredAddClauses.length) {
      var next = deferredAddClauses.pop();
      self._addClauses(next.clauses, next.extraTerms, useTerm);
    }
  };

  Logic.Solver.prototype._addClauses = function (array, _extraTerms,
                                                 _useTermOverride) {
    if (assert) assert(array, isArrayWhere(Logic.isClause));
    var self = this;
    _.each(array, function (cls) {
      self._addClause(cls, _extraTerms, _useTermOverride);
    });
  };

  Logic.Solver.prototype.require = function (/*formulaOrArray, ...*/) {
    this._requireForbidImpl(true, _.flatten(arguments));
  };

  Logic.Solver.prototype.forbid = function (/*formulaOrArray, ...*/) {
    this._requireForbidImpl(false, _.flatten(arguments));
  };

  Logic.Solver.prototype._requireForbidImpl = function (isRequire, formulas) {
    var self = this;
    if (assert) assert(formulas, isArrayWhere(isFormulaOrTerm));

    _.each(formulas, function (f) {
      if (f instanceof Logic.NotFormula) {
        self._requireForbidImpl(!isRequire, [f.operand]);
      } else if (f instanceof Logic.Formula) {
        var info = self._getFormulaInfo(f);
        if (info.varNum !== null) {
          var sign = isRequire ? 1 : -1;
          self._addClause(new Logic.Clause(sign*info.varNum));
        } else {
          self._addClauses(self._generateFormula(isRequire, f));
        }
        if (isRequire) {
          info.isRequired = true;
        } else {
          info.isForbidden = true;
        }
      } else {
        self._addClauses(self._generateFormula(isRequire, f));
      }
    });
  };

  Logic.Solver.prototype._generateFormula = function (isTrue, formula, _termifier) {
    var self = this;
    if (assert) assert(formula, isFormulaOrTerm);

    if (formula instanceof Logic.NotFormula) {
      return self._generateFormula(!isTrue, formula.operand);
    } else if (formula instanceof Logic.Formula) {
      var info = self._getFormulaInfo(formula);
      if ((isTrue && info.isRequired) ||
          (!isTrue && info.isForbidden)) {
        return [];
        } else if ((isTrue && info.isForbidden) ||
                   (!isTrue && info.isRequired)) {
          return [new Logic.Clause()]; // never satisfied clause
        } else {
          var ret = formula.generateClauses(isTrue,
                                            _termifier || self._termifier);
          return _.isArray(ret) ? ret : [ret];
        }
    } else { // Term
      var t = self.toNumTerm(formula);
      var sign = isTrue ? 1 : -1;
      if (t === sign*Logic.NUM_TRUE || t === -sign*Logic.NUM_FALSE) {
        return [];
      } else if (t === sign*Logic.NUM_FALSE || t === -sign*Logic.NUM_TRUE) {
        return [new Logic.Clause()]; // never satisfied clause
      } else {
        return [new Logic.Clause(sign*t)];
      }
    }
  };

  // Get clause data as an array of arrays of integers,
  // for testing and debugging purposes.
  Logic.Solver.prototype._clauseData = function () {
    var clauses = _.pluck(this.clauses, 'terms');
    if (! this._T_used) {
      clauses.splice(1, 1);
    }
    if (! this._F_used) {
      clauses.splice(0, 1);
    }
    return clauses;
  };

  // Get clause data as an array of human-readable strings,
  // for testing and debugging purposes.
  // A clause might look like "A v -B" (where "v" represents
  // and OR operator).
  Logic.Solver.prototype._clauseStrings = function () {
    var self = this;
    var clauseData = self._clauseData();
    return _.map(clauseData, function (clause) {
      return _.map(clause, function (nterm) {
        var str = self.toNameTerm(nterm);
        if (/\s/.test(str)) {
          // write name in quotes for readability.  we don't bother
          // making this string machine-parsable in the general case.
          var sign = '';
          if (str.charAt(0) === '-') {
            // temporarily remove '-'
            sign = '-';
            str = str.slice(1);
          }
          str = sign + '"' + str + '"';
        }
        return str;
      }).join(' v ');
    });
  };

  Logic.Solver.prototype._getFormulaInfo = function (formula, _noCreate) {
    var self = this;
    var guid = formula.guid();
    if (! self._formulaInfo[guid]) {
      if (_noCreate) {
        return null;
      }
      self._formulaInfo[guid] = new FormulaInfo();
    }
    return self._formulaInfo[guid];
  };

  // Takes a Formula or an array of Formulas, returns a NumTerm or
  // array of NumTerms.
  Logic.Solver.prototype._formulaToTerm = function (formula) {
    var self = this;

    if (_.isArray(formula)) {
      if (assert) assert(formula, isArrayWhere(isFormulaOrTerm));
      return _.map(formula, _.bind(self._formulaToTerm, self));
    } else {
      if (assert) assert(formula, isFormulaOrTerm);
    }

    if (formula instanceof Logic.NotFormula) {
      // shortcut that avoids creating a variable called
      // something like "$not1" when you use Logic.not(formula).
      return Logic.not(self._formulaToTerm(formula.operand));
    } else if (formula instanceof Logic.Formula) {
      var info = this._getFormulaInfo(formula);
      if (info.isRequired) {
        return Logic.NUM_TRUE;
      } else if (info.isForbidden) {
        return Logic.NUM_FALSE;
      } else if (info.varNum === null) {
        // generate a Solver-local formula variable like "$or1"
        var type = formula.type;
        if (! this._nextFormulaNumByType[type]) {
          this._nextFormulaNumByType[type] = 1;
        }
        var numForVarName = this._nextFormulaNumByType[type]++;
        info.varName = "$" + formula.type + numForVarName;
        info.varNum = this.getVarNum(info.varName, false, true);
        this._ungeneratedFormulas[info.varNum] = formula;
      }
      return info.varNum;
    } else {
      // formula is a Term
      return self.toNumTerm(formula);
    }
  };

  Logic.or = function (/*formulaOrArray, ...*/) {
    var args = _.flatten(arguments);
    if (args.length === 0) {
      return Logic.FALSE;
    } else if (args.length === 1) {
      if (assert) assert(args[0], isFormulaOrTerm);
      return args[0];
    } else {
      return new Logic.OrFormula(args);
    }
  };

  Logic.OrFormula = function (operands) {
    if (assert) assert(operands, isArrayWhere(isFormulaOrTerm));
    this.operands = operands;
  };

  Logic._defineFormula(Logic.OrFormula, 'or', {
    generateClauses: function (isTrue, t) {
      if (isTrue) {
        // eg A v B v C
        return t.clause(this.operands);
      } else {
        // eg -A; -B; -C
        var result = [];
        _.each(this.operands, function (o) {
          result.push.apply(result, t.generate(false, o));
        });
        return result;
      }
    }
  });

  Logic.NotFormula = function (operand) {
    if (assert) assert(operand, isFormulaOrTerm);
    this.operand = operand;
  };

  // No generation or simplification for 'not'; it is
  // simplified away by the solver itself.
  Logic._defineFormula(Logic.NotFormula, 'not');

  Logic.and = function (/*formulaOrArray, ...*/) {
    var args = _.flatten(arguments);
    if (args.length === 0) {
      return Logic.TRUE;
    } else if (args.length === 1) {
      if (assert) assert(args[0], isFormulaOrTerm);
      return args[0];
    } else {
      return new Logic.AndFormula(args);
    }
  };

  Logic.AndFormula = function (operands) {
    if (assert) assert(operands, isArrayWhere(isFormulaOrTerm));
    this.operands = operands;
  };

  Logic._defineFormula(Logic.AndFormula, 'and', {
    generateClauses: function (isTrue, t) {
      if (isTrue) {
        // eg A; B; C
        var result = [];
        _.each(this.operands, function (o) {
          result.push.apply(result, t.generate(true, o));
        });
        return result;
      } else {
        // eg -A v -B v -C
        return t.clause(_.map(this.operands, Logic.not));
      }
    }
  });

  // Group `array` into groups of N, where the last group
  // may be shorter than N.  group([a,b,c,d,e], 3) => [[a,b,c],[d,e]]
  var group = function (array, N) {
    var ret = [];
    for (var i = 0; i < array.length; i += N) {
      ret.push(array.slice(i, i+N));
    }
    return ret;
  };

  Logic.xor = function (/*formulaOrArray, ...*/) {
    var args = _.flatten(arguments);
    if (args.length === 0) {
      return Logic.FALSE;
    } else if (args.length === 1) {
      if (assert) assert(args[0], isFormulaOrTerm);
      return args[0];
    } else {
      return new Logic.XorFormula(args);
    }
  };

  Logic.XorFormula = function (operands) {
    if (assert) assert(operands, isArrayWhere(isFormulaOrTerm));
    this.operands = operands;
  };

  Logic._defineFormula(Logic.XorFormula, 'xor', {
    generateClauses: function (isTrue, t) {
      var args = this.operands;
      var not = Logic.not;
      if (args.length > 3) {
        return t.generate(
          isTrue,
          Logic.xor(
            _.map(group(this.operands, 3), function (group) {
              return Logic.xor(group);
            })));
      } else if (isTrue) { // args.length <= 3
        if (args.length === 0) {
          return t.clause(); // always fail
        } else if (args.length === 1) {
          return t.clause(args[0]);
        } else if (args.length === 2) {
          var A = args[0], B = args[1];
          return [t.clause(A, B), // A v B
                  t.clause(not(A), not(B))]; // -A v -B
        } else if (args.length === 3) {
          var A = args[0], B = args[1], C = args[2];
          return [t.clause(A, B, C), // A v B v C
                  t.clause(A, not(B), not(C)), // A v -B v -C
                  t.clause(not(A), B, not(C)), // -A v B v -C
                  t.clause(not(A), not(B), C)]; // -A v -B v C
        }
      } else { // !isTrue, args.length <= 3
        if (args.length === 0) {
          return []; // always succeed
        } else if (args.length === 1) {
          return t.clause(not(args[0]));
        } else if (args.length === 2) {
          var A = args[0], B = args[1];
          return [t.clause(A, not(B)), // A v -B
                  t.clause(not(A), B)]; // -A v B
        } else if (args.length === 3) {
          var A = args[0], B = args[1], C = args[2];
          return [t.clause(not(A), not(B), not(C)), // -A v -B v -C
                  t.clause(not(A), B, C), // -A v B v C
                  t.clause(A, not(B), C), // A v -B v C
                  t.clause(A, B, not(C))]; // A v B v -C
        }
      }
    }
  });

  Logic.atMostOne = function (/*formulaOrArray, ...*/) {
    var args = _.flatten(arguments);
    if (args.length <= 1) {
      return Logic.TRUE;
    } else {
      return new Logic.AtMostOneFormula(args);
    }
  };

  Logic.AtMostOneFormula = function (operands) {
    if (assert) assert(operands, isArrayWhere(isFormulaOrTerm));
    this.operands = operands;
  };

  Logic._defineFormula(Logic.AtMostOneFormula, 'atMostOne', {
    generateClauses: function (isTrue, t) {
       var args = this.operands;
       var not = Logic.not;
       if (args.length <= 1) {
         return []; // always succeed
       } else if (args.length === 2) {
         return t.generate(isTrue, Logic.not(Logic.and(args)));
       } else if (isTrue && args.length === 3) {
         // Pick any two args; at least one is false (they aren't
         // both true).  This strategy would also work for
         // N>3, and could provide a speed-up by having more clauses
         // (N^2) but fewer propagation steps.  No speed-up was
         // observed on the Sudoku test from using this strategy
         // up to N=10.
         var clauses = [];
         for (var i = 0; i < args.length; i++) {
           for (var j = i+1; j < args.length; j++) {
             clauses.push(t.clause(not(args[i]), not(args[j])));
           }
         }
         return clauses;
       } else if ((! isTrue) && args.length === 3) {
         var A = args[0], B = args[1], C = args[2];
         // Pick any two args; at least one is true (they aren't
         // both false).  This only works for N=3.
         return [t.clause(A, B), t.clause(A, C), t.clause(B, C)];
       } else {
         // See the "commander variables" technique from:
         // http://www.cs.cmu.edu/~wklieber/papers/2007_efficient-cnf-encoding-for-selecting-1.pdf
         // But in short: At most one group has at least one "true",
         // and each group has at most one "true".  Formula generation
         // automatically generates the right implications.
         var groups = group(args, 3);
         var ors = _.map(groups, function (g) { return Logic.or(g); });
         if (groups[groups.length - 1].length < 2) {
           // Remove final group of length 1 so we don't generate
           // no-op clauses of one sort or another
           groups.pop();
         }
         var atMostOnes = _.map(groups, function (g) {
           return Logic.atMostOne(g);
         });
         return t.generate(isTrue, Logic.and(Logic.atMostOne(ors), atMostOnes));
       }
    }
  });

  Logic.implies = function (A, B) {
    if (assert) assertNumArgs(arguments.length, 2, "Logic.implies");
    return new Logic.ImpliesFormula(A, B);
  };

  Logic.ImpliesFormula = function (A, B) {
    if (assert) assert(A, isFormulaOrTerm);
    if (assert) assert(B, isFormulaOrTerm);
    if (assert) assertNumArgs(arguments.length, 2, "Logic.implies");
    this.A = A;
    this.B = B;
  };

  Logic._defineFormula(Logic.ImpliesFormula, 'implies', {
    generateClauses: function (isTrue, t) {
      return t.generate(isTrue, Logic.or(Logic.not(this.A), this.B));
    }
  });

  Logic.equiv = function (A, B) {
    if (assert) assertNumArgs(arguments.length, 2, "Logic.equiv");
    return new Logic.EquivFormula(A, B);
  };

  Logic.EquivFormula = function (A, B) {
    if (assert) assert(A, isFormulaOrTerm);
    if (assert) assert(B, isFormulaOrTerm);
    if (assert) assertNumArgs(arguments.length, 2, "Logic.equiv");
    this.A = A;
    this.B = B;
  };

  Logic._defineFormula(Logic.EquivFormula, 'equiv', {
    generateClauses: function (isTrue, t) {
      return t.generate(!isTrue, Logic.xor(this.A, this.B));
    }
  });

  Logic.exactlyOne = function (/*formulaOrArray, ...*/) {
    var args = _.flatten(arguments);
    if (args.length === 0) {
      return Logic.FALSE;
    } else if (args.length === 1) {
      if (assert) assert(args[0], isFormulaOrTerm);
      return args[0];
    } else {
      return new Logic.ExactlyOneFormula(args);
    }
  };

  Logic.ExactlyOneFormula = function (operands) {
    if (assert) assert(operands, isArrayWhere(isFormulaOrTerm));
    this.operands = operands;
  };

  Logic._defineFormula(Logic.ExactlyOneFormula, 'exactlyOne', {
    generateClauses: function (isTrue, t) {
      var args = this.operands;
      if (args.length < 3) {
        return t.generate(isTrue, Logic.xor(args));
      } else {
        return t.generate(isTrue, Logic.and(Logic.atMostOne(args),
                                            Logic.or(args)));
      }
    }
  });

  // List of 0 or more formulas or terms, which together represent
  // a non-negative integer.  Least significant bit is first.  That is,
  // the kth array element has a place value of 2^k.
  Logic.Bits = function (formulaArray) {
    if (assert) assert(formulaArray, isArrayWhere(isFormulaOrTerm));
    this.bits = formulaArray; // public, immutable
  };

  Logic.constantBits = function (wholeNumber) {
    if (assert) assert(wholeNumber, Logic.isWholeNumber);
    var result = [];
    while (wholeNumber) {
      result.push((wholeNumber & 1) ? Logic.TRUE : Logic.FALSE);
      wholeNumber >>>= 1;
    }
    return new Logic.Bits(result);
  };

  Logic.variableBits = function (baseName, nbits) {
    if (assert) assert(nbits, Logic.isWholeNumber);
    var result = [];
    for (var i = 0; i < nbits; i++) {
      result.push(baseName + '$' + i);
    }
    return new Logic.Bits(result);
  };

  // bits1 <= bits2
  Logic.lessThanOrEqual = function (bits1, bits2) {
    return new Logic.LessThanOrEqualFormula(bits1, bits2);
  };

  Logic.LessThanOrEqualFormula = function (bits1, bits2) {
    if (assert) assert(bits1, Logic.isBits);
    if (assert) assert(bits2, Logic.isBits);
    if (assert) assertNumArgs(arguments.length, 2, "Bits comparison function");
    this.bits1 = bits1;
    this.bits2 = bits2;
  };

  var genLTE = function (bits1, bits2, t, notEqual) {
    var ret = [];
    // clone so we can mutate them in place
    var A = bits1.bits.slice();
    var B = bits2.bits.slice();
    if (notEqual && ! bits2.bits.length) {
      // can't be less than 0
      return t.clause();
    }
    // if A is longer than B, the extra (high) bits
    // must be 0.
    while (A.length > B.length) {
      var hi = A.pop();
      ret.push(t.clause(Logic.not(hi)));
    }
    // now B.length >= A.length
    // Let xors[i] be (A[i] xor B[i]), or just
    // B[i] if A is too short.
    var xors = _.map(B, function (b, i) {
      if (i < A.length) {
        return Logic.xor(A[i], b);
      } else {
        return b;
      }
    });

    // Suppose we are comparing 3-bit numbers, requiring
    // that ABC <= XYZ.  Here is what we require:
    //
    // * It is false that A=1 and X=0.
    // * It is false that A=X, B=1, and Y=0.
    // * It is false that A=X, B=Y, C=1, and Y=0.
    //
    // Translating these into clauses using DeMorgan's law:
    //
    // * A=0 or X=1
    // * (A xor X) or B=0 or Y=1
    // * (A xor X) or (B xor Y) or C=0 or Y=1
    //
    // Since our arguments are LSB first, in the example
    // we would be given [C, B, A] and [Z, Y, X] as input.
    // We iterate over the first argument starting from
    // the right, and build up a clause by iterating over
    // the xors from the right.
    //
    // If we have ABC <= VWXYZ, then we still have three clauses,
    // but each one is prefixed with "V or W or", because V and W
    // are at the end of the xors array.  This is equivalent to
    // padding ABC with two zeros.

    for (var i = A.length-1; i >= 0; i--) {
      ret.push(t.clause(xors.slice(i+1), Logic.not(A[i]), B[i]));
    }
    if (notEqual) {
      ret.push.apply(ret, t.generate(true, Logic.or(xors)));
    }
    return ret;
  };

  Logic._defineFormula(Logic.LessThanOrEqualFormula, 'lte', {
    generateClauses: function (isTrue, t) {
      if (isTrue) {
        // bits1 <= bits2
        return genLTE(this.bits1, this.bits2, t, false);
      } else {
        // bits2 < bits1
        return genLTE(this.bits2, this.bits1, t, true);
      }
    }
  });

  // bits1 < bits2
  Logic.lessThan = function (bits1, bits2) {
    return new Logic.LessThanFormula(bits1, bits2);
  };

  Logic.LessThanFormula = function (bits1, bits2) {
    if (assert) assert(bits1, Logic.isBits);
    if (assert) assert(bits2, Logic.isBits);
    if (assert) assertNumArgs(arguments.length, 2, "Bits comparison function");
    this.bits1 = bits1;
    this.bits2 = bits2;
  };

  Logic._defineFormula(Logic.LessThanFormula, 'lt', {
    generateClauses: function (isTrue, t) {
      if (isTrue) {
        // bits1 < bits2
        return genLTE(this.bits1, this.bits2, t, true);
      } else {
        // bits2 <= bits1
        return genLTE(this.bits2, this.bits1, t, false);
      }
    }
  });

  Logic.greaterThan = function (bits1, bits2) {
    return Logic.lessThan(bits2, bits1);
  };

  Logic.greaterThanOrEqual = function (bits1, bits2) {
    return Logic.lessThanOrEqual(bits2, bits1);
  };

  Logic.equalBits = function (bits1, bits2) {
    return new Logic.EqualBitsFormula(bits1, bits2);
  };

  Logic.EqualBitsFormula = function (bits1, bits2) {
    if (assert) assert(bits1, Logic.isBits);
    if (assert) assert(bits2, Logic.isBits);
    if (assert) assertNumArgs(arguments.length, 2, "Logic.equalBits");
    this.bits1 = bits1;
    this.bits2 = bits2;
  };

  Logic._defineFormula(Logic.EqualBitsFormula, 'equalBits', {
    generateClauses: function (isTrue, t) {
      var A = this.bits1.bits;
      var B = this.bits2.bits;
      var nbits = Math.max(A.length, B.length);
      var facts = [];
      for (var i = 0; i < nbits; i++) {
        if (i >= A.length) {
          facts.push(Logic.not(B[i]));
        } else if (i >= B.length) {
          facts.push(Logic.not(A[i]));
        } else {
          facts.push(Logic.equiv(A[i], B[i]));
        }
      }
      return t.generate(isTrue, Logic.and(facts));
    }
  });

  // Definition of full-adder and half-adder:
  //
  // A full-adder is a 3-input, 2-output gate producing the sum of its
  // inputs as a 2-bit binary number. The most significant bit is called
  // "carry", the least significant "sum". A half-adder does the same
  // thing, but has only 2 inputs (and can therefore never output a
  // "3").
  //
  // The half-adder sum bit is really just an XOR, and the carry bit
  // is really just an AND.  However, they get their own formula types
  // here to enhance readability of the generated clauses.

  Logic.HalfAdderSum = function (formula1, formula2) {
    if (assert) assert(formula1, isFormulaOrTerm);
    if (assert) assert(formula2, isFormulaOrTerm);

    if (assert) assertNumArgs(arguments.length, 2, "Logic.HalfAdderSum");
    this.a = formula1;
    this.b = formula2;
  };

  Logic._defineFormula(Logic.HalfAdderSum, 'hsum', {
    generateClauses: function (isTrue, t) {
      return t.generate(isTrue, Logic.xor(this.a, this.b));
    }
  });

  Logic.HalfAdderCarry = function (formula1, formula2) {
    if (assert) assert(formula1, isFormulaOrTerm);
    if (assert) assert(formula2, isFormulaOrTerm);
    if (assert) assertNumArgs(arguments.length, 2, "Logic.HalfAdderCarry");
    this.a = formula1;
    this.b = formula2;
  };

  Logic._defineFormula(Logic.HalfAdderCarry, 'hcarry', {
    generateClauses: function (isTrue, t) {
      return t.generate(isTrue, Logic.and(this.a, this.b));
    }
  });

  Logic.FullAdderSum = function (formula1, formula2, formula3) {
    if (assert) assert(formula1, isFormulaOrTerm);
    if (assert) assert(formula2, isFormulaOrTerm);
    if (assert) assert(formula3, isFormulaOrTerm);
    if (assert) assertNumArgs(arguments.length, 3, "Logic.FullAdderSum");
    this.a = formula1;
    this.b = formula2;
    this.c = formula3;
  };

  Logic._defineFormula(Logic.FullAdderSum, 'fsum', {
    generateClauses: function (isTrue, t) {
      return t.generate(isTrue, Logic.xor(this.a, this.b, this.c));
    }
  });

  Logic.FullAdderCarry = function (formula1, formula2, formula3) {
    if (assert) assert(formula1, isFormulaOrTerm);
    if (assert) assert(formula2, isFormulaOrTerm);
    if (assert) assert(formula3, isFormulaOrTerm);
    if (assert) assertNumArgs(arguments.length, 3, "Logic.FullAdderCarry");
    this.a = formula1;
    this.b = formula2;
    this.c = formula3;
  };

  Logic._defineFormula(Logic.FullAdderCarry, 'fcarry', {
    generateClauses: function (isTrue, t) {
      return t.generate(! isTrue,
                        Logic.atMostOne(this.a, this.b, this.c));
    }
  });

  // Implements the Adder strategy from the MiniSat+ paper:
  // http://minisat.se/downloads/MiniSat+.pdf
  // "Translating Pseudo-boolean Constraints into SAT"
  //
  // Takes a list of list of Formulas.  The first list is bits
  // to give weight 1; the second is bits to give weight 2;
  // the third is bits to give weight 4; and so on.
  //
  // Returns an array of Logic.FormulaOrTerm.
  var binaryWeightedSum = function (varsByWeight) {
    if (assert) assert(varsByWeight,
                       isArrayWhere(isArrayWhere(isFormulaOrTerm)));
    // initialize buckets to a two-level clone of varsByWeight
    var buckets = _.map(varsByWeight, _.clone);
    var lowestWeight = 0; // index of the first non-empty array
    var output = [];
    while (lowestWeight < buckets.length) {
      var bucket = buckets[lowestWeight];
      if (! bucket.length) {
        output.push(Logic.FALSE);
        lowestWeight++;
      } else if (bucket.length === 1) {
        output.push(bucket[0]);
        lowestWeight++;
      } else if (bucket.length === 2) {
        var sum = new Logic.HalfAdderSum(bucket[0], bucket[1]);
        var carry = new Logic.HalfAdderCarry(bucket[0], bucket[1]);
        bucket.length = 0;
        bucket.push(sum);
        pushToNth(buckets, lowestWeight+1, carry);
      } else {
        // Whether we take variables from the start or end of the
        // bucket (i.e. `pop` or `shift`) determines the shape of the tree.
        // Empirically, some logic problems are faster with `shift` (2x or so),
        // but `pop` gives an order-of-magnitude speed-up on the Meteor Version
        // Solver "benchmark-tests" suite (Slava's benchmarks based on data from
        // Rails).  So, `pop` it is.
        var c = bucket.pop();
        var b = bucket.pop();
        var a = bucket.pop();
        var sum = new Logic.FullAdderSum(a, b, c);
        var carry = new Logic.FullAdderCarry(a, b, c);
        bucket.push(sum);
        pushToNth(buckets, lowestWeight+1, carry);
      }
    }
    return output;
  };

  // Push `newItem` onto the array at arrayOfArrays[n],
  // first ensuring that it exists by pushing empty
  // arrays onto arrayOfArrays.
  var pushToNth = function (arrayOfArrays, n, newItem) {
    while (n >= arrayOfArrays.length) {
      arrayOfArrays.push([]);
    }
    arrayOfArrays[n].push(newItem);
  };

  var checkWeightedSumArgs = function (formulas, weights) {
    if (assert) assert(formulas, isArrayWhere(isFormulaOrTerm));
    if (typeof weights === 'number') {
      if (assert) assert(weights, Logic.isWholeNumber);
    } else {
      if (assert) assert(weights, isArrayWhere(Logic.isWholeNumber));
      if (formulas.length !== weights.length) {
        throw new Error("Formula array and weight array must be same length" +
                        "; they are " + formulas.length + " and " + weights.length);
      }
    }
  };

  Logic.weightedSum = function (formulas, weights) {
    checkWeightedSumArgs(formulas, weights);

    if (formulas.length === 0) {
      return new Logic.Bits([]);
    }

    if (typeof weights === 'number') {
      weights = _.map(formulas, function () { return weights; });
    }

    var binaryWeighted = [];
    _.each(formulas, function (f, i) {
      var w = weights[i];
      var whichBit = 0;
      while (w) {
        if (w & 1) {
          pushToNth(binaryWeighted, whichBit, f);
        }
        w >>>= 1;
        whichBit++;
      }
    });

    return new Logic.Bits(binaryWeightedSum(binaryWeighted));
  };

  Logic.sum = function (/*formulaOrBitsOrArray, ...*/) {
    var things = _.flatten(arguments);
    if (assert) assert(things, isArrayWhere(isFormulaOrTermOrBits));

    var binaryWeighted = [];
    _.each(things, function (x) {
      if (x instanceof Logic.Bits) {
        _.each(x.bits, function (b, i) {
          pushToNth(binaryWeighted, i, b);
        });
      } else {
        pushToNth(binaryWeighted, 0, x);
      }
    });

    return new Logic.Bits(binaryWeightedSum(binaryWeighted));
  };

  ////////////////////////////////////////

  Logic.Solver.prototype.solve = function (_assumpVar) {
    var self = this;
    if (_assumpVar !== undefined) {
      if (! (_assumpVar >= 1)) {
        throw new Error("_assumpVar must be a variable number");
      }
    }

    if (self._unsat) {
      return null;
    }

    while (self._numClausesAddedToMiniSat < self.clauses.length) {
      var i = self._numClausesAddedToMiniSat;
      var terms = self.clauses[i].terms;
      if (assert) assert(terms, isArrayWhere(Logic.isNumTerm));
      var stillSat = self._minisat.addClause(terms);
      self._numClausesAddedToMiniSat++;
      if (! stillSat) {
        self._unsat = true;
        return null;
      }
    }

    if (assert) assert(this._num2name.length - 1, Logic.isWholeNumber);
    self._minisat.ensureVar(this._num2name.length - 1);

    var stillSat = (_assumpVar ?
                    self._minisat.solveAssuming(_assumpVar) :
                    self._minisat.solve());
    if (! stillSat) {
      if (! _assumpVar) {
        self._unsat = true;
      }
      return null;
    }

    return new Logic.Solution(self, self._minisat.getSolution());
  };

  Logic.Solver.prototype.solveAssuming = function (formula) {
    if (assert) assert(formula, isFormulaOrTerm);

    // Wrap the formula in a formula of type Assumption, so that
    // we always generate a var like `$assump123`, regardless
    // of whether `formula` is a Term, a NotFormula, an already
    // required or forbidden Formula, etc.
    var assump = new Logic.Assumption(formula);
    var assumpVar = this._formulaToTerm(assump);
    if (! (typeof assumpVar === 'number' && assumpVar > 0)) {
      throw new Error("Assertion failure: not a positive numeric term");
    }

    // Generate clauses as if we used the assumption variable in a
    // clause, in the positive.  So if we assume "A v B", we might get a
    // clause like "A v B v -$assump123" (or actually, "$or1 v
    // -$assump123"), as if we had used $assump123 in a clause.  Instead
    // of using it in a clause, though, we temporarily assume it to be
    // true.
    this._useFormulaTerm(assumpVar);

    var result = this.solve(assumpVar);
    // Tell MiniSat that we will never use assumpVar again.
    // The formula may be used again, however.  (For example, you
    // can solve assuming a formula F, and if it works, require F.)
    this._minisat.retireVar(assumpVar);

    return result;
  };

  Logic.Assumption = function (formula) {
    if (assert) assert(formula, isFormulaOrTerm);
    this.formula = formula;
  };

  Logic._defineFormula(Logic.Assumption, 'assump', {
    generateClauses: function (isTrue, t) {
      if (isTrue) {
        return t.clause(this.formula);
      } else {
        return t.clause(Logic.not(this.formula));
      }
    }
  });

  Logic.Solution = function (_solver, _assignment) {
    var self = this;
    self._solver = _solver;
    self._assignment = _assignment;

    // save a snapshot of which formulas have variables designated
    // for them, but where we haven't generated clauses that constrain
    // those variables in both the positive and the negative direction.
    self._ungeneratedFormulas = _.clone(_solver._ungeneratedFormulas);

    self._formulaValueCache = {};
    self._termifier = new Logic.Termifier(self._solver);
    // Normally, when a Formula uses a Termifier to generate clauses that
    // refer to other Formulas, the Termifier replaces the Formulas with
    // their variables.  We hijack this mechanism to replace the Formulas
    // with their truth variables instead, leading to recursive evaluation.
    // Note that we cache the evaluated truth values of Formulas to avoid
    // redundant evaluation.
    self._termifier.term = function (formula) {
      return self.evaluate(formula) ? Logic.NUM_TRUE : Logic.NUM_FALSE;
    };

    // When true, evaluation doesn't throw errors when
    // `evaluate` or `getWeightedSum` encounter named variables that are
    // unknown or variables that weren't present when this Solution was
    // generated.  Instead, the unknown variables are assumed to be false.
    self._ignoreUnknownVariables = false;
  };

  Logic.Solution.prototype.ignoreUnknownVariables = function () {
    // We only make this settable one way (false to true).
    // Setting it back and forth would be questionable, since we keep
    // a cache of Formula evaluations.
    this._ignoreUnknownVariables = true;
  };

  // Get a map of variables to their assignments,
  // such as `{A: true, B: false, C: true}`.
  // Internal variables are excluded.
  Logic.Solution.prototype.getMap = function () {
    var solver = this._solver;
    var assignment = this._assignment;
    var result = {};
    for (var i = 1; i < assignment.length; i++) {
      var name = solver.getVarName(i);
      if (name && name.charAt(0) !== '$') {
        result[name] = assignment[i];
      }
    }
    return result;
  };

  // Get an array of variables that are assigned
  // `true` by this solution, sorted by name.
  // Internal variables are excluded.
  Logic.Solution.prototype.getTrueVars = function () {
    var solver = this._solver;
    var assignment = this._assignment;
    var result = [];
    for (var i = 1; i < assignment.length; i++) {
      if (assignment[i]) {
        var name = solver.getVarName(i);
        if (name && name.charAt(0) !== '$') {
          result.push(name);
        }
      }
    }
    result.sort();
    return result;
  };

  // Get a Formula that says that the variables are assigned
  // according to this solution.  (Internal variables are
  // excluded.)  By forbidding this Formula and solving again,
  // you can see if there are other solutions.
  Logic.Solution.prototype.getFormula = function () {
    var solver = this._solver;
    var assignment = this._assignment;
    var terms = [];
    for (var i = 1; i < assignment.length; i++) {
      var name = solver.getVarName(i);
      if (name && name.charAt(0) !== '$') {
        terms.push(assignment[i] ? i : -i);
      }
    }
    return Logic.and(terms);
  };

  // Returns a boolean if the argument is a Formula (or Term), and an integer
  // if the argument is a Logic.Bits.
  Logic.Solution.prototype.evaluate = function (formulaOrBits) {
    var self = this;
    if (assert) assert(formulaOrBits, isFormulaOrTermOrBits);

    if (formulaOrBits instanceof Logic.Bits) {
      // Evaluate to an integer
      var ret = 0;
      _.each(formulaOrBits.bits, function (f, i) {
        if (self.evaluate(f)) {
          ret += 1 << i;
        }
      });
      return ret;
    }

    var solver = self._solver;
    var ignoreUnknownVariables = self._ignoreUnknownVariables;
    var assignment = self._assignment;
    var formula = formulaOrBits;
    if (formula instanceof Logic.NotFormula) {
      return ! self.evaluate(formula.operand);
    } else if (formula instanceof Logic.Formula) {
      var cachedResult = self._formulaValueCache[formula.guid()];
      if (typeof cachedResult === 'boolean') {
        return cachedResult;
      } else {
        var value;
        var info = solver._getFormulaInfo(formula, true);
        if (info && info.varNum && info.varNum < assignment.length &&
            ! _.has(self._ungeneratedFormulas, info.varNum)) {
          // as an optimization, read the value of the formula directly
          // from a variable if the formula's clauses were completely
          // generated at the time of solving.  (We must be careful,
          // because if we didn't generate both the positive and the
          // negative polarity clauses for the formula, then the formula
          // variable is not actually constrained to have the right
          // value.)
          value = assignment[info.varNum];
        } else {
          var clauses = solver._generateFormula(true, formula, self._termifier);
          var value = _.all(clauses, function (cls) {
            return _.any(cls.terms, function (t) {
              return self.evaluate(t);
            });
          });
        }
        self._formulaValueCache[formula.guid()] = value;
        return value;
      }
    } else {
      // Term; convert to numeric (possibly negative), but throw
      // an error if the name is not found.  If `ignoreUnknownVariables`
      // is set, return false instead.
      var numTerm = solver.toNumTerm(formula, true);
      if (! numTerm) {
        if (ignoreUnknownVariables) {
          return false;
        } else {
          // formula must be a NameTerm naming a variable that doesn't exist
          var vname = String(formula).replace(/^-*/, '');
          throw new Error("No such variable: " + vname);
        }
      }
      var v = numTerm;
      var isNot = false;
      if (numTerm < 0) {
        v = -v;
        isNot = true;
      }
      if (v < 1 || v >= assignment.length) {
        var vname = v;
        if (v >= 1 && v < solver._num2name.length) {
          vname = solver._num2name[v];
        }
        if (ignoreUnknownVariables) {
          return false;
        } else {
          throw new Error("Variable not part of solution: " + vname);
        }
      }
      var ret = assignment[v];
      if (isNot) {
        ret = ! ret;
      }
      return ret;
    }
  };

  Logic.Solution.prototype.getWeightedSum = function (formulas, weights) {
    checkWeightedSumArgs(formulas, weights);

    var total = 0;
    if (typeof weights === 'number') {
      for (var i = 0; i < formulas.length; i++) {
        total += weights * (this.evaluate(formulas[i]) ? 1 : 0);
      }
    } else {
      for (var i = 0; i < formulas.length; i++) {
        total += weights[i] * (this.evaluate(formulas[i]) ? 1 : 0);
      }
    }
    return total;
  };
  var getNonZeroWeightedTerms = function (costTerms, costWeights) {
    if (typeof costWeights === 'number') {
      return costWeights ? costTerms : [];
    } else {
      var terms = [];
      for (var i = 0; i < costTerms.length; i++) {
        if (costWeights[i]) {
          terms.push(costTerms[i]);
        }
      }
      return terms;
    }
  };

  // See comments on minimizeWeightedSum and maximizeWeightedSum.
  var minMaxWS = function (solver, solution, costTerms, costWeights, options,
                           isMin) {
    var curSolution = solution;
    var curCost = curSolution.getWeightedSum(costTerms, costWeights);

    var optFormula = options && options.formula;
    var weightedSum = (optFormula || Logic.weightedSum(costTerms, costWeights));

    var progress = options && options.progress;
    var strategy = options && options.strategy;

    // array of terms with non-zero weights, populated on demand
    var nonZeroTerms = null;

    if (isMin && curCost > 0) {
      // try to skip straight to 0 cost, because if it works, it could
      // save us some time
      if (progress) {
        progress('trying', 0);
      }
      var zeroSolution = null;
      nonZeroTerms = getNonZeroWeightedTerms(costTerms, costWeights);
      var zeroSolution = solver.solveAssuming(Logic.not(Logic.or(nonZeroTerms)));
      if (zeroSolution) {
        curSolution = zeroSolution;
        curCost = 0;
      }
    }

    if (isMin && strategy === 'bottom-up') {
      for (var trialCost = 1; trialCost < curCost; trialCost++) {
        if (progress) {
          progress('trying', trialCost);
        }
        var costIsTrialCost = Logic.equalBits(
          weightedSum, Logic.constantBits(trialCost));
        var newSolution = solver.solveAssuming(costIsTrialCost);
        if (newSolution) {
          curSolution = newSolution;
          curCost = trialCost;
          break;
        }
      }
    } else if (strategy && strategy !== 'default') {
      throw new Error("Bad strategy: " + strategy);
    } else {
      strategy = 'default';
    }

    if (strategy === 'default') {
      // for minimization, count down from current cost. for maximization,
      // count up.
      while (isMin ? curCost > 0 : true) {
        if (progress) {
          progress('improving', curCost);
        }
        var improvement = (isMin ? Logic.lessThan : Logic.greaterThan)(
          weightedSum, Logic.constantBits(curCost));
        var newSolution = solver.solveAssuming(improvement);
        if (! newSolution) {
          break;
        }
        solver.require(improvement);
        curSolution = newSolution;
        curCost = curSolution.getWeightedSum(costTerms, costWeights);
      }
    }

    if (isMin && curCost === 0) {
      // express the requirement that the weighted sum be 0 in an efficient
      // way for the solver (all terms with non-zero weights must be 0)
      if (! nonZeroTerms) {
        nonZeroTerms = getNonZeroWeightedTerms(costTerms, costWeights);
      }
      solver.forbid(nonZeroTerms);
    } else {
      solver.require(Logic.equalBits(weightedSum, Logic.constantBits(curCost)));
    }

    if (progress) {
      progress('finished', curCost);
    }

    return curSolution;
  };

  // Minimize (or maximize) the dot product of costTerms and
  // costWeights, and further, require (as in solver.require) that the
  // value of the dot product be equal to the optimum found.  Returns a
  // valid solution where this optimum is achieved.
  //
  // `solution` must be a current valid solution as returned from
  // `solve` or `solveAssuming`.  It is used as a starting point (to
  // evaluate the current cost).
  //
  // costWeights is an array (of same length as costTerms) or a single
  // WholeNumber.
  //
  // if the caller passes options.formula, it should be the formula
  // Logic.weightedSum(costTerms, costWeights).  The optimizer will use
  // this existing formula rather than generating a new one (for
  // efficiency).  The optimizer still wants to know the terms and
  // weights, because it is more efficient for it to evaluate the
  // current cost using them directly rather than the formula.
  //
  // options.progress: a function that takes two arguments, to call at
  // particular times during optimization.  Called with arguments
  // ('improving', cost) when about to search for a way to improve on
  // `cost`, and called with arguments ('finished', cost) when the
  // optimum is reached.  There's also ('trying', cost) when a cost
  // is tried directly (which is usually done with 0 right off the bat).
  //
  // options.strategy: a string hinting how to go about the optimization.
  // the default strategy (option absent or 'default') is to work down
  // from the current cost for minimization or up from the current cost
  // for maximization, and iteratively insist that the cost be made lower
  // if possible.  For minimization, the alternate strategy 'bottom-up' is
  // available, which starts at 0 and tries ever higher costs until one
  // works.  All strategies first try and see if a cost of 0 is possible.

  // ("costTerms" is kind of a misnomer since they may be Formulas or Terms.)
  Logic.Solver.prototype.minimizeWeightedSum = function (solution, costTerms,
                                                         costWeights, options) {
    return minMaxWS(this, solution, costTerms, costWeights, options, true);
  };

  Logic.Solver.prototype.maximizeWeightedSum = function (solution, costTerms,
                                                         costWeights, options) {
    return minMaxWS(this, solution, costTerms, costWeights, options, false);
  };
  module.exports = Logic;


  /***/ }),
  /* 246 */
  /***/ (function(module, exports, __webpack_require__) {

  var C_MINISAT = __webpack_require__(247);
  var _ = __webpack_require__(248);
  var MiniSat;
  MiniSat = function () {
    // A MiniSat object wraps an instance of "native" MiniSat.  You can
    // have as many MiniSat objects as you want, and they are all
    // independent.
    //
    // C is the "module" object created by Emscripten.  We wrap the
    // output of Emscripten in a closure, so each call to C_MINISAT()
    // actually instantiates a separate C environment, including
    // the "native" heap.
    //
    // The methods available on `C` include the global functions we
    // define in `logic-solver.cc`, each prefixed with `_`, and a varied
    // assortment of helpers put there by Emscripten, some of which are
    // documented here:
    // http://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html
    //
    // See the README in the meteor/minisat repo for more notes about
    // our build of MiniSat.
    var C = this._C = C_MINISAT();

    this._native = {
      getStackPointer: function () {
        return C.Runtime.stackSave();
      },
      setStackPointer: function (ptr) {
        C.Runtime.stackRestore(ptr);
      },
      allocateBytes: function (len) {
        return C.allocate(len, 'i8', C.ALLOC_STACK);
      },
      pushString: function (str) {
        return this.allocateBytes(C.intArrayFromString(str));
      },
      savingStack: function (func) {
        var SP = this.getStackPointer();
        try {
          return func(this, C);
        } finally {
          this.setStackPointer(SP);
        }
      }
    };

    C._createTheSolver();

    // useful log for debugging and testing
    this._clauses = [];
  };


  // Make sure MiniSat has allocated space in its model for v,
  // even if v is unused.  If we have variables A,B,C,D which
  // are numbers 1,2,3,4, for example, but we never actually use
  // C and D, calling ensureVar(4) will make MiniSat give us
  // solution values for them anyway.
  MiniSat.prototype.ensureVar = function (v) {
    this._C._ensureVar(v);
  };

  // Add a clause, in the form of an array of Logic.NumTerms.
  // Returns true if the problem is still satisfiable
  // (as far as we know without doing more work), and false if
  // we can already tell that it is unsatisfiable.
  MiniSat.prototype.addClause = function (terms) {
    this._clauses.push(terms);
    return this._native.savingStack(function (native, C) {
      var termsPtr = C.allocate((terms.length+1)*4, 'i32', C.ALLOC_STACK);
      _.each(terms, function (t, i) {
        C.setValue(termsPtr + i*4, t, 'i32');
      });
      C.setValue(termsPtr + terms.length*4, 0, 'i32'); // 0-terminate
      return C._addClause(termsPtr) ? true : false;
    });
  };

  MiniSat.prototype.solve = function () {
    return this._C._solve() ? true : false;
  };

  MiniSat.prototype.solveAssuming = function (v) {
    return this._C._solveAssuming(v) ? true : false;
  };

  MiniSat.prototype.getSolution = function () {
    var solution = [null]; // no 0th var
    var C = this._C;
    var numVars = C._getNumVars();
    var solPtr = C._getSolution();
    for (var i = 0; i < numVars; i++) {
      // 0 is Minisat::l_True (lifted "true").
      // Internally, Minisat has three states for a variable:
      // true, false, and undetermined.  It doesn't distinguish
      // between "false" and "undetermined" in solutions though
      // (I think it sets undetermined variables to false).
      solution[i+1] = (C.getValue(solPtr+i, 'i8') === 0);
    }
    return solution;
  };

  MiniSat.prototype.retireVar = function (v) {
    this._C._retireVar(v);
  };

  // The "conflict clause" feature of MiniSat is not what it sounds
  // like, unfortunately -- it doesn't help explain conflicts.
  // It only tells us which assumption vars are to blame for a failed
  // solveAssuming (and we only ever pass one var).
  // We keep this function around in case we discover a use for it.
  MiniSat.prototype.getConflictClause = function () {
    var C = this._C;
    var numTerms = C._getConflictClauseSize();
    var clausePtr = C._getConflictClause();
    var terms = [];
    for (var i = 0; i < numTerms; i++) {
      var t = C.getValue(clausePtr + i*4, 'i32');
      var v = (t >>> 1);
      var s = (t & 1) ? -1 : 1;
      terms[i] = v * s;
    }
    return terms;
  };
  module.exports = MiniSat;


  /***/ }),
  /* 247 */
  /***/ (function(module, exports, __webpack_require__) {

  var C_MINISAT;
  // This file is generated by the meteor/minisat repo.
  // See that repo's README for instructions for building it.
  C_MINISAT=(function(){var module={};var require=(function(){});var process={argv:["node","minisat"],on:(function(){}),stdout:{write:(function(str){console.log("MINISAT-out:",str.replace(/\n$/,""))})},stderr:{write:(function(str){console.log("MINISAT-err:",str.replace(/\n$/,""))})}};var window=0;var Module;if(!Module)Module=(typeof Module!=="undefined"?Module:null)||{};var moduleOverrides={};for(var key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key]}}var ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof require==="function";var ENVIRONMENT_IS_WEB=typeof window==="object";var ENVIRONMENT_IS_WORKER=typeof importScripts==="function";var ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER;if(ENVIRONMENT_IS_NODE){if(!Module["print"])Module["print"]=function print(x){process["stdout"].write(x+"\n")};if(!Module["printErr"])Module["printErr"]=function printErr(x){process["stderr"].write(x+"\n")};var nodeFS=require("fs");var nodePath=require("path");Module["read"]=function read(filename,binary){filename=nodePath["normalize"](filename);var ret=nodeFS["readFileSync"](filename);if(!ret&&filename!=nodePath["resolve"](filename)){filename=path.join(__dirname,"..","src",filename);ret=nodeFS["readFileSync"](filename)}if(ret&&!binary)ret=ret.toString();return ret};Module["readBinary"]=function readBinary(filename){return Module["read"](filename,true)};Module["load"]=function load(f){globalEval(read(f))};if(process["argv"].length>1){Module["thisProgram"]=process["argv"][1].replace(/\\/g,"/")}else{Module["thisProgram"]="unknown-program"}Module["arguments"]=process["argv"].slice(2);if(typeof module!=="undefined"){module["exports"]=Module}process["on"]("uncaughtException",(function(ex){if(!(ex instanceof ExitStatus)){throw ex}}))}else if(ENVIRONMENT_IS_SHELL){if(!Module["print"])Module["print"]=print;if(typeof printErr!="undefined")Module["printErr"]=printErr;if(typeof read!="undefined"){Module["read"]=read}else{Module["read"]=function read(){throw"no read() available (jsc?)"}}Module["readBinary"]=function readBinary(f){if(typeof readbuffer==="function"){return new Uint8Array(readbuffer(f))}var data=read(f,"binary");assert(typeof data==="object");return data};if(typeof scriptArgs!="undefined"){Module["arguments"]=scriptArgs}else if(typeof arguments!="undefined"){Module["arguments"]=arguments}this["Module"]=Module}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){Module["read"]=function read(url){var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText};if(typeof arguments!="undefined"){Module["arguments"]=arguments}if(typeof console!=="undefined"){if(!Module["print"])Module["print"]=function print(x){console.log(x)};if(!Module["printErr"])Module["printErr"]=function printErr(x){console.log(x)}}else{var TRY_USE_DUMP=false;if(!Module["print"])Module["print"]=TRY_USE_DUMP&&typeof dump!=="undefined"?(function(x){dump(x)}):(function(x){})}if(ENVIRONMENT_IS_WEB){window["Module"]=Module}else{Module["load"]=importScripts}}else{throw"Unknown runtime environment. Where are we?"}function globalEval(x){eval.call(null,x)}if(!Module["load"]&&Module["read"]){Module["load"]=function load(f){globalEval(Module["read"](f))}}if(!Module["print"]){Module["print"]=(function(){})}if(!Module["printErr"]){Module["printErr"]=Module["print"]}if(!Module["arguments"]){Module["arguments"]=[]}if(!Module["thisProgram"]){Module["thisProgram"]="./this.program"}Module.print=Module["print"];Module.printErr=Module["printErr"];Module["preRun"]=[];Module["postRun"]=[];for(var key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key]}}var Runtime={setTempRet0:(function(value){tempRet0=value}),getTempRet0:(function(){return tempRet0}),stackSave:(function(){return STACKTOP}),stackRestore:(function(stackTop){STACKTOP=stackTop}),getNativeTypeSize:(function(type){switch(type){case"i1":case"i8":return 1;case"i16":return 2;case"i32":return 4;case"i64":return 8;case"float":return 4;case"double":return 8;default:{if(type[type.length-1]==="*"){return Runtime.QUANTUM_SIZE}else if(type[0]==="i"){var bits=parseInt(type.substr(1));assert(bits%8===0);return bits/8}else{return 0}}}}),getNativeFieldSize:(function(type){return Math.max(Runtime.getNativeTypeSize(type),Runtime.QUANTUM_SIZE)}),STACK_ALIGN:16,getAlignSize:(function(type,size,vararg){if(!vararg&&(type=="i64"||type=="double"))return 8;if(!type)return Math.min(size,8);return Math.min(size||(type?Runtime.getNativeFieldSize(type):0),Runtime.QUANTUM_SIZE)}),dynCall:(function(sig,ptr,args){if(args&&args.length){if(!args.splice)args=Array.prototype.slice.call(args);args.splice(0,0,ptr);return Module["dynCall_"+sig].apply(null,args)}else{return Module["dynCall_"+sig].call(null,ptr)}}),functionPointers:[],addFunction:(function(func){for(var i=0;i<Runtime.functionPointers.length;i++){if(!Runtime.functionPointers[i]){Runtime.functionPointers[i]=func;return 2*(1+i)}}throw"Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS."}),removeFunction:(function(index){Runtime.functionPointers[(index-2)/2]=null}),getAsmConst:(function(code,numArgs){if(!Runtime.asmConstCache)Runtime.asmConstCache={};var func=Runtime.asmConstCache[code];if(func)return func;var args=[];for(var i=0;i<numArgs;i++){args.push(String.fromCharCode(36)+i)}var source=Pointer_stringify(code);if(source[0]==='"'){if(source.indexOf('"',1)===source.length-1){source=source.substr(1,source.length-2)}else{abort("invalid EM_ASM input |"+source+"|. Please use EM_ASM(..code..) (no quotes) or EM_ASM({ ..code($0).. }, input) (to input values)")}}try{var evalled=eval("(function(Module, FS) { return function("+args.join(",")+"){ "+source+" } })")(Module,typeof FS!=="undefined"?FS:null)}catch(e){Module.printErr("error in executing inline EM_ASM code: "+e+" on: \n\n"+source+"\n\nwith args |"+args+"| (make sure to use the right one out of EM_ASM, EM_ASM_ARGS, etc.)");throw e}return Runtime.asmConstCache[code]=evalled}),warnOnce:(function(text){if(!Runtime.warnOnce.shown)Runtime.warnOnce.shown={};if(!Runtime.warnOnce.shown[text]){Runtime.warnOnce.shown[text]=1;Module.printErr(text)}}),funcWrappers:{},getFuncWrapper:(function(func,sig){assert(sig);if(!Runtime.funcWrappers[sig]){Runtime.funcWrappers[sig]={}}var sigCache=Runtime.funcWrappers[sig];if(!sigCache[func]){sigCache[func]=function dynCall_wrapper(){return Runtime.dynCall(sig,func,arguments)}}return sigCache[func]}),UTF8Processor:(function(){var buffer=[];var needed=0;this.processCChar=(function(code){code=code&255;if(buffer.length==0){if((code&128)==0){return String.fromCharCode(code)}buffer.push(code);if((code&224)==192){needed=1}else if((code&240)==224){needed=2}else{needed=3}return""}if(needed){buffer.push(code);needed--;if(needed>0)return""}var c1=buffer[0];var c2=buffer[1];var c3=buffer[2];var c4=buffer[3];var ret;if(buffer.length==2){ret=String.fromCharCode((c1&31)<<6|c2&63)}else if(buffer.length==3){ret=String.fromCharCode((c1&15)<<12|(c2&63)<<6|c3&63)}else{var codePoint=(c1&7)<<18|(c2&63)<<12|(c3&63)<<6|c4&63;ret=String.fromCharCode(((codePoint-65536)/1024|0)+55296,(codePoint-65536)%1024+56320)}buffer.length=0;return ret});this.processJSString=function processJSString(string){string=unescape(encodeURIComponent(string));var ret=[];for(var i=0;i<string.length;i++){ret.push(string.charCodeAt(i))}return ret}}),getCompilerSetting:(function(name){throw"You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work"}),stackAlloc:(function(size){var ret=STACKTOP;STACKTOP=STACKTOP+size|0;STACKTOP=STACKTOP+15&-16;return ret}),staticAlloc:(function(size){var ret=STATICTOP;STATICTOP=STATICTOP+size|0;STATICTOP=STATICTOP+15&-16;return ret}),dynamicAlloc:(function(size){var ret=DYNAMICTOP;DYNAMICTOP=DYNAMICTOP+size|0;DYNAMICTOP=DYNAMICTOP+15&-16;if(DYNAMICTOP>=TOTAL_MEMORY)enlargeMemory();return ret}),alignMemory:(function(size,quantum){var ret=size=Math.ceil(size/(quantum?quantum:16))*(quantum?quantum:16);return ret}),makeBigInt:(function(low,high,unsigned){var ret=unsigned?+(low>>>0)+ +(high>>>0)*+4294967296:+(low>>>0)+ +(high|0)*+4294967296;return ret}),GLOBAL_BASE:8,QUANTUM_SIZE:4,__dummy__:0};Module["Runtime"]=Runtime;var __THREW__=0;var ABORT=false;var EXITSTATUS=0;var undef=0;var tempValue,tempInt,tempBigInt,tempInt2,tempBigInt2,tempPair,tempBigIntI,tempBigIntR,tempBigIntS,tempBigIntP,tempBigIntD,tempDouble,tempFloat;var tempI64,tempI64b;var tempRet0,tempRet1,tempRet2,tempRet3,tempRet4,tempRet5,tempRet6,tempRet7,tempRet8,tempRet9;function assert(condition,text){if(!condition){abort("Assertion failed: "+text)}}var globalScope=this;function getCFunc(ident){var func=Module["_"+ident];if(!func){try{func=eval("_"+ident)}catch(e){}}assert(func,"Cannot call unknown function "+ident+" (perhaps LLVM optimizations or closure removed it?)");return func}var cwrap,ccall;((function(){var JSfuncs={"stackSave":(function(){Runtime.stackSave()}),"stackRestore":(function(){Runtime.stackRestore()}),"arrayToC":(function(arr){var ret=Runtime.stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}),"stringToC":(function(str){var ret=0;if(str!==null&&str!==undefined&&str!==0){ret=Runtime.stackAlloc((str.length<<2)+1);writeStringToMemory(str,ret)}return ret})};var toC={"string":JSfuncs["stringToC"],"array":JSfuncs["arrayToC"]};ccall=function ccallFunc(ident,returnType,argTypes,args){var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=Runtime.stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func.apply(null,cArgs);if(returnType==="string")ret=Pointer_stringify(ret);if(stack!==0)Runtime.stackRestore(stack);return ret};var sourceRegex=/^function\s*\(([^)]*)\)\s*{\s*([^*]*?)[\s;]*(?:return\s*(.*?)[;\s]*)?}$/;function parseJSFunc(jsfunc){var parsed=jsfunc.toString().match(sourceRegex).slice(1);return{arguments:parsed[0],body:parsed[1],returnValue:parsed[2]}}var JSsource={};for(var fun in JSfuncs){if(JSfuncs.hasOwnProperty(fun)){JSsource[fun]=parseJSFunc(JSfuncs[fun])}}cwrap=function cwrap(ident,returnType,argTypes){argTypes=argTypes||[];var cfunc=getCFunc(ident);var numericArgs=argTypes.every((function(type){return type==="number"}));var numericRet=returnType!=="string";if(numericRet&&numericArgs){return cfunc}var argNames=argTypes.map((function(x,i){return"$"+i}));var funcstr="(function("+argNames.join(",")+") {";var nargs=argTypes.length;if(!numericArgs){funcstr+="var stack = "+JSsource["stackSave"].body+";";for(var i=0;i<nargs;i++){var arg=argNames[i],type=argTypes[i];if(type==="number")continue;var convertCode=JSsource[type+"ToC"];funcstr+="var "+convertCode.arguments+" = "+arg+";";funcstr+=convertCode.body+";";funcstr+=arg+"="+convertCode.returnValue+";"}}var cfuncname=parseJSFunc((function(){return cfunc})).returnValue;funcstr+="var ret = "+cfuncname+"("+argNames.join(",")+");";if(!numericRet){var strgfy=parseJSFunc((function(){return Pointer_stringify})).returnValue;funcstr+="ret = "+strgfy+"(ret);"}if(!numericArgs){funcstr+=JSsource["stackRestore"].body.replace("()","(stack)")+";"}funcstr+="return ret})";return eval(funcstr)}}))();Module["cwrap"]=cwrap;Module["ccall"]=ccall;function setValue(ptr,value,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case"i1":HEAP8[ptr>>0]=value;break;case"i8":HEAP8[ptr>>0]=value;break;case"i16":HEAP16[ptr>>1]=value;break;case"i32":HEAP32[ptr>>2]=value;break;case"i64":tempI64=[value>>>0,(tempDouble=value,+Math_abs(tempDouble)>=+1?tempDouble>+0?(Math_min(+Math_floor(tempDouble/+4294967296),+4294967295)|0)>>>0:~~+Math_ceil((tempDouble- +(~~tempDouble>>>0))/+4294967296)>>>0:0)],HEAP32[ptr>>2]=tempI64[0],HEAP32[ptr+4>>2]=tempI64[1];break;case"float":HEAPF32[ptr>>2]=value;break;case"double":HEAPF64[ptr>>3]=value;break;default:abort("invalid type for setValue: "+type)}}Module["setValue"]=setValue;function getValue(ptr,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case"i1":return HEAP8[ptr>>0];case"i8":return HEAP8[ptr>>0];case"i16":return HEAP16[ptr>>1];case"i32":return HEAP32[ptr>>2];case"i64":return HEAP32[ptr>>2];case"float":return HEAPF32[ptr>>2];case"double":return HEAPF64[ptr>>3];default:abort("invalid type for setValue: "+type)}return null}Module["getValue"]=getValue;var ALLOC_NORMAL=0;var ALLOC_STACK=1;var ALLOC_STATIC=2;var ALLOC_DYNAMIC=3;var ALLOC_NONE=4;Module["ALLOC_NORMAL"]=ALLOC_NORMAL;Module["ALLOC_STACK"]=ALLOC_STACK;Module["ALLOC_STATIC"]=ALLOC_STATIC;Module["ALLOC_DYNAMIC"]=ALLOC_DYNAMIC;Module["ALLOC_NONE"]=ALLOC_NONE;function allocate(slab,types,allocator,ptr){var zeroinit,size;if(typeof slab==="number"){zeroinit=true;size=slab}else{zeroinit=false;size=slab.length}var singleType=typeof types==="string"?types:null;var ret;if(allocator==ALLOC_NONE){ret=ptr}else{ret=[_malloc,Runtime.stackAlloc,Runtime.staticAlloc,Runtime.dynamicAlloc][allocator===undefined?ALLOC_STATIC:allocator](Math.max(size,singleType?1:types.length))}if(zeroinit){var ptr=ret,stop;assert((ret&3)==0);stop=ret+(size&~3);for(;ptr<stop;ptr+=4){HEAP32[ptr>>2]=0}stop=ret+size;while(ptr<stop){HEAP8[ptr++>>0]=0}return ret}if(singleType==="i8"){if(slab.subarray||slab.slice){HEAPU8.set(slab,ret)}else{HEAPU8.set(new Uint8Array(slab),ret)}return ret}var i=0,type,typeSize,previousType;while(i<size){var curr=slab[i];if(typeof curr==="function"){curr=Runtime.getFunctionIndex(curr)}type=singleType||types[i];if(type===0){i++;continue}if(type=="i64")type="i32";setValue(ret+i,curr,type);if(previousType!==type){typeSize=Runtime.getNativeTypeSize(type);previousType=type}i+=typeSize}return ret}Module["allocate"]=allocate;function Pointer_stringify(ptr,length){if(length===0||!ptr)return"";var hasUtf=false;var t;var i=0;while(1){t=HEAPU8[ptr+i>>0];if(t>=128)hasUtf=true;else if(t==0&&!length)break;i++;if(length&&i==length)break}if(!length)length=i;var ret="";if(!hasUtf){var MAX_CHUNK=1024;var curr;while(length>0){curr=String.fromCharCode.apply(String,HEAPU8.subarray(ptr,ptr+Math.min(length,MAX_CHUNK)));ret=ret?ret+curr:curr;ptr+=MAX_CHUNK;length-=MAX_CHUNK}return ret}var utf8=new Runtime.UTF8Processor;for(i=0;i<length;i++){t=HEAPU8[ptr+i>>0];ret+=utf8.processCChar(t)}return ret}Module["Pointer_stringify"]=Pointer_stringify;function UTF16ToString(ptr){var i=0;var str="";while(1){var codeUnit=HEAP16[ptr+i*2>>1];if(codeUnit==0)return str;++i;str+=String.fromCharCode(codeUnit)}}Module["UTF16ToString"]=UTF16ToString;function stringToUTF16(str,outPtr){for(var i=0;i<str.length;++i){var codeUnit=str.charCodeAt(i);HEAP16[outPtr+i*2>>1]=codeUnit}HEAP16[outPtr+str.length*2>>1]=0}Module["stringToUTF16"]=stringToUTF16;function UTF32ToString(ptr){var i=0;var str="";while(1){var utf32=HEAP32[ptr+i*4>>2];if(utf32==0)return str;++i;if(utf32>=65536){var ch=utf32-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}else{str+=String.fromCharCode(utf32)}}}Module["UTF32ToString"]=UTF32ToString;function stringToUTF32(str,outPtr){var iChar=0;for(var iCodeUnit=0;iCodeUnit<str.length;++iCodeUnit){var codeUnit=str.charCodeAt(iCodeUnit);if(codeUnit>=55296&&codeUnit<=57343){var trailSurrogate=str.charCodeAt(++iCodeUnit);codeUnit=65536+((codeUnit&1023)<<10)|trailSurrogate&1023}HEAP32[outPtr+iChar*4>>2]=codeUnit;++iChar}HEAP32[outPtr+iChar*4>>2]=0}Module["stringToUTF32"]=stringToUTF32;function demangle(func){var hasLibcxxabi=!!Module["___cxa_demangle"];if(hasLibcxxabi){try{var buf=_malloc(func.length);writeStringToMemory(func.substr(1),buf);var status=_malloc(4);var ret=Module["___cxa_demangle"](buf,0,0,status);if(getValue(status,"i32")===0&&ret){return Pointer_stringify(ret)}}catch(e){}finally{if(buf)_free(buf);if(status)_free(status);if(ret)_free(ret)}}var i=3;var basicTypes={"v":"void","b":"bool","c":"char","s":"short","i":"int","l":"long","f":"float","d":"double","w":"wchar_t","a":"signed char","h":"unsigned char","t":"unsigned short","j":"unsigned int","m":"unsigned long","x":"long long","y":"unsigned long long","z":"..."};var subs=[];var first=true;function dump(x){if(x)Module.print(x);Module.print(func);var pre="";for(var a=0;a<i;a++)pre+=" ";Module.print(pre+"^")}function parseNested(){i++;if(func[i]==="K")i++;var parts=[];while(func[i]!=="E"){if(func[i]==="S"){i++;var next=func.indexOf("_",i);var num=func.substring(i,next)||0;parts.push(subs[num]||"?");i=next+1;continue}if(func[i]==="C"){parts.push(parts[parts.length-1]);i+=2;continue}var size=parseInt(func.substr(i));var pre=size.toString().length;if(!size||!pre){i--;break}var curr=func.substr(i+pre,size);parts.push(curr);subs.push(curr);i+=pre+size}i++;return parts}function parse(rawList,limit,allowVoid){limit=limit||Infinity;var ret="",list=[];function flushList(){return"("+list.join(", ")+")"}var name;if(func[i]==="N"){name=parseNested().join("::");limit--;if(limit===0)return rawList?[name]:name}else{if(func[i]==="K"||first&&func[i]==="L")i++;var size=parseInt(func.substr(i));if(size){var pre=size.toString().length;name=func.substr(i+pre,size);i+=pre+size}}first=false;if(func[i]==="I"){i++;var iList=parse(true);var iRet=parse(true,1,true);ret+=iRet[0]+" "+name+"<"+iList.join(", ")+">"}else{ret=name}paramLoop:while(i<func.length&&limit-->0){var c=func[i++];if(c in basicTypes){list.push(basicTypes[c])}else{switch(c){case"P":list.push(parse(true,1,true)[0]+"*");break;case"R":list.push(parse(true,1,true)[0]+"&");break;case"L":{i++;var end=func.indexOf("E",i);var size=end-i;list.push(func.substr(i,size));i+=size+2;break};case"A":{var size=parseInt(func.substr(i));i+=size.toString().length;if(func[i]!=="_")throw"?";i++;list.push(parse(true,1,true)[0]+" ["+size+"]");break};case"E":break paramLoop;default:ret+="?"+c;break paramLoop}}}if(!allowVoid&&list.length===1&&list[0]==="void")list=[];if(rawList){if(ret){list.push(ret+"?")}return list}else{return ret+flushList()}}var parsed=func;try{if(func=="Object._main"||func=="_main"){return"main()"}if(typeof func==="number")func=Pointer_stringify(func);if(func[0]!=="_")return func;if(func[1]!=="_")return func;if(func[2]!=="Z")return func;switch(func[3]){case"n":return"operator new()";case"d":return"operator delete()"}parsed=parse()}catch(e){parsed+="?"}if(parsed.indexOf("?")>=0&&!hasLibcxxabi){Runtime.warnOnce("warning: a problem occurred in builtin C++ name demangling; build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling")}return parsed}function demangleAll(text){return text.replace(/__Z[\w\d_]+/g,(function(x){var y=demangle(x);return x===y?x:x+" ["+y+"]"}))}function jsStackTrace(){var err=new Error;if(!err.stack){try{throw new Error(0)}catch(e){err=e}if(!err.stack){return"(no stack trace available)"}}return err.stack.toString()}function stackTrace(){return demangleAll(jsStackTrace())}Module["stackTrace"]=stackTrace;var PAGE_SIZE=4096;function alignMemoryPage(x){return x+4095&-4096}var HEAP;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;var STATIC_BASE=0,STATICTOP=0,staticSealed=false;var STACK_BASE=0,STACKTOP=0,STACK_MAX=0;var DYNAMIC_BASE=0,DYNAMICTOP=0;function enlargeMemory(){abort("Cannot enlarge memory arrays. Either (1) compile with -s TOTAL_MEMORY=X with X higher than the current value "+TOTAL_MEMORY+", (2) compile with ALLOW_MEMORY_GROWTH which adjusts the size at runtime but prevents some optimizations, or (3) set Module.TOTAL_MEMORY before the program runs.")}var TOTAL_STACK=Module["TOTAL_STACK"]||5242880;var TOTAL_MEMORY=Module["TOTAL_MEMORY"]||67108864;var FAST_MEMORY=Module["FAST_MEMORY"]||2097152;var totalMemory=64*1024;while(totalMemory<TOTAL_MEMORY||totalMemory<2*TOTAL_STACK){if(totalMemory<16*1024*1024){totalMemory*=2}else{totalMemory+=16*1024*1024}}if(totalMemory!==TOTAL_MEMORY){Module.printErr("increasing TOTAL_MEMORY to "+totalMemory+" to be compliant with the asm.js spec");TOTAL_MEMORY=totalMemory}assert(typeof Int32Array!=="undefined"&&typeof Float64Array!=="undefined"&&!!(new Int32Array(1))["subarray"]&&!!(new Int32Array(1))["set"],"JS engine does not provide full typed array support");var buffer=new ArrayBuffer(TOTAL_MEMORY);HEAP8=new Int8Array(buffer);HEAP16=new Int16Array(buffer);HEAP32=new Int32Array(buffer);HEAPU8=new Uint8Array(buffer);HEAPU16=new Uint16Array(buffer);HEAPU32=new Uint32Array(buffer);HEAPF32=new Float32Array(buffer);HEAPF64=new Float64Array(buffer);HEAP32[0]=255;assert(HEAPU8[0]===255&&HEAPU8[3]===0,"Typed arrays 2 must be run on a little-endian system");Module["HEAP"]=HEAP;Module["buffer"]=buffer;Module["HEAP8"]=HEAP8;Module["HEAP16"]=HEAP16;Module["HEAP32"]=HEAP32;Module["HEAPU8"]=HEAPU8;Module["HEAPU16"]=HEAPU16;Module["HEAPU32"]=HEAPU32;Module["HEAPF32"]=HEAPF32;Module["HEAPF64"]=HEAPF64;function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback();continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){Runtime.dynCall("v",func)}else{Runtime.dynCall("vi",func,[callback.arg])}}else{func(callback.arg===undefined?null:callback.arg)}}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATEXIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeExited=false;function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function ensureInitRuntime(){if(runtimeInitialized)return;runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function exitRuntime(){callRuntimeCallbacks(__ATEXIT__);runtimeExited=true}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}Module["addOnPreRun"]=Module.addOnPreRun=addOnPreRun;function addOnInit(cb){__ATINIT__.unshift(cb)}Module["addOnInit"]=Module.addOnInit=addOnInit;function addOnPreMain(cb){__ATMAIN__.unshift(cb)}Module["addOnPreMain"]=Module.addOnPreMain=addOnPreMain;function addOnExit(cb){__ATEXIT__.unshift(cb)}Module["addOnExit"]=Module.addOnExit=addOnExit;function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}Module["addOnPostRun"]=Module.addOnPostRun=addOnPostRun;function intArrayFromString(stringy,dontAddNull,length){var ret=(new Runtime.UTF8Processor).processJSString(stringy);if(length){ret.length=length}if(!dontAddNull){ret.push(0)}return ret}Module["intArrayFromString"]=intArrayFromString;function intArrayToString(array){var ret=[];for(var i=0;i<array.length;i++){var chr=array[i];if(chr>255){chr&=255}ret.push(String.fromCharCode(chr))}return ret.join("")}Module["intArrayToString"]=intArrayToString;function writeStringToMemory(string,buffer,dontAddNull){var array=intArrayFromString(string,dontAddNull);var i=0;while(i<array.length){var chr=array[i];HEAP8[buffer+i>>0]=chr;i=i+1}}Module["writeStringToMemory"]=writeStringToMemory;function writeArrayToMemory(array,buffer){for(var i=0;i<array.length;i++){HEAP8[buffer+i>>0]=array[i]}}Module["writeArrayToMemory"]=writeArrayToMemory;function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;i++){HEAP8[buffer+i>>0]=str.charCodeAt(i)}if(!dontAddNull)HEAP8[buffer+str.length>>0]=0}Module["writeAsciiToMemory"]=writeAsciiToMemory;function unSign(value,bits,ignore){if(value>=0){return value}return bits<=32?2*Math.abs(1<<bits-1)+value:Math.pow(2,bits)+value}function reSign(value,bits,ignore){if(value<=0){return value}var half=bits<=32?Math.abs(1<<bits-1):Math.pow(2,bits-1);if(value>=half&&(bits<=32||value>half)){value=-2*half+value}return value}if(!Math["imul"]||Math["imul"](4294967295,5)!==-5)Math["imul"]=function imul(a,b){var ah=a>>>16;var al=a&65535;var bh=b>>>16;var bl=b&65535;return al*bl+(ah*bl+al*bh<<16)|0};Math.imul=Math["imul"];var Math_abs=Math.abs;var Math_cos=Math.cos;var Math_sin=Math.sin;var Math_tan=Math.tan;var Math_acos=Math.acos;var Math_asin=Math.asin;var Math_atan=Math.atan;var Math_atan2=Math.atan2;var Math_exp=Math.exp;var Math_log=Math.log;var Math_sqrt=Math.sqrt;var Math_ceil=Math.ceil;var Math_floor=Math.floor;var Math_pow=Math.pow;var Math_imul=Math.imul;var Math_fround=Math.fround;var Math_min=Math.min;var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}Module["addRunDependency"]=addRunDependency;function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}Module["removeRunDependency"]=removeRunDependency;Module["preloadedImages"]={};Module["preloadedAudios"]={};var memoryInitializer=null;STATIC_BASE=8;STATICTOP=STATIC_BASE+5664;__ATINIT__.push({func:(function(){__GLOBAL__I_a()})},{func:(function(){__GLOBAL__I_a127()})});allocate([78,55,77,105,110,105,115,97,116,50,48,79,117,116,79,102,77,101,109,111,114,121,69,120,99,101,112,116,105,111,110,69,0,0,0,0,0,0,0,0,88,18,0,0,8,0,0,0,78,55,77,105,110,105,115,97,116,54,79,112,116,105,111,110,69,0,0,0,0,0,0,0,88,18,0,0,56,0,0,0,10,32,32,32,32,32,32,32,32,37,115,10,0,0,0,0,0,0,0,0,80,0,0,0,1,0,0,0,2,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,200,0,0,0,1,0,0,0,3,0,0,0,1,0,0,0,1,0,0,0,78,55,77,105,110,105,115,97,116,49,48,66,111,111,108,79,112,116,105,111,110,69,0,0,128,18,0,0,176,0,0,0,80,0,0,0,0,0,0,0,32,32,45,37,115,44,32,45,110,111,45,37,115,0,0,0,40,100,101,102,97,117,108,116,58,32,37,115,41,10,0,0,111,110,0,0,0,0,0,0,111,102,102,0,0,0,0,0,110,111,45,0,0,0,0,0,0,0,0,0,64,1,0,0,1,0,0,0,4,0,0,0,2,0,0,0,2,0,0,0,78,55,77,105,110,105,115,97,116,57,73,110,116,79,112,116,105,111,110,69,0,0,0,0,128,18,0,0,40,1,0,0,80,0,0,0,0,0,0,0,32,32,45,37,45,49,50,115,32,61,32,37,45,56,115,32,91,0,0,0,0,0,0,0,105,109,105,110,0,0,0,0,37,52,100,0,0,0,0,0,32,46,46,32,0,0,0,0,105,109,97,120,0,0,0,0,93,32,40,100,101,102,97,117,108,116,58,32,37,100,41,10,0,0,0,0,0,0,0,0,69,82,82,79,82,33,32,118,97,108,117,101,32,60,37,115,62,32,105,115,32,116,111,111,32,108,97,114,103,101,32,102,111,114,32,111,112,116,105,111,110,32,34,37,115,34,46,10,0,0,0,0,0,0,0,0,69,82,82,79,82,33,32,118,97,108,117,101,32,60,37,115,62,32,105,115,32,116,111,111,32,115,109,97,108,108,32,102,111,114,32,111,112,116,105,111,110,32,34,37,115,34,46,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,118,97,114,45,100,101,99,97,121,0,0,0,0,0,0,0,84,104,101,32,118,97,114,105,97,98,108,101,32,97,99,116,105,118,105,116,121,32,100,101,99,97,121,32,102,97,99,116,111,114,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,99,108,97,45,100,101,99,97,121,0,0,0,0,0,0,0,84,104,101,32,99,108,97,117,115,101,32,97,99,116,105,118,105,116,121,32,100,101,99,97,121,32,102,97,99,116,111,114,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,114,110,100,45,102,114,101,113,0,0,0,0,0,0,0,0,84,104,101,32,102,114,101,113,117,101,110,99,121,32,119,105,116,104,32,119,104,105,99,104,32,116,104,101,32,100,101,99,105,115,105,111,110,32,104,101,117,114,105,115,116,105,99,32,116,114,105,101,115,32,116,111,32,99,104,111,111,115,101,32,97,32,114,97,110,100,111,109,32,118,97,114,105,97,98,108,101,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,114,110,100,45,115,101,101,100,0,0,0,0,0,0,0,0,85,115,101,100,32,98,121,32,116,104,101,32,114,97,110,100,111,109,32,118,97,114,105,97,98,108,101,32,115,101,108,101,99,116,105,111,110,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,99,99,109,105,110,45,109,111,100,101,0,0,0,0,0,0,67,111,110,116,114,111,108,115,32,99,111,110,102,108,105,99,116,32,99,108,97,117,115,101,32,109,105,110,105,109,105,122,97,116,105,111,110,32,40,48,61,110,111,110,101,44,32,49,61,98,97,115,105,99,44,32,50,61,100,101,101,112,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,112,104,97,115,101,45,115,97,118,105,110,103,0,0,0,0,67,111,110,116,114,111,108,115,32,116,104,101,32,108,101,118,101,108,32,111,102,32,112,104,97,115,101,32,115,97,118,105,110,103,32,40,48,61,110,111,110,101,44,32,49,61,108,105,109,105,116,101,100,44,32,50,61,102,117,108,108,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,114,110,100,45,105,110,105,116,0,0,0,0,0,0,0,0,82,97,110,100,111,109,105,122,101,32,116,104,101,32,105,110,105,116,105,97,108,32,97,99,116,105,118,105,116,121,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,108,117,98,121,0,0,0,0,85,115,101,32,116,104,101,32,76,117,98,121,32,114,101,115,116,97,114,116,32,115,101,113,117,101,110,99,101,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,114,102,105,114,115,116,0,0,84,104,101,32,98,97,115,101,32,114,101,115,116,97,114,116,32,105,110,116,101,114,118,97,108,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,114,105,110,99,0,0,0,0,82,101,115,116,97,114,116,32,105,110,116,101,114,118,97,108,32,105,110,99,114,101,97,115,101,32,102,97,99,116,111,114,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,103,99,45,102,114,97,99,0,84,104,101,32,102,114,97,99,116,105,111,110,32,111,102,32,119,97,115,116,101,100,32,109,101,109,111,114,121,32,97,108,108,111,119,101,100,32,98,101,102,111,114,101,32,97,32,103,97,114,98,97,103,101,32,99,111,108,108,101,99,116,105,111,110,32,105,115,32,116,114,105,103,103,101,114,101,100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,109,105,110,45,108,101,97,114,110,116,115,0,0,0,0,0,77,105,110,105,109,117,109,32,108,101,97,114,110,116,32,99,108,97,117,115,101,32,108,105,109,105,116,0,0,0,0,0,0,0,0,0,192,7,0,0,5,0,0,0,6,0,0,0,7,0,0,0,0,0,0,0,124,32,37,57,100,32,124,32,37,55,100,32,37,56,100,32,37,56,100,32,124,32,37,56,100,32,37,56,100,32,37,54,46,48,102,32,124,32,37,54,46,51,102,32,37,37,32,124,10,0,0,0,0,0,0,0,124,32,32,71,97,114,98,97,103,101,32,99,111,108,108,101,99,116,105,111,110,58,32,32,32,37,49,50,100,32,98,121,116,101,115,32,61,62,32,37,49,50,100,32,98,121,116,101,115,32,32,32,32,32,32,32,32,32,32,32,32,32,124,10,0,0,0,0,0,0,0,0,78,55,77,105,110,105,115,97,116,54,83,111,108,118,101,114,69,0,0,0,0,0,0,0,88,18,0,0,168,7,0,0,60,98,111,111,108,62,0,0,10,32,32,32,32,32,32,32,32,37,115,10,0,0,0,0,60,105,110,116,51,50,62,0,69,82,82,79,82,33,32,118,97,108,117,101,32,60,37,115,62,32,105,115,32,116,111,111,32,108,97,114,103,101,32,102,111,114,32,111,112,116,105,111,110,32,34,37,115,34,46,10,0,0,0,0,0,0,0,0,69,82,82,79,82,33,32,118,97,108,117,101,32,60,37,115,62,32,105,115,32,116,111,111,32,115,109,97,108,108,32,102,111,114,32,111,112,116,105,111,110,32,34,37,115,34,46,10,0,0,0,0,0,0,0,0,67,79,82,69,0,0,0,0,60,100,111,117,98,108,101,62,0,0,0,0,0,0,0,0,0,0,0,0,168,8,0,0,1,0,0,0,8,0,0,0,3,0,0,0,3,0,0,0,78,55,77,105,110,105,115,97,116,49,50,68,111,117,98,108,101,79,112,116,105,111,110,69,0,0,0,0,0,0,0,0,128,18,0,0,136,8,0,0,80,0,0,0,0,0,0,0,32,32,45,37,45,49,50,115,32,61,32,37,45,56,115,32,37,99,37,52,46,50,103,32,46,46,32,37,52,46,50,103,37,99,32,40,100,101,102,97,117,108,116,58,32,37,103,41,10,0,0,0,0,0,0,0,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,91,32,83,101,97,114,99,104,32,83,116,97,116,105,115,116,105,99,115,32,93,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,0,124,32,67,111,110,102,108,105,99,116,115,32,124,32,32,32,32,32,32,32,32,32,32,79,82,73,71,73,78,65,76,32,32,32,32,32,32,32,32,32,124,32,32,32,32,32,32,32,32,32,32,76,69,65,82,78,84,32,32,32,32,32,32,32,32,32,32,124,32,80,114,111,103,114,101,115,115,32,124,0,124,32,32,32,32,32,32,32,32,32,32,32,124,32,32,32,32,86,97,114,115,32,32,67,108,97,117,115,101,115,32,76,105,116,101,114,97,108,115,32,124,32,32,32,32,76,105,109,105,116,32,32,67,108,97,117,115,101,115,32,76,105,116,47,67,108,32,124,32,32,32,32,32,32,32,32,32,32,124,0,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,97,115,121,109,109,0,0,0,83,104,114,105,110,107,32,99,108,97,117,115,101,115,32,98,121,32,97,115,121,109,109,101,116,114,105,99,32,98,114,97,110,99,104,105,110,103,46,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,114,99,104,101,99,107,0,0,67,104,101,99,107,32,105,102,32,97,32,99,108,97,117,115,101,32,105,115,32,97,108,114,101,97,100,121,32,105,109,112,108,105,101,100,46,32,40,99,111,115,116,108,121,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,101,108,105,109,0,0,0,0,80,101,114,102,111,114,109,32,118,97,114,105,97,98,108,101,32,101,108,105,109,105,110,97,116,105,111,110,46,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,103,114,111,119,0,0,0,0,65,108,108,111,119,32,97,32,118,97,114,105,97,98,108,101,32,101,108,105,109,105,110,97,116,105,111,110,32,115,116,101,112,32,116,111,32,103,114,111,119,32,98,121,32,97,32,110,117,109,98,101,114,32,111,102,32,99,108,97,117,115,101,115,46,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,99,108,45,108,105,109,0,0,86,97,114,105,97,98,108,101,115,32,97,114,101,32,110,111,116,32,101,108,105,109,105,110,97,116,101,100,32,105,102,32,105,116,32,112,114,111,100,117,99,101,115,32,97,32,114,101,115,111,108,118,101,110,116,32,119,105,116,104,32,97,32,108,101,110,103,116,104,32,97,98,111,118,101,32,116,104,105,115,32,108,105,109,105,116,46,32,45,49,32,109,101,97,110,115,32,110,111,32,108,105,109,105,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,115,117,98,45,108,105,109,0,68,111,32,110,111,116,32,99,104,101,99,107,32,105,102,32,115,117,98,115,117,109,112,116,105,111,110,32,97,103,97,105,110,115,116,32,97,32,99,108,97,117,115,101,32,108,97,114,103,101,114,32,116,104,97,110,32,116,104,105,115,46,32,45,49,32,109,101,97,110,115,32,110,111,32,108,105,109,105,116,46,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,115,105,109,112,45,103,99,45,102,114,97,99,0,0,0,0,84,104,101,32,102,114,97,99,116,105,111,110,32,111,102,32,119,97,115,116,101,100,32,109,101,109,111,114,121,32,97,108,108,111,119,101,100,32,98,101,102,111,114,101,32,97,32,103,97,114,98,97,103,101,32,99,111,108,108,101,99,116,105,111,110,32,105,115,32,116,114,105,103,103,101,114,101,100,32,100,117,114,105,110,103,32,115,105,109,112,108,105,102,105,99,97,116,105,111,110,46,0,0,0,0,0,0,0,120,14,0,0,9,0,0,0,10,0,0,0,11,0,0,0,0,0,0,0,115,117,98,115,117,109,112,116,105,111,110,32,108,101,102,116,58,32,37,49,48,100,32,40,37,49,48,100,32,115,117,98,115,117,109,101,100,44,32,37,49,48,100,32,100,101,108,101,116,101,100,32,108,105,116,101,114,97,108,115,41,13,0,0,101,108,105,109,105,110,97,116,105,111,110,32,108,101,102,116,58,32,37,49,48,100,13,0,124,32,32,69,108,105,109,105,110,97,116,101,100,32,99,108,97,117,115,101,115,58,32,32,32,32,32,37,49,48,46,50,102,32,77,98,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,124,10,0,0,0,0,124,32,32,71,97,114,98,97,103,101,32,99,111,108,108,101,99,116,105,111,110,58,32,32,32,37,49,50,100,32,98,121,116,101,115,32,61,62,32,37,49,50,100,32,98,121,116,101,115,32,32,32,32,32,32,32,32,32,32,32,32,32,124,10,0,0,0,0,0,0,0,0,78,55,77,105,110,105,115,97,116,49,48,83,105,109,112,83,111,108,118,101,114,69,0,0,128,18,0,0,96,14,0,0,192,7,0,0,0,0,0,0,60,100,111,117,98,108,101,62,0,0,0,0,0,0,0,0,60,105,110,116,51,50,62,0,83,73,77,80,0,0,0,0,60,98,111,111,108,62,0,0,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,89,79,33,0,0,0,0,0,2,0,0,0,0,0,0,0,48,15,0,0,0,0,0,0,117,110,99,97,117,103,104,116,0,0,0,0,0,0,0,0,116,101,114,109,105,110,97,116,105,110,103,32,119,105,116,104,32,37,115,32,101,120,99,101,112,116,105,111,110,32,111,102,32,116,121,112,101,32,37,115,58,32,37,115,0,0,0,0,116,101,114,109,105,110,97,116,105,110,103,32,119,105,116,104,32,37,115,32,101,120,99,101,112,116,105,111,110,32,111,102,32,116,121,112,101,32,37,115,0,0,0,0,0,0,0,0,116,101,114,109,105,110,97,116,105,110,103,32,119,105,116,104,32,37,115,32,102,111,114,101,105,103,110,32,101,120,99,101,112,116,105,111,110,0,0,0,116,101,114,109,105,110,97,116,105,110,103,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,112,116,104,114,101,97,100,95,111,110,99,101,32,102,97,105,108,117,114,101,32,105,110,32,95,95,99,120,97,95,103,101,116,95,103,108,111,98,97,108,115,95,102,97,115,116,40,41,0,0,0,0,0,0,0,0,99,97,110,110,111,116,32,99,114,101,97,116,101,32,112,116,104,114,101,97,100,32,107,101,121,32,102,111,114,32,95,95,99,120,97,95,103,101,116,95,103,108,111,98,97,108,115,40,41,0,0,0,0,0,0,0,99,97,110,110,111,116,32,122,101,114,111,32,111,117,116,32,116,104,114,101,97,100,32,118,97,108,117,101,32,102,111,114,32,95,95,99,120,97,95,103,101,116,95,103,108,111,98,97,108,115,40,41,0,0,0,0,0,0,0,0,200,16,0,0,12,0,0,0,13,0,0,0,1,0,0,0,0,0,0,0,115,116,100,58,58,98,97,100,95,97,108,108,111,99,0,0,83,116,57,98,97,100,95,97,108,108,111,99,0,0,0,0,128,18,0,0,184,16,0,0,80,17,0,0,0,0,0,0,116,101,114,109,105,110,97,116,101,95,104,97,110,100,108,101,114,32,117,110,101,120,112,101,99,116,101,100,108,121,32,114,101,116,117,114,110,101,100,0,116,101,114,109,105,110,97,116,101,95,104,97,110,100,108,101,114,32,117,110,101,120,112,101,99,116,101,100,108,121,32,116,104,114,101,119,32,97,110,32,101,120,99,101,112,116,105,111,110,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,83,116,57,101,120,99,101,112,116,105,111,110,0,0,0,0,88,18,0,0,64,17,0,0,83,116,57,116,121,112,101,95,105,110,102,111,0,0,0,0,88,18,0,0,88,17,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,54,95,95,115,104,105,109,95,116,121,112,101,95,105,110,102,111,69,0,0,0,0,0,0,0,0,128,18,0,0,112,17,0,0,104,17,0,0,0,0,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,55,95,95,99,108,97,115,115,95,116,121,112,101,95,105,110,102,111,69,0,0,0,0,0,0,0,128,18,0,0,168,17,0,0,152,17,0,0,0,0,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,57,95,95,112,111,105,110,116,101,114,95,116,121,112,101,95,105,110,102,111,69,0,0,0,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,55,95,95,112,98,97,115,101,95,116,121,112,101,95,105,110,102,111,69,0,0,0,0,0,0,0,128,18,0,0,8,18,0,0,152,17,0,0,0,0,0,0,128,18,0,0,224,17,0,0,48,18,0,0,0,0,0,0,0,0,0,0,208,17,0,0,14,0,0,0,15,0,0,0,16,0,0,0,17,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,200,18,0,0,14,0,0,0,18,0,0,0,16,0,0,0,17,0,0,0,1,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,50,48,95,95,115,105,95,99,108,97,115,115,95,116,121,112,101,95,105,110,102,111,69,0,0,0,0,128,18,0,0,160,18,0,0,208,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,2,3,4,5,6,7,8,9,255,255,255,255,255,255,255,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,255,255,255,255,255,255,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,1,2,4,7,3,6,5,0,0,0,0,0,0,0,0,105,110,102,105,110,105,116,121,0,0,0,0,0,0,0,0,110,97,110,0,0,0,0,0,95,112,137,0,255,9,47,15,10,0,0,0,100,0,0,0,232,3,0,0,16,39,0,0,160,134,1,0,64,66,15,0,128,150,152,0,0,225,245,5],"i8",ALLOC_NONE,Runtime.GLOBAL_BASE);var tempDoublePtr=Runtime.alignMemory(allocate(12,"i8",ALLOC_STATIC),8);assert(tempDoublePtr%8==0);function copyTempFloat(ptr){HEAP8[tempDoublePtr]=HEAP8[ptr];HEAP8[tempDoublePtr+1]=HEAP8[ptr+1];HEAP8[tempDoublePtr+2]=HEAP8[ptr+2];HEAP8[tempDoublePtr+3]=HEAP8[ptr+3]}function copyTempDouble(ptr){HEAP8[tempDoublePtr]=HEAP8[ptr];HEAP8[tempDoublePtr+1]=HEAP8[ptr+1];HEAP8[tempDoublePtr+2]=HEAP8[ptr+2];HEAP8[tempDoublePtr+3]=HEAP8[ptr+3];HEAP8[tempDoublePtr+4]=HEAP8[ptr+4];HEAP8[tempDoublePtr+5]=HEAP8[ptr+5];HEAP8[tempDoublePtr+6]=HEAP8[ptr+6];HEAP8[tempDoublePtr+7]=HEAP8[ptr+7]}function _atexit(func,arg){__ATEXIT__.unshift({func:func,arg:arg})}function ___cxa_atexit(){return _atexit.apply(null,arguments)}Module["_i64Subtract"]=_i64Subtract;var ___errno_state=0;function ___setErrNo(value){HEAP32[___errno_state>>2]=value;return value}var ERRNO_CODES={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};function _sysconf(name){switch(name){case 30:return PAGE_SIZE;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 80:case 81:case 79:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:{if(typeof navigator==="object")return navigator["hardwareConcurrency"]||1;return 1}}___setErrNo(ERRNO_CODES.EINVAL);return-1}function __ZSt18uncaught_exceptionv(){return!!__ZSt18uncaught_exceptionv.uncaught_exception}var EXCEPTIONS={last:0,caught:[],infos:{},deAdjust:(function(adjusted){if(!adjusted||EXCEPTIONS.infos[adjusted])return adjusted;for(var ptr in EXCEPTIONS.infos){var info=EXCEPTIONS.infos[ptr];if(info.adjusted===adjusted){return ptr}}return adjusted}),addRef:(function(ptr){if(!ptr)return;var info=EXCEPTIONS.infos[ptr];info.refcount++}),decRef:(function(ptr){if(!ptr)return;var info=EXCEPTIONS.infos[ptr];assert(info.refcount>0);info.refcount--;if(info.refcount===0){if(info.destructor){Runtime.dynCall("vi",info.destructor,[ptr])}delete EXCEPTIONS.infos[ptr];___cxa_free_exception(ptr)}}),clearRef:(function(ptr){if(!ptr)return;var info=EXCEPTIONS.infos[ptr];info.refcount=0})};function ___resumeException(ptr){if(!EXCEPTIONS.last){EXCEPTIONS.last=ptr}EXCEPTIONS.clearRef(EXCEPTIONS.deAdjust(ptr));throw ptr+" - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch."}function ___cxa_find_matching_catch(){var thrown=EXCEPTIONS.last;if(!thrown){return(asm["setTempRet0"](0),0)|0}var info=EXCEPTIONS.infos[thrown];var throwntype=info.type;if(!throwntype){return(asm["setTempRet0"](0),thrown)|0}var typeArray=Array.prototype.slice.call(arguments);var pointer=Module["___cxa_is_pointer_type"](throwntype);if(!___cxa_find_matching_catch.buffer)___cxa_find_matching_catch.buffer=_malloc(4);HEAP32[___cxa_find_matching_catch.buffer>>2]=thrown;thrown=___cxa_find_matching_catch.buffer;for(var i=0;i<typeArray.length;i++){if(typeArray[i]&&Module["___cxa_can_catch"](typeArray[i],throwntype,thrown)){thrown=HEAP32[thrown>>2];info.adjusted=thrown;return(asm["setTempRet0"](typeArray[i]),thrown)|0}}thrown=HEAP32[thrown>>2];return(asm["setTempRet0"](throwntype),thrown)|0}function ___cxa_throw(ptr,type,destructor){EXCEPTIONS.infos[ptr]={ptr:ptr,adjusted:ptr,type:type,destructor:destructor,refcount:0};EXCEPTIONS.last=ptr;if(!("uncaught_exception"in __ZSt18uncaught_exceptionv)){__ZSt18uncaught_exceptionv.uncaught_exception=1}else{__ZSt18uncaught_exceptionv.uncaught_exception++}throw ptr+" - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch."}Module["_memset"]=_memset;Module["_bitshift64Shl"]=_bitshift64Shl;function _abort(){Module["abort"]()}var FS=undefined;var SOCKFS=undefined;function _send(fd,buf,len,flags){var sock=SOCKFS.getSocket(fd);if(!sock){___setErrNo(ERRNO_CODES.EBADF);return-1}return _write(fd,buf,len)}function _pwrite(fildes,buf,nbyte,offset){var stream=FS.getStream(fildes);if(!stream){___setErrNo(ERRNO_CODES.EBADF);return-1}try{var slab=HEAP8;return FS.write(stream,slab,buf,nbyte,offset)}catch(e){FS.handleFSError(e);return-1}}function _write(fildes,buf,nbyte){var stream=FS.getStream(fildes);if(!stream){___setErrNo(ERRNO_CODES.EBADF);return-1}try{var slab=HEAP8;return FS.write(stream,slab,buf,nbyte)}catch(e){FS.handleFSError(e);return-1}}function _fileno(stream){stream=FS.getStreamFromPtr(stream);if(!stream)return-1;return stream.fd}function _fwrite(ptr,size,nitems,stream){var bytesToWrite=nitems*size;if(bytesToWrite==0)return 0;var fd=_fileno(stream);var bytesWritten=_write(fd,ptr,bytesToWrite);if(bytesWritten==-1){var streamObj=FS.getStreamFromPtr(stream);if(streamObj)streamObj.error=true;return 0}else{return bytesWritten/size|0}}Module["_strlen"]=_strlen;function __reallyNegative(x){return x<0||x===0&&1/x===-Infinity}function __formatString(format,varargs){var textIndex=format;var argIndex=0;function getNextArg(type){var ret;if(type==="double"){ret=(HEAP32[tempDoublePtr>>2]=HEAP32[varargs+argIndex>>2],HEAP32[tempDoublePtr+4>>2]=HEAP32[varargs+(argIndex+4)>>2],+HEAPF64[tempDoublePtr>>3])}else if(type=="i64"){ret=[HEAP32[varargs+argIndex>>2],HEAP32[varargs+(argIndex+4)>>2]]}else{type="i32";ret=HEAP32[varargs+argIndex>>2]}argIndex+=Runtime.getNativeFieldSize(type);return ret}var ret=[];var curr,next,currArg;while(1){var startTextIndex=textIndex;curr=HEAP8[textIndex>>0];if(curr===0)break;next=HEAP8[textIndex+1>>0];if(curr==37){var flagAlwaysSigned=false;var flagLeftAlign=false;var flagAlternative=false;var flagZeroPad=false;var flagPadSign=false;flagsLoop:while(1){switch(next){case 43:flagAlwaysSigned=true;break;case 45:flagLeftAlign=true;break;case 35:flagAlternative=true;break;case 48:if(flagZeroPad){break flagsLoop}else{flagZeroPad=true;break};case 32:flagPadSign=true;break;default:break flagsLoop}textIndex++;next=HEAP8[textIndex+1>>0]}var width=0;if(next==42){width=getNextArg("i32");textIndex++;next=HEAP8[textIndex+1>>0]}else{while(next>=48&&next<=57){width=width*10+(next-48);textIndex++;next=HEAP8[textIndex+1>>0]}}var precisionSet=false,precision=-1;if(next==46){precision=0;precisionSet=true;textIndex++;next=HEAP8[textIndex+1>>0];if(next==42){precision=getNextArg("i32");textIndex++}else{while(1){var precisionChr=HEAP8[textIndex+1>>0];if(precisionChr<48||precisionChr>57)break;precision=precision*10+(precisionChr-48);textIndex++}}next=HEAP8[textIndex+1>>0]}if(precision<0){precision=6;precisionSet=false}var argSize;switch(String.fromCharCode(next)){case"h":var nextNext=HEAP8[textIndex+2>>0];if(nextNext==104){textIndex++;argSize=1}else{argSize=2}break;case"l":var nextNext=HEAP8[textIndex+2>>0];if(nextNext==108){textIndex++;argSize=8}else{argSize=4}break;case"L":case"q":case"j":argSize=8;break;case"z":case"t":case"I":argSize=4;break;default:argSize=null}if(argSize)textIndex++;next=HEAP8[textIndex+1>>0];switch(String.fromCharCode(next)){case"d":case"i":case"u":case"o":case"x":case"X":case"p":{var signed=next==100||next==105;argSize=argSize||4;var currArg=getNextArg("i"+argSize*8);var origArg=currArg;var argText;if(argSize==8){currArg=Runtime.makeBigInt(currArg[0],currArg[1],next==117)}if(argSize<=4){var limit=Math.pow(256,argSize)-1;currArg=(signed?reSign:unSign)(currArg&limit,argSize*8)}var currAbsArg=Math.abs(currArg);var prefix="";if(next==100||next==105){if(argSize==8&&i64Math)argText=i64Math.stringify(origArg[0],origArg[1],null);else argText=reSign(currArg,8*argSize,1).toString(10)}else if(next==117){if(argSize==8&&i64Math)argText=i64Math.stringify(origArg[0],origArg[1],true);else argText=unSign(currArg,8*argSize,1).toString(10);currArg=Math.abs(currArg)}else if(next==111){argText=(flagAlternative?"0":"")+currAbsArg.toString(8)}else if(next==120||next==88){prefix=flagAlternative&&currArg!=0?"0x":"";if(argSize==8&&i64Math){if(origArg[1]){argText=(origArg[1]>>>0).toString(16);var lower=(origArg[0]>>>0).toString(16);while(lower.length<8)lower="0"+lower;argText+=lower}else{argText=(origArg[0]>>>0).toString(16)}}else if(currArg<0){currArg=-currArg;argText=(currAbsArg-1).toString(16);var buffer=[];for(var i=0;i<argText.length;i++){buffer.push((15-parseInt(argText[i],16)).toString(16))}argText=buffer.join("");while(argText.length<argSize*2)argText="f"+argText}else{argText=currAbsArg.toString(16)}if(next==88){prefix=prefix.toUpperCase();argText=argText.toUpperCase()}}else if(next==112){if(currAbsArg===0){argText="(nil)"}else{prefix="0x";argText=currAbsArg.toString(16)}}if(precisionSet){while(argText.length<precision){argText="0"+argText}}if(currArg>=0){if(flagAlwaysSigned){prefix="+"+prefix}else if(flagPadSign){prefix=" "+prefix}}if(argText.charAt(0)=="-"){prefix="-"+prefix;argText=argText.substr(1)}while(prefix.length+argText.length<width){if(flagLeftAlign){argText+=" "}else{if(flagZeroPad){argText="0"+argText}else{prefix=" "+prefix}}}argText=prefix+argText;argText.split("").forEach((function(chr){ret.push(chr.charCodeAt(0))}));break};case"f":case"F":case"e":case"E":case"g":case"G":{var currArg=getNextArg("double");var argText;if(isNaN(currArg)){argText="nan";flagZeroPad=false}else if(!isFinite(currArg)){argText=(currArg<0?"-":"")+"inf";flagZeroPad=false}else{var isGeneral=false;var effectivePrecision=Math.min(precision,20);if(next==103||next==71){isGeneral=true;precision=precision||1;var exponent=parseInt(currArg.toExponential(effectivePrecision).split("e")[1],10);if(precision>exponent&&exponent>=-4){next=(next==103?"f":"F").charCodeAt(0);precision-=exponent+1}else{next=(next==103?"e":"E").charCodeAt(0);precision--}effectivePrecision=Math.min(precision,20)}if(next==101||next==69){argText=currArg.toExponential(effectivePrecision);if(/[eE][-+]\d$/.test(argText)){argText=argText.slice(0,-1)+"0"+argText.slice(-1)}}else if(next==102||next==70){argText=currArg.toFixed(effectivePrecision);if(currArg===0&&__reallyNegative(currArg)){argText="-"+argText}}var parts=argText.split("e");if(isGeneral&&!flagAlternative){while(parts[0].length>1&&parts[0].indexOf(".")!=-1&&(parts[0].slice(-1)=="0"||parts[0].slice(-1)==".")){parts[0]=parts[0].slice(0,-1)}}else{if(flagAlternative&&argText.indexOf(".")==-1)parts[0]+=".";while(precision>effectivePrecision++)parts[0]+="0"}argText=parts[0]+(parts.length>1?"e"+parts[1]:"");if(next==69)argText=argText.toUpperCase();if(currArg>=0){if(flagAlwaysSigned){argText="+"+argText}else if(flagPadSign){argText=" "+argText}}}while(argText.length<width){if(flagLeftAlign){argText+=" "}else{if(flagZeroPad&&(argText[0]=="-"||argText[0]=="+")){argText=argText[0]+"0"+argText.slice(1)}else{argText=(flagZeroPad?"0":" ")+argText}}}if(next<97)argText=argText.toUpperCase();argText.split("").forEach((function(chr){ret.push(chr.charCodeAt(0))}));break};case"s":{var arg=getNextArg("i8*");var argLength=arg?_strlen(arg):"(null)".length;if(precisionSet)argLength=Math.min(argLength,precision);if(!flagLeftAlign){while(argLength<width--){ret.push(32)}}if(arg){for(var i=0;i<argLength;i++){ret.push(HEAPU8[arg++>>0])}}else{ret=ret.concat(intArrayFromString("(null)".substr(0,argLength),true))}if(flagLeftAlign){while(argLength<width--){ret.push(32)}}break};case"c":{if(flagLeftAlign)ret.push(getNextArg("i8"));while(--width>0){ret.push(32)}if(!flagLeftAlign)ret.push(getNextArg("i8"));break};case"n":{var ptr=getNextArg("i32*");HEAP32[ptr>>2]=ret.length;break};case"%":{ret.push(curr);break};default:{for(var i=startTextIndex;i<textIndex+2;i++){ret.push(HEAP8[i>>0])}}}textIndex+=2}else{ret.push(curr);textIndex+=1}}return ret}function _fprintf(stream,format,varargs){var result=__formatString(format,varargs);var stack=Runtime.stackSave();var ret=_fwrite(allocate(result,"i8",ALLOC_STACK),1,result.length,stream);Runtime.stackRestore(stack);return ret}function _printf(format,varargs){var result=__formatString(format,varargs);var string=intArrayToString(result);if(string[string.length-1]==="\n")string=string.substr(0,string.length-1);Module.print(string);return result.length}function _pthread_once(ptr,func){if(!_pthread_once.seen)_pthread_once.seen={};if(ptr in _pthread_once.seen)return;Runtime.dynCall("v",func);_pthread_once.seen[ptr]=1}function _fputc(c,stream){var chr=unSign(c&255);HEAP8[_fputc.ret>>0]=chr;var fd=_fileno(stream);var ret=_write(fd,_fputc.ret,1);if(ret==-1){var streamObj=FS.getStreamFromPtr(stream);if(streamObj)streamObj.error=true;return-1}else{return chr}}var PTHREAD_SPECIFIC={};function _pthread_getspecific(key){return PTHREAD_SPECIFIC[key]||0}Module["_i64Add"]=_i64Add;function _fputs(s,stream){var fd=_fileno(stream);return _write(fd,s,_strlen(s))}var _stdout=allocate(1,"i32*",ALLOC_STATIC);function _puts(s){var result=Pointer_stringify(s);var string=result.substr(0);if(string[string.length-1]==="\n")string=string.substr(0,string.length-1);Module.print(string);return result.length}function _pthread_setspecific(key,value){if(!(key in PTHREAD_SPECIFIC)){return ERRNO_CODES.EINVAL}PTHREAD_SPECIFIC[key]=value;return 0}function __exit(status){Module["exit"](status)}function _exit(status){__exit(status)}var _UItoD=true;function _malloc(bytes){var ptr=Runtime.dynamicAlloc(bytes+8);return ptr+8&4294967288}Module["_malloc"]=_malloc;function ___cxa_allocate_exception(size){return _malloc(size)}function _fmod(x,y){return x%y}function _fmodl(){return _fmod.apply(null,arguments)}Module["_bitshift64Lshr"]=_bitshift64Lshr;function ___cxa_pure_virtual(){ABORT=true;throw"Pure virtual function called!"}function _time(ptr){var ret=Date.now()/1e3|0;if(ptr){HEAP32[ptr>>2]=ret}return ret}var PTHREAD_SPECIFIC_NEXT_KEY=1;function _pthread_key_create(key,destructor){if(key==0){return ERRNO_CODES.EINVAL}HEAP32[key>>2]=PTHREAD_SPECIFIC_NEXT_KEY;PTHREAD_SPECIFIC[PTHREAD_SPECIFIC_NEXT_KEY]=0;PTHREAD_SPECIFIC_NEXT_KEY++;return 0}function ___cxa_guard_acquire(variable){if(!HEAP8[variable>>0]){HEAP8[variable>>0]=1;return 1}return 0}function ___cxa_guard_release(){}function _vfprintf(s,f,va_arg){return _fprintf(s,f,HEAP32[va_arg>>2])}function ___cxa_begin_catch(ptr){__ZSt18uncaught_exceptionv.uncaught_exception--;EXCEPTIONS.caught.push(ptr);EXCEPTIONS.addRef(EXCEPTIONS.deAdjust(ptr));return ptr}function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest);return dest}Module["_memcpy"]=_memcpy;var _llvm_pow_f64=Math_pow;function _sbrk(bytes){var self=_sbrk;if(!self.called){DYNAMICTOP=alignMemoryPage(DYNAMICTOP);self.called=true;assert(Runtime.dynamicAlloc);self.alloc=Runtime.dynamicAlloc;Runtime.dynamicAlloc=(function(){abort("cannot dynamically allocate, sbrk now has control")})}var ret=DYNAMICTOP;if(bytes!=0)self.alloc(bytes);return ret}var _fabs=Math_abs;function ___errno_location(){return ___errno_state}var _BItoD=true;function _copysign(a,b){return __reallyNegative(a)===__reallyNegative(b)?a:-a}function _copysignl(){return _copysign.apply(null,arguments)}var ___dso_handle=allocate(1,"i32*",ALLOC_STATIC);var _stderr=allocate(1,"i32*",ALLOC_STATIC);___errno_state=Runtime.staticAlloc(4);HEAP32[___errno_state>>2]=0;_fputc.ret=allocate([0],"i8",ALLOC_STATIC);STACK_BASE=STACKTOP=Runtime.alignMemory(STATICTOP);staticSealed=true;STACK_MAX=STACK_BASE+TOTAL_STACK;DYNAMIC_BASE=DYNAMICTOP=Runtime.alignMemory(STACK_MAX);assert(DYNAMIC_BASE<TOTAL_MEMORY,"TOTAL_MEMORY not big enough for stack");var ctlz_i8=allocate([8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"i8",ALLOC_DYNAMIC);var cttz_i8=allocate([8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0],"i8",ALLOC_DYNAMIC);function invoke_iiii(index,a1,a2,a3){try{return Module["dynCall_iiii"](index,a1,a2,a3)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_viiiii(index,a1,a2,a3,a4,a5){try{Module["dynCall_viiiii"](index,a1,a2,a3,a4,a5)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_vi(index,a1){try{Module["dynCall_vi"](index,a1)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_vii(index,a1,a2){try{Module["dynCall_vii"](index,a1,a2)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_ii(index,a1){try{return Module["dynCall_ii"](index,a1)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_v(index){try{Module["dynCall_v"](index)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_viiiiii(index,a1,a2,a3,a4,a5,a6){try{Module["dynCall_viiiiii"](index,a1,a2,a3,a4,a5,a6)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_iii(index,a1,a2){try{return Module["dynCall_iii"](index,a1,a2)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_viiii(index,a1,a2,a3,a4){try{Module["dynCall_viiii"](index,a1,a2,a3,a4)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}Module.asmGlobalArg={"Math":Math,"Int8Array":Int8Array,"Int16Array":Int16Array,"Int32Array":Int32Array,"Uint8Array":Uint8Array,"Uint16Array":Uint16Array,"Uint32Array":Uint32Array,"Float32Array":Float32Array,"Float64Array":Float64Array};Module.asmLibraryArg={"abort":abort,"assert":assert,"min":Math_min,"invoke_iiii":invoke_iiii,"invoke_viiiii":invoke_viiiii,"invoke_vi":invoke_vi,"invoke_vii":invoke_vii,"invoke_ii":invoke_ii,"invoke_v":invoke_v,"invoke_viiiiii":invoke_viiiiii,"invoke_iii":invoke_iii,"invoke_viiii":invoke_viiii,"_fabs":_fabs,"_llvm_pow_f64":_llvm_pow_f64,"_send":_send,"_fmod":_fmod,"___cxa_guard_acquire":___cxa_guard_acquire,"___setErrNo":___setErrNo,"_vfprintf":_vfprintf,"___cxa_allocate_exception":___cxa_allocate_exception,"___cxa_find_matching_catch":___cxa_find_matching_catch,"___cxa_guard_release":___cxa_guard_release,"_pwrite":_pwrite,"__reallyNegative":__reallyNegative,"_sbrk":_sbrk,"___cxa_begin_catch":___cxa_begin_catch,"_emscripten_memcpy_big":_emscripten_memcpy_big,"_fileno":_fileno,"___resumeException":___resumeException,"__ZSt18uncaught_exceptionv":__ZSt18uncaught_exceptionv,"_sysconf":_sysconf,"_pthread_getspecific":_pthread_getspecific,"_atexit":_atexit,"_pthread_once":_pthread_once,"_puts":_puts,"_printf":_printf,"_pthread_key_create":_pthread_key_create,"_write":_write,"___errno_location":___errno_location,"_pthread_setspecific":_pthread_setspecific,"___cxa_atexit":___cxa_atexit,"_copysign":_copysign,"_fputc":_fputc,"___cxa_throw":___cxa_throw,"__exit":__exit,"_copysignl":_copysignl,"_abort":_abort,"_fwrite":_fwrite,"_time":_time,"_fprintf":_fprintf,"__formatString":__formatString,"_fputs":_fputs,"_exit":_exit,"___cxa_pure_virtual":___cxa_pure_virtual,"_fmodl":_fmodl,"STACKTOP":STACKTOP,"STACK_MAX":STACK_MAX,"tempDoublePtr":tempDoublePtr,"ABORT":ABORT,"cttz_i8":cttz_i8,"ctlz_i8":ctlz_i8,"NaN":NaN,"Infinity":Infinity,"___dso_handle":___dso_handle,"_stderr":_stderr};// EMSCRIPTEN_START_ASM
  var asm=(function(global,env,buffer) {
  "use asm";var a=new global.Int8Array(buffer);var b=new global.Int16Array(buffer);var c=new global.Int32Array(buffer);var d=new global.Uint8Array(buffer);var e=new global.Uint16Array(buffer);var f=new global.Uint32Array(buffer);var g=new global.Float32Array(buffer);var h=new global.Float64Array(buffer);var i=env.STACKTOP|0;var j=env.STACK_MAX|0;var k=env.tempDoublePtr|0;var l=env.ABORT|0;var m=env.cttz_i8|0;var n=env.ctlz_i8|0;var o=env.___dso_handle|0;var p=env._stderr|0;var q=0;var r=0;var s=0;var t=0;var u=+env.NaN,v=+env.Infinity;var w=0,x=0,y=0,z=0,A=0.0,B=0,C=0,D=0,E=0.0;var F=0;var G=0;var H=0;var I=0;var J=0;var K=0;var L=0;var M=0;var N=0;var O=0;var P=global.Math.floor;var Q=global.Math.abs;var R=global.Math.sqrt;var S=global.Math.pow;var T=global.Math.cos;var U=global.Math.sin;var V=global.Math.tan;var W=global.Math.acos;var X=global.Math.asin;var Y=global.Math.atan;var Z=global.Math.atan2;var _=global.Math.exp;var $=global.Math.log;var aa=global.Math.ceil;var ba=global.Math.imul;var ca=env.abort;var da=env.assert;var ea=env.min;var fa=env.invoke_iiii;var ga=env.invoke_viiiii;var ha=env.invoke_vi;var ia=env.invoke_vii;var ja=env.invoke_ii;var ka=env.invoke_v;var la=env.invoke_viiiiii;var ma=env.invoke_iii;var na=env.invoke_viiii;var oa=env._fabs;var pa=env._llvm_pow_f64;var qa=env._send;var ra=env._fmod;var sa=env.___cxa_guard_acquire;var ta=env.___setErrNo;var ua=env._vfprintf;var va=env.___cxa_allocate_exception;var wa=env.___cxa_find_matching_catch;var xa=env.___cxa_guard_release;var ya=env._pwrite;var za=env.__reallyNegative;var Aa=env._sbrk;var Ba=env.___cxa_begin_catch;var Ca=env._emscripten_memcpy_big;var Da=env._fileno;var Ea=env.___resumeException;var Fa=env.__ZSt18uncaught_exceptionv;var Ga=env._sysconf;var Ha=env._pthread_getspecific;var Ia=env._atexit;var Ja=env._pthread_once;var Ka=env._puts;var La=env._printf;var Ma=env._pthread_key_create;var Na=env._write;var Oa=env.___errno_location;var Pa=env._pthread_setspecific;var Qa=env.___cxa_atexit;var Ra=env._copysign;var Sa=env._fputc;var Ta=env.___cxa_throw;var Ua=env.__exit;var Va=env._copysignl;var Wa=env._abort;var Xa=env._fwrite;var Ya=env._time;var Za=env._fprintf;var _a=env.__formatString;var $a=env._fputs;var ab=env._exit;var bb=env.___cxa_pure_virtual;var cb=env._fmodl;var db=0.0;
  // EMSCRIPTEN_START_FUNCS
  function nb(a){a=a|0;var b=0;b=i;i=i+a|0;i=i+15&-16;return b|0}function ob(){return i|0}function pb(a){a=a|0;i=a}function qb(a,b){a=a|0;b=b|0;if(!q){q=a;r=b}}function rb(b){b=b|0;a[k>>0]=a[b>>0];a[k+1>>0]=a[b+1>>0];a[k+2>>0]=a[b+2>>0];a[k+3>>0]=a[b+3>>0]}function sb(b){b=b|0;a[k>>0]=a[b>>0];a[k+1>>0]=a[b+1>>0];a[k+2>>0]=a[b+2>>0];a[k+3>>0]=a[b+3>>0];a[k+4>>0]=a[b+4>>0];a[k+5>>0]=a[b+5>>0];a[k+6>>0]=a[b+6>>0];a[k+7>>0]=a[b+7>>0]}function tb(a){a=a|0;F=a}function ub(){return F|0}function vb(a){a=a|0;Ba(a|0)|0;ud()}function wb(a){a=a|0;return}function xb(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0;h=i;c[b>>2]=112;c[b+4>>2]=d;c[b+8>>2]=e;c[b+12>>2]=f;c[b+16>>2]=g;if((a[144]|0)==0?(sa(144)|0)!=0:0){c[32]=0;c[33]=0;c[34]=0;Qa(19,128,o|0)|0;xa(144)}g=c[33]|0;if((g|0)==(c[34]|0)){f=(g>>1)+2&-2;f=(f|0)<2?2:f;if((f|0)>(2147483647-g|0)){d=va(1)|0;Ta(d|0,48,0)}e=c[32]|0;d=f+g|0;c[34]=d;d=Ud(e,d<<2)|0;c[32]=d;if((d|0)==0?(c[(Oa()|0)>>2]|0)==12:0){d=va(1)|0;Ta(d|0,48,0)}g=c[33]|0}c[33]=g+1;g=(c[32]|0)+(g<<2)|0;if(!g){i=h;return}c[g>>2]=b;i=h;return}function yb(a){a=a|0;var b=0;b=i;pd(a);i=b;return}function zb(a){a=a|0;var b=0,d=0;b=i;d=c[a>>2]|0;if(!d){i=b;return}c[a+4>>2]=0;Td(d);c[a>>2]=0;c[a+8>>2]=0;i=b;return}function Ab(a){a=a|0;var b=0;b=i;pd(a);i=b;return}function Bb(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0;e=i;if((a[d>>0]|0)!=45){k=0;i=e;return k|0}f=d+1|0;g=110;j=f;k=0;while(1){h=k+1|0;if((a[j>>0]|0)!=g<<24>>24){g=1;break}j=d+(k+2)|0;if((h|0)==3){g=0;f=j;break}else{g=a[264+h>>0]|0;k=h}}if(ee(f,c[b+4>>2]|0)|0){k=0;i=e;return k|0}a[b+20>>0]=g;k=1;i=e;return k|0}function Cb(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0;h=i;i=i+16|0;e=h;f=c[p>>2]|0;g=b+4|0;j=c[g>>2]|0;c[e>>2]=j;c[e+4>>2]=j;Za(f|0,216,e|0)|0;j=0;while(1){k=j>>>0<(32-((me(c[g>>2]|0)|0)<<1)|0)>>>0;Sa(32,f|0)|0;if(k)j=j+1|0;else break}c[e>>2]=(a[b+20>>0]|0)!=0?248:256;Za(f|0,232,e|0)|0;if(!d){i=h;return}c[e>>2]=c[b+8>>2];Za(f|0,88,e|0)|0;Sa(10,f|0)|0;i=h;return}function Db(a){a=a|0;var b=0;b=i;pd(a);i=b;return}function Eb(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0;e=i;i=i+16|0;h=e;g=e+8|0;if((a[d>>0]|0)!=45){n=0;i=e;return n|0}l=d+1|0;f=b+4|0;j=c[f>>2]|0;k=a[j>>0]|0;a:do if(k<<24>>24){m=0;while(1){n=m;m=m+1|0;if((a[l>>0]|0)!=k<<24>>24){b=0;break}k=a[j+m>>0]|0;l=d+(n+2)|0;if(!(k<<24>>24))break a}i=e;return b|0}while(0);if((a[l>>0]|0)!=61){n=0;i=e;return n|0}d=l+1|0;j=de(d,g,10)|0;if(!(c[g>>2]|0)){n=0;i=e;return n|0}if((j|0)>(c[b+24>>2]|0)){n=c[p>>2]|0;m=c[f>>2]|0;c[h>>2]=d;c[h+4>>2]=m;Za(n|0,416,h|0)|0;ab(1)}if((j|0)<(c[b+20>>2]|0)){n=c[p>>2]|0;m=c[f>>2]|0;c[h>>2]=d;c[h+4>>2]=m;Za(n|0,472,h|0)|0;ab(1)}c[b+28>>2]=j;n=1;i=e;return n|0}function Fb(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;i=i+16|0;e=d;f=c[p>>2]|0;g=c[a+16>>2]|0;c[e>>2]=c[a+4>>2];c[e+4>>2]=g;Za(f|0,336,e|0)|0;g=c[a+20>>2]|0;if((g|0)==-2147483648)Xa(360,4,1,f|0)|0;else{c[e>>2]=g;Za(f|0,368,e|0)|0}Xa(376,4,1,f|0)|0;g=c[a+24>>2]|0;if((g|0)==2147483647)Xa(384,4,1,f|0)|0;else{c[e>>2]=g;Za(f|0,368,e|0)|0}c[e>>2]=c[a+28>>2];Za(f|0,392,e|0)|0;if(!b){i=d;return}c[e>>2]=c[a+8>>2];Za(f|0,88,e|0)|0;Sa(10,f|0)|0;i=d;return}function Gb(b){b=b|0;var d=0,e=0,f=0,g=0,j=0;g=i;c[b>>2]=1816;f=b+4|0;e=b+32|0;j=b+48|0;c[f+0>>2]=0;c[f+4>>2]=0;c[f+8>>2]=0;c[f+12>>2]=0;c[f+16>>2]=0;c[f+20>>2]=0;c[e+0>>2]=0;c[e+4>>2]=0;c[e+8>>2]=0;c[e+12>>2]=0;h[j>>3]=+h[75];h[b+56>>3]=+h[89];h[b+64>>3]=+h[103];h[b+72>>3]=+h[123];a[b+80>>0]=a[1364]|0;c[b+84>>2]=c[269];c[b+88>>2]=c[297];a[b+92>>0]=0;a[b+93>>0]=a[1292]|0;h[b+96>>3]=+h[204];c[b+104>>2]=c[439];c[b+108>>2]=c[359];h[b+112>>3]=+h[191];h[b+120>>3]=.3333333333333333;h[b+128>>3]=1.1;c[b+136>>2]=100;h[b+144>>3]=1.5;j=b+316|0;c[b+332>>2]=0;c[b+336>>2]=0;c[b+340>>2]=0;c[b+348>>2]=0;c[b+352>>2]=0;c[b+356>>2]=0;c[b+364>>2]=0;c[b+368>>2]=0;c[b+372>>2]=0;c[b+380>>2]=0;c[b+384>>2]=0;c[b+388>>2]=0;c[b+396>>2]=0;c[b+400>>2]=0;c[b+404>>2]=0;e=b+544|0;c[b+412>>2]=0;c[b+416>>2]=0;c[b+420>>2]=0;c[b+428>>2]=0;c[b+432>>2]=0;c[b+436>>2]=0;c[b+444>>2]=0;c[b+448>>2]=0;c[b+452>>2]=0;ke(b+152|0,0,176)|0;c[b+456>>2]=e;f=b+460|0;c[f+0>>2]=0;c[f+4>>2]=0;c[f+8>>2]=0;c[f+12>>2]=0;c[f+16>>2]=0;c[f+20>>2]=0;c[b+488>>2]=j;a[b+492>>0]=1;h[b+496>>3]=1.0;h[b+504>>3]=1.0;c[b+512>>2]=0;c[b+516>>2]=-1;j=b+520|0;f=b+536|0;c[j+0>>2]=0;c[j+4>>2]=0;c[j+8>>2]=0;c[j+12>>2]=0;a[f>>0]=1;f=b+540|0;c[f+0>>2]=0;c[f+4>>2]=0;c[f+8>>2]=0;c[f+12>>2]=0;c[f+16>>2]=0;gc(e,1048576);a[b+560>>0]=0;e=b+604|0;f=b+664|0;j=b+564|0;d=j+36|0;do{c[j>>2]=0;j=j+4|0}while((j|0)<(d|0));j=e+0|0;d=j+36|0;do{c[j>>2]=0;j=j+4|0}while((j|0)<(d|0));j=b+680|0;c[f+0>>2]=-1;c[f+4>>2]=-1;c[f+8>>2]=-1;c[f+12>>2]=-1;a[j>>0]=0;i=g;return}function Hb(a){a=a|0;var b=0;b=i;Ib(a);pd(a);i=b;return}function Ib(a){a=a|0;var b=0,d=0,e=0;b=i;c[a>>2]=1816;d=a+628|0;e=c[d>>2]|0;if(e){c[a+632>>2]=0;Td(e);c[d>>2]=0;c[a+636>>2]=0}d=a+616|0;e=c[d>>2]|0;if(e){c[a+620>>2]=0;Td(e);c[d>>2]=0;c[a+624>>2]=0}d=a+604|0;e=c[d>>2]|0;if(e){c[a+608>>2]=0;Td(e);c[d>>2]=0;c[a+612>>2]=0}d=a+588|0;e=c[d>>2]|0;if(e){c[a+592>>2]=0;Td(e);c[d>>2]=0;c[a+596>>2]=0}d=a+576|0;e=c[d>>2]|0;if(e){c[a+580>>2]=0;Td(e);c[d>>2]=0;c[a+584>>2]=0}d=a+564|0;e=c[d>>2]|0;if(e){c[a+568>>2]=0;Td(e);c[d>>2]=0;c[a+572>>2]=0}d=c[a+544>>2]|0;if(d)Td(d);d=a+472|0;e=c[d>>2]|0;if(e){c[a+476>>2]=0;Td(e);c[d>>2]=0;c[a+480>>2]=0}d=a+460|0;e=c[d>>2]|0;if(e){c[a+464>>2]=0;Td(e);c[d>>2]=0;c[a+468>>2]=0}hc(a+412|0);d=a+396|0;e=c[d>>2]|0;if(e){c[a+400>>2]=0;Td(e);c[d>>2]=0;c[a+404>>2]=0}d=a+380|0;e=c[d>>2]|0;if(e){c[a+384>>2]=0;Td(e);c[d>>2]=0;c[a+388>>2]=0}e=a+364|0;d=c[e>>2]|0;if(d){c[a+368>>2]=0;Td(d);c[e>>2]=0;c[a+372>>2]=0}d=a+348|0;e=c[d>>2]|0;if(e){c[a+352>>2]=0;Td(e);c[d>>2]=0;c[a+356>>2]=0}d=a+332|0;e=c[d>>2]|0;if(e){c[a+336>>2]=0;Td(e);c[d>>2]=0;c[a+340>>2]=0}d=a+316|0;e=c[d>>2]|0;if(e){c[a+320>>2]=0;Td(e);c[d>>2]=0;c[a+324>>2]=0}d=a+304|0;e=c[d>>2]|0;if(e){c[a+308>>2]=0;Td(e);c[d>>2]=0;c[a+312>>2]=0}d=a+292|0;e=c[d>>2]|0;if(e){c[a+296>>2]=0;Td(e);c[d>>2]=0;c[a+300>>2]=0}d=a+280|0;e=c[d>>2]|0;if(e){c[a+284>>2]=0;Td(e);c[d>>2]=0;c[a+288>>2]=0}d=a+268|0;e=c[d>>2]|0;if(e){c[a+272>>2]=0;Td(e);c[d>>2]=0;c[a+276>>2]=0}d=a+256|0;e=c[d>>2]|0;if(e){c[a+260>>2]=0;Td(e);c[d>>2]=0;c[a+264>>2]=0}d=a+32|0;e=c[d>>2]|0;if(e){c[a+36>>2]=0;Td(e);c[d>>2]=0;c[a+40>>2]=0}d=a+16|0;e=c[d>>2]|0;if(e){c[a+20>>2]=0;Td(e);c[d>>2]=0;c[a+24>>2]=0}e=a+4|0;d=c[e>>2]|0;if(!d){i=b;return}c[a+8>>2]=0;Td(d);c[e>>2]=0;c[a+12>>2]=0;i=b;return}function Jb(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,j=0,k=0,l=0.0,m=0,n=0,o=0,p=0,q=0,r=0;f=i;i=i+16|0;k=f+4|0;j=f;g=b+580|0;m=c[g>>2]|0;if((m|0)>0){o=m+ -1|0;p=c[(c[b+576>>2]|0)+(o<<2)>>2]|0;c[g>>2]=o;g=p}else{p=b+540|0;g=c[p>>2]|0;c[p>>2]=g+1}m=b+412|0;p=g<<1;c[k>>2]=p;ic(m,k);c[j>>2]=p|1;ic(m,j);k=b+332|0;m=a[544]|0;j=g+1|0;jc(k,j);a[(c[k>>2]|0)+g>>0]=m;k=b+396|0;m=b+400|0;if((c[m>>2]|0)<(j|0)){o=b+404|0;p=c[o>>2]|0;if((p|0)<(j|0)){q=g+2-p&-2;n=(p>>1)+2&-2;n=(q|0)>(n|0)?q:n;if((n|0)>(2147483647-p|0)){q=va(1)|0;Ta(q|0,48,0)}r=c[k>>2]|0;q=n+p|0;c[o>>2]=q;q=Ud(r,q<<3)|0;c[k>>2]=q;if((q|0)==0?(c[(Oa()|0)>>2]|0)==12:0){r=va(1)|0;Ta(r|0,48,0)}}o=c[m>>2]|0;if((o|0)<(j|0))do{n=(c[k>>2]|0)+(o<<3)|0;if(n){r=n;c[r>>2]=0;c[r+4>>2]=0}o=o+1|0}while((o|0)!=(j|0));c[m>>2]=j}m=(c[k>>2]|0)+(g<<3)|0;c[m>>2]=-1;c[m+4>>2]=0;m=b+316|0;if(!(a[b+93>>0]|0))l=0.0;else{r=b+72|0;l=+h[r>>3]*1389796.0;l=l- +(~~(l/2147483647.0)|0)*2147483647.0;h[r>>3]=l;l=l/2147483647.0*1.0e-5}k=b+320|0;if((c[k>>2]|0)<(j|0)){n=b+324|0;o=c[n>>2]|0;if((o|0)<(j|0)){r=g+2-o&-2;p=(o>>1)+2&-2;p=(r|0)>(p|0)?r:p;if((p|0)>(2147483647-o|0)){r=va(1)|0;Ta(r|0,48,0)}q=c[m>>2]|0;r=p+o|0;c[n>>2]=r;r=Ud(q,r<<3)|0;c[m>>2]=r;if((r|0)==0?(c[(Oa()|0)>>2]|0)==12:0){r=va(1)|0;Ta(r|0,48,0)}}p=c[k>>2]|0;if((p|0)<(j|0)){n=c[m>>2]|0;do{o=n+(p<<3)|0;if(o)h[o>>3]=0.0;p=p+1|0}while((p|0)!=(j|0))}c[k>>2]=j}h[(c[m>>2]|0)+(g<<3)>>3]=l;kc(b+588|0,g,0);kc(b+348|0,g,1);k=b+364|0;d=a[d>>0]|0;jc(k,j);a[(c[k>>2]|0)+g>>0]=d;k=b+380|0;d=b+384|0;if((c[d>>2]|0)<(j|0)){m=b+388|0;o=c[m>>2]|0;if((o|0)<(j|0)){r=g+2-o&-2;n=(o>>1)+2&-2;n=(r|0)>(n|0)?r:n;if((n|0)>(2147483647-o|0)){r=va(1)|0;Ta(r|0,48,0)}q=c[k>>2]|0;r=n+o|0;c[m>>2]=r;r=Ud(q,r)|0;c[k>>2]=r;if((r|0)==0?(c[(Oa()|0)>>2]|0)==12:0){r=va(1)|0;Ta(r|0,48,0)}}m=c[d>>2]|0;if((m|0)<(j|0))do{n=(c[k>>2]|0)+m|0;if(n)a[n>>0]=0;m=m+1|0}while((m|0)!=(j|0));c[d>>2]=j}d=b+288|0;k=c[d>>2]|0;if((k|0)<(j|0)){r=g+2-k&-2;j=(k>>1)+2&-2;j=(r|0)>(j|0)?r:j;if((j|0)>(2147483647-k|0)){r=va(1)|0;Ta(r|0,48,0)}q=b+280|0;p=c[q>>2]|0;r=j+k|0;c[d>>2]=r;r=Ud(p,r<<2)|0;c[q>>2]=r;if((r|0)==0?(c[(Oa()|0)>>2]|0)==12:0){r=va(1)|0;Ta(r|0,48,0)}}j=b+380|0;d=(c[j>>2]|0)+g|0;k=(a[d>>0]|0)==0;if(e){if(k){r=b+200|0;q=r;q=ne(c[q>>2]|0,c[q+4>>2]|0,1,0)|0;c[r>>2]=q;c[r+4>>2]=F}}else if(!k){r=b+200|0;q=r;q=ne(c[q>>2]|0,c[q+4>>2]|0,-1,-1)|0;c[r>>2]=q;c[r+4>>2]=F}a[d>>0]=e&1;e=b+460|0;if((c[b+476>>2]|0)>(g|0)?(c[(c[b+472>>2]|0)+(g<<2)>>2]|0)>-1:0){i=f;return g|0}if(!(a[(c[j>>2]|0)+g>>0]|0)){i=f;return g|0}lc(e,g);i=f;return g|0}function Kb(b,e){b=b|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;f=i;i=i+16|0;k=f+1|0;j=f;g=b+492|0;if(!(a[g>>0]|0)){s=0;i=f;return s|0}s=c[e>>2]|0;h=e+4|0;l=c[h>>2]|0;a[k+0>>0]=a[j+0>>0]|0;oc(s,l,k);l=c[h>>2]|0;a:do if((l|0)>0){k=b+332|0;j=a[528]|0;m=0;n=0;p=-2;while(1){s=c[e>>2]|0;o=c[s+(m<<2)>>2]|0;r=d[(c[k>>2]|0)+(o>>1)>>0]|0;t=r^o&1;q=t&255;u=j&255;if((o|0)==(p^1|0)?1:(q<<24>>24==j<<24>>24&(u>>>1^1)|u&2&t|0)!=0){b=1;break}t=a[536]|0;u=t&255;if((o|0)!=(p|0)?((u>>>1^1)&q<<24>>24==t<<24>>24|r&2&u|0)==0:0){c[s+(n<<2)>>2]=o;l=c[h>>2]|0;n=n+1|0}else o=p;m=m+1|0;if((m|0)<(l|0))p=o;else break a}i=f;return b|0}else{m=0;n=0}while(0);j=m-n|0;if((j|0)>0){l=l-j|0;c[h>>2]=l}if(!l){a[g>>0]=0;u=0;i=f;return u|0}else if((l|0)==1){t=c[c[e>>2]>>2]|0;s=t>>1;a[(c[b+332>>2]|0)+s>>0]=(t&1^1)&255^1;u=c[b+296>>2]|0;s=(c[b+396>>2]|0)+(s<<3)|0;c[s>>2]=-1;c[s+4>>2]=u;s=b+284|0;u=c[s>>2]|0;c[s>>2]=u+1;c[(c[b+280>>2]|0)+(u<<2)>>2]=t;u=(Mb(b)|0)==-1;a[g>>0]=u&1;i=f;return u|0}else{e=pc(b+544|0,e,0)|0;h=b+256|0;g=b+260|0;k=c[g>>2]|0;j=b+264|0;if((k|0)==(c[j>>2]|0)){l=(k>>1)+2&-2;l=(l|0)<2?2:l;if((l|0)>(2147483647-k|0)){u=va(1)|0;Ta(u|0,48,0)}t=c[h>>2]|0;u=l+k|0;c[j>>2]=u;u=Ud(t,u<<2)|0;c[h>>2]=u;if((u|0)==0?(c[(Oa()|0)>>2]|0)==12:0){u=va(1)|0;Ta(u|0,48,0)}k=c[g>>2]|0}c[g>>2]=k+1;g=(c[h>>2]|0)+(k<<2)|0;if(g)c[g>>2]=e;Nb(b,e);u=1;i=f;return u|0}return 0}function Lb(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0;f=c[d>>2]|0;d=f>>1;a[(c[b+332>>2]|0)+d>>0]=(f&1^1)&255^1;g=c[b+296>>2]|0;d=(c[b+396>>2]|0)+(d<<3)|0;c[d>>2]=e;c[d+4>>2]=g;e=b+284|0;d=c[e>>2]|0;c[e>>2]=d+1;c[(c[b+280>>2]|0)+(d<<2)>>2]=f;return}function Mb(b){b=b|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0;k=i;i=i+16|0;r=k;h=b+512|0;t=c[h>>2]|0;q=b+284|0;if((t|0)>=(c[q>>2]|0)){M=0;K=0;O=-1;N=b+184|0;I=N;L=I;L=c[L>>2]|0;I=I+4|0;I=c[I>>2]|0;I=ne(L|0,I|0,M|0,K|0)|0;L=F;J=N;c[J>>2]=I;N=N+4|0;c[N>>2]=L;N=b+520|0;L=N;J=L;J=c[J>>2]|0;L=L+4|0;L=c[L>>2]|0;K=je(J|0,L|0,M|0,K|0)|0;M=F;L=N;c[L>>2]=K;N=N+4|0;c[N>>2]=M;i=k;return O|0}o=b+280|0;j=b+428|0;g=b+412|0;l=b+332|0;m=b+544|0;n=r+4|0;e=b+396|0;p=b+296|0;f=b+456|0;z=-1;s=0;do{c[h>>2]=t+1;w=c[(c[o>>2]|0)+(t<<2)>>2]|0;if(a[(c[j>>2]|0)+w>>0]|0){u=c[g>>2]|0;t=u+(w*12|0)+4|0;y=c[t>>2]|0;if((y|0)>0){u=u+(w*12|0)|0;v=0;x=0;do{B=c[u>>2]|0;A=B+(v<<3)|0;if((c[(c[c[f>>2]>>2]|0)+(c[A>>2]<<2)>>2]&3|0)!=1){N=A;O=c[N+4>>2]|0;y=B+(x<<3)|0;c[y>>2]=c[N>>2];c[y+4>>2]=O;y=c[t>>2]|0;x=x+1|0}v=v+1|0}while((v|0)<(y|0))}else{v=0;x=0}u=v-x|0;if((u|0)>0)c[t>>2]=y-u;a[(c[j>>2]|0)+w>>0]=0}t=c[g>>2]|0;s=s+1|0;u=c[t+(w*12|0)>>2]|0;t=t+(w*12|0)+4|0;x=c[t>>2]|0;v=u+(x<<3)|0;a:do if(!x){v=u;y=u}else{w=w^1;x=(x<<3)+ -1|0;B=u;y=u;while(1){while(1){b:while(1){H=c[B+4>>2]|0;O=d[(c[l>>2]|0)+(H>>1)>>0]^H&1;J=a[528]|0;I=J&255;K=I&2;I=I>>>1^1;if((O&255)<<24>>24==J<<24>>24&I|K&O){E=19;break}A=c[B>>2]|0;E=c[m>>2]|0;G=E+(A<<2)|0;C=E+(A+1<<2)|0;D=c[C>>2]|0;if((D|0)==(w|0)){O=E+(A+2<<2)|0;D=c[O>>2]|0;c[C>>2]=D;c[O>>2]=w}C=B+8|0;c[r>>2]=A;c[n>>2]=D;if((D|0)!=(H|0)?(O=d[(c[l>>2]|0)+(D>>1)>>0]^D&1,((O&255)<<24>>24==J<<24>>24&I|K&O|0)!=0):0){E=27;break}K=c[G>>2]|0;if(K>>>0<=95){E=31;break}I=c[l>>2]|0;J=a[536]|0;H=J&255;O=H&2;H=H>>>1^1;N=2;while(1){L=G+(N<<2)+4|0;M=c[L>>2]|0;P=d[I+(M>>1)>>0]^M&1;N=N+1|0;if(!((P&255)<<24>>24==J<<24>>24&H|O&P))break;if((N|0)>=(K>>>5|0)){E=32;break b}}P=E+(A+2<<2)|0;c[P>>2]=M;c[L>>2]=w;qc((c[g>>2]|0)+((c[P>>2]^1)*12|0)|0,r);if((C|0)==(v|0))break a;else B=C}if((E|0)==19){E=0;N=B;O=c[N+4>>2]|0;P=y;c[P>>2]=c[N>>2];c[P+4>>2]=O;B=B+8|0;y=y+8|0}else if((E|0)==27){E=0;O=r;P=c[O+4>>2]|0;B=y;c[B>>2]=c[O>>2];c[B+4>>2]=P;B=C;y=y+8|0}else if((E|0)==31){J=a[536]|0;E=32}if((E|0)==32){E=y+8|0;G=r;I=c[G+4>>2]|0;H=y;c[H>>2]=c[G>>2];c[H+4>>2]=I;H=D>>1;I=D&1;G=(c[l>>2]|0)+H|0;P=d[G>>0]^I;O=J&255;if((P&255)<<24>>24==J<<24>>24&(O>>>1^1)|O&2&P)break;a[G>>0]=(I^1)&255^1;y=c[p>>2]|0;B=(c[e>>2]|0)+(H<<3)|0;c[B>>2]=A;c[B+4>>2]=y;B=c[q>>2]|0;c[q>>2]=B+1;c[(c[o>>2]|0)+(B<<2)>>2]=D;B=C;y=E}if((B|0)==(v|0))break a}c[h>>2]=c[q>>2];if(C>>>0<v>>>0){z=(u+(x-C)|0)>>>3;while(1){N=C;C=C+8|0;O=c[N+4>>2]|0;P=E;c[P>>2]=c[N>>2];c[P+4>>2]=O;if(C>>>0>=v>>>0)break;else E=E+8|0}B=B+(z+2<<3)|0;y=y+(z+2<<3)|0}else{B=C;y=E}if((B|0)==(v|0)){z=A;break}else z=A}}while(0);u=v-y|0;if((u|0)>0)c[t>>2]=(c[t>>2]|0)-(u>>3);t=c[h>>2]|0}while((t|0)<(c[q>>2]|0));N=s;L=((s|0)<0)<<31>>31;P=z;O=b+184|0;J=O;M=J;M=c[M>>2]|0;J=J+4|0;J=c[J>>2]|0;J=ne(M|0,J|0,N|0,L|0)|0;M=F;K=O;c[K>>2]=J;O=O+4|0;c[O>>2]=M;O=b+520|0;M=O;K=M;K=c[K>>2]|0;M=M+4|0;M=c[M>>2]|0;L=je(K|0,M|0,N|0,L|0)|0;N=F;M=O;c[M>>2]=L;O=O+4|0;c[O>>2]=N;i=k;return P|0}function Nb(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;d=i;i=i+16|0;k=d+8|0;f=d;g=c[a+544>>2]|0;e=g+(b<<2)|0;h=g+(b+1<<2)|0;j=a+412|0;l=(c[j>>2]|0)+((c[h>>2]^1)*12|0)|0;g=g+(b+2<<2)|0;m=c[g>>2]|0;c[k>>2]=b;c[k+4>>2]=m;qc(l,k);g=(c[j>>2]|0)+((c[g>>2]^1)*12|0)|0;h=c[h>>2]|0;c[f>>2]=b;c[f+4>>2]=h;qc(g,f);if(!(c[e>>2]&4)){m=a+208|0;l=m;l=ne(c[l>>2]|0,c[l+4>>2]|0,1,0)|0;c[m>>2]=l;c[m+4>>2]=F;m=a+224|0;l=m;l=ne((c[e>>2]|0)>>>5|0,0,c[l>>2]|0,c[l+4>>2]|0)|0;c[m>>2]=l;c[m+4>>2]=F;i=d;return}else{m=a+216|0;l=m;l=ne(c[l>>2]|0,c[l+4>>2]|0,1,0)|0;c[m>>2]=l;c[m+4>>2]=F;m=a+232|0;l=m;l=ne((c[e>>2]|0)>>>5|0,0,c[l>>2]|0,c[l+4>>2]|0)|0;c[m>>2]=l;c[m+4>>2]=F;i=d;return}}function Ob(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;g=i;i=i+16|0;l=g+4|0;j=g;h=c[b+544>>2]|0;f=h+(d<<2)|0;k=c[h+(d+1<<2)>>2]^1;if(!e){c[l>>2]=k;e=b+428|0;m=c[e>>2]|0;k=m+k|0;if(!(a[k>>0]|0)){a[k>>0]=1;mc(b+444|0,l);m=c[e>>2]|0}d=c[h+(d+2<<2)>>2]^1;c[j>>2]=d;d=m+d|0;if(!(a[d>>0]|0)){a[d>>0]=1;mc(b+444|0,j)}}else{j=b+412|0;e=c[j>>2]|0;l=e+(k*12|0)|0;h=h+(d+2<<2)|0;k=e+(k*12|0)+4|0;m=c[k>>2]|0;a:do if((m|0)>0){p=c[l>>2]|0;o=0;while(1){n=o+1|0;if((c[p+(o<<3)>>2]|0)==(d|0)){n=o;break a}if((n|0)<(m|0))o=n;else break}}else n=0;while(0);m=m+ -1|0;if((n|0)<(m|0)){do{e=c[l>>2]|0;m=n;n=n+1|0;o=e+(n<<3)|0;p=c[o+4>>2]|0;m=e+(m<<3)|0;c[m>>2]=c[o>>2];c[m+4>>2]=p;m=(c[k>>2]|0)+ -1|0}while((n|0)<(m|0));e=c[j>>2]|0}c[k>>2]=m;j=c[h>>2]^1;h=e+(j*12|0)|0;j=e+(j*12|0)+4|0;k=c[j>>2]|0;b:do if((k|0)>0){e=c[h>>2]|0;m=0;while(1){l=m+1|0;if((c[e+(m<<3)>>2]|0)==(d|0)){l=m;break b}if((l|0)<(k|0))m=l;else break}}else l=0;while(0);d=k+ -1|0;if((l|0)<(d|0))do{n=c[h>>2]|0;d=l;l=l+1|0;o=n+(l<<3)|0;p=c[o+4>>2]|0;d=n+(d<<3)|0;c[d>>2]=c[o>>2];c[d+4>>2]=p;d=(c[j>>2]|0)+ -1|0}while((l|0)<(d|0));c[j>>2]=d}if(!(c[f>>2]&4)){p=b+208|0;o=p;o=ne(c[o>>2]|0,c[o+4>>2]|0,-1,-1)|0;c[p>>2]=o;c[p+4>>2]=F;p=b+224|0;o=p;o=je(c[o>>2]|0,c[o+4>>2]|0,(c[f>>2]|0)>>>5|0,0)|0;c[p>>2]=o;c[p+4>>2]=F;i=g;return}else{p=b+216|0;o=p;o=ne(c[o>>2]|0,c[o+4>>2]|0,-1,-1)|0;c[p>>2]=o;c[p+4>>2]=F;p=b+232|0;o=p;o=je(c[o>>2]|0,c[o+4>>2]|0,(c[f>>2]|0)>>>5|0,0)|0;c[p>>2]=o;c[p+4>>2]=F;i=g;return}}function Pb(b,e){b=b|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;h=i;g=b+544|0;m=c[g>>2]|0;f=m+(e<<2)|0;Ob(b,e,0);m=c[m+(e+1<<2)>>2]|0;j=m>>1;m=(d[(c[b+332>>2]|0)+j>>0]|0)^m&1;o=a[528]|0;n=o&255;if((((m&255)<<24>>24==o<<24>>24&(n>>>1^1)|n&2&m|0)!=0?(k=(c[b+396>>2]|0)+(j<<3)|0,l=c[k>>2]|0,(l|0)!=-1):0)?((c[g>>2]|0)+(l<<2)|0)==(f|0):0)c[k>>2]=-1;c[f>>2]=c[f>>2]&-4|1;n=c[(c[g>>2]|0)+(e<<2)>>2]|0;o=b+556|0;c[o>>2]=((((n>>>3&1)+(n>>>5)<<2)+4|0)>>>2)+(c[o>>2]|0);i=h;return}function Qb(b,e){b=b|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0;f=i;g=c[e>>2]|0;if(g>>>0<=31){l=0;i=f;return l|0}h=c[b+332>>2]|0;j=a[528]|0;k=j&255;l=k&2;k=k>>>1^1;b=0;while(1){m=c[e+(b<<2)+4>>2]|0;m=(d[h+(m>>1)>>0]|0)^m&1;b=b+1|0;if((m&255)<<24>>24==j<<24>>24&k|l&m){g=1;e=5;break}if((b|0)>=(g>>>5|0)){g=0;e=5;break}}if((e|0)==5){i=f;return g|0}return 0}function Rb(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;g=i;e=b+296|0;if((c[e>>2]|0)<=(d|0)){i=g;return}f=b+284|0;s=c[f>>2]|0;j=b+292|0;t=c[j>>2]|0;u=c[t+(d<<2)>>2]|0;if((s|0)>(u|0)){r=b+280|0;m=b+332|0;l=b+88|0;k=b+348|0;n=b+460|0;p=b+476|0;q=b+472|0;o=b+380|0;do{s=s+ -1|0;u=c[(c[r>>2]|0)+(s<<2)>>2]>>1;a[(c[m>>2]|0)+u>>0]=a[544]|0;t=c[l>>2]|0;if((t|0)<=1){if((t|0)==1?(s|0)>(c[(c[j>>2]|0)+((c[e>>2]|0)+ -1<<2)>>2]|0):0)h=7}else h=7;if((h|0)==7){h=0;a[(c[k>>2]|0)+u>>0]=c[(c[r>>2]|0)+(s<<2)>>2]&1}if(!((c[p>>2]|0)>(u|0)?(c[(c[q>>2]|0)+(u<<2)>>2]|0)>-1:0))h=11;if((h|0)==11?(h=0,(a[(c[o>>2]|0)+u>>0]|0)!=0):0)lc(n,u);t=c[j>>2]|0;u=c[t+(d<<2)>>2]|0}while((s|0)>(u|0));s=c[f>>2]|0}c[b+512>>2]=u;b=c[t+(d<<2)>>2]|0;if((s-b|0)>0)c[f>>2]=b;if(((c[e>>2]|0)-d|0)<=0){i=g;return}c[e>>2]=d;i=g;return}function Sb(b){b=b|0;var d=0,e=0,f=0,g=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0.0,r=0;d=i;f=b+72|0;q=+h[f>>3]*1389796.0;q=q- +(~~(q/2147483647.0)|0)*2147483647.0;h[f>>3]=q;l=b+464|0;if(q/2147483647.0<+h[b+64>>3]?(m=c[l>>2]|0,(m|0)!=0):0){q=q*1389796.0;q=q- +(~~(q/2147483647.0)|0)*2147483647.0;h[f>>3]=q;m=c[(c[b+460>>2]|0)+(~~(+(m|0)*(q/2147483647.0))<<2)>>2]|0;o=a[(c[b+332>>2]|0)+m>>0]|0;n=a[544]|0;p=n&255;if(((p>>>1^1)&o<<24>>24==n<<24>>24|o&2&p|0)!=0?(a[(c[b+380>>2]|0)+m>>0]|0)!=0:0){p=b+176|0;o=p;o=ne(c[o>>2]|0,c[o+4>>2]|0,1,0)|0;c[p>>2]=o;c[p+4>>2]=F}}else m=-1;n=b+460|0;p=b+332|0;o=b+380|0;while(1){if(((m|0)!=-1?(r=a[(c[p>>2]|0)+m>>0]|0,j=a[544]|0,e=j&255,g=e>>>1^1,(g&r<<24>>24==j<<24>>24|r&2&e|0)!=0):0)?(a[(c[o>>2]|0)+m>>0]|0)!=0:0)break;if(!(c[l>>2]|0)){e=-2;k=17;break}m=rc(n)|0}if((k|0)==17){i=d;return e|0}l=a[(c[b+364>>2]|0)+m>>0]|0;k=l&255;if(!(g&l<<24>>24==j<<24>>24|e&2&k)){p=a[528]|0;r=p&255;r=((r>>>1^1)&l<<24>>24==p<<24>>24|k&2&r|0)!=0|m<<1;i=d;return r|0}if(!(a[b+92>>0]|0)){r=(a[(c[b+348>>2]|0)+m>>0]|0)!=0|m<<1;i=d;return r|0}else{q=+h[f>>3]*1389796.0;q=q- +(~~(q/2147483647.0)|0)*2147483647.0;h[f>>3]=q;r=q/2147483647.0<.5|m<<1;i=d;return r|0}return 0}function Tb(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0.0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0.0,U=0;j=i;i=i+16|0;p=j+8|0;t=j+4|0;n=j;m=e+4|0;k=c[m>>2]|0;l=e+8|0;if((k|0)==(c[l>>2]|0)){q=(k>>1)+2&-2;q=(q|0)<2?2:q;if((q|0)>(2147483647-k|0)){S=va(1)|0;Ta(S|0,48,0)}R=c[e>>2]|0;S=q+k|0;c[l>>2]=S;S=Ud(R,S<<2)|0;c[e>>2]=S;if((S|0)==0?(c[(Oa()|0)>>2]|0)==12:0){S=va(1)|0;Ta(S|0,48,0)}k=c[m>>2]|0}l=(c[e>>2]|0)+(k<<2)|0;if(l){c[l>>2]=0;k=c[m>>2]|0}c[m>>2]=k+1;q=b+544|0;H=b+280|0;k=b+588|0;l=b+396|0;C=b+504|0;E=b+316|0;D=b+540|0;B=b+476|0;A=b+472|0;z=b+460|0;y=b+488|0;x=b+296|0;v=b+496|0;w=b+272|0;G=b+268|0;J=-2;I=(c[b+284>>2]|0)+ -1|0;K=0;do{L=c[q>>2]|0;d=L+(d<<2)|0;M=c[d>>2]|0;if((M&4|0)!=0?(r=+h[v>>3],S=d+(M>>>5<<2)+4|0,T=r+ +g[S>>2],g[S>>2]=T,T>1.0e20):0){O=c[w>>2]|0;if((O|0)>0){N=c[G>>2]|0;M=0;do{S=L+(c[N+(M<<2)>>2]<<2)|0;S=S+((c[S>>2]|0)>>>5<<2)+4|0;g[S>>2]=+g[S>>2]*1.0e-20;M=M+1|0}while((M|0)!=(O|0))}h[v>>3]=r*1.0e-20}J=(J|0)!=-2&1;if(J>>>0<(c[d>>2]|0)>>>5>>>0)do{M=c[d+(J<<2)+4>>2]|0;c[t>>2]=M;M=M>>1;L=(c[k>>2]|0)+M|0;do if((a[L>>0]|0)==0?(c[(c[l>>2]|0)+(M<<3)+4>>2]|0)>0:0){O=c[E>>2]|0;S=O+(M<<3)|0;T=+h[C>>3]+ +h[S>>3];h[S>>3]=T;if(T>1.0e+100){P=c[D>>2]|0;if((P|0)>0){N=0;do{S=O+(N<<3)|0;h[S>>3]=+h[S>>3]*1.0e-100;N=N+1|0}while((N|0)!=(P|0))}h[C>>3]=+h[C>>3]*1.0e-100}if((c[B>>2]|0)>(M|0)?(u=c[A>>2]|0,s=c[u+(M<<2)>>2]|0,(s|0)>-1):0){N=c[z>>2]|0;O=c[N+(s<<2)>>2]|0;a:do if(!s)R=0;else{S=s;while(1){R=S;S=S+ -1>>1;Q=N+(S<<2)|0;P=c[Q>>2]|0;U=c[c[y>>2]>>2]|0;if(!(+h[U+(O<<3)>>3]>+h[U+(P<<3)>>3]))break a;c[N+(R<<2)>>2]=P;c[u+(c[Q>>2]<<2)>>2]=R;if(!S){R=0;break}}}while(0);c[N+(R<<2)>>2]=O;c[u+(O<<2)>>2]=R}a[L>>0]=1;if((c[(c[l>>2]|0)+(M<<3)+4>>2]|0)<(c[x>>2]|0)){mc(e,t);break}else{K=K+1|0;break}}while(0);J=J+1|0}while((J|0)<((c[d>>2]|0)>>>5|0));d=c[H>>2]|0;L=c[k>>2]|0;do{J=I;I=I+ -1|0;J=c[d+(J<<2)>>2]|0;N=J>>1;M=L+N|0}while((a[M>>0]|0)==0);d=c[(c[l>>2]|0)+(N<<3)>>2]|0;a[M>>0]=0;K=K+ -1|0}while((K|0)>0);c[c[e>>2]>>2]=J^1;t=b+616|0;v=c[t>>2]|0;s=b+620|0;if(!v)w=c[s>>2]|0;else{c[s>>2]=0;w=0}u=c[m>>2]|0;if((w|0)<(u|0)){y=b+624|0;x=c[y>>2]|0;if((x|0)<(u|0)){U=u+1-x&-2;w=(x>>1)+2&-2;w=(U|0)>(w|0)?U:w;if((w|0)>(2147483647-x|0)){U=va(1)|0;Ta(U|0,48,0)}U=w+x|0;c[y>>2]=U;v=Ud(v,U<<2)|0;c[t>>2]=v;if((v|0)==0?(c[(Oa()|0)>>2]|0)==12:0){U=va(1)|0;Ta(U|0,48,0)}}w=c[s>>2]|0;b:do if((w|0)<(u|0))while(1){v=v+(w<<2)|0;if(v)c[v>>2]=0;w=w+1|0;if((w|0)==(u|0))break b;v=c[t>>2]|0}while(0);c[s>>2]=u;u=c[m>>2]|0}if((u|0)>0){w=c[t>>2]|0;v=c[e>>2]|0;x=0;do{c[w+(x<<2)>>2]=c[v+(x<<2)>>2];x=x+1|0;u=c[m>>2]|0}while((x|0)<(u|0))}v=c[b+84>>2]|0;if((v|0)==1)if((u|0)>1){n=c[e>>2]|0;o=1;v=1;while(1){u=c[n+(o<<2)>>2]|0;p=c[l>>2]|0;w=c[p+(u>>1<<3)>>2]|0;c:do if((w|0)!=-1){x=(c[q>>2]|0)+(w<<2)|0;y=c[x>>2]|0;if(y>>>0>63){w=c[k>>2]|0;z=1;while(1){U=c[x+(z<<2)+4>>2]>>1;if((a[w+U>>0]|0)==0?(c[p+(U<<3)+4>>2]|0)>0:0)break;z=z+1|0;if((z|0)>=(y>>>5|0))break c}c[n+(v<<2)>>2]=u;v=v+1|0}}else{c[n+(v<<2)>>2]=u;v=v+1|0}while(0);o=o+1|0;p=c[m>>2]|0;if((o|0)>=(p|0)){n=p;break}}}else{n=u;o=1;v=1}else if((v|0)==2)if((u|0)>1){q=1;v=1;do{w=c[e>>2]|0;u=c[w+(q<<2)>>2]|0;if((c[(c[l>>2]|0)+(u>>1<<3)>>2]|0)!=-1){c[n>>2]=u;c[p+0>>2]=c[n+0>>2];if(!(Ub(b,p)|0)){u=c[e>>2]|0;w=u;u=c[u+(q<<2)>>2]|0;o=62}}else o=62;if((o|0)==62){o=0;c[w+(v<<2)>>2]=u;v=v+1|0}q=q+1|0;u=c[m>>2]|0}while((q|0)<(u|0));n=u;o=q}else{n=u;o=1;v=1}else{n=u;o=u;v=u}U=b+240|0;S=U;S=ne(c[S>>2]|0,c[S+4>>2]|0,n|0,((n|0)<0)<<31>>31|0)|0;c[U>>2]=S;c[U+4>>2]=F;o=o-v|0;if((o|0)>0){n=n-o|0;c[m>>2]=n}U=b+248|0;S=U;S=ne(c[S>>2]|0,c[S+4>>2]|0,n|0,((n|0)<0)<<31>>31|0)|0;c[U>>2]=S;c[U+4>>2]=F;if((n|0)==1)e=0;else{e=c[e>>2]|0;if((n|0)>2){b=c[l>>2]|0;m=2;o=1;do{o=(c[b+(c[e+(m<<2)>>2]>>1<<3)+4>>2]|0)>(c[b+(c[e+(o<<2)>>2]>>1<<3)+4>>2]|0)?m:o;m=m+1|0}while((m|0)<(n|0))}else o=1;S=e+(o<<2)|0;U=c[S>>2]|0;e=e+4|0;c[S>>2]=c[e>>2];c[e>>2]=U;e=c[(c[l>>2]|0)+(U>>1<<3)+4>>2]|0}c[f>>2]=e;if((c[s>>2]|0)>0)f=0;else{i=j;return}do{a[(c[k>>2]|0)+(c[(c[t>>2]|0)+(f<<2)>>2]>>1)>>0]=0;f=f+1|0}while((f|0)<(c[s>>2]|0));i=j;return}function Ub(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;e=i;n=c[d>>2]|0;l=b+396|0;q=c[l>>2]|0;k=b+544|0;s=(c[k>>2]|0)+(c[q+(n>>1<<3)>>2]<<2)|0;h=b+604|0;f=b+608|0;if(c[h>>2]|0)c[f>>2]=0;g=b+588|0;j=b+612|0;b=b+616|0;o=1;while(1){if(o>>>0<(c[s>>2]|0)>>>5>>>0){r=c[s+(o<<2)+4>>2]|0;p=r>>1;if((c[q+(p<<3)+4>>2]|0)!=0?(m=a[(c[g>>2]|0)+p>>0]|0,(m+ -1<<24>>24&255)>=2):0){s=c[f>>2]|0;t=(s|0)==(c[j>>2]|0);if(m<<24>>24==3?1:(c[q+(p<<3)>>2]|0)==-1){k=8;break}if(t){q=(s>>1)+2&-2;q=(q|0)<2?2:q;if((q|0)>(2147483647-s|0)){k=24;break}u=c[h>>2]|0;t=q+s|0;c[j>>2]=t;t=Ud(u,t<<3)|0;c[h>>2]=t;if((t|0)==0?(c[(Oa()|0)>>2]|0)==12:0){k=24;break}s=c[f>>2]|0}c[f>>2]=s+1;q=(c[h>>2]|0)+(s<<3)|0;if(q){u=q;c[u>>2]=o;c[u+4>>2]=n}c[d>>2]=r;s=c[l>>2]|0;n=r;q=s;s=(c[k>>2]|0)+(c[s+(p<<3)>>2]<<2)|0;o=0}}else{n=(c[g>>2]|0)+(n>>1)|0;if(!(a[n>>0]|0)){a[n>>0]=2;mc(b,d)}n=c[f>>2]|0;if(!n){f=1;k=34;break}u=n+ -1|0;n=c[h>>2]|0;o=c[n+(u<<3)>>2]|0;n=c[n+(u<<3)+4>>2]|0;c[d>>2]=n;q=c[l>>2]|0;s=(c[k>>2]|0)+(c[q+(n>>1<<3)>>2]<<2)|0;c[f>>2]=u}o=o+1|0}if((k|0)==8){if(t){k=(s>>1)+2&-2;k=(k|0)<2?2:k;if((k|0)>(2147483647-s|0)){u=va(1)|0;Ta(u|0,48,0)}t=c[h>>2]|0;u=k+s|0;c[j>>2]=u;u=Ud(t,u<<3)|0;c[h>>2]=u;if((u|0)==0?(c[(Oa()|0)>>2]|0)==12:0){u=va(1)|0;Ta(u|0,48,0)}s=c[f>>2]|0}j=s+1|0;c[f>>2]=j;k=(c[h>>2]|0)+(s<<3)|0;if(k){j=k;c[j>>2]=0;c[j+4>>2]=n;j=c[f>>2]|0}if((j|0)>0)k=0;else{u=0;i=e;return u|0}do{l=(c[g>>2]|0)+(c[(c[h>>2]|0)+(k<<3)+4>>2]>>1)|0;if(!(a[l>>0]|0)){a[l>>0]=3;mc(b,(c[h>>2]|0)+(k<<3)+4|0);j=c[f>>2]|0}k=k+1|0}while((k|0)<(j|0));f=0;i=e;return f|0}else if((k|0)==24)Ta(va(1)|0,48,0);else if((k|0)==34){i=e;return f|0}return 0}function Vb(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;j=i;i=i+32|0;h=j+16|0;g=j+12|0;k=j+8|0;f=j;n=e+20|0;l=e+16|0;if((c[n>>2]|0)>0){m=0;do{a[(c[e>>2]|0)+(c[(c[l>>2]|0)+(m<<2)>>2]|0)>>0]=0;m=m+1|0}while((m|0)<(c[n>>2]|0))}if(c[l>>2]|0)c[n>>2]=0;m=c[d>>2]|0;c[k>>2]=m;c[g>>2]=m;c[h+0>>2]=c[g+0>>2];sc(e,h,0);l=(c[e>>2]|0)+m|0;if(!(a[l>>0]|0)){a[l>>0]=1;mc(e+16|0,k)}if(!(c[b+296>>2]|0)){i=j;return}d=m>>1;o=b+588|0;a[(c[o>>2]|0)+d>>0]=1;p=c[b+284>>2]|0;n=b+292|0;s=c[c[n>>2]>>2]|0;if((p|0)>(s|0)){k=b+280|0;l=b+396|0;m=e+16|0;b=b+544|0;do{p=p+ -1|0;r=c[(c[k>>2]|0)+(p<<2)>>2]|0;q=r>>1;if(a[(c[o>>2]|0)+q>>0]|0){s=c[l>>2]|0;t=c[s+(q<<3)>>2]|0;a:do if((t|0)==-1){r=r^1;c[f>>2]=r;c[g>>2]=r;c[h+0>>2]=c[g+0>>2];sc(e,h,0);r=(c[e>>2]|0)+r|0;if(!(a[r>>0]|0)){a[r>>0]=1;mc(m,f)}}else{r=(c[b>>2]|0)+(t<<2)|0;t=c[r>>2]|0;if(t>>>0>63){u=1;while(1){v=c[r+(u<<2)+4>>2]>>1;if((c[s+(v<<3)+4>>2]|0)>0){a[(c[o>>2]|0)+v>>0]=1;t=c[r>>2]|0}u=u+1|0;if((u|0)>=(t>>>5|0))break a;s=c[l>>2]|0}}}while(0);a[(c[o>>2]|0)+q>>0]=0;s=c[c[n>>2]>>2]|0}}while((p|0)>(s|0))}a[(c[o>>2]|0)+d>>0]=0;i=j;return}function Wb(b){b=b|0;var e=0,f=0,j=0,k=0,l=0,m=0,n=0.0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0;f=i;i=i+16|0;p=f+4|0;u=f;e=b+272|0;w=c[e>>2]|0;n=+h[b+496>>3]/+(w|0);k=b+544|0;l=b+268|0;v=c[l>>2]|0;c[u>>2]=k;c[p+0>>2]=c[u+0>>2];tc(v,w,p);p=c[e>>2]|0;if((p|0)>0){m=b+332|0;o=b+396|0;q=0;v=0;do{t=c[l>>2]|0;u=c[t+(q<<2)>>2]|0;w=c[k>>2]|0;r=w+(u<<2)|0;s=c[r>>2]|0;do if(s>>>0>95){x=c[w+(u+1<<2)>>2]|0;w=x>>1;x=(d[(c[m>>2]|0)+w>>0]|0)^x&1;z=a[528]|0;y=z&255;if(((x&255)<<24>>24==z<<24>>24&(y>>>1^1)|y&2&x|0)!=0?(z=c[(c[o>>2]|0)+(w<<3)>>2]|0,(z|0)!=-1&(z|0)==(u|0)):0){j=9;break}if((q|0)>=((p|0)/2|0|0)?!(+g[r+(s>>>5<<2)+4>>2]<n):0){j=9;break}Pb(b,u)}else j=9;while(0);if((j|0)==9){j=0;c[t+(v<<2)>>2]=u;v=v+1|0}q=q+1|0;p=c[e>>2]|0}while((q|0)<(p|0))}else{q=0;v=0}j=q-v|0;if((j|0)>0)c[e>>2]=p-j;if(!(+((c[b+556>>2]|0)>>>0)>+h[b+96>>3]*+((c[b+548>>2]|0)>>>0))){i=f;return}gb[c[(c[b>>2]|0)+8>>2]&31](b);i=f;return}function Xb(b,e){b=b|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;f=i;g=e+4|0;m=c[g>>2]|0;if((m|0)>0){j=b+544|0;h=b+332|0;k=0;l=0;do{u=c[e>>2]|0;p=c[u+(k<<2)>>2]|0;m=(c[j>>2]|0)+(p<<2)|0;o=c[m>>2]|0;do if(o>>>0>31){v=c[h>>2]|0;r=a[528]|0;q=r&255;w=q&2;q=q>>>1^1;s=o>>>5;t=0;do{x=c[m+(t<<2)+4>>2]|0;x=(d[v+(x>>1)>>0]|0)^x&1;t=t+1|0;if((x&255)<<24>>24==r<<24>>24&q|w&x){n=7;break}}while((t|0)<(s|0));if((n|0)==7){n=0;Pb(b,p);break}if(o>>>0>95){n=a[536]|0;q=o>>>5;p=2;do{r=m+(p<<2)+4|0;x=c[r>>2]|0;x=(d[(c[h>>2]|0)+(x>>1)>>0]|0)^x&1;w=n&255;if((x&255)<<24>>24==n<<24>>24&(w>>>1^1)|w&2&x){c[r>>2]=c[m+(q+ -1<<2)+4>>2];o=c[m>>2]|0;if(o&8){o=o>>>5;c[m+(o+ -1<<2)+4>>2]=c[m+(o<<2)+4>>2];o=c[m>>2]|0}o=o+ -32|0;c[m>>2]=o;p=p+ -1|0}p=p+1|0;q=o>>>5}while((p|0)<(q|0));p=c[e>>2]|0;u=p;p=c[p+(k<<2)>>2]|0;n=16}else n=16}else n=16;while(0);if((n|0)==16){n=0;c[u+(l<<2)>>2]=p;l=l+1|0}k=k+1|0;m=c[g>>2]|0}while((k|0)<(m|0))}else{k=0;l=0}e=k-l|0;if((e|0)<=0){i=f;return}c[g>>2]=m-e;i=f;return}function Yb(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;g=i;i=i+16|0;e=g+4|0;h=g;c[e>>2]=0;d=e+4|0;c[d>>2]=0;f=e+8|0;c[f>>2]=0;c[h>>2]=0;j=b+540|0;n=c[j>>2]|0;if((n|0)>0){l=b+380|0;k=b+332|0;m=0;do{if((a[(c[l>>2]|0)+m>>0]|0)!=0?(p=a[(c[k>>2]|0)+m>>0]|0,q=a[544]|0,o=q&255,((o>>>1^1)&p<<24>>24==q<<24>>24|p&2&o|0)!=0):0){nc(e,h);n=c[j>>2]|0}m=m+1|0;c[h>>2]=m}while((m|0)<(n|0))}uc(b+460|0,e);b=c[e>>2]|0;if(!b){i=g;return}c[d>>2]=0;Td(b);c[e>>2]=0;c[f>>2]=0;i=g;return}function Zb(b){b=b|0;var d=0,e=0,f=0,g=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;d=i;f=b+492|0;if((a[f>>0]|0)!=0?(Mb(b)|0)==-1:0){f=b+284|0;g=b+516|0;if((c[f>>2]|0)==(c[g>>2]|0)){s=1;i=d;return s|0}j=b+520|0;s=j;r=c[s+4>>2]|0;if((r|0)>0|(r|0)==0&(c[s>>2]|0)>>>0>0){s=1;i=d;return s|0}Xb(b,b+268|0);if(a[b+536>>0]|0){Xb(b,b+256|0);l=b+564|0;k=b+568|0;if((c[k>>2]|0)>0){n=b+588|0;m=0;do{a[(c[n>>2]|0)+(c[(c[l>>2]|0)+(m<<2)>>2]|0)>>0]=1;m=m+1|0}while((m|0)<(c[k>>2]|0))}p=c[f>>2]|0;if((p|0)>0){m=c[b+280>>2]|0;n=c[b+588>>2]|0;q=0;o=0;do{r=c[m+(q<<2)>>2]|0;if(!(a[n+(r>>1)>>0]|0)){c[m+(o<<2)>>2]=r;p=c[f>>2]|0;o=o+1|0}q=q+1|0}while((q|0)<(p|0))}else{q=0;o=0}m=q-o|0;if((m|0)>0){p=p-m|0;c[f>>2]=p}c[b+512>>2]=p;a:do if((c[k>>2]|0)>0){o=b+588|0;m=0;do{a[(c[o>>2]|0)+(c[(c[l>>2]|0)+(m<<2)>>2]|0)>>0]=0;m=m+1|0;n=c[k>>2]|0}while((m|0)<(n|0));if((n|0)>0){n=b+580|0;o=b+584|0;m=b+576|0;p=0;while(1){r=c[n>>2]|0;if((r|0)==(c[o>>2]|0)){q=(r>>1)+2&-2;q=(q|0)<2?2:q;if((q|0)>(2147483647-r|0)){e=28;break}s=c[m>>2]|0;q=q+r|0;c[o>>2]=q;q=Ud(s,q<<2)|0;c[m>>2]=q;if((q|0)==0?(c[(Oa()|0)>>2]|0)==12:0){e=28;break}r=c[n>>2]|0}else q=c[m>>2]|0;s=q+(r<<2)|0;if(s){c[s>>2]=0;r=c[n>>2]|0}c[n>>2]=r+1;s=c[l>>2]|0;c[q+(r<<2)>>2]=c[s+(p<<2)>>2];p=p+1|0;if((p|0)>=(c[k>>2]|0))break a}if((e|0)==28)Ta(va(1)|0,48,0)}else e=21}else e=21;while(0);if((e|0)==21)s=c[l>>2]|0;if(s)c[k>>2]=0}if(+((c[b+556>>2]|0)>>>0)>+h[b+96>>3]*+((c[b+548>>2]|0)>>>0))gb[c[(c[b>>2]|0)+8>>2]&31](b);Yb(b);c[g>>2]=c[f>>2];r=b+224|0;s=b+232|0;r=ne(c[s>>2]|0,c[s+4>>2]|0,c[r>>2]|0,c[r+4>>2]|0)|0;s=j;c[s>>2]=r;c[s+4>>2]=F;s=1;i=d;return s|0}a[f>>0]=0;s=0;i=d;return s|0}function _b(b,e,f){b=b|0;e=e|0;f=f|0;var j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0.0,ga=0,ha=0,ia=0,ja=0.0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0.0,ra=0,sa=0,ta=0.0;n=i;i=i+64|0;_=n;G=n+60|0;B=n+56|0;j=n+44|0;$=n+40|0;c[j>>2]=0;m=j+4|0;c[m>>2]=0;l=j+8|0;c[l>>2]=0;N=e+160|0;M=N;M=ne(c[M>>2]|0,c[M+4>>2]|0,1,0)|0;c[N>>2]=M;c[N+4>>2]=F;N=(f|0)<0;M=e+680|0;L=e+664|0;K=e+672|0;q=e+296|0;w=e+272|0;o=e+284|0;I=e+640|0;E=e+308|0;D=e+304|0;r=e+332|0;H=e+292|0;ba=e+168|0;t=e+396|0;v=e+280|0;J=e+184|0;C=e+192|0;u=e+48|0;U=e+504|0;Y=e+56|0;aa=e+496|0;ca=e+656|0;O=e+144|0;P=e+648|0;Q=e+128|0;R=e+44|0;T=e+200|0;V=e+208|0;W=e+224|0;X=e+216|0;s=e+232|0;Z=e+540|0;p=e+292|0;x=e+544|0;z=e+276|0;y=e+268|0;A=e+268|0;da=0;a:while(1){ea=N|(da|0)<(f|0);while(1){ga=Mb(e)|0;if((ga|0)!=-1)break;if(!ea){ga=41;break a}if(a[M>>0]|0){ga=41;break a}ga=L;ha=c[ga+4>>2]|0;if((ha|0)>=0?(sa=C,ra=c[sa+4>>2]|0,!(ra>>>0<ha>>>0|((ra|0)==(ha|0)?(c[sa>>2]|0)>>>0<(c[ga>>2]|0)>>>0:0))):0){ga=41;break a}ga=K;ha=c[ga+4>>2]|0;if((ha|0)>=0?(sa=J,ra=c[sa+4>>2]|0,!(ra>>>0<ha>>>0|((ra|0)==(ha|0)?(c[sa>>2]|0)>>>0<(c[ga>>2]|0)>>>0:0))):0){ga=41;break a}if((c[q>>2]|0)==0?!(Zb(e)|0):0){ga=50;break a}if(+((c[w>>2]|0)-(c[o>>2]|0)|0)>=+h[I>>3])Wb(e);while(1){ga=c[q>>2]|0;if((ga|0)>=(c[E>>2]|0)){ga=59;break}ka=c[(c[D>>2]|0)+(ga<<2)>>2]|0;ha=d[(c[r>>2]|0)+(ka>>1)>>0]|0;sa=ha^ka&1;ia=sa&255;pa=a[528]|0;ra=pa&255;if(!(ia<<24>>24==pa<<24>>24&(ra>>>1^1)|ra&2&sa)){ga=56;break}c[G>>2]=c[o>>2];nc(H,G)}if((ga|0)==56){ga=0;ra=a[536]|0;sa=ra&255;if((sa>>>1^1)&ia<<24>>24==ra<<24>>24|ha&2&sa){ga=57;break a}if((ka|0)==-2)ga=59}if((ga|0)==59){sa=ba;sa=ne(c[sa>>2]|0,c[sa+4>>2]|0,1,0)|0;ka=ba;c[ka>>2]=sa;c[ka+4>>2]=F;ka=Sb(e)|0;if((ka|0)==-2){ga=60;break a}}c[_>>2]=c[o>>2];nc(H,_);sa=ka>>1;a[(c[r>>2]|0)+sa>>0]=(ka&1^1)&255^1;ra=c[q>>2]|0;sa=(c[t>>2]|0)+(sa<<3)|0;c[sa>>2]=-1;c[sa+4>>2]=ra;sa=c[o>>2]|0;c[o>>2]=sa+1;c[(c[v>>2]|0)+(sa<<2)>>2]=ka}ra=C;ra=ne(c[ra>>2]|0,c[ra+4>>2]|0,1,0)|0;sa=C;c[sa>>2]=ra;c[sa+4>>2]=F;da=da+1|0;if(!(c[q>>2]|0)){ga=5;break}if(c[j>>2]|0)c[m>>2]=0;Tb(e,ga,j,B);Rb(e,c[B>>2]|0);if((c[m>>2]|0)==1){ra=c[c[j>>2]>>2]|0;sa=ra>>1;a[(c[r>>2]|0)+sa>>0]=(ra&1^1)&255^1;pa=c[q>>2]|0;sa=(c[t>>2]|0)+(sa<<3)|0;c[sa>>2]=-1;c[sa+4>>2]=pa;sa=c[o>>2]|0;c[o>>2]=sa+1;c[(c[v>>2]|0)+(sa<<2)>>2]=ra}else{ea=pc(x,j,1)|0;ga=c[w>>2]|0;if((ga|0)==(c[z>>2]|0)){ha=(ga>>1)+2&-2;ha=(ha|0)<2?2:ha;if((ha|0)>(2147483647-ga|0)){ga=14;break}ra=c[y>>2]|0;sa=ha+ga|0;c[z>>2]=sa;sa=Ud(ra,sa<<2)|0;c[y>>2]=sa;if((sa|0)==0?(c[(Oa()|0)>>2]|0)==12:0){ga=14;break}ga=c[w>>2]|0}c[w>>2]=ga+1;ga=(c[y>>2]|0)+(ga<<2)|0;if(ga)c[ga>>2]=ea;Nb(e,ea);ia=c[x>>2]|0;sa=ia+(ea<<2)|0;fa=+h[aa>>3];sa=sa+((c[sa>>2]|0)>>>5<<2)+4|0;ta=fa+ +g[sa>>2];g[sa>>2]=ta;if(ta>1.0e20){ha=c[w>>2]|0;if((ha|0)>0){ga=c[A>>2]|0;ka=0;do{sa=ia+(c[ga+(ka<<2)>>2]<<2)|0;sa=sa+((c[sa>>2]|0)>>>5<<2)+4|0;g[sa>>2]=+g[sa>>2]*1.0e-20;ka=ka+1|0}while((ka|0)!=(ha|0))}h[aa>>3]=fa*1.0e-20}ra=c[c[j>>2]>>2]|0;sa=ra>>1;a[(c[r>>2]|0)+sa>>0]=(ra&1^1)&255^1;pa=c[q>>2]|0;sa=(c[t>>2]|0)+(sa<<3)|0;c[sa>>2]=ea;c[sa+4>>2]=pa;sa=c[o>>2]|0;c[o>>2]=sa+1;c[(c[v>>2]|0)+(sa<<2)>>2]=ra}h[U>>3]=1.0/+h[u>>3]*+h[U>>3];h[aa>>3]=1.0/+h[Y>>3]*+h[aa>>3];sa=(c[ca>>2]|0)+ -1|0;c[ca>>2]=sa;if(sa)continue;fa=+h[O>>3]*+h[P>>3];h[P>>3]=fa;c[ca>>2]=~~fa;fa=+h[Q>>3]*+h[I>>3];h[I>>3]=fa;if((c[R>>2]|0)<=0)continue;ga=c[C>>2]|0;ea=c[T>>2]|0;oa=c[q>>2]|0;if(!oa)ha=o;else ha=c[p>>2]|0;ha=c[ha>>2]|0;na=c[V>>2]|0;ma=c[W>>2]|0;la=c[X>>2]|0;ka=s;ia=c[ka>>2]|0;ka=c[ka+4>>2]|0;ja=+(c[Z>>2]|0);qa=1.0/ja;if((oa|0)<0)ta=0.0;else{pa=0;ta=0.0;while(1){if(!pa)ra=0;else ra=c[(c[p>>2]|0)+(pa+ -1<<2)>>2]|0;if((pa|0)==(oa|0))sa=o;else sa=(c[p>>2]|0)+(pa<<2)|0;ta=ta+ +S(+qa,+(+(pa|0)))*+((c[sa>>2]|0)-ra|0);if((pa|0)==(oa|0))break;else pa=pa+1|0}}c[_>>2]=ga;c[_+4>>2]=ea-ha;c[_+8>>2]=na;c[_+12>>2]=ma;c[_+16>>2]=~~fa;c[_+20>>2]=la;sa=_+24|0;h[k>>3]=(+(ia>>>0)+4294967296.0*+(ka>>>0))/+(la|0);c[sa>>2]=c[k>>2];c[sa+4>>2]=c[k+4>>2];sa=_+32|0;h[k>>3]=ta/ja*100.0;c[sa>>2]=c[k>>2];c[sa+4>>2]=c[k+4>>2];La(1832,_|0)|0}if((ga|0)==5)a[b>>0]=a[536]|0;else if((ga|0)==14)Ta(va(1)|0,48,0);else if((ga|0)==41){fa=+(c[Z>>2]|0);ja=1.0/fa;r=c[q>>2]|0;if((r|0)<0)qa=0.0;else{q=0;qa=0.0;while(1){if(!q)s=0;else s=c[(c[p>>2]|0)+(q+ -1<<2)>>2]|0;if((q|0)==(r|0))t=o;else t=(c[p>>2]|0)+(q<<2)|0;qa=qa+ +S(+ja,+(+(q|0)))*+((c[t>>2]|0)-s|0);if((q|0)==(r|0))break;else q=q+1|0}}h[e+528>>3]=qa/fa;Rb(e,0);a[b>>0]=a[544]|0}else if((ga|0)==50)a[b>>0]=a[536]|0;else if((ga|0)==57){c[$>>2]=ka^1;sa=e+16|0;c[_+0>>2]=c[$+0>>2];Vb(e,_,sa);a[b>>0]=a[536]|0}else if((ga|0)==60)a[b>>0]=a[528]|0;b=c[j>>2]|0;if(!b){i=n;return}c[m>>2]=0;Td(b);c[j>>2]=0;c[l>>2]=0;i=n;return}function $b(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0.0,w=0,x=0,y=0,z=0.0,A=0,B=0;f=i;i=i+16|0;j=f;e=d+4|0;if(c[e>>2]|0)c[d+8>>2]=0;g=d+36|0;k=d+32|0;if((c[g>>2]|0)>0){l=d+16|0;m=0;do{a[(c[l>>2]|0)+(c[(c[k>>2]|0)+(m<<2)>>2]|0)>>0]=0;m=m+1|0}while((m|0)<(c[g>>2]|0))}if(c[k>>2]|0)c[g>>2]=0;k=d+492|0;if(!(a[k>>0]|0)){a[b>>0]=a[536]|0;i=f;return}l=d+152|0;y=l;y=ne(c[y>>2]|0,c[y+4>>2]|0,1,0)|0;c[l>>2]=y;c[l+4>>2]=F;z=+h[d+120>>3]*+(c[d+208>>2]|0);l=d+640|0;h[l>>3]=z;v=+(c[d+104>>2]|0);if(z<v)h[l>>3]=v;w=c[d+136>>2]|0;h[d+648>>3]=+(w|0);c[d+656>>2]=w;w=a[544]|0;l=d+44|0;if((c[l>>2]|0)>0){Ka(2288)|0;Ka(2368)|0;Ka(2448)|0;Ka(2528)|0;o=a[544]|0}else o=w;n=d+192|0;m=d+184|0;y=o&255;a:do if((y>>>1^1)&w<<24>>24==o<<24>>24|w&2&y){q=d+80|0;t=d+112|0;p=d+108|0;o=d+680|0;r=d+664|0;s=d+672|0;u=0;while(1){v=+h[t>>3];if(!(a[q>>0]|0))v=+S(+v,+(+(u|0)));else{y=u+1|0;if((u|0)>0){x=0;w=1;do{x=x+1|0;w=w<<1|1}while((w|0)<(y|0));y=w+ -1|0}else{x=0;y=0}if((y|0)!=(u|0)){w=u;do{A=y>>1;x=x+ -1|0;w=(w|0)%(A|0)|0;y=A+ -1|0}while((y|0)!=(w|0))}v=+S(+v,+(+(x|0)))}_b(j,d,~~(v*+(c[p>>2]|0)));w=a[j>>0]|0;if(a[o>>0]|0)break a;y=r;x=c[y+4>>2]|0;if((x|0)>=0?(A=n,B=c[A+4>>2]|0,!(B>>>0<x>>>0|((B|0)==(x|0)?(c[A>>2]|0)>>>0<(c[y>>2]|0)>>>0:0))):0)break a;y=s;x=c[y+4>>2]|0;if((x|0)>=0?(B=m,A=c[B+4>>2]|0,!(A>>>0<x>>>0|((A|0)==(x|0)?(c[B>>2]|0)>>>0<(c[y>>2]|0)>>>0:0))):0)break a;A=a[544]|0;B=A&255;if(!((B>>>1^1)&w<<24>>24==A<<24>>24|w&2&B))break;else u=u+1|0}}while(0);if((c[l>>2]|0)>0)Ka(2528)|0;A=a[528]|0;B=A&255;j=w&2;if(!((B>>>1^1)&w<<24>>24==A<<24>>24|j&B)){A=a[536]|0;B=A&255;if(((B>>>1^1)&w<<24>>24==A<<24>>24|j&B|0)!=0?(c[g>>2]|0)==0:0)a[k>>0]=0}else{g=d+540|0;jc(e,c[g>>2]|0);if((c[g>>2]|0)>0){j=d+332|0;k=0;do{a[(c[e>>2]|0)+k>>0]=a[(c[j>>2]|0)+k>>0]|0;k=k+1|0}while((k|0)<(c[g>>2]|0))}}Rb(d,0);a[b>>0]=w;i=f;return}function ac(b,e){b=b|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;f=i;h=b+412|0;vc(h);k=b+540|0;if((c[k>>2]|0)>0){j=b+544|0;g=0;do{l=g<<1;n=c[h>>2]|0;m=n+(l*12|0)+4|0;if((c[m>>2]|0)>0){p=n+(l*12|0)|0;o=0;do{s=(c[p>>2]|0)+(o<<3)|0;n=c[s>>2]|0;q=c[j>>2]|0;r=q+(n<<2)|0;if(!(c[r>>2]&16)){t=wc(e,r)|0;c[s>>2]=t;c[r>>2]=c[r>>2]|16;c[q+(n+1<<2)>>2]=t}else c[s>>2]=c[q+(n+1<<2)>>2];o=o+1|0}while((o|0)<(c[m>>2]|0));m=c[h>>2]|0}else m=n;n=l|1;l=m+(n*12|0)+4|0;if((c[l>>2]|0)>0){r=m+(n*12|0)|0;q=0;do{m=(c[r>>2]|0)+(q<<3)|0;p=c[m>>2]|0;o=c[j>>2]|0;n=o+(p<<2)|0;if(!(c[n>>2]&16)){t=wc(e,n)|0;c[m>>2]=t;c[n>>2]=c[n>>2]|16;c[o+(p+1<<2)>>2]=t}else c[m>>2]=c[o+(p+1<<2)>>2];q=q+1|0}while((q|0)<(c[l>>2]|0))}g=g+1|0}while((g|0)<(c[k>>2]|0))}g=b+284|0;if((c[g>>2]|0)>0){l=b+280|0;k=b+396|0;j=b+544|0;h=b+332|0;m=0;do{r=c[k>>2]|0;p=r+(c[(c[l>>2]|0)+(m<<2)>>2]>>1<<3)|0;q=c[p>>2]|0;do if((q|0)!=-1){t=c[j>>2]|0;s=t+(q<<2)|0;o=(c[s>>2]&16|0)==0;if(o){u=c[t+(q+1<<2)>>2]|0;n=u>>1;u=(d[(c[h>>2]|0)+n>>0]|0)^u&1;w=a[528]|0;v=w&255;if(!((u&255)<<24>>24==w<<24>>24&(v>>>1^1)|v&2&u))break;w=c[r+(n<<3)>>2]|0;if(!((w|0)!=-1&(w|0)==(q|0)))break;if(o){w=wc(e,s)|0;c[p>>2]=w;c[s>>2]=c[s>>2]|16;c[t+(q+1<<2)>>2]=w;break}}c[p>>2]=c[t+(q+1<<2)>>2]}while(0);m=m+1|0}while((m|0)<(c[g>>2]|0))}g=b+272|0;n=c[g>>2]|0;if((n|0)>0){j=b+268|0;h=b+544|0;m=c[j>>2]|0;k=0;l=0;do{p=m+(k<<2)|0;o=c[p>>2]|0;r=c[h>>2]|0;q=r+(o<<2)|0;s=c[q>>2]|0;if((s&3|0)!=1){if(!(s&16)){n=wc(e,q)|0;c[p>>2]=n;c[q>>2]=c[q>>2]|16;c[r+(o+1<<2)>>2]=n;n=c[j>>2]|0;m=n;n=c[n+(k<<2)>>2]|0}else{n=c[r+(o+1<<2)>>2]|0;c[p>>2]=n}c[m+(l<<2)>>2]=n;n=c[g>>2]|0;l=l+1|0}k=k+1|0}while((k|0)<(n|0))}else{k=0;l=0}h=k-l|0;if((h|0)>0)c[g>>2]=n-h;g=b+260|0;m=c[g>>2]|0;if((m|0)>0){h=b+256|0;b=b+544|0;l=c[h>>2]|0;j=0;k=0;do{n=l+(j<<2)|0;p=c[n>>2]|0;o=c[b>>2]|0;r=o+(p<<2)|0;q=c[r>>2]|0;if((q&3|0)!=1){if(!(q&16)){m=wc(e,r)|0;c[n>>2]=m;c[r>>2]=c[r>>2]|16;c[o+(p+1<<2)>>2]=m;m=c[h>>2]|0;l=m;m=c[m+(j<<2)>>2]|0}else{m=c[o+(p+1<<2)>>2]|0;c[n>>2]=m}c[l+(k<<2)>>2]=m;m=c[g>>2]|0;k=k+1|0}j=j+1|0}while((j|0)<(m|0))}else{j=0;k=0}e=j-k|0;if((e|0)<=0){i=f;return}c[g>>2]=m-e;i=f;return}function bc(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0;g=i;i=i+32|0;j=g;d=g+8|0;e=b+548|0;f=b+556|0;h=(c[e>>2]|0)-(c[f>>2]|0)|0;c[d+0>>2]=0;c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;gc(d,h);h=d+16|0;a[h>>0]=0;ac(b,d);if((c[b+44>>2]|0)>1){k=c[d+4>>2]<<2;c[j>>2]=c[e>>2]<<2;c[j+4>>2]=k;La(1888,j|0)|0}a[b+560>>0]=a[h>>0]|0;h=b+544|0;j=c[h>>2]|0;if(j)Td(j);c[h>>2]=c[d>>2];c[e>>2]=c[d+4>>2];c[b+552>>2]=c[d+8>>2];c[f>>2]=c[d+12>>2];i=g;return}function cc(){var d=0,e=0,f=0;d=i;i=i+16|0;e=d;a[528]=0;a[536]=1;a[544]=2;xb(552,608,624,2136,2144);c[138]=2168;h[72]=0.0;h[73]=1.0;a[592]=0;a[593]=0;b[297]=b[e+0>>1]|0;b[298]=b[e+2>>1]|0;b[299]=b[e+4>>1]|0;h[75]=.95;xb(664,720,736,2136,2144);c[166]=2168;h[86]=0.0;h[87]=1.0;a[704]=0;a[705]=0;b[353]=b[e+0>>1]|0;b[354]=b[e+2>>1]|0;b[355]=b[e+4>>1]|0;h[89]=.999;xb(776,832,848,2136,2144);c[194]=2168;h[100]=0.0;h[101]=1.0;a[816]=1;a[817]=1;b[409]=b[e+0>>1]|0;b[410]=b[e+2>>1]|0;b[411]=b[e+4>>1]|0;h[103]=0.0;xb(936,992,1008,2136,2144);c[234]=2168;h[120]=0.0;h[121]=v;a[976]=0;a[977]=0;b[489]=b[e+0>>1]|0;b[490]=b[e+2>>1]|0;b[491]=b[e+4>>1]|0;h[123]=91648253.0;xb(1048,1080,1096,2136,2016);c[262]=280;f=1068|0;c[f>>2]=0;c[f+4>>2]=2;c[269]=2;xb(1160,1192,1208,2136,2016);c[290]=280;f=1180|0;c[f>>2]=0;c[f+4>>2]=2;c[297]=2;xb(1272,1296,1312,2136,1992);c[318]=160;a[1292]=0;xb(1344,1368,1376,2136,1992);c[336]=160;a[1364]=1;xb(1408,1440,1448,2136,2016);c[352]=280;f=1428|0;c[f>>2]=1;c[f+4>>2]=2147483647;c[359]=100;xb(1480,1536,1544,2136,2144);c[370]=2168;h[188]=1.0;h[189]=v;a[1520]=0;a[1521]=0;b[761]=b[e+0>>1]|0;b[762]=b[e+2>>1]|0;b[763]=b[e+4>>1]|0;h[191]=2.0;xb(1584,1640,1648,2136,2144);c[396]=2168;h[201]=0.0;h[202]=v;a[1624]=0;a[1625]=0;b[813]=b[e+0>>1]|0;b[814]=b[e+2>>1]|0;b[815]=b[e+4>>1]|0;h[204]=.2;xb(1728,1760,1776,2136,2016);c[432]=280;e=1748|0;c[e>>2]=0;c[e+4>>2]=2147483647;c[439]=0;i=d;return}function dc(a){a=a|0;var b=0;b=i;pd(a);i=b;return}function ec(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,j=0,k=0,l=0,m=0,n=0,o=0,q=0.0,r=0.0;e=i;i=i+16|0;j=e;g=e+8|0;if((a[d>>0]|0)!=45){o=0;i=e;return o|0}m=d+1|0;f=b+4|0;k=c[f>>2]|0;l=a[k>>0]|0;a:do if(l<<24>>24){n=0;while(1){o=n;n=n+1|0;if((a[m>>0]|0)!=l<<24>>24){b=0;break}l=a[k+n>>0]|0;m=d+(o+2)|0;if(!(l<<24>>24))break a}i=e;return b|0}while(0);if((a[m>>0]|0)!=61){o=0;i=e;return o|0}k=m+1|0;q=+ce(k,g);if(!(c[g>>2]|0)){o=0;i=e;return o|0}r=+h[b+32>>3];if(q>=r?(a[b+41>>0]|0)==0|q!=r:0){o=c[p>>2]|0;n=c[f>>2]|0;c[j>>2]=k;c[j+4>>2]=n;Za(o|0,2024,j|0)|0;ab(1)}r=+h[b+24>>3];if(q<=r?(a[b+40>>0]|0)==0|q!=r:0){o=c[p>>2]|0;n=c[f>>2]|0;c[j>>2]=k;c[j+4>>2]=n;Za(o|0,2080,j|0)|0;ab(1)}h[b+48>>3]=q;o=1;i=e;return o|0}function fc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,j=0,l=0.0,m=0,n=0.0,o=0.0,q=0;e=i;i=i+48|0;f=e;g=c[p>>2]|0;q=c[b+16>>2]|0;m=(a[b+40>>0]|0)!=0?91:40;o=+h[b+24>>3];n=+h[b+32>>3];j=(a[b+41>>0]|0)!=0?93:41;l=+h[b+48>>3];c[f>>2]=c[b+4>>2];c[f+4>>2]=q;c[f+8>>2]=m;m=f+12|0;h[k>>3]=o;c[m>>2]=c[k>>2];c[m+4>>2]=c[k+4>>2];m=f+20|0;h[k>>3]=n;c[m>>2]=c[k>>2];c[m+4>>2]=c[k+4>>2];c[f+28>>2]=j;j=f+32|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Za(g|0,2232,f|0)|0;if(!d){i=e;return}c[f>>2]=c[b+8>>2];Za(g|0,2e3,f|0)|0;Sa(10,g|0)|0;i=e;return}function gc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=i;e=a+8|0;f=c[e>>2]|0;if(f>>>0<b>>>0)h=f;else{i=d;return}while(1){if(h>>>0>=b>>>0)break;h=((h>>>3)+2+(h>>>1)&-2)+h|0;c[e>>2]=h;if(h>>>0<=f>>>0){g=4;break}}if((g|0)==4)Ta(va(1)|0,48,0);e=Ud(c[a>>2]|0,h<<2)|0;if((e|0)==0?(c[(Oa()|0)>>2]|0)==12:0)Ta(va(1)|0,48,0);c[a>>2]=e;i=d;return}function hc(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0;b=i;e=a+32|0;d=c[e>>2]|0;if(d){c[a+36>>2]=0;Td(d);c[e>>2]=0;c[a+40>>2]=0}e=a+16|0;d=c[e>>2]|0;if(d){c[a+20>>2]=0;Td(d);c[e>>2]=0;c[a+24>>2]=0}e=c[a>>2]|0;if(!e){i=b;return}d=a+4|0;g=c[d>>2]|0;if((g|0)>0){f=0;do{j=e+(f*12|0)|0;h=c[j>>2]|0;if(h){c[e+(f*12|0)+4>>2]=0;Td(h);c[j>>2]=0;c[e+(f*12|0)+8>>2]=0;e=c[a>>2]|0;g=c[d>>2]|0}f=f+1|0}while((f|0)<(g|0))}c[d>>2]=0;Td(e);c[a>>2]=0;c[a+8>>2]=0;i=b;return}function ic(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0;f=i;i=i+16|0;e=f+4|0;d=f;l=c[b>>2]|0;h=l+1|0;g=a+4|0;if((c[g>>2]|0)<(h|0)){k=a+8|0;j=c[k>>2]|0;if((j|0)<(h|0)){m=l+2-j&-2;l=(j>>1)+2&-2;l=(m|0)>(l|0)?m:l;if((l|0)>(2147483647-j|0)){m=va(1)|0;Ta(m|0,48,0)}n=c[a>>2]|0;m=l+j|0;c[k>>2]=m;m=Ud(n,m*12|0)|0;c[a>>2]=m;if((m|0)==0?(c[(Oa()|0)>>2]|0)==12:0){n=va(1)|0;Ta(n|0,48,0)}}k=c[g>>2]|0;if((k|0)<(h|0)){j=c[a>>2]|0;do{l=j+(k*12|0)|0;if(l){c[l>>2]=0;c[j+(k*12|0)+4>>2]=0;c[j+(k*12|0)+8>>2]=0}k=k+1|0}while((k|0)!=(h|0))}c[g>>2]=h;l=c[b>>2]|0}g=c[a>>2]|0;if(!(c[g+(l*12|0)>>2]|0)){m=l;n=a+16|0;c[d>>2]=m;c[e+0>>2]=c[d+0>>2];sc(n,e,0);i=f;return}c[g+(l*12|0)+4>>2]=0;m=c[b>>2]|0;n=a+16|0;c[d>>2]=m;c[e+0>>2]=c[d+0>>2];sc(n,e,0);i=f;return}function jc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0;f=i;e=b+4|0;if((c[e>>2]|0)>=(d|0)){i=f;return}h=b+8|0;g=c[h>>2]|0;if((g|0)<(d|0)){k=d+1-g&-2;j=(g>>1)+2&-2;j=(k|0)>(j|0)?k:j;if((j|0)>(2147483647-g|0)){k=va(1)|0;Ta(k|0,48,0)}l=c[b>>2]|0;k=j+g|0;c[h>>2]=k;k=Ud(l,k)|0;c[b>>2]=k;if((k|0)==0?(c[(Oa()|0)>>2]|0)==12:0){l=va(1)|0;Ta(l|0,48,0)}}g=c[e>>2]|0;if((g|0)<(d|0)){b=c[b>>2]|0;do{h=b+g|0;if(h)a[h>>0]=0;g=g+1|0}while((g|0)!=(d|0))}c[e>>2]=d;i=f;return}function kc(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0;h=i;g=d+1|0;f=b+4|0;if((c[f>>2]|0)>=(g|0)){l=c[b>>2]|0;l=l+d|0;a[l>>0]=e;i=h;return}k=b+8|0;j=c[k>>2]|0;if((j|0)<(g|0)){m=d+2-j&-2;l=(j>>1)+2&-2;l=(m|0)>(l|0)?m:l;if((l|0)>(2147483647-j|0)){m=va(1)|0;Ta(m|0,48,0)}n=c[b>>2]|0;m=l+j|0;c[k>>2]=m;m=Ud(n,m)|0;c[b>>2]=m;if((m|0)==0?(c[(Oa()|0)>>2]|0)==12:0){n=va(1)|0;Ta(n|0,48,0)}}j=c[f>>2]|0;if((j|0)<(g|0))do{k=(c[b>>2]|0)+j|0;if(k)a[k>>0]=0;j=j+1|0}while((j|0)!=(g|0));c[f>>2]=g;n=c[b>>2]|0;n=n+d|0;a[n>>0]=e;i=h;return}function lc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,j=0,k=0,l=0,m=0,n=0,o=0;d=i;i=i+16|0;g=d;c[g>>2]=b;j=a+12|0;f=b+1|0;e=a+16|0;if((c[e>>2]|0)<(f|0)){l=a+20|0;k=c[l>>2]|0;if((k|0)<(f|0)){n=b+2-k&-2;m=(k>>1)+2&-2;m=(n|0)>(m|0)?n:m;if((m|0)>(2147483647-k|0)){n=va(1)|0;Ta(n|0,48,0)}o=c[j>>2]|0;n=m+k|0;c[l>>2]=n;n=Ud(o,n<<2)|0;c[j>>2]=n;if((n|0)==0?(c[(Oa()|0)>>2]|0)==12:0){o=va(1)|0;Ta(o|0,48,0)}}k=c[e>>2]|0;if((f|0)>(k|0))ke((c[j>>2]|0)+(k<<2)|0,-1,f-k<<2|0)|0;c[e>>2]=f}c[(c[j>>2]|0)+(b<<2)>>2]=c[a+4>>2];nc(a,g);e=c[j>>2]|0;g=c[e+(b<<2)>>2]|0;b=c[a>>2]|0;f=c[b+(g<<2)>>2]|0;if(!g){n=0;o=b+(n<<2)|0;c[o>>2]=f;o=e+(f<<2)|0;c[o>>2]=n;i=d;return}a=a+28|0;while(1){j=g;g=g+ -1>>1;k=b+(g<<2)|0;l=c[k>>2]|0;o=c[c[a>>2]>>2]|0;if(!(+h[o+(f<<3)>>3]>+h[o+(l<<3)>>3])){a=14;break}c[b+(j<<2)>>2]=l;c[e+(c[k>>2]<<2)>>2]=j;if(!g){j=0;a=14;break}}if((a|0)==14){o=b+(j<<2)|0;c[o>>2]=f;o=e+(f<<2)|0;c[o>>2]=j;i=d;return}}function mc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0;d=i;e=a+4|0;f=c[e>>2]|0;g=a+8|0;h=c[g>>2]|0;if((f|0)==(h|0)&(h|0)<(f+1|0)){h=(f>>1)+2&-2;h=(h|0)<2?2:h;if((h|0)>(2147483647-f|0)){h=va(1)|0;Ta(h|0,48,0)}j=c[a>>2]|0;f=h+f|0;c[g>>2]=f;f=Ud(j,f<<2)|0;c[a>>2]=f;if((f|0)==0?(c[(Oa()|0)>>2]|0)==12:0){j=va(1)|0;Ta(j|0,48,0)}}else f=c[a>>2]|0;j=c[e>>2]|0;c[e>>2]=j+1;e=f+(j<<2)|0;if(!e){i=d;return}c[e>>2]=c[b>>2];i=d;return}function nc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0;d=i;e=a+4|0;f=c[e>>2]|0;g=a+8|0;h=c[g>>2]|0;if((f|0)==(h|0)&(h|0)<(f+1|0)){h=(f>>1)+2&-2;h=(h|0)<2?2:h;if((h|0)>(2147483647-f|0)){h=va(1)|0;Ta(h|0,48,0)}j=c[a>>2]|0;f=h+f|0;c[g>>2]=f;f=Ud(j,f<<2)|0;c[a>>2]=f;if((f|0)==0?(c[(Oa()|0)>>2]|0)==12:0){j=va(1)|0;Ta(j|0,48,0)}}else f=c[a>>2]|0;j=c[e>>2]|0;c[e>>2]=j+1;e=f+(j<<2)|0;if(!e){i=d;return}c[e>>2]=c[b>>2];i=d;return}function oc(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;e=i;i=i+16|0;f=e+2|0;h=e+1|0;g=e;if((d|0)<16){g=d+ -1|0;if((g|0)>0)h=0;else{i=e;return}do{f=h;h=h+1|0;if((h|0)<(d|0)){k=f;j=h;do{k=(c[b+(j<<2)>>2]|0)<(c[b+(k<<2)>>2]|0)?j:k;j=j+1|0}while((j|0)!=(d|0))}else k=f;n=b+(f<<2)|0;o=c[n>>2]|0;p=b+(k<<2)|0;c[n>>2]=c[p>>2];c[p>>2]=o}while((h|0)!=(g|0));i=e;return}j=c[b+(((d|0)/2|0)<<2)>>2]|0;m=-1;n=d;while(1){do{m=m+1|0;l=b+(m<<2)|0;k=c[l>>2]|0}while((k|0)<(j|0));do{n=n+ -1|0;o=b+(n<<2)|0;p=c[o>>2]|0}while((j|0)<(p|0));if((m|0)>=(n|0))break;c[l>>2]=p;c[o>>2]=k}a[f+0>>0]=a[h+0>>0]|0;oc(b,m,f);p=d-m|0;a[f+0>>0]=a[g+0>>0]|0;oc(l,p,f);i=e;return}function pc(a,b,e){a=a|0;b=b|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0;f=i;k=e&1;j=d[a+16>>0]|0|k;h=b+4|0;l=((j+(c[h>>2]|0)<<2)+4|0)>>>2;m=a+4|0;gc(a,l+(c[m>>2]|0)|0);e=c[m>>2]|0;l=l+e|0;c[m>>2]=l;if(l>>>0<e>>>0)Ta(va(1)|0,48,0);a=(c[a>>2]|0)+(e<<2)|0;if(!a){i=f;return e|0}j=j<<3|k<<2;c[a>>2]=c[a>>2]&-32|j;j=c[h>>2]<<5|j;c[a>>2]=j;if((c[h>>2]|0)>0){j=c[b>>2]|0;b=0;do{c[a+(b<<2)+4>>2]=c[j+(b<<2)>>2];b=b+1|0}while((b|0)<(c[h>>2]|0));j=c[a>>2]|0}if(!(j&8)){i=f;return e|0}h=j>>>5;if(j&4){g[a+(h<<2)+4>>2]=0.0;i=f;return e|0}if(!h){h=0;j=0}else{j=0;b=0;do{j=1<<((c[a+(b<<2)+4>>2]|0)>>>1&31)|j;b=b+1|0}while((b|0)<(h|0))}c[a+(h<<2)+4>>2]=j;i=f;return e|0}function qc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0;d=i;e=a+4|0;f=c[e>>2]|0;g=a+8|0;h=c[g>>2]|0;if((f|0)==(h|0)&(h|0)<(f+1|0)){h=(f>>1)+2&-2;h=(h|0)<2?2:h;if((h|0)>(2147483647-f|0)){h=va(1)|0;Ta(h|0,48,0)}j=c[a>>2]|0;f=h+f|0;c[g>>2]=f;f=Ud(j,f<<3)|0;c[a>>2]=f;if((f|0)==0?(c[(Oa()|0)>>2]|0)==12:0){j=va(1)|0;Ta(j|0,48,0)}}else f=c[a>>2]|0;j=c[e>>2]|0;c[e>>2]=j+1;e=f+(j<<3)|0;if(!e){i=d;return}g=b;h=c[g+4>>2]|0;j=e;c[j>>2]=c[g>>2];c[j+4>>2]=h;i=d;return}function rc(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0.0,r=0.0,s=0;b=i;d=c[a>>2]|0;f=c[d>>2]|0;k=a+4|0;o=c[d+((c[k>>2]|0)+ -1<<2)>>2]|0;c[d>>2]=o;e=c[a+12>>2]|0;c[e+(o<<2)>>2]=0;c[e+(f<<2)>>2]=-1;o=(c[k>>2]|0)+ -1|0;c[k>>2]=o;if((o|0)<=1){i=b;return f|0}g=c[d>>2]|0;l=a+28|0;a=0;m=1;while(1){n=(a<<1)+2|0;if((n|0)<(o|0)){p=c[d+(n<<2)>>2]|0;s=c[d+(m<<2)>>2]|0;o=c[c[l>>2]>>2]|0;q=+h[o+(p<<3)>>3];r=+h[o+(s<<3)>>3];if(!(q>r)){p=s;q=r;j=6}}else{o=c[c[l>>2]>>2]|0;j=c[d+(m<<2)>>2]|0;p=j;q=+h[o+(j<<3)>>3];j=6}if((j|0)==6){j=0;n=m}if(!(q>+h[o+(g<<3)>>3]))break;c[d+(a<<2)>>2]=p;c[e+(p<<2)>>2]=a;m=n<<1|1;o=c[k>>2]|0;if((m|0)>=(o|0)){a=n;break}else a=n}c[d+(a<<2)>>2]=g;c[e+(g<<2)>>2]=a;i=b;return f|0}function sc(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0;f=i;k=c[d>>2]|0;d=k+1|0;g=b+4|0;if((c[g>>2]|0)>=(d|0)){i=f;return}j=b+8|0;h=c[j>>2]|0;if((h|0)<(d|0)){l=k+2-h&-2;k=(h>>1)+2&-2;k=(l|0)>(k|0)?l:k;if((k|0)>(2147483647-h|0)){l=va(1)|0;Ta(l|0,48,0)}m=c[b>>2]|0;l=k+h|0;c[j>>2]=l;l=Ud(m,l)|0;c[b>>2]=l;if((l|0)==0?(c[(Oa()|0)>>2]|0)==12:0){m=va(1)|0;Ta(m|0,48,0)}}h=c[g>>2]|0;if((h|0)<(d|0))do{a[(c[b>>2]|0)+h>>0]=e;h=h+1|0}while((h|0)!=(d|0));c[g>>2]=d;i=f;return}function tc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;e=i;i=i+16|0;h=e+8|0;f=e+4|0;j=e;if((b|0)<16){f=b+ -1|0;if((f|0)<=0){i=e;return}h=c[d>>2]|0;d=0;do{j=d;d=d+1|0;if((d|0)<(b|0)){k=c[h>>2]|0;m=j;l=d;do{n=k+(c[a+(l<<2)>>2]<<2)|0;u=c[n>>2]|0;q=u>>>5;if(u>>>0>95){o=k+(c[a+(m<<2)>>2]<<2)|0;p=(c[o>>2]|0)>>>5;if((p|0)==2)m=l;else m=+g[n+(q<<2)+4>>2]<+g[o+(p<<2)+4>>2]?l:m}l=l+1|0}while((l|0)!=(b|0))}else m=j;s=a+(j<<2)|0;t=c[s>>2]|0;u=a+(m<<2)|0;c[s>>2]=c[u>>2];c[u>>2]=t}while((d|0)!=(f|0));i=e;return}k=c[a+(((b|0)/2|0)<<2)>>2]|0;q=-1;o=b;while(1){t=q+1|0;p=a+(t<<2)|0;u=c[p>>2]|0;l=c[d>>2]|0;m=c[l>>2]|0;s=m+(u<<2)|0;r=c[s>>2]|0;q=m+(k<<2)|0;n=c[q>>2]|0;a:do if(r>>>0>95)while(1){v=n>>>5;if((v|0)!=2?!(+g[s+(r>>>5<<2)+4>>2]<+g[q+(v<<2)+4>>2]):0){q=t;break a}t=t+1|0;p=a+(t<<2)|0;u=c[p>>2]|0;s=m+(u<<2)|0;r=c[s>>2]|0;if(r>>>0<=95){q=t;break}}else q=t;while(0);o=o+ -1|0;s=a+(o<<2)|0;r=m+(k<<2)|0;b:do if(n>>>0>95)while(1){t=m+(c[s>>2]<<2)|0;v=(c[t>>2]|0)>>>5;if((v|0)!=2?!(+g[r+(n>>>5<<2)+4>>2]<+g[t+(v<<2)+4>>2]):0)break b;v=o+ -1|0;s=a+(v<<2)|0;o=v}while(0);if((q|0)>=(o|0))break;c[p>>2]=c[s>>2];c[s>>2]=u}c[f>>2]=l;c[h+0>>2]=c[f+0>>2];tc(a,q,h);v=b-q|0;c[j>>2]=l;c[h+0>>2]=c[j+0>>2];tc(p,v,h);i=e;return}function uc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0.0,r=0.0,s=0;e=i;f=a+4|0;j=c[f>>2]|0;g=c[a>>2]|0;if((j|0)>0){l=c[a+12>>2]|0;k=0;do{c[l+(c[g+(k<<2)>>2]<<2)>>2]=-1;k=k+1|0;j=c[f>>2]|0}while((k|0)<(j|0))}if(g){c[f>>2]=0;j=0}g=b+4|0;if((c[g>>2]|0)>0){k=a+12|0;j=0;do{s=(c[b>>2]|0)+(j<<2)|0;c[(c[k>>2]|0)+(c[s>>2]<<2)>>2]=j;nc(a,s);j=j+1|0}while((j|0)<(c[g>>2]|0));j=c[f>>2]|0}if((j|0)<=1){i=e;return}g=c[a>>2]|0;b=a+28|0;a=a+12|0;o=j;k=(j|0)/2|0;while(1){k=k+ -1|0;j=c[g+(k<<2)>>2]|0;m=k<<1|1;a:do if((m|0)<(o|0)){l=k;while(1){n=(l<<1)+2|0;if((n|0)<(o|0)){p=c[g+(n<<2)>>2]|0;s=c[g+(m<<2)>>2]|0;o=c[c[b>>2]>>2]|0;q=+h[o+(p<<3)>>3];r=+h[o+(s<<3)>>3];if(!(q>r)){p=s;q=r;d=16}}else{o=c[c[b>>2]>>2]|0;d=c[g+(m<<2)>>2]|0;p=d;q=+h[o+(d<<3)>>3];d=16}if((d|0)==16){d=0;n=m}if(!(q>+h[o+(j<<3)>>3]))break a;c[g+(l<<2)>>2]=p;c[(c[a>>2]|0)+(p<<2)>>2]=l;m=n<<1|1;o=c[f>>2]|0;if((m|0)>=(o|0)){l=n;break}else l=n}}else l=k;while(0);c[g+(l<<2)>>2]=j;c[(c[a>>2]|0)+(j<<2)>>2]=l;if((k|0)<=0)break;o=c[f>>2]|0}i=e;return}function vc(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;e=i;d=b+36|0;l=c[d>>2]|0;f=b+32|0;n=c[f>>2]|0;if((l|0)>0){h=b+16|0;g=b+44|0;j=0;do{k=n+(j<<2)|0;m=c[k>>2]|0;if(a[(c[h>>2]|0)+m>>0]|0){n=c[b>>2]|0;l=n+(m*12|0)+4|0;p=c[l>>2]|0;if((p|0)>0){m=n+(m*12|0)|0;n=0;o=0;do{q=c[m>>2]|0;r=q+(n<<3)|0;if((c[(c[c[g>>2]>>2]|0)+(c[r>>2]<<2)>>2]&3|0)!=1){s=r;r=c[s+4>>2]|0;p=q+(o<<3)|0;c[p>>2]=c[s>>2];c[p+4>>2]=r;p=c[l>>2]|0;o=o+1|0}n=n+1|0}while((n|0)<(p|0))}else{n=0;o=0}m=n-o|0;if((m|0)>0)c[l>>2]=p-m;a[(c[h>>2]|0)+(c[k>>2]|0)>>0]=0;l=c[d>>2]|0;n=c[f>>2]|0}j=j+1|0}while((j|0)<(l|0))}if(!n){i=e;return}c[d>>2]=0;i=e;return}function wc(a,b){a=a|0;b=b|0;var e=0,f=0,h=0,j=0,k=0;f=i;j=c[b>>2]|0;h=j>>>2&1|(d[a+16>>0]|0);j=((h+(j>>>5)<<2)+4|0)>>>2;k=a+4|0;gc(a,j+(c[k>>2]|0)|0);e=c[k>>2]|0;j=j+e|0;c[k>>2]=j;if(j>>>0<e>>>0)Ta(va(1)|0,48,0);a=(c[a>>2]|0)+(e<<2)|0;if(!a){i=f;return e|0}h=c[b>>2]&-9|h<<3;c[a>>2]=h;if((c[b>>2]|0)>>>0>31){h=0;do{c[a+(h<<2)+4>>2]=c[b+(h<<2)+4>>2];h=h+1|0}while((h|0)<((c[b>>2]|0)>>>5|0));h=c[a>>2]|0}if(!(h&8)){i=f;return e|0}j=h>>>5;b=b+(j<<2)+4|0;if(!(h&4)){c[a+(j<<2)+4>>2]=c[b>>2];i=f;return e|0}else{g[a+(j<<2)+4>>2]=+g[b>>2];i=f;return e|0}return 0}function xc(b){b=b|0;var d=0,e=0,f=0,g=0,j=0,k=0;d=i;i=i+16|0;g=d;Gb(b);c[b>>2]=3424;c[b+684>>2]=c[719];c[b+688>>2]=c[747];c[b+692>>2]=c[785];h[b+696>>3]=+h[411];a[b+704>>0]=a[2652]|0;a[b+705>>0]=a[2724]|0;a[b+706>>0]=a[2804]|0;a[b+707>>0]=1;c[b+708>>2]=0;c[b+712>>2]=0;c[b+716>>2]=0;c[b+720>>2]=1;a[b+724>>0]=1;e=b+732|0;k=b+544|0;c[b+760>>2]=0;c[b+764>>2]=0;c[b+768>>2]=0;c[b+776>>2]=0;c[b+780>>2]=0;c[b+784>>2]=0;c[b+792>>2]=0;c[b+796>>2]=0;c[b+800>>2]=0;j=b+804|0;c[e+0>>2]=0;c[e+4>>2]=0;c[e+8>>2]=0;c[e+12>>2]=0;c[e+16>>2]=0;c[e+20>>2]=0;c[j>>2]=k;j=b+808|0;c[j>>2]=0;c[b+812>>2]=0;c[b+816>>2]=0;e=b+824|0;c[e+0>>2]=0;c[e+4>>2]=0;c[e+8>>2]=0;c[e+12>>2]=0;c[e+16>>2]=0;c[e+20>>2]=0;c[b+852>>2]=j;Qc(b+856|0,1);j=b+868|0;e=b+892|0;c[b+920>>2]=0;c[b+924>>2]=0;c[j+0>>2]=0;c[j+4>>2]=0;c[j+8>>2]=0;c[j+12>>2]=0;c[j+16>>2]=0;c[e+0>>2]=0;c[e+4>>2]=0;c[e+8>>2]=0;c[e+12>>2]=0;c[e+16>>2]=0;c[e+20>>2]=0;e=g+4|0;c[e>>2]=0;j=g+8|0;c[j>>2]=2;f=Ud(0,8)|0;c[g>>2]=f;if((f|0)==0?(c[(Oa()|0)>>2]|0)==12:0)Ta(va(1)|0,48,0);c[f>>2]=-2;c[e>>2]=1;a[b+560>>0]=1;c[b+928>>2]=pc(k,g,0)|0;a[b+536>>0]=0;if(!f){i=d;return}c[e>>2]=0;Td(f);c[g>>2]=0;c[j>>2]=0;i=d;return}function yc(a){a=a|0;var b=0;b=i;zc(a);pd(a);i=b;return}function zc(a){a=a|0;var b=0,d=0,e=0;b=i;c[a>>2]=3424;d=a+904|0;e=c[d>>2]|0;if(e){c[a+908>>2]=0;Td(e);c[d>>2]=0;c[a+912>>2]=0}d=a+892|0;e=c[d>>2]|0;if(e){c[a+896>>2]=0;Td(e);c[d>>2]=0;c[a+900>>2]=0}d=a+876|0;e=c[d>>2]|0;if(e){c[a+880>>2]=0;Td(e);c[d>>2]=0;c[a+884>>2]=0}d=a+856|0;e=c[d>>2]|0;if(e){c[a+860>>2]=0;Td(e);c[d>>2]=0;c[a+864>>2]=0}e=a+836|0;d=c[e>>2]|0;if(d){c[a+840>>2]=0;Td(d);c[e>>2]=0;c[a+844>>2]=0}d=a+824|0;e=c[d>>2]|0;if(e){c[a+828>>2]=0;Td(e);c[d>>2]=0;c[a+832>>2]=0}d=a+808|0;e=c[d>>2]|0;if(e){c[a+812>>2]=0;Td(e);c[d>>2]=0;c[a+816>>2]=0}Rc(a+760|0);d=a+744|0;e=c[d>>2]|0;if(e){c[a+748>>2]=0;Td(e);c[d>>2]=0;c[a+752>>2]=0}d=a+732|0;e=c[d>>2]|0;if(!e){Ib(a);i=b;return}c[a+736>>2]=0;Td(e);c[d>>2]=0;c[a+740>>2]=0;Ib(a);i=b;return}function Ac(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0;f=i;i=i+32|0;h=f+12|0;k=f+8|0;l=f+16|0;g=f+4|0;j=f;a[l>>0]=a[d>>0]|0;a[h+0>>0]=a[l+0>>0]|0;e=Jb(b,h,e)|0;c[k>>2]=e;kc(b+876|0,e,0);kc(b+904|0,e,0);if(!(a[b+724>>0]|0)){i=f;return e|0}l=b+808|0;d=e<<1;c[g>>2]=d;c[h+0>>2]=c[g+0>>2];Sc(l,h,0);c[j>>2]=d|1;c[h+0>>2]=c[j+0>>2];Sc(l,h,0);Tc(b+760|0,k);kc(b+744|0,e,0);Uc(b+824|0,e);i=f;return e|0}function Bc(b,e,f,g){b=b|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;k=i;i=i+32|0;h=k+4|0;r=k;p=k+16|0;c[h>>2]=0;j=h+4|0;c[j>>2]=0;l=h+8|0;c[l>>2]=0;s=a[2608]|0;a[b>>0]=s;m=e+724|0;f=(d[m>>0]&(f&1)|0)!=0;if(f){u=e+308|0;x=c[u>>2]|0;if((x|0)>0){t=e+304|0;s=e+876|0;v=0;do{w=c[(c[t>>2]|0)+(v<<2)>>2]>>1;c[r>>2]=w;w=(c[s>>2]|0)+w|0;if(!(a[w>>0]|0)){a[w>>0]=1;nc(h,r);x=c[u>>2]|0}v=v+1|0}while((v|0)<(x|0))}r=(Cc(e,g)|0)&1^1;a[b>>0]=r;g=a[2608]|0}else{g=s;r=s}x=g&255;if(!((x>>>1^1)&r<<24>>24==g<<24>>24|x&2&(r&255))){if((c[e+44>>2]|0)>0)Ka(3760)|0}else{$b(p,e);r=a[p>>0]|0;a[b>>0]=r}w=a[2608]|0;x=w&255;if((((x>>>1^1)&r<<24>>24==w<<24>>24|x&2&(r&255)|0)!=0?(a[e+707>>0]|0)!=0:0)?(q=(c[e+736>>2]|0)+ -1|0,(q|0)>0):0){b=e+732|0;p=e+4|0;do{g=c[b>>2]|0;u=c[g+(q<<2)>>2]|0;v=q+ -1|0;w=c[g+(v<<2)>>2]|0;q=c[p>>2]|0;a:do if((u|0)>1){s=a[2616]|0;r=s&255;t=r&2;r=r>>>1^1;x=v;while(1){w=d[q+(w>>1)>>0]^w&1;v=u+ -1|0;if(!((w&255)<<24>>24==s<<24>>24&r|t&w))break a;u=x+ -1|0;w=c[g+(u<<2)>>2]|0;if((v|0)>1){x=u;u=v}else{x=u;u=v;o=20;break}}}else{x=v;o=20}while(0);if((o|0)==20){o=0;a[q+(w>>1)>>0]=(w&1^1)&255^1}q=x-u|0}while((q|0)>0)}if(f?(n=c[j>>2]|0,(n|0)>0):0){o=c[h>>2]|0;f=e+876|0;p=0;do{b=c[o+(p<<2)>>2]|0;a[(c[f>>2]|0)+b>>0]=0;if(a[m>>0]|0)Vc(e,b);p=p+1|0}while((p|0)<(n|0))}e=c[h>>2]|0;if(!e){i=k;return}c[j>>2]=0;Td(e);c[h>>2]=0;c[l>>2]=0;i=k;return}function Cc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0;m=i;i=i+16|0;j=m;if(!(Zb(b)|0)){H=0;i=m;return H|0}l=b+724|0;if(!(a[l>>0]|0)){H=1;i=m;return H|0}x=b+924|0;v=b+872|0;w=b+868|0;u=b+860|0;r=b+680|0;y=b+824|0;g=b+828|0;o=b+836|0;z=b+904|0;A=b+332|0;e=b+44|0;B=b+704|0;D=b+706|0;E=b+696|0;p=b+556|0;q=b+548|0;C=b+876|0;s=b+920|0;t=b+284|0;a:while(1){if(((c[x>>2]|0)<=0?(c[s>>2]|0)>=(c[t>>2]|0):0)?(c[g>>2]|0)<=0:0)break;Ic(b);G=c[v>>2]|0;H=c[w>>2]|0;F=G-H|0;if((G|0)<(H|0))F=(c[u>>2]|0)+F|0;if(!((F|0)<=0?(c[s>>2]|0)>=(c[t>>2]|0):0))n=11;if((n|0)==11?(n=0,!(Jc(b,1)|0)):0){n=12;break}H=c[g>>2]|0;if(a[r>>0]|0){n=15;break}if(!H)continue;else F=0;while(1){J=c[y>>2]|0;G=c[J>>2]|0;I=c[J+(H+ -1<<2)>>2]|0;c[J>>2]=I;H=c[o>>2]|0;c[H+(I<<2)>>2]=0;c[H+(G<<2)>>2]=-1;H=(c[g>>2]|0)+ -1|0;c[g>>2]=H;if((H|0)>1)Wc(y,0);if(a[r>>0]|0)continue a;if((a[(c[z>>2]|0)+G>>0]|0)==0?(I=a[(c[A>>2]|0)+G>>0]|0,H=a[2624]|0,J=H&255,((J>>>1^1)&I<<24>>24==H<<24>>24|I&2&J|0)!=0):0){if((c[e>>2]|0)>1&((F|0)%100|0|0)==0){c[j>>2]=c[g>>2];La(3504,j|0)|0}if(a[B>>0]|0){J=(c[C>>2]|0)+G|0;H=a[J>>0]|0;a[J>>0]=1;if(!(Lc(b,G)|0)){n=29;break a}a[(c[C>>2]|0)+G>>0]=H<<24>>24!=0&1}if((((a[D>>0]|0)!=0?(I=a[(c[A>>2]|0)+G>>0]|0,H=a[2624]|0,J=H&255,((J>>>1^1)&I<<24>>24==H<<24>>24|I&2&J|0)!=0):0)?(a[(c[C>>2]|0)+G>>0]|0)==0:0)?!(Mc(b,G)|0):0){n=35;break a}if(+((c[p>>2]|0)>>>0)>+h[E>>3]*+((c[q>>2]|0)>>>0))gb[c[(c[b>>2]|0)+8>>2]&31](b)}H=c[g>>2]|0;if(!H)continue a;else F=F+1|0}}do if((n|0)==12)a[b+492>>0]=0;else if((n|0)==15){r=c[b+824>>2]|0;if((H|0)<=0){if(!r)break}else{t=c[o>>2]|0;s=0;do{c[t+(c[r+(s<<2)>>2]<<2)>>2]=-1;s=s+1|0}while((s|0)<(c[g>>2]|0))}c[g>>2]=0}else if((n|0)==29)a[b+492>>0]=0;else if((n|0)==35)a[b+492>>0]=0;while(0);if(!d){if(+((c[p>>2]|0)>>>0)>+h[b+96>>3]*+((c[q>>2]|0)>>>0))gb[c[(c[b>>2]|0)+8>>2]&31](b)}else{d=b+744|0;p=c[d>>2]|0;if(p){c[b+748>>2]=0;Td(p);c[d>>2]=0;c[b+752>>2]=0}Xc(b+760|0,1);d=b+808|0;p=c[d>>2]|0;if(p){c[b+812>>2]=0;Td(p);c[d>>2]=0;c[b+816>>2]=0}p=b+824|0;d=c[p>>2]|0;if((c[g>>2]|0)<=0){if(d)n=48}else{n=c[o>>2]|0;o=0;do{c[n+(c[d+(o<<2)>>2]<<2)>>2]=-1;o=o+1|0}while((o|0)<(c[g>>2]|0));n=48}if((n|0)==48){c[g>>2]=0;Td(d);c[p>>2]=0;c[b+832>>2]=0}Yc(b+856|0,1);a[l>>0]=0;a[b+536>>0]=1;a[b+560>>0]=0;c[b+728>>2]=c[b+540>>2];Yb(b);gb[c[(c[b>>2]|0)+8>>2]&31](b)}if((c[e>>2]|0)>0?(f=c[b+736>>2]|0,(f|0)>0):0){h[k>>3]=+(f<<2>>>0)*9.5367431640625e-7;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];La(3528,j|0)|0}J=(a[b+492>>0]|0)!=0;i=m;return J|0}function Dc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;e=i;i=i+16|0;g=e;j=b+256|0;k=b+260|0;h=c[k>>2]|0;if((a[b+705>>0]|0)!=0?Ec(b,d)|0:0){p=1;i=e;return p|0}if(!(Kb(b,d)|0)){p=0;i=e;return p|0}if(!(a[b+724>>0]|0)){p=1;i=e;return p|0}d=c[k>>2]|0;if((d|0)!=(h+1|0)){p=1;i=e;return p|0}p=c[(c[j>>2]|0)+(d+ -1<<2)>>2]|0;c[g>>2]=p;m=(c[b+544>>2]|0)+(p<<2)|0;Zc(b+856|0,p);if((c[m>>2]|0)>>>0<=31){p=1;i=e;return p|0}l=b+760|0;k=b+808|0;j=b+744|0;h=b+924|0;d=b+824|0;n=b+840|0;b=b+836|0;o=0;do{p=m+(o<<2)+4|0;_c((c[l>>2]|0)+((c[p>>2]>>1)*12|0)|0,g);q=(c[k>>2]|0)+(c[p>>2]<<2)|0;c[q>>2]=(c[q>>2]|0)+1;a[(c[j>>2]|0)+(c[p>>2]>>1)>>0]=1;c[h>>2]=(c[h>>2]|0)+1;p=c[p>>2]>>1;if((c[n>>2]|0)>(p|0)?(f=c[(c[b>>2]|0)+(p<<2)>>2]|0,(f|0)>-1):0)Wc(d,f);o=o+1|0}while((o|0)<((c[m>>2]|0)>>>5|0));f=1;i=e;return f|0}function Ec(b,e){b=b|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;k=i;i=i+16|0;h=k+8|0;j=k+4|0;g=k;c[j>>2]=c[b+284>>2];nc(b+292|0,j);j=e+4|0;m=c[j>>2]|0;a:do if((m|0)>0){f=b+332|0;l=0;while(1){n=c[(c[e>>2]|0)+(l<<2)>>2]|0;p=d[(c[f>>2]|0)+(n>>1)>>0]|0;q=p^n&1;o=q&255;s=a[2608]|0;r=s&255;if(o<<24>>24==s<<24>>24&(r>>>1^1)|r&2&q)break;r=a[2616]|0;s=r&255;if(!((s>>>1^1)&o<<24>>24==r<<24>>24|p&2&s)){c[g>>2]=n^1;c[h+0>>2]=c[g+0>>2];Lb(b,h,-1);m=c[j>>2]|0}l=l+1|0;if((l|0)>=(m|0))break a}Rb(b,0);s=1;i=k;return s|0}while(0);s=(Mb(b)|0)!=-1;Rb(b,0);i=k;return s|0}function Fc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0;e=i;i=i+16|0;g=e;f=(c[b+544>>2]|0)+(d<<2)|0;if(!(a[b+724>>0]|0)){Pb(b,d);i=e;return}if((c[f>>2]|0)>>>0<=31){Pb(b,d);i=e;return}j=b+808|0;k=b+776|0;h=b+792|0;l=0;do{m=f+(l<<2)+4|0;n=(c[j>>2]|0)+(c[m>>2]<<2)|0;c[n>>2]=(c[n>>2]|0)+ -1;Vc(b,c[m>>2]>>1);m=c[m>>2]>>1;c[g>>2]=m;m=(c[k>>2]|0)+m|0;if(!(a[m>>0]|0)){a[m>>0]=1;nc(h,g)}l=l+1|0}while((l|0)<((c[f>>2]|0)>>>5|0));Pb(b,d);i=e;return}function Gc(b,e,f){b=b|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;g=i;i=i+16|0;j=g+4|0;h=g;l=c[b+544>>2]|0;k=l+(e<<2)|0;Zc(b+856|0,e);if((c[k>>2]&-32|0)==64){Fc(b,e);p=c[f>>2]|0;f=c[k>>2]|0;a:do if(f>>>0>31){m=f>>>5;n=0;while(1){o=n+1|0;if((c[k+(n<<2)+4>>2]|0)==(p|0)){o=n;break a}if((o|0)<(m|0))n=o;else break}}else{m=0;o=0}while(0);n=m+ -1|0;if((o|0)<(n|0))do{f=o;o=o+1|0;c[k+(f<<2)+4>>2]=c[k+(o<<2)+4>>2];f=c[k>>2]|0;m=f>>>5;n=m+ -1|0}while((o|0)<(n|0));if(f&8){c[k+(n<<2)+4>>2]=c[k+(m<<2)+4>>2];f=c[k>>2]|0}m=f+ -32|0;c[k>>2]=m;m=m>>>5;if(!m){m=0;f=0}else{f=0;n=0;do{f=1<<((c[k+(n<<2)+4>>2]|0)>>>1&31)|f;n=n+1|0}while((n|0)<(m|0))}c[k+(m<<2)+4>>2]=f}else{Ob(b,e,1);f=c[f>>2]|0;n=c[k>>2]|0;b:do if(n>>>0>31){m=n>>>5;o=0;while(1){p=o+1|0;if((c[k+(o<<2)+4>>2]|0)==(f|0)){p=o;break b}if((p|0)<(m|0))o=p;else break}}else{m=0;p=0}while(0);o=m+ -1|0;if((p|0)<(o|0))do{n=p;p=p+1|0;c[k+(n<<2)+4>>2]=c[k+(p<<2)+4>>2];n=c[k>>2]|0;m=n>>>5;o=m+ -1|0}while((p|0)<(o|0));if(n&8){c[k+(o<<2)+4>>2]=c[k+(m<<2)+4>>2];n=c[k>>2]|0}o=n+ -32|0;c[k>>2]=o;o=o>>>5;if(!o){o=0;m=0}else{m=0;n=0;do{m=1<<((c[k+(n<<2)+4>>2]|0)>>>1&31)|m;n=n+1|0}while((n|0)<(o|0))}c[k+(o<<2)+4>>2]=m;Nb(b,e);m=f>>1;n=c[b+760>>2]|0;o=n+(m*12|0)|0;n=n+(m*12|0)+4|0;p=c[n>>2]|0;c:do if((p|0)>0){s=c[o>>2]|0;q=0;while(1){r=q+1|0;if((c[s+(q<<2)>>2]|0)==(e|0))break c;if((r|0)<(p|0))q=r;else{q=r;break}}}else q=0;while(0);p=p+ -1|0;if((q|0)<(p|0)){o=c[o>>2]|0;do{p=q;q=q+1|0;c[o+(p<<2)>>2]=c[o+(q<<2)>>2];p=(c[n>>2]|0)+ -1|0}while((q|0)<(p|0))}c[n>>2]=p;s=(c[b+808>>2]|0)+(f<<2)|0;c[s>>2]=(c[s>>2]|0)+ -1;Vc(b,m)}if((c[k>>2]&-32|0)!=32){s=1;i=g;return s|0}l=c[l+(e+1<<2)>>2]|0;k=d[(c[b+332>>2]|0)+(l>>1)>>0]|0;s=k^l&1;e=s&255;q=a[2624]|0;r=q&255;if(!(e<<24>>24==q<<24>>24&(r>>>1^1)|r&2&s)){r=a[2616]|0;s=r&255;if((s>>>1^1)&e<<24>>24==r<<24>>24|k&2&s){s=0;i=g;return s|0}}else{c[h>>2]=l;c[j+0>>2]=c[h+0>>2];Lb(b,j,-1)}s=(Mb(b)|0)==-1;i=g;return s|0}function Hc(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;g=i;i=i+16|0;j=g+4|0;h=g;o=a+708|0;c[o>>2]=(c[o>>2]|0)+1;if(c[f>>2]|0)c[f+4>>2]=0;k=(c[b>>2]|0)>>>5>>>0<(c[d>>2]|0)>>>5>>>0;a=k?d:b;b=k?b:d;k=c[b>>2]|0;a:do if(k>>>0>31){d=0;b:while(1){l=c[b+(d<<2)+4>>2]|0;c:do if((l>>1|0)!=(e|0)){m=c[a>>2]|0;d:do if(m>>>0>31){n=0;while(1){o=c[a+(n<<2)+4>>2]|0;n=n+1|0;if((l^o)>>>0<2)break;if((n|0)>=(m>>>5|0))break d}if((o|0)==(l^1|0)){f=0;break b}else break c}while(0);c[j>>2]=l;mc(f,j);k=c[b>>2]|0}while(0);d=d+1|0;if((d|0)>=(k>>>5|0))break a}i=g;return f|0}while(0);d=c[a>>2]|0;if(d>>>0<=31){o=1;i=g;return o|0}j=0;do{b=c[a+(j<<2)+4>>2]|0;if((b>>1|0)!=(e|0)){c[h>>2]=b;mc(f,h);d=c[a>>2]|0}j=j+1|0}while((j|0)<(d>>>5|0));f=1;i=g;return f|0}function Ic(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;d=i;k=b+924|0;if(!(c[k>>2]|0)){i=d;return}h=b+856|0;e=b+872|0;f=b+868|0;j=b+860|0;g=b+544|0;l=0;while(1){w=c[e>>2]|0;m=c[f>>2]|0;n=w-m|0;if((w|0)<(m|0))n=(c[j>>2]|0)+n|0;if((l|0)>=(n|0))break;n=(c[g>>2]|0)+(c[(c[h>>2]|0)+(((m+l|0)%(c[j>>2]|0)|0)<<2)>>2]<<2)|0;m=c[n>>2]|0;if(!(m&3))c[n>>2]=m&-4|2;l=l+1|0}l=b+540|0;q=c[l>>2]|0;if((q|0)>0){n=b+744|0;o=b+776|0;m=b+760|0;b=b+804|0;p=0;do{if(a[(c[n>>2]|0)+p>>0]|0){r=(c[o>>2]|0)+p|0;if(a[r>>0]|0){s=c[m>>2]|0;q=s+(p*12|0)+4|0;u=c[q>>2]|0;if((u|0)>0){s=c[s+(p*12|0)>>2]|0;v=0;t=0;do{w=c[s+(v<<2)>>2]|0;if((c[(c[c[b>>2]>>2]|0)+(w<<2)>>2]&3|0)!=1){c[s+(t<<2)>>2]=w;u=c[q>>2]|0;t=t+1|0}v=v+1|0}while((v|0)<(u|0))}else{v=0;t=0}s=v-t|0;if((s|0)>0)c[q>>2]=u-s;a[r>>0]=0}r=c[m>>2]|0;q=r+(p*12|0)+4|0;t=c[q>>2]|0;if((t|0)>0){r=r+(p*12|0)|0;s=0;do{u=c[(c[r>>2]|0)+(s<<2)>>2]|0;if(!(c[(c[g>>2]|0)+(u<<2)>>2]&3)){Zc(h,u);t=(c[g>>2]|0)+(c[(c[r>>2]|0)+(s<<2)>>2]<<2)|0;c[t>>2]=c[t>>2]&-4|2;t=c[q>>2]|0}s=s+1|0}while((s|0)<(t|0))}a[(c[n>>2]|0)+p>>0]=0;q=c[l>>2]|0}p=p+1|0}while((p|0)<(q|0));l=0}else l=0;while(1){w=c[e>>2]|0;m=c[f>>2]|0;n=w-m|0;if((w|0)<(m|0))n=(c[j>>2]|0)+n|0;if((l|0)>=(n|0))break;m=(c[g>>2]|0)+(c[(c[h>>2]|0)+(((m+l|0)%(c[j>>2]|0)|0)<<2)>>2]<<2)|0;n=c[m>>2]|0;if((n&3|0)==2)c[m>>2]=n&-4;l=l+1|0}c[k>>2]=0;i=d;return}function Jc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0;e=i;i=i+16|0;m=e;x=e+12|0;g=b+856|0;l=b+872|0;q=b+868|0;j=b+860|0;u=b+680|0;f=b+920|0;h=b+284|0;t=b+280|0;r=b+544|0;s=b+928|0;o=b+44|0;n=b+776|0;v=b+692|0;p=b+804|0;k=b+760|0;C=0;F=0;D=0;a:while(1){E=c[q>>2]|0;do{A=c[l>>2]|0;B=(A|0)<(E|0);A=A-E|0;if(B)G=(c[j>>2]|0)+A|0;else G=A;if((G|0)<=0?(c[f>>2]|0)>=(c[h>>2]|0):0){f=1;j=53;break a}if(a[u>>0]|0){j=8;break a}if(B)A=(c[j>>2]|0)+A|0;if((A|0)==0?(z=c[f>>2]|0,(z|0)<(c[h>>2]|0)):0){c[f>>2]=z+1;c[(c[r>>2]|0)+((c[s>>2]|0)+1<<2)>>2]=c[(c[t>>2]|0)+(z<<2)>>2];A=(c[r>>2]|0)+(c[s>>2]<<2)|0;B=(c[A>>2]|0)>>>5;if(!B){B=0;G=0}else{G=0;E=0;do{G=1<<((c[A+(E<<2)+4>>2]|0)>>>1&31)|G;E=E+1|0}while((E|0)<(B|0))}c[A+(B<<2)+4>>2]=G;Zc(g,c[s>>2]|0);E=c[q>>2]|0}A=c[(c[g>>2]|0)+(E<<2)>>2]|0;E=E+1|0;J=c[j>>2]|0;E=(E|0)==(J|0)?0:E;c[q>>2]=E;G=c[r>>2]|0;B=G+(A<<2)|0;I=c[B>>2]|0}while((I&3|0)!=0);if(d?(c[o>>2]|0)>1:0){H=C+1|0;if(!((C|0)%1e3|0)){I=c[l>>2]|0;c[m>>2]=I-E+((I|0)<(E|0)?J:0);c[m+4>>2]=D;c[m+8>>2]=F;La(3440,m|0)|0;I=c[B>>2]|0;C=H}else C=H}E=G+(A+1<<2)|0;G=c[E>>2]>>1;if(I>>>0>63){H=c[k>>2]|0;I=I>>>5;J=1;do{P=c[B+(J<<2)+4>>2]>>1;G=(c[H+(P*12|0)+4>>2]|0)<(c[H+(G*12|0)+4>>2]|0)?P:G;J=J+1|0}while((J|0)<(I|0))}I=(c[n>>2]|0)+G|0;if(a[I>>0]|0){J=c[k>>2]|0;H=J+(G*12|0)+4|0;M=c[H>>2]|0;if((M|0)>0){J=c[J+(G*12|0)>>2]|0;L=0;K=0;do{N=c[J+(L<<2)>>2]|0;if((c[(c[c[p>>2]>>2]|0)+(N<<2)>>2]&3|0)!=1){c[J+(K<<2)>>2]=N;M=c[H>>2]|0;K=K+1|0}L=L+1|0}while((L|0)<(M|0))}else{L=0;K=0}J=L-K|0;if((J|0)>0)c[H>>2]=M-J;a[I>>0]=0}I=c[k>>2]|0;H=c[I+(G*12|0)>>2]|0;I=I+(G*12|0)+4|0;if((c[I>>2]|0)>0)J=0;else continue;while(1){N=c[B>>2]|0;if(N&3)continue a;K=c[H+(J<<2)>>2]|0;L=c[r>>2]|0;O=L+(K<<2)|0;M=c[O>>2]|0;b:do if(((!((M&3|0)!=0|(K|0)==(A|0))?(P=c[v>>2]|0,y=M>>>5,(P|0)==-1|(y|0)<(P|0)):0)?(w=N>>>5,y>>>0>=w>>>0):0)?(c[B+(w<<2)+4>>2]&~c[O+(y<<2)+4>>2]|0)==0:0){L=L+(K+1<<2)|0;do if(N>>>0>31){if(M>>>0>31){O=-2;M=0}else break b;while(1){N=c[E+(M<<2)>>2]|0;c:do if((O|0)==-2){P=0;while(1){O=c[L+(P<<2)>>2]|0;if((N|0)==(O|0)){N=-2;break c}P=P+1|0;if((N|0)==(O^1|0))break c;if(P>>>0>=y>>>0)break b}}else{P=0;while(1){if((N|0)==(c[L+(P<<2)>>2]|0)){N=O;break c}P=P+1|0;if(P>>>0>=y>>>0)break b}}while(0);M=M+1|0;if(M>>>0>=w>>>0)break;else O=N}if((N|0)==-2)break;else if((N|0)==-1)break b;c[x>>2]=N^1;c[m+0>>2]=c[x+0>>2];if(!(Gc(b,K,m)|0)){f=0;j=53;break a}F=F+1|0;J=(((N>>1|0)==(G|0))<<31>>31)+J|0;break b}while(0);Fc(b,K);D=D+1|0}while(0);J=J+1|0;if((J|0)>=(c[I>>2]|0))continue a}}if((j|0)==8){Yc(g,0);c[f>>2]=c[h>>2];P=1;i=e;return P|0}else if((j|0)==53){i=e;return f|0}return 0}function Kc(b,e,f){b=b|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0;h=i;i=i+16|0;g=h+12|0;m=h+8|0;k=h+4|0;j=h;l=(c[b+544>>2]|0)+(f<<2)|0;if(c[l>>2]&3){r=1;i=h;return r|0}if(Qb(b,l)|0){r=1;i=h;return r|0}c[m>>2]=c[b+284>>2];nc(b+292|0,m);p=c[l>>2]|0;if(p>>>0>31){m=b+332|0;n=0;o=-2;do{q=c[l+(n<<2)+4>>2]|0;r=q>>1;if((r|0)!=(e|0)?(r=(d[(c[m>>2]|0)+r>>0]|0)^q&1,t=a[2616]|0,s=t&255,((r&255)<<24>>24==t<<24>>24&(s>>>1^1)|s&2&r|0)==0):0){c[k>>2]=q^1;c[g+0>>2]=c[k+0>>2];Lb(b,g,-1);p=c[l>>2]|0}else o=q;n=n+1|0}while((n|0)<(p>>>5|0))}else o=-2;t=(Mb(b)|0)==-1;Rb(b,0);if(!t){t=b+712|0;c[t>>2]=(c[t>>2]|0)+1;c[j>>2]=o;c[g+0>>2]=c[j+0>>2];if(!(Gc(b,f,g)|0)){t=0;i=h;return t|0}}t=1;i=h;return t|0}function Lc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;e=i;h=(c[b+776>>2]|0)+d|0;f=b+760|0;if(a[h>>0]|0){k=c[f>>2]|0;g=k+(d*12|0)+4|0;n=c[g>>2]|0;if((n|0)>0){j=b+804|0;k=c[k+(d*12|0)>>2]|0;m=0;l=0;do{o=c[k+(m<<2)>>2]|0;if((c[(c[c[j>>2]>>2]|0)+(o<<2)>>2]&3|0)!=1){c[k+(l<<2)>>2]=o;n=c[g>>2]|0;l=l+1|0}m=m+1|0}while((m|0)<(n|0))}else{m=0;l=0}j=m-l|0;if((j|0)>0)c[g>>2]=n-j;a[h>>0]=0}g=c[f>>2]|0;n=a[(c[b+332>>2]|0)+d>>0]|0;m=a[2624]|0;o=m&255;if(!((o>>>1^1)&n<<24>>24==m<<24>>24|n&2&o)){o=1;i=e;return o|0}f=g+(d*12|0)+4|0;h=c[f>>2]|0;if(!h){o=1;i=e;return o|0}a:do if((h|0)>0){g=g+(d*12|0)|0;h=0;while(1){if(!(Kc(b,d,c[(c[g>>2]|0)+(h<<2)>>2]|0)|0)){b=0;break}h=h+1|0;if((h|0)>=(c[f>>2]|0))break a}i=e;return b|0}while(0);o=Jc(b,0)|0;i=e;return o|0}function Mc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0;e=i;i=i+48|0;s=e+36|0;r=e+32|0;t=e+28|0;u=e+24|0;f=e+12|0;g=e;n=(c[b+776>>2]|0)+d|0;m=b+760|0;if(a[n>>0]|0){q=c[m>>2]|0;o=q+(d*12|0)+4|0;y=c[o>>2]|0;if((y|0)>0){p=b+804|0;q=c[q+(d*12|0)>>2]|0;w=0;v=0;do{z=c[q+(w<<2)>>2]|0;if((c[(c[c[p>>2]>>2]|0)+(z<<2)>>2]&3|0)!=1){c[q+(v<<2)>>2]=z;y=c[o>>2]|0;v=v+1|0}w=w+1|0}while((w|0)<(y|0))}else{w=0;v=0}p=w-v|0;if((p|0)>0)c[o>>2]=y-p;a[n>>0]=0}v=c[m>>2]|0;w=v+(d*12|0)|0;c[f>>2]=0;n=f+4|0;c[n>>2]=0;o=f+8|0;c[o>>2]=0;c[g>>2]=0;q=g+4|0;c[q>>2]=0;p=g+8|0;c[p>>2]=0;v=v+(d*12|0)+4|0;a:do if((c[v>>2]|0)>0){y=b+544|0;B=d<<1;A=0;do{C=(c[w>>2]|0)+(A<<2)|0;E=(c[y>>2]|0)+(c[C>>2]<<2)|0;Z=c[E>>2]|0;z=Z>>>5;b:do if(Z>>>0>31){G=0;while(1){D=G+1|0;if((c[E+(G<<2)+4>>2]|0)==(B|0)){D=G;break b}if((D|0)<(z|0))G=D;else break}}else D=0;while(0);_c((D|0)<(z|0)?f:g,C);A=A+1|0;z=c[v>>2]|0}while((A|0)<(z|0));y=c[n>>2]|0;B=(y|0)>0;if(B){C=c[q>>2]|0;K=(C|0)>0;J=b+544|0;D=c[f>>2]|0;A=c[g>>2]|0;E=b+708|0;I=b+684|0;H=b+688|0;P=0;G=0;while(1){if(K){M=D+(G<<2)|0;L=c[J>>2]|0;N=c[E>>2]|0;O=0;do{S=L+(c[M>>2]<<2)|0;U=L+(c[A+(O<<2)>>2]<<2)|0;N=N+1|0;c[E>>2]=N;Q=(c[S>>2]|0)>>>5>>>0<(c[U>>2]|0)>>>5>>>0;R=Q?U:S;U=Q?S:U;S=R+4|0;Q=U+4|0;R=c[R>>2]|0;T=R>>>5;W=T+ -1|0;U=c[U>>2]|0;c:do if(U>>>0>31){V=0;while(1){Z=c[Q+(V<<2)>>2]|0;d:do if((Z>>1|0)!=(d|0)){e:do if(R>>>0>31){Y=0;while(1){X=c[S+(Y<<2)>>2]|0;Y=Y+1|0;if((X^Z)>>>0<2)break;if((Y|0)>=(T|0))break e}if((X|0)==(Z^1|0))break c;else break d}while(0);W=W+1|0}while(0);V=V+1|0;if((V|0)>=(U>>>5|0)){x=28;break}}}else x=28;while(0);if((x|0)==28){x=0;if((P|0)>=((c[I>>2]|0)+z|0)){b=1;break a}Z=c[H>>2]|0;if((Z|0)!=-1&(W|0)>(Z|0)){b=1;break a}else P=P+1|0}O=O+1|0}while((O|0)<(C|0))}G=G+1|0;if((G|0)>=(y|0)){x=32;break}}}else{B=0;x=32}}else{y=0;B=0;x=32}while(0);f:do if((x|0)==32){a[(c[b+904>>2]|0)+d>>0]=1;z=b+380|0;A=(c[z>>2]|0)+d|0;if(a[A>>0]|0){Z=b+200|0;Y=Z;Y=ne(c[Y>>2]|0,c[Y+4>>2]|0,-1,-1)|0;c[Z>>2]=Y;c[Z+4>>2]=F}a[A>>0]=0;A=b+460|0;if(!((c[b+476>>2]|0)>(d|0)?(c[(c[b+472>>2]|0)+(d<<2)>>2]|0)>-1:0))x=36;if((x|0)==36?(a[(c[z>>2]|0)+d>>0]|0)!=0:0)lc(A,d);x=b+716|0;c[x>>2]=(c[x>>2]|0)+1;x=c[q>>2]|0;if((y|0)>(x|0)){A=b+732|0;if((x|0)>0){u=b+544|0;t=c[g>>2]|0;E=b+736|0;D=0;do{C=(c[u>>2]|0)+(c[t+(D<<2)>>2]<<2)|0;z=c[E>>2]|0;if((c[C>>2]|0)>>>0>31){G=0;H=-1;do{Z=C+(G<<2)+4|0;c[s>>2]=c[Z>>2];_c(A,s);H=(c[Z>>2]>>1|0)==(d|0)?G+z|0:H;G=G+1|0}while((G|0)<((c[C>>2]|0)>>>5|0))}else H=-1;Z=c[A>>2]|0;X=Z+(H<<2)|0;Y=c[X>>2]|0;Z=Z+(z<<2)|0;c[X>>2]=c[Z>>2];c[Z>>2]=Y;c[r>>2]=(c[C>>2]|0)>>>5;_c(A,r);D=D+1|0}while((D|0)<(x|0))}c[s>>2]=d<<1;_c(A,s);c[r>>2]=1;_c(A,r)}else{D=b+732|0;if(B){G=b+544|0;E=c[f>>2]|0;z=b+736|0;H=0;do{C=(c[G>>2]|0)+(c[E+(H<<2)>>2]<<2)|0;A=c[z>>2]|0;if((c[C>>2]|0)>>>0>31){I=0;J=-1;do{Z=C+(I<<2)+4|0;c[s>>2]=c[Z>>2];_c(D,s);J=(c[Z>>2]>>1|0)==(d|0)?I+A|0:J;I=I+1|0}while((I|0)<((c[C>>2]|0)>>>5|0))}else J=-1;Z=c[D>>2]|0;X=Z+(J<<2)|0;Y=c[X>>2]|0;Z=Z+(A<<2)|0;c[X>>2]=c[Z>>2];c[Z>>2]=Y;c[r>>2]=(c[C>>2]|0)>>>5;_c(D,r);H=H+1|0}while((H|0)<(y|0))}c[t>>2]=d<<1|1;_c(D,t);c[u>>2]=1;_c(D,u)}if((c[v>>2]|0)>0){r=0;do{Fc(b,c[(c[w>>2]|0)+(r<<2)>>2]|0);r=r+1|0}while((r|0)<(c[v>>2]|0))}r=b+628|0;g:do if(B){s=b+544|0;w=c[f>>2]|0;A=c[g>>2]|0;if((x|0)>0)v=0;else{r=0;while(1){r=r+1|0;if((r|0)>=(y|0))break g}}do{u=w+(v<<2)|0;t=0;do{Z=c[s>>2]|0;if(Hc(b,Z+(c[u>>2]<<2)|0,Z+(c[A+(t<<2)>>2]<<2)|0,d,r)|0?!(Dc(b,r)|0):0){b=0;break f}t=t+1|0}while((t|0)<(x|0));v=v+1|0}while((v|0)<(y|0))}while(0);r=c[m>>2]|0;m=r+(d*12|0)|0;s=c[m>>2]|0;if(s){c[r+(d*12|0)+4>>2]=0;Td(s);c[m>>2]=0;c[r+(d*12|0)+8>>2]=0}m=b+412|0;d=d<<1;s=c[m>>2]|0;r=s+(d*12|0)+4|0;if((c[r>>2]|0)==0?(l=s+(d*12|0)|0,k=c[l>>2]|0,(k|0)!=0):0){c[r>>2]=0;Td(k);c[l>>2]=0;c[s+(d*12|0)+8>>2]=0;s=c[m>>2]|0}k=d|1;l=s+(k*12|0)+4|0;if((c[l>>2]|0)==0?(j=s+(k*12|0)|0,h=c[j>>2]|0,(h|0)!=0):0){c[l>>2]=0;Td(h);c[j>>2]=0;c[s+(k*12|0)+8>>2]=0}b=Jc(b,0)|0;A=c[g>>2]|0}while(0);if(A){c[q>>2]=0;Td(A);c[g>>2]=0;c[p>>2]=0}g=c[f>>2]|0;if(!g){i=e;return b|0}c[n>>2]=0;Td(g);c[f>>2]=0;c[o>>2]=0;i=e;return b|0}function Nc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0;e=i;if(!(a[b+724>>0]|0)){i=e;return}l=b+540|0;if((c[l>>2]|0)>0){j=b+760|0;f=b+804|0;g=b+776|0;k=b+544|0;h=0;do{n=c[j>>2]|0;m=n+(h*12|0)+4|0;p=c[m>>2]|0;if((p|0)>0){n=c[n+(h*12|0)>>2]|0;q=0;o=0;do{r=c[n+(q<<2)>>2]|0;if((c[(c[c[f>>2]>>2]|0)+(r<<2)>>2]&3|0)!=1){c[n+(o<<2)>>2]=r;p=c[m>>2]|0;o=o+1|0}q=q+1|0}while((q|0)<(p|0))}else{q=0;o=0}n=q-o|0;if((n|0)>0)c[m>>2]=p-n;a[(c[g>>2]|0)+h>>0]=0;n=c[j>>2]|0;m=n+(h*12|0)+4|0;if((c[m>>2]|0)>0){r=n+(h*12|0)|0;p=0;do{n=(c[r>>2]|0)+(p<<2)|0;o=c[n>>2]|0;q=c[k>>2]|0;s=q+(o<<2)|0;if(!(c[s>>2]&16)){t=wc(d,s)|0;c[n>>2]=t;c[s>>2]=c[s>>2]|16;c[q+(o+1<<2)>>2]=t}else c[n>>2]=c[q+(o+1<<2)>>2];p=p+1|0}while((p|0)<(c[m>>2]|0))}h=h+1|0}while((h|0)<(c[l>>2]|0))}f=b+856|0;t=c[b+872>>2]|0;g=b+868|0;m=c[g>>2]|0;k=t-m|0;if((t|0)<(m|0))k=(c[b+860>>2]|0)+k|0;a:do if((k|0)>0){h=b+860|0;j=b+544|0;while(1){l=c[(c[f>>2]|0)+(m<<2)>>2]|0;n=m+1|0;c[g>>2]=(n|0)==(c[h>>2]|0)?0:n;n=c[j>>2]|0;o=n+(l<<2)|0;m=c[o>>2]|0;if(!(m&3)){if(!(m&16)){t=wc(d,o)|0;c[o>>2]=c[o>>2]|16;c[n+(l+1<<2)>>2]=t;l=t}else l=c[n+(l+1<<2)>>2]|0;Zc(f,l)}k=k+ -1|0;if((k|0)<=0)break a;m=c[g>>2]|0}}else j=b+544|0;while(0);b=b+928|0;f=c[b>>2]|0;h=c[j>>2]|0;g=h+(f<<2)|0;if(!(c[g>>2]&16)){t=wc(d,g)|0;c[b>>2]=t;c[g>>2]=c[g>>2]|16;c[h+(f+1<<2)>>2]=t;i=e;return}else{c[b>>2]=c[h+(f+1<<2)>>2];i=e;return}}function Oc(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;h=i;i=i+32|0;l=h;d=h+8|0;e=b+544|0;f=b+548|0;g=b+556|0;j=(c[f>>2]|0)-(c[g>>2]|0)|0;c[d+0>>2]=0;c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;gc(d,j);j=d+16|0;k=b+560|0;a[j>>0]=a[k>>0]|0;Nc(b,d);ac(b,d);if((c[b+44>>2]|0)>1){m=c[d+4>>2]<<2;c[l>>2]=c[f>>2]<<2;c[l+4>>2]=m;La(3608,l|0)|0}a[k>>0]=a[j>>0]|0;j=c[e>>2]|0;if(j)Td(j);c[e>>2]=c[d>>2];c[f>>2]=c[d+4>>2];c[b+552>>2]=c[d+8>>2];c[g>>2]=c[d+12>>2];i=h;return}function Pc(){var d=0,e=0,f=0;d=i;i=i+16|0;e=d;a[2608]=0;a[2616]=1;a[2624]=2;xb(2632,2656,2664,3744,3752);c[658]=160;a[2652]=0;xb(2704,2728,2736,3744,3752);c[676]=160;a[2724]=0;xb(2784,2808,2816,3744,3752);c[696]=160;a[2804]=1;xb(2848,2880,2888,3744,3736);c[712]=280;f=2868|0;c[f>>2]=-2147483648;c[f+4>>2]=2147483647;c[719]=0;xb(2960,2992,3e3,3744,3736);c[740]=280;f=2980|0;c[f>>2]=-1;c[f+4>>2]=2147483647;c[747]=20;xb(3112,3144,3152,3744,3736);c[778]=280;f=3132|0;c[f>>2]=-1;c[f+4>>2]=2147483647;c[785]=1e3;xb(3240,3296,3312,3744,3720);c[810]=2168;h[408]=0.0;h[409]=v;a[3280]=0;a[3281]=0;b[1641]=b[e+0>>1]|0;b[1642]=b[e+2>>1]|0;b[1643]=b[e+4>>1]|0;h[411]=.5;i=d;return}function Qc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;c[a>>2]=0;e=a+4|0;c[e>>2]=0;f=a+8|0;c[f>>2]=0;if((b|0)<=0){i=d;return}g=b+1&-2;g=(g|0)>2?g:2;c[f>>2]=g;f=Ud(0,g<<2)|0;c[a>>2]=f;if((f|0)==0?(c[(Oa()|0)>>2]|0)==12:0)Ta(va(1)|0,48,0);a=c[e>>2]|0;if((a|0)<(b|0))do{g=f+(a<<2)|0;if(g)c[g>>2]=0;a=a+1|0}while((a|0)!=(b|0));c[e>>2]=b;i=d;return}function Rc(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0;b=i;e=a+32|0;d=c[e>>2]|0;if(d){c[a+36>>2]=0;Td(d);c[e>>2]=0;c[a+40>>2]=0}e=a+16|0;d=c[e>>2]|0;if(d){c[a+20>>2]=0;Td(d);c[e>>2]=0;c[a+24>>2]=0}e=c[a>>2]|0;if(!e){i=b;return}d=a+4|0;g=c[d>>2]|0;if((g|0)>0){f=0;do{j=e+(f*12|0)|0;h=c[j>>2]|0;if(h){c[e+(f*12|0)+4>>2]=0;Td(h);c[j>>2]=0;c[e+(f*12|0)+8>>2]=0;e=c[a>>2]|0;g=c[d>>2]|0}f=f+1|0}while((f|0)<(g|0))}c[d>>2]=0;Td(e);c[a>>2]=0;c[a+8>>2]=0;i=b;return}function Sc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;e=i;b=c[b>>2]|0;g=b+1|0;f=a+4|0;if((c[f>>2]|0)>=(g|0)){k=c[a>>2]|0;k=k+(b<<2)|0;c[k>>2]=d;i=e;return}h=a+8|0;k=c[h>>2]|0;if((k|0)<(g|0)){l=b+2-k&-2;j=(k>>1)+2&-2;j=(l|0)>(j|0)?l:j;if((j|0)>(2147483647-k|0)){l=va(1)|0;Ta(l|0,48,0)}m=c[a>>2]|0;l=j+k|0;c[h>>2]=l;l=Ud(m,l<<2)|0;c[a>>2]=l;if((l|0)==0?(c[(Oa()|0)>>2]|0)==12:0){m=va(1)|0;Ta(m|0,48,0)}}k=c[f>>2]|0;if((k|0)<(g|0)){h=c[a>>2]|0;do{j=h+(k<<2)|0;if(j)c[j>>2]=0;k=k+1|0}while((k|0)!=(g|0))}c[f>>2]=g;m=c[a>>2]|0;m=m+(b<<2)|0;c[m>>2]=d;i=e;return}function Tc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;e=i;k=c[d>>2]|0;g=k+1|0;f=b+4|0;if((c[f>>2]|0)<(g|0)){j=b+8|0;h=c[j>>2]|0;if((h|0)<(g|0)){l=k+2-h&-2;k=(h>>1)+2&-2;k=(l|0)>(k|0)?l:k;if((k|0)>(2147483647-h|0)){l=va(1)|0;Ta(l|0,48,0)}m=c[b>>2]|0;l=k+h|0;c[j>>2]=l;l=Ud(m,l*12|0)|0;c[b>>2]=l;if((l|0)==0?(c[(Oa()|0)>>2]|0)==12:0){m=va(1)|0;Ta(m|0,48,0)}}j=c[f>>2]|0;if((j|0)<(g|0)){h=c[b>>2]|0;do{k=h+(j*12|0)|0;if(k){c[k>>2]=0;c[h+(j*12|0)+4>>2]=0;c[h+(j*12|0)+8>>2]=0}j=j+1|0}while((j|0)!=(g|0))}c[f>>2]=g;h=c[d>>2]|0}else h=k;f=c[b>>2]|0;if(c[f+(h*12|0)>>2]|0){c[f+(h*12|0)+4>>2]=0;h=c[d>>2]|0}d=b+16|0;f=h+1|0;g=b+20|0;if((c[g>>2]|0)>=(f|0)){i=e;return}j=b+24|0;b=c[j>>2]|0;if((b|0)<(f|0)){m=h+2-b&-2;h=(b>>1)+2&-2;h=(m|0)>(h|0)?m:h;if((h|0)>(2147483647-b|0)){m=va(1)|0;Ta(m|0,48,0)}l=c[d>>2]|0;m=h+b|0;c[j>>2]=m;m=Ud(l,m)|0;c[d>>2]=m;if((m|0)==0?(c[(Oa()|0)>>2]|0)==12:0){m=va(1)|0;Ta(m|0,48,0)}}b=c[g>>2]|0;if((b|0)<(f|0))do{a[(c[d>>2]|0)+b>>0]=0;b=b+1|0}while((b|0)!=(f|0));c[g>>2]=f;i=e;return}function Uc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;d=i;i=i+16|0;g=d;c[g>>2]=b;f=a+12|0;e=b+1|0;h=a+16|0;if((c[h>>2]|0)<(e|0)){k=a+20|0;j=c[k>>2]|0;if((j|0)<(e|0)){m=b+2-j&-2;l=(j>>1)+2&-2;l=(m|0)>(l|0)?m:l;if((l|0)>(2147483647-j|0)){m=va(1)|0;Ta(m|0,48,0)}n=c[f>>2]|0;m=l+j|0;c[k>>2]=m;m=Ud(n,m<<2)|0;c[f>>2]=m;if((m|0)==0?(c[(Oa()|0)>>2]|0)==12:0){n=va(1)|0;Ta(n|0,48,0)}}j=c[h>>2]|0;if((e|0)>(j|0))ke((c[f>>2]|0)+(j<<2)|0,-1,e-j<<2|0)|0;c[h>>2]=e}c[(c[f>>2]|0)+(b<<2)>>2]=c[a+4>>2];nc(a,g);e=c[f>>2]|0;j=c[e+(b<<2)>>2]|0;b=c[a>>2]|0;f=c[b+(j<<2)>>2]|0;if(!j){m=0;n=b+(m<<2)|0;c[n>>2]=f;n=e+(f<<2)|0;c[n>>2]=m;i=d;return}a=a+28|0;g=f<<1;h=g|1;while(1){m=j;j=j+ -1>>1;l=b+(j<<2)|0;k=c[l>>2]|0;r=c[c[a>>2]>>2]|0;o=c[r+(g<<2)>>2]|0;q=c[r+(h<<2)>>2]|0;o=we(q|0,((q|0)<0)<<31>>31|0,o|0,((o|0)<0)<<31>>31|0)|0;q=F;p=k<<1;n=c[r+(p<<2)>>2]|0;p=c[r+((p|1)<<2)>>2]|0;n=we(p|0,((p|0)<0)<<31>>31|0,n|0,((n|0)<0)<<31>>31|0)|0;p=F;if(!(q>>>0<p>>>0|(q|0)==(p|0)&o>>>0<n>>>0)){a=14;break}c[b+(m<<2)>>2]=k;c[e+(c[l>>2]<<2)>>2]=m;if(!j){m=0;a=14;break}}if((a|0)==14){r=b+(m<<2)|0;c[r>>2]=f;r=e+(f<<2)|0;c[r>>2]=m;i=d;return}}function Vc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;e=i;h=b+824|0;l=(c[b+840>>2]|0)>(d|0);if(l?(c[(c[b+836>>2]|0)+(d<<2)>>2]|0)>-1:0)j=7;else j=3;do if((j|0)==3){if(a[(c[b+876>>2]|0)+d>>0]|0){i=e;return}if(a[(c[b+904>>2]|0)+d>>0]|0){i=e;return}o=a[(c[b+332>>2]|0)+d>>0]|0;n=a[2624]|0;p=n&255;if((p>>>1^1)&o<<24>>24==n<<24>>24|o&2&p)if(l){j=7;break}else break;else{i=e;return}}while(0);if((j|0)==7?(f=c[b+836>>2]|0,g=f+(d<<2)|0,k=c[g>>2]|0,(k|0)>-1):0){d=c[h>>2]|0;j=c[d+(k<<2)>>2]|0;a:do if(!k)o=0;else{l=b+852|0;m=j<<1;b=m|1;while(1){o=k;k=k+ -1>>1;p=d+(k<<2)|0;n=c[p>>2]|0;u=c[c[l>>2]>>2]|0;r=c[u+(m<<2)>>2]|0;t=c[u+(b<<2)>>2]|0;r=we(t|0,((t|0)<0)<<31>>31|0,r|0,((r|0)<0)<<31>>31|0)|0;t=F;s=n<<1;q=c[u+(s<<2)>>2]|0;s=c[u+((s|1)<<2)>>2]|0;q=we(s|0,((s|0)<0)<<31>>31|0,q|0,((q|0)<0)<<31>>31|0)|0;s=F;if(!(t>>>0<s>>>0|(t|0)==(s|0)&r>>>0<q>>>0))break a;c[d+(o<<2)>>2]=n;c[f+(c[p>>2]<<2)>>2]=o;if(!k){o=0;break}}}while(0);c[d+(o<<2)>>2]=j;c[f+(j<<2)>>2]=o;Wc(h,c[g>>2]|0);i=e;return}Uc(h,d);i=e;return}function Wc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;d=i;e=c[a>>2]|0;f=c[e+(b<<2)>>2]|0;m=b<<1|1;l=a+4|0;o=c[l>>2]|0;if((m|0)>=(o|0)){p=b;q=a+12|0;o=e+(p<<2)|0;c[o>>2]=f;q=c[q>>2]|0;q=q+(f<<2)|0;c[q>>2]=p;i=d;return}h=a+28|0;k=f<<1;j=k|1;a=a+12|0;while(1){n=(b<<1)+2|0;if((n|0)<(o|0)){p=c[e+(n<<2)>>2]|0;q=c[e+(m<<2)>>2]|0;u=p<<1;o=c[c[h>>2]>>2]|0;s=c[o+(u<<2)>>2]|0;u=c[o+((u|1)<<2)>>2]|0;s=we(u|0,((u|0)<0)<<31>>31|0,s|0,((s|0)<0)<<31>>31|0)|0;u=F;t=q<<1;r=c[o+(t<<2)>>2]|0;t=c[o+((t|1)<<2)>>2]|0;r=we(t|0,((t|0)<0)<<31>>31|0,r|0,((r|0)<0)<<31>>31|0)|0;t=F;if(!(u>>>0<t>>>0|(u|0)==(t|0)&s>>>0<r>>>0)){p=q;g=7}}else{p=c[e+(m<<2)>>2]|0;o=c[c[h>>2]>>2]|0;g=7}if((g|0)==7){g=0;n=m}r=p<<1;t=c[o+(r<<2)>>2]|0;r=c[o+((r|1)<<2)>>2]|0;t=we(r|0,((r|0)<0)<<31>>31|0,t|0,((t|0)<0)<<31>>31|0)|0;r=F;u=c[o+(k<<2)>>2]|0;s=c[o+(j<<2)>>2]|0;u=we(s|0,((s|0)<0)<<31>>31|0,u|0,((u|0)<0)<<31>>31|0)|0;s=F;if(!(r>>>0<s>>>0|(r|0)==(s|0)&t>>>0<u>>>0)){g=10;break}c[e+(b<<2)>>2]=p;c[(c[a>>2]|0)+(p<<2)>>2]=b;m=n<<1|1;o=c[l>>2]|0;if((m|0)>=(o|0)){b=n;g=10;break}else b=n}if((g|0)==10){u=e+(b<<2)|0;c[u>>2]=f;u=c[a>>2]|0;u=u+(f<<2)|0;c[u>>2]=b;i=d;return}}function Xc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0;d=i;h=c[a>>2]|0;if(h){e=a+4|0;f=c[e>>2]|0;a:do if((f|0)>0){g=0;while(1){j=h+(g*12|0)|0;k=c[j>>2]|0;if(k){c[h+(g*12|0)+4>>2]=0;Td(k);c[j>>2]=0;c[h+(g*12|0)+8>>2]=0;f=c[e>>2]|0}g=g+1|0;if((g|0)>=(f|0))break a;h=c[a>>2]|0}}while(0);c[e>>2]=0;if(b){Td(c[a>>2]|0);c[a>>2]=0;c[a+8>>2]=0}}e=a+16|0;f=c[e>>2]|0;if((f|0)!=0?(c[a+20>>2]=0,b):0){Td(f);c[e>>2]=0;c[a+24>>2]=0}f=a+32|0;e=c[f>>2]|0;if(!e){i=d;return}c[a+36>>2]=0;if(!b){i=d;return}Td(e);c[f>>2]=0;c[a+40>>2]=0;i=d;return}function Yc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0;e=i;f=c[a>>2]|0;d=a+4|0;if(f){c[d>>2]=0;if(b){Td(f);c[a>>2]=0;c[a+8>>2]=0;f=0}}else f=0;if((c[d>>2]|0)>=1){h=a+16|0;c[h>>2]=0;h=a+12|0;c[h>>2]=0;i=e;return}h=a+8|0;g=c[h>>2]|0;if((g|0)<1){j=2-g&-2;b=(g>>1)+2&-2;b=(j|0)>(b|0)?j:b;if((b|0)>(2147483647-g|0)){j=va(1)|0;Ta(j|0,48,0)}j=b+g|0;c[h>>2]=j;f=Ud(f,j<<2)|0;c[a>>2]=f;if((f|0)==0?(c[(Oa()|0)>>2]|0)==12:0){j=va(1)|0;Ta(j|0,48,0)}}b=c[d>>2]|0;if((b|0)<1)while(1){g=f+(b<<2)|0;if(g)c[g>>2]=0;if(!b)break;else b=b+1|0}c[d>>2]=1;j=a+16|0;c[j>>2]=0;j=a+12|0;c[j>>2]=0;i=e;return}function Zc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;e=i;i=i+16|0;d=e;f=a+16|0;j=c[f>>2]|0;c[f>>2]=j+1;c[(c[a>>2]|0)+(j<<2)>>2]=b;j=c[f>>2]|0;b=a+4|0;h=c[b>>2]|0;if((j|0)==(h|0)){c[f>>2]=0;j=0}g=a+12|0;if((c[g>>2]|0)!=(j|0)){i=e;return}Qc(d,(h*3|0)+1>>1);l=c[g>>2]|0;m=c[b>>2]|0;if((l|0)<(m|0)){j=c[a>>2]|0;k=c[d>>2]|0;m=0;while(1){h=m+1|0;c[k+(m<<2)>>2]=c[j+(l<<2)>>2];l=l+1|0;m=c[b>>2]|0;if((l|0)>=(m|0)){k=h;break}else m=h}}else k=0;h=c[a>>2]|0;if((c[f>>2]|0)>0){j=c[d>>2]|0;l=0;while(1){c[j+(k<<2)>>2]=c[h+(l<<2)>>2];l=l+1|0;if((l|0)>=(c[f>>2]|0))break;else k=k+1|0}m=c[b>>2]|0}c[g>>2]=0;c[f>>2]=m;if(!h)f=a+8|0;else{c[b>>2]=0;Td(h);c[a>>2]=0;f=a+8|0;c[f>>2]=0}c[a>>2]=c[d>>2];l=d+4|0;c[b>>2]=c[l>>2];m=d+8|0;c[f>>2]=c[m>>2];c[d>>2]=0;c[l>>2]=0;c[m>>2]=0;i=e;return}function _c(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0;d=i;e=a+4|0;f=c[e>>2]|0;g=a+8|0;h=c[g>>2]|0;if((f|0)==(h|0)&(h|0)<(f+1|0)){h=(f>>1)+2&-2;h=(h|0)<2?2:h;if((h|0)>(2147483647-f|0)){h=va(1)|0;Ta(h|0,48,0)}j=c[a>>2]|0;f=h+f|0;c[g>>2]=f;f=Ud(j,f<<2)|0;c[a>>2]=f;if((f|0)==0?(c[(Oa()|0)>>2]|0)==12:0){j=va(1)|0;Ta(j|0,48,0)}}else f=c[a>>2]|0;j=c[e>>2]|0;c[e>>2]=j+1;e=f+(j<<2)|0;if(!e){i=d;return}c[e>>2]=c[b>>2];i=d;return}function $c(){var a=0,b=0;b=i;Ka(3864)|0;a=od(936)|0;xc(a);i=b;return a|0}function ad(a){a=a|0;var b=0;b=i;if(!a){i=b;return}gb[c[(c[a>>2]|0)+4>>2]&31](a);i=b;return}function bd(){var b=0,d=0,e=0;b=i;i=i+16|0;d=b;e=od(936)|0;xc(e);c[964]=e;Cc(e,1)|0;e=c[964]|0;a[d+0>>0]=a[3840]|0;Ac(e,d,1)|0;i=b;return}function cd(b){b=b|0;var d=0,e=0,f=0;d=i;i=i+16|0;e=d;if((c[962]|0)>=(b|0)){i=d;return}do{f=c[964]|0;a[e+0>>0]=a[3840]|0;Ac(f,e,1)|0;f=(c[962]|0)+1|0;c[962]=f}while((f|0)<(b|0));i=d;return}function dd(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;g=i;i=i+32|0;h=g+16|0;e=g+4|0;j=g;c[e>>2]=0;f=e+4|0;c[f>>2]=0;d=e+8|0;c[d>>2]=0;k=c[b>>2]|0;if(k)do{l=(k|0)<0?0-k|0:k;if((c[962]|0)<(l|0))do{m=c[964]|0;a[h+0>>0]=a[3840]|0;Ac(m,h,1)|0;m=(c[962]|0)+1|0;c[962]=m}while((m|0)<(l|0));c[j>>2]=l<<1|k>>>31;mc(e,j);b=b+4|0;k=c[b>>2]|0}while((k|0)!=0);j=c[964]|0;h=j+628|0;ld(e,h);h=Dc(j,h)|0;j=c[e>>2]|0;if(!j){i=g;return h|0}c[f>>2]=0;Td(j);c[e>>2]=0;c[d>>2]=0;i=g;return h|0}function ed(){var b=0,d=0,e=0,f=0;d=i;i=i+16|0;b=d;e=c[964]|0;f=e+664|0;c[f+0>>2]=-1;c[f+4>>2]=-1;c[f+8>>2]=-1;c[f+12>>2]=-1;if(c[e+304>>2]|0)c[e+308>>2]=0;Bc(b,e,1,0);i=d;return(a[b>>0]|0)==0|0}function fd(){return(c[(c[964]|0)+4>>2]|0)+1|0}function gd(){return c[962]|0}function hd(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0;d=i;i=i+32|0;h=d+16|0;f=d+4|0;j=d;c[f>>2]=0;e=f+4|0;c[e>>2]=0;g=f+8|0;c[g>>2]=0;c[j>>2]=b<<1;mc(f,j);b=c[964]|0;j=b+664|0;c[j+0>>2]=-1;c[j+4>>2]=-1;c[j+8>>2]=-1;c[j+12>>2]=-1;ld(f,b+304|0);Bc(h,b,1,0);b=(a[h>>0]|0)==0;h=c[f>>2]|0;if(!h){i=d;return b|0}c[e>>2]=0;Td(h);c[f>>2]=0;c[g>>2]=0;i=d;return b|0}function id(a){a=a|0;var b=0,d=0,e=0;b=i;i=i+16|0;e=b;d=c[964]|0;c[e>>2]=a<<1|1;a=d+628|0;if(c[a>>2]|0)c[d+632>>2]=0;mc(a,e);Dc(d,a)|0;i=b;return}function jd(){return c[(c[964]|0)+36>>2]|0}function kd(){return c[(c[964]|0)+32>>2]|0}function ld(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;d=i;h=c[b>>2]|0;e=b+4|0;if(!h)j=c[e>>2]|0;else{c[e>>2]=0;j=0}e=a+4|0;f=c[e>>2]|0;g=b+4|0;if((j|0)<(f|0)){k=b+8|0;j=c[k>>2]|0;if((j|0)<(f|0)){m=f+1-j&-2;l=(j>>1)+2&-2;l=(m|0)>(l|0)?m:l;if((l|0)>(2147483647-j|0)){m=va(1)|0;Ta(m|0,48,0)}m=l+j|0;c[k>>2]=m;h=Ud(h,m<<2)|0;c[b>>2]=h;if((h|0)==0?(c[(Oa()|0)>>2]|0)==12:0){m=va(1)|0;Ta(m|0,48,0)}}j=c[g>>2]|0;a:do if((j|0)<(f|0))while(1){h=h+(j<<2)|0;if(h)c[h>>2]=0;j=j+1|0;if((j|0)==(f|0))break a;h=c[b>>2]|0}while(0);c[g>>2]=f;f=c[e>>2]|0}if((f|0)<=0){i=d;return}b=c[b>>2]|0;a=c[a>>2]|0;f=0;do{c[b+(f<<2)>>2]=c[a+(f<<2)>>2];f=f+1|0}while((f|0)<(c[e>>2]|0));i=d;return}function md(a,b){a=a|0;b=b|0;var d=0;d=i;i=i+16|0;c[d>>2]=b;b=c[p>>2]|0;ua(b|0,a|0,d|0)|0;Sa(10,b|0)|0;Wa()}function nd(){var a=0,b=0;a=i;i=i+16|0;if(!(Ja(4064,3)|0)){b=Ha(c[1014]|0)|0;i=a;return b|0}else md(4072,a);return 0}function od(a){a=a|0;var b=0,d=0;b=i;a=(a|0)==0?1:a;d=Sd(a)|0;if(d){i=b;return d|0}while(1){d=vd()|0;if(!d){a=4;break}jb[d&3]();d=Sd(a)|0;if(d){a=5;break}}if((a|0)==4){d=va(4)|0;c[d>>2]=4248;Ta(d|0,4296,12)}else if((a|0)==5){i=b;return d|0}return 0}function pd(a){a=a|0;var b=0;b=i;Td(a);i=b;return}function qd(a){a=a|0;var b=0;b=i;pd(a);i=b;return}function rd(a){a=a|0;return}function sd(a){a=a|0;return 4264}function td(a){a=a|0;var b=0;b=i;i=i+16|0;jb[a&3]();md(4312,b)}function ud(){var a=0,b=0;b=nd()|0;if(((b|0)!=0?(a=c[b>>2]|0,(a|0)!=0):0)?(b=a+48|0,(c[b>>2]&-256|0)==1126902528?(c[b+4>>2]|0)==1129074247:0):0)td(c[a+12>>2]|0);b=c[968]|0;c[968]=b+0;td(b)}function vd(){var a=0;a=c[1102]|0;c[1102]=a+0;return a|0}function wd(a){a=a|0;return}function xd(a){a=a|0;return}function yd(a){a=a|0;return}function zd(a){a=a|0;return}function Ad(a){a=a|0;return}function Bd(a){a=a|0;var b=0;b=i;pd(a);i=b;return}function Cd(a){a=a|0;var b=0;b=i;pd(a);i=b;return}function Dd(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0;e=i;i=i+64|0;f=e;if((a|0)==(b|0)){h=1;i=e;return h|0}if(!b){h=0;i=e;return h|0}b=Hd(b,4504,4560,0)|0;if(!b){h=0;i=e;return h|0}h=f+0|0;g=h+56|0;do{c[h>>2]=0;h=h+4|0}while((h|0)<(g|0));c[f>>2]=b;c[f+8>>2]=a;c[f+12>>2]=-1;c[f+48>>2]=1;mb[c[(c[b>>2]|0)+28>>2]&3](b,f,c[d>>2]|0,1);if((c[f+24>>2]|0)!=1){h=0;i=e;return h|0}c[d>>2]=c[f+16>>2];h=1;i=e;return h|0}function Ed(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;b=i;g=d+16|0;h=c[g>>2]|0;if(!h){c[g>>2]=e;c[d+24>>2]=f;c[d+36>>2]=1;i=b;return}if((h|0)!=(e|0)){h=d+36|0;c[h>>2]=(c[h>>2]|0)+1;c[d+24>>2]=2;a[d+54>>0]=1;i=b;return}e=d+24|0;if((c[e>>2]|0)!=2){i=b;return}c[e>>2]=f;i=b;return}function Fd(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0;f=i;if((c[b+8>>2]|0)!=(a|0)){i=f;return}Ed(0,b,d,e);i=f;return}function Gd(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0;f=i;if((a|0)==(c[b+8>>2]|0)){Ed(0,b,d,e);i=f;return}else{a=c[a+8>>2]|0;mb[c[(c[a>>2]|0)+28>>2]&3](a,b,d,e);i=f;return}}function Hd(d,e,f,g){d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;h=i;i=i+64|0;j=h;k=c[d>>2]|0;l=d+(c[k+ -8>>2]|0)|0;k=c[k+ -4>>2]|0;c[j>>2]=f;c[j+4>>2]=d;c[j+8>>2]=e;c[j+12>>2]=g;n=j+16|0;o=j+20|0;e=j+24|0;m=j+28|0;g=j+32|0;d=j+40|0;p=(k|0)==(f|0);q=n+0|0;f=q+36|0;do{c[q>>2]=0;q=q+4|0}while((q|0)<(f|0));b[n+36>>1]=0;a[n+38>>0]=0;if(p){c[j+48>>2]=1;kb[c[(c[k>>2]|0)+20>>2]&3](k,j,l,l,1,0);q=(c[e>>2]|0)==1?l:0;i=h;return q|0}fb[c[(c[k>>2]|0)+24>>2]&3](k,j,l,1,0);j=c[j+36>>2]|0;if(!j){q=(c[d>>2]|0)==1&(c[m>>2]|0)==1&(c[g>>2]|0)==1?c[o>>2]|0:0;i=h;return q|0}else if((j|0)==1){if((c[e>>2]|0)!=1?!((c[d>>2]|0)==0&(c[m>>2]|0)==1&(c[g>>2]|0)==1):0){q=0;i=h;return q|0}q=c[n>>2]|0;i=h;return q|0}else{q=0;i=h;return q|0}return 0}function Id(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0;b=i;a[d+53>>0]=1;if((c[d+4>>2]|0)!=(f|0)){i=b;return}a[d+52>>0]=1;f=d+16|0;h=c[f>>2]|0;if(!h){c[f>>2]=e;c[d+24>>2]=g;c[d+36>>2]=1;if(!((g|0)==1?(c[d+48>>2]|0)==1:0)){i=b;return}a[d+54>>0]=1;i=b;return}if((h|0)!=(e|0)){h=d+36|0;c[h>>2]=(c[h>>2]|0)+1;a[d+54>>0]=1;i=b;return}e=d+24|0;f=c[e>>2]|0;if((f|0)==2)c[e>>2]=g;else g=f;if(!((g|0)==1?(c[d+48>>2]|0)==1:0)){i=b;return}a[d+54>>0]=1;i=b;return}function Jd(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0;h=i;if((b|0)==(c[d+8>>2]|0)){if((c[d+4>>2]|0)!=(e|0)){i=h;return}j=d+28|0;if((c[j>>2]|0)==1){i=h;return}c[j>>2]=f;i=h;return}if((b|0)!=(c[d>>2]|0)){l=c[b+8>>2]|0;fb[c[(c[l>>2]|0)+24>>2]&3](l,d,e,f,g);i=h;return}if((c[d+16>>2]|0)!=(e|0)?(k=d+20|0,(c[k>>2]|0)!=(e|0)):0){c[d+32>>2]=f;f=d+44|0;if((c[f>>2]|0)==4){i=h;return}l=d+52|0;a[l>>0]=0;m=d+53|0;a[m>>0]=0;b=c[b+8>>2]|0;kb[c[(c[b>>2]|0)+20>>2]&3](b,d,e,e,1,g);if(a[m>>0]|0){if(!(a[l>>0]|0)){b=1;j=13}}else{b=0;j=13}do if((j|0)==13){c[k>>2]=e;m=d+40|0;c[m>>2]=(c[m>>2]|0)+1;if((c[d+36>>2]|0)==1?(c[d+24>>2]|0)==2:0){a[d+54>>0]=1;if(b)break}else j=16;if((j|0)==16?b:0)break;c[f>>2]=4;i=h;return}while(0);c[f>>2]=3;i=h;return}if((f|0)!=1){i=h;return}c[d+32>>2]=1;i=h;return}function Kd(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0;g=i;if((c[d+8>>2]|0)==(b|0)){if((c[d+4>>2]|0)!=(e|0)){i=g;return}d=d+28|0;if((c[d>>2]|0)==1){i=g;return}c[d>>2]=f;i=g;return}if((c[d>>2]|0)!=(b|0)){i=g;return}if((c[d+16>>2]|0)!=(e|0)?(h=d+20|0,(c[h>>2]|0)!=(e|0)):0){c[d+32>>2]=f;c[h>>2]=e;b=d+40|0;c[b>>2]=(c[b>>2]|0)+1;if((c[d+36>>2]|0)==1?(c[d+24>>2]|0)==2:0)a[d+54>>0]=1;c[d+44>>2]=4;i=g;return}if((f|0)!=1){i=g;return}c[d+32>>2]=1;i=g;return}function Ld(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0;h=i;if((a|0)==(c[b+8>>2]|0)){Id(0,b,d,e,f);i=h;return}else{a=c[a+8>>2]|0;kb[c[(c[a>>2]|0)+20>>2]&3](a,b,d,e,f,g);i=h;return}}function Md(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;g=i;if((c[b+8>>2]|0)!=(a|0)){i=g;return}Id(0,b,d,e,f);i=g;return}function Nd(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=i;i=i+16|0;f=e;c[f>>2]=c[d>>2];a=eb[c[(c[a>>2]|0)+16>>2]&1](a,b,f)|0;b=a&1;if(!a){i=e;return b|0}c[d>>2]=c[f>>2];i=e;return b|0}function Od(a){a=a|0;var b=0;b=i;if(!a)a=0;else a=(Hd(a,4504,4672,0)|0)!=0;i=b;return a&1|0}function Pd(){var a=0,b=0,d=0,e=0,f=0;a=i;i=i+16|0;b=a;a=a+12|0;d=nd()|0;if(!d)md(4040,b);d=c[d>>2]|0;if(!d)md(4040,b);f=d+48|0;e=c[f>>2]|0;f=c[f+4>>2]|0;if(!((e&-256|0)==1126902528&(f|0)==1129074247)){c[b>>2]=c[970];md(4e3,b)}if((e|0)==1126902529&(f|0)==1129074247)e=c[d+44>>2]|0;else e=d+80|0;c[a>>2]=e;f=c[d>>2]|0;d=c[f+4>>2]|0;if(eb[c[(c[4432>>2]|0)+16>>2]&1](4432,f,a)|0){f=c[a>>2]|0;e=c[970]|0;f=ib[c[(c[f>>2]|0)+8>>2]&1](f)|0;c[b>>2]=e;c[b+4>>2]=d;c[b+8>>2]=f;md(3904,b)}else{c[b>>2]=c[970];c[b+4>>2]=d;md(3952,b)}}function Qd(){var a=0;a=i;i=i+16|0;if(!(Ma(4056,20)|0)){i=a;return}else md(4128,a)}function Rd(a){a=a|0;var b=0;b=i;i=i+16|0;Td(a);if(!(Pa(c[1014]|0,0)|0)){i=b;return}else md(4184,b)}function Sd(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0;b=i;do if(a>>>0<245){if(a>>>0<11)a=16;else a=a+11&-8;x=a>>>3;p=c[1206]|0;w=p>>>x;if(w&3){g=(w&1^1)+x|0;f=g<<1;d=4864+(f<<2)|0;f=4864+(f+2<<2)|0;h=c[f>>2]|0;j=h+8|0;e=c[j>>2]|0;do if((d|0)!=(e|0)){if(e>>>0<(c[1210]|0)>>>0)Wa();k=e+12|0;if((c[k>>2]|0)==(h|0)){c[k>>2]=d;c[f>>2]=e;break}else Wa()}else c[1206]=p&~(1<<g);while(0);H=g<<3;c[h+4>>2]=H|3;H=h+(H|4)|0;c[H>>2]=c[H>>2]|1;H=j;i=b;return H|0}v=c[1208]|0;if(a>>>0>v>>>0){if(w){h=2<<x;h=w<<x&(h|0-h);h=(h&0-h)+ -1|0;d=h>>>12&16;h=h>>>d;j=h>>>5&8;h=h>>>j;f=h>>>2&4;h=h>>>f;g=h>>>1&2;h=h>>>g;e=h>>>1&1;e=(j|d|f|g|e)+(h>>>e)|0;h=e<<1;g=4864+(h<<2)|0;h=4864+(h+2<<2)|0;f=c[h>>2]|0;d=f+8|0;j=c[d>>2]|0;do if((g|0)!=(j|0)){if(j>>>0<(c[1210]|0)>>>0)Wa();k=j+12|0;if((c[k>>2]|0)==(f|0)){c[k>>2]=g;c[h>>2]=j;E=c[1208]|0;break}else Wa()}else{c[1206]=p&~(1<<e);E=v}while(0);H=e<<3;e=H-a|0;c[f+4>>2]=a|3;g=f+a|0;c[f+(a|4)>>2]=e|1;c[f+H>>2]=e;if(E){f=c[1211]|0;l=E>>>3;j=l<<1;h=4864+(j<<2)|0;k=c[1206]|0;l=1<<l;if(k&l){j=4864+(j+2<<2)|0;k=c[j>>2]|0;if(k>>>0<(c[1210]|0)>>>0)Wa();else{D=j;C=k}}else{c[1206]=k|l;D=4864+(j+2<<2)|0;C=h}c[D>>2]=f;c[C+12>>2]=f;c[f+8>>2]=C;c[f+12>>2]=h}c[1208]=e;c[1211]=g;H=d;i=b;return H|0}p=c[1207]|0;if(p){d=(p&0-p)+ -1|0;G=d>>>12&16;d=d>>>G;F=d>>>5&8;d=d>>>F;H=d>>>2&4;d=d>>>H;f=d>>>1&2;d=d>>>f;e=d>>>1&1;e=c[5128+((F|G|H|f|e)+(d>>>e)<<2)>>2]|0;d=(c[e+4>>2]&-8)-a|0;f=e;while(1){g=c[f+16>>2]|0;if(!g){g=c[f+20>>2]|0;if(!g)break}f=(c[g+4>>2]&-8)-a|0;H=f>>>0<d>>>0;d=H?f:d;f=g;e=H?g:e}h=c[1210]|0;if(e>>>0<h>>>0)Wa();f=e+a|0;if(e>>>0>=f>>>0)Wa();g=c[e+24>>2]|0;k=c[e+12>>2]|0;do if((k|0)==(e|0)){k=e+20|0;j=c[k>>2]|0;if(!j){k=e+16|0;j=c[k>>2]|0;if(!j){B=0;break}}while(1){l=j+20|0;m=c[l>>2]|0;if(m){j=m;k=l;continue}l=j+16|0;m=c[l>>2]|0;if(!m)break;else{j=m;k=l}}if(k>>>0<h>>>0)Wa();else{c[k>>2]=0;B=j;break}}else{j=c[e+8>>2]|0;if(j>>>0<h>>>0)Wa();h=j+12|0;if((c[h>>2]|0)!=(e|0))Wa();l=k+8|0;if((c[l>>2]|0)==(e|0)){c[h>>2]=k;c[l>>2]=j;B=k;break}else Wa()}while(0);do if(g){j=c[e+28>>2]|0;h=5128+(j<<2)|0;if((e|0)==(c[h>>2]|0)){c[h>>2]=B;if(!B){c[1207]=c[1207]&~(1<<j);break}}else{if(g>>>0<(c[1210]|0)>>>0)Wa();h=g+16|0;if((c[h>>2]|0)==(e|0))c[h>>2]=B;else c[g+20>>2]=B;if(!B)break}h=c[1210]|0;if(B>>>0<h>>>0)Wa();c[B+24>>2]=g;g=c[e+16>>2]|0;do if(g)if(g>>>0<h>>>0)Wa();else{c[B+16>>2]=g;c[g+24>>2]=B;break}while(0);g=c[e+20>>2]|0;if(g)if(g>>>0<(c[1210]|0)>>>0)Wa();else{c[B+20>>2]=g;c[g+24>>2]=B;break}}while(0);if(d>>>0<16){H=d+a|0;c[e+4>>2]=H|3;H=e+(H+4)|0;c[H>>2]=c[H>>2]|1}else{c[e+4>>2]=a|3;c[e+(a|4)>>2]=d|1;c[e+(d+a)>>2]=d;h=c[1208]|0;if(h){g=c[1211]|0;k=h>>>3;l=k<<1;h=4864+(l<<2)|0;j=c[1206]|0;k=1<<k;if(j&k){j=4864+(l+2<<2)|0;k=c[j>>2]|0;if(k>>>0<(c[1210]|0)>>>0)Wa();else{A=j;z=k}}else{c[1206]=j|k;A=4864+(l+2<<2)|0;z=h}c[A>>2]=g;c[z+12>>2]=g;c[g+8>>2]=z;c[g+12>>2]=h}c[1208]=d;c[1211]=f}H=e+8|0;i=b;return H|0}}}else if(a>>>0<=4294967231){z=a+11|0;a=z&-8;B=c[1207]|0;if(B){A=0-a|0;z=z>>>8;if(z)if(a>>>0>16777215)C=31;else{G=(z+1048320|0)>>>16&8;H=z<<G;F=(H+520192|0)>>>16&4;H=H<<F;C=(H+245760|0)>>>16&2;C=14-(F|G|C)+(H<<C>>>15)|0;C=a>>>(C+7|0)&1|C<<1}else C=0;D=c[5128+(C<<2)>>2]|0;a:do if(!D){F=0;z=0}else{if((C|0)==31)z=0;else z=25-(C>>>1)|0;F=0;E=a<<z;z=0;while(1){G=c[D+4>>2]&-8;H=G-a|0;if(H>>>0<A>>>0)if((G|0)==(a|0)){A=H;F=D;z=D;break a}else{A=H;z=D}H=c[D+20>>2]|0;D=c[D+(E>>>31<<2)+16>>2]|0;F=(H|0)==0|(H|0)==(D|0)?F:H;if(!D)break;else E=E<<1}}while(0);if((F|0)==0&(z|0)==0){H=2<<C;B=B&(H|0-H);if(!B)break;H=(B&0-B)+ -1|0;D=H>>>12&16;H=H>>>D;C=H>>>5&8;H=H>>>C;E=H>>>2&4;H=H>>>E;G=H>>>1&2;H=H>>>G;F=H>>>1&1;F=c[5128+((C|D|E|G|F)+(H>>>F)<<2)>>2]|0}if(F)while(1){H=(c[F+4>>2]&-8)-a|0;B=H>>>0<A>>>0;A=B?H:A;z=B?F:z;B=c[F+16>>2]|0;if(B){F=B;continue}F=c[F+20>>2]|0;if(!F)break}if((z|0)!=0?A>>>0<((c[1208]|0)-a|0)>>>0:0){f=c[1210]|0;if(z>>>0<f>>>0)Wa();d=z+a|0;if(z>>>0>=d>>>0)Wa();e=c[z+24>>2]|0;g=c[z+12>>2]|0;do if((g|0)==(z|0)){h=z+20|0;g=c[h>>2]|0;if(!g){h=z+16|0;g=c[h>>2]|0;if(!g){x=0;break}}while(1){j=g+20|0;k=c[j>>2]|0;if(k){g=k;h=j;continue}j=g+16|0;k=c[j>>2]|0;if(!k)break;else{g=k;h=j}}if(h>>>0<f>>>0)Wa();else{c[h>>2]=0;x=g;break}}else{h=c[z+8>>2]|0;if(h>>>0<f>>>0)Wa();j=h+12|0;if((c[j>>2]|0)!=(z|0))Wa();f=g+8|0;if((c[f>>2]|0)==(z|0)){c[j>>2]=g;c[f>>2]=h;x=g;break}else Wa()}while(0);do if(e){f=c[z+28>>2]|0;g=5128+(f<<2)|0;if((z|0)==(c[g>>2]|0)){c[g>>2]=x;if(!x){c[1207]=c[1207]&~(1<<f);break}}else{if(e>>>0<(c[1210]|0)>>>0)Wa();f=e+16|0;if((c[f>>2]|0)==(z|0))c[f>>2]=x;else c[e+20>>2]=x;if(!x)break}f=c[1210]|0;if(x>>>0<f>>>0)Wa();c[x+24>>2]=e;e=c[z+16>>2]|0;do if(e)if(e>>>0<f>>>0)Wa();else{c[x+16>>2]=e;c[e+24>>2]=x;break}while(0);e=c[z+20>>2]|0;if(e)if(e>>>0<(c[1210]|0)>>>0)Wa();else{c[x+20>>2]=e;c[e+24>>2]=x;break}}while(0);b:do if(A>>>0>=16){c[z+4>>2]=a|3;c[z+(a|4)>>2]=A|1;c[z+(A+a)>>2]=A;f=A>>>3;if(A>>>0<256){h=f<<1;e=4864+(h<<2)|0;g=c[1206]|0;f=1<<f;do if(!(g&f)){c[1206]=g|f;w=4864+(h+2<<2)|0;v=e}else{f=4864+(h+2<<2)|0;g=c[f>>2]|0;if(g>>>0>=(c[1210]|0)>>>0){w=f;v=g;break}Wa()}while(0);c[w>>2]=d;c[v+12>>2]=d;c[z+(a+8)>>2]=v;c[z+(a+12)>>2]=e;break}e=A>>>8;if(e)if(A>>>0>16777215)e=31;else{G=(e+1048320|0)>>>16&8;H=e<<G;F=(H+520192|0)>>>16&4;H=H<<F;e=(H+245760|0)>>>16&2;e=14-(F|G|e)+(H<<e>>>15)|0;e=A>>>(e+7|0)&1|e<<1}else e=0;f=5128+(e<<2)|0;c[z+(a+28)>>2]=e;c[z+(a+20)>>2]=0;c[z+(a+16)>>2]=0;g=c[1207]|0;h=1<<e;if(!(g&h)){c[1207]=g|h;c[f>>2]=d;c[z+(a+24)>>2]=f;c[z+(a+12)>>2]=d;c[z+(a+8)>>2]=d;break}h=c[f>>2]|0;if((e|0)==31)e=0;else e=25-(e>>>1)|0;c:do if((c[h+4>>2]&-8|0)!=(A|0)){e=A<<e;while(1){g=h+(e>>>31<<2)+16|0;f=c[g>>2]|0;if(!f)break;if((c[f+4>>2]&-8|0)==(A|0)){p=f;break c}else{e=e<<1;h=f}}if(g>>>0<(c[1210]|0)>>>0)Wa();else{c[g>>2]=d;c[z+(a+24)>>2]=h;c[z+(a+12)>>2]=d;c[z+(a+8)>>2]=d;break b}}else p=h;while(0);f=p+8|0;e=c[f>>2]|0;H=c[1210]|0;if(p>>>0>=H>>>0&e>>>0>=H>>>0){c[e+12>>2]=d;c[f>>2]=d;c[z+(a+8)>>2]=e;c[z+(a+12)>>2]=p;c[z+(a+24)>>2]=0;break}else Wa()}else{H=A+a|0;c[z+4>>2]=H|3;H=z+(H+4)|0;c[H>>2]=c[H>>2]|1}while(0);H=z+8|0;i=b;return H|0}}}else a=-1;while(0);p=c[1208]|0;if(p>>>0>=a>>>0){e=p-a|0;d=c[1211]|0;if(e>>>0>15){c[1211]=d+a;c[1208]=e;c[d+(a+4)>>2]=e|1;c[d+p>>2]=e;c[d+4>>2]=a|3}else{c[1208]=0;c[1211]=0;c[d+4>>2]=p|3;H=d+(p+4)|0;c[H>>2]=c[H>>2]|1}H=d+8|0;i=b;return H|0}p=c[1209]|0;if(p>>>0>a>>>0){G=p-a|0;c[1209]=G;H=c[1212]|0;c[1212]=H+a;c[H+(a+4)>>2]=G|1;c[H+4>>2]=a|3;H=H+8|0;i=b;return H|0}do if(!(c[1324]|0)){p=Ga(30)|0;if(!(p+ -1&p)){c[1326]=p;c[1325]=p;c[1327]=-1;c[1328]=-1;c[1329]=0;c[1317]=0;c[1324]=(Ya(0)|0)&-16^1431655768;break}else Wa()}while(0);x=a+48|0;p=c[1326]|0;w=a+47|0;A=p+w|0;p=0-p|0;v=A&p;if(v>>>0<=a>>>0){H=0;i=b;return H|0}z=c[1316]|0;if((z|0)!=0?(G=c[1314]|0,H=G+v|0,H>>>0<=G>>>0|H>>>0>z>>>0):0){H=0;i=b;return H|0}d:do if(!(c[1317]&4)){B=c[1212]|0;e:do if(B){z=5272|0;while(1){C=c[z>>2]|0;if(C>>>0<=B>>>0?(y=z+4|0,(C+(c[y>>2]|0)|0)>>>0>B>>>0):0)break;z=c[z+8>>2]|0;if(!z){o=181;break e}}if(z){A=A-(c[1209]|0)&p;if(A>>>0<2147483647){p=Aa(A|0)|0;if((p|0)==((c[z>>2]|0)+(c[y>>2]|0)|0)){z=A;o=190}else{z=A;o=191}}else z=0}else o=181}else o=181;while(0);do if((o|0)==181){y=Aa(0)|0;if((y|0)!=(-1|0)){A=y;z=c[1325]|0;p=z+ -1|0;if(!(p&A))z=v;else z=v-A+(p+A&0-z)|0;p=c[1314]|0;A=p+z|0;if(z>>>0>a>>>0&z>>>0<2147483647){H=c[1316]|0;if((H|0)!=0?A>>>0<=p>>>0|A>>>0>H>>>0:0){z=0;break}p=Aa(z|0)|0;if((p|0)==(y|0)){p=y;o=190}else o=191}else z=0}else z=0}while(0);f:do if((o|0)==190){if((p|0)!=(-1|0)){q=z;o=201;break d}}else if((o|0)==191){o=0-z|0;do if((p|0)!=(-1|0)&z>>>0<2147483647&x>>>0>z>>>0?(u=c[1326]|0,u=w-z+u&0-u,u>>>0<2147483647):0)if((Aa(u|0)|0)==(-1|0)){Aa(o|0)|0;z=0;break f}else{z=u+z|0;break}while(0);if((p|0)==(-1|0))z=0;else{q=z;o=201;break d}}while(0);c[1317]=c[1317]|4;o=198}else{z=0;o=198}while(0);if((((o|0)==198?v>>>0<2147483647:0)?(t=Aa(v|0)|0,s=Aa(0)|0,(t|0)!=(-1|0)&(s|0)!=(-1|0)&t>>>0<s>>>0):0)?(r=s-t|0,q=r>>>0>(a+40|0)>>>0,q):0){p=t;q=q?r:z;o=201}if((o|0)==201){r=(c[1314]|0)+q|0;c[1314]=r;if(r>>>0>(c[1315]|0)>>>0)c[1315]=r;r=c[1212]|0;g:do if(r){t=5272|0;while(1){s=c[t>>2]|0;v=t+4|0;w=c[v>>2]|0;if((p|0)==(s+w|0)){o=213;break}u=c[t+8>>2]|0;if(!u)break;else t=u}if(((o|0)==213?(c[t+12>>2]&8|0)==0:0)?r>>>0>=s>>>0&r>>>0<p>>>0:0){c[v>>2]=w+q;d=(c[1209]|0)+q|0;e=r+8|0;if(!(e&7))e=0;else e=0-e&7;H=d-e|0;c[1212]=r+e;c[1209]=H;c[r+(e+4)>>2]=H|1;c[r+(d+4)>>2]=40;c[1213]=c[1328];break}s=c[1210]|0;if(p>>>0<s>>>0){c[1210]=p;s=p}v=p+q|0;t=5272|0;while(1){if((c[t>>2]|0)==(v|0)){o=223;break}u=c[t+8>>2]|0;if(!u)break;else t=u}if((o|0)==223?(c[t+12>>2]&8|0)==0:0){c[t>>2]=p;h=t+4|0;c[h>>2]=(c[h>>2]|0)+q;h=p+8|0;if(!(h&7))h=0;else h=0-h&7;j=p+(q+8)|0;if(!(j&7))n=0;else n=0-j&7;o=p+(n+q)|0;k=h+a|0;j=p+k|0;m=o-(p+h)-a|0;c[p+(h+4)>>2]=a|3;h:do if((o|0)!=(r|0)){if((o|0)==(c[1211]|0)){H=(c[1208]|0)+m|0;c[1208]=H;c[1211]=j;c[p+(k+4)>>2]=H|1;c[p+(H+k)>>2]=H;break}r=q+4|0;u=c[p+(r+n)>>2]|0;if((u&3|0)==1){a=u&-8;t=u>>>3;i:do if(u>>>0>=256){l=c[p+((n|24)+q)>>2]|0;t=c[p+(q+12+n)>>2]|0;do if((t|0)==(o|0)){v=n|16;u=p+(r+v)|0;t=c[u>>2]|0;if(!t){u=p+(v+q)|0;t=c[u>>2]|0;if(!t){g=0;break}}while(1){w=t+20|0;v=c[w>>2]|0;if(v){t=v;u=w;continue}w=t+16|0;v=c[w>>2]|0;if(!v)break;else{t=v;u=w}}if(u>>>0<s>>>0)Wa();else{c[u>>2]=0;g=t;break}}else{u=c[p+((n|8)+q)>>2]|0;if(u>>>0<s>>>0)Wa();v=u+12|0;if((c[v>>2]|0)!=(o|0))Wa();s=t+8|0;if((c[s>>2]|0)==(o|0)){c[v>>2]=t;c[s>>2]=u;g=t;break}else Wa()}while(0);if(!l)break;s=c[p+(q+28+n)>>2]|0;t=5128+(s<<2)|0;do if((o|0)!=(c[t>>2]|0)){if(l>>>0<(c[1210]|0)>>>0)Wa();s=l+16|0;if((c[s>>2]|0)==(o|0))c[s>>2]=g;else c[l+20>>2]=g;if(!g)break i}else{c[t>>2]=g;if(g)break;c[1207]=c[1207]&~(1<<s);break i}while(0);o=c[1210]|0;if(g>>>0<o>>>0)Wa();c[g+24>>2]=l;s=n|16;l=c[p+(s+q)>>2]|0;do if(l)if(l>>>0<o>>>0)Wa();else{c[g+16>>2]=l;c[l+24>>2]=g;break}while(0);l=c[p+(r+s)>>2]|0;if(!l)break;if(l>>>0<(c[1210]|0)>>>0)Wa();else{c[g+20>>2]=l;c[l+24>>2]=g;break}}else{g=c[p+((n|8)+q)>>2]|0;r=c[p+(q+12+n)>>2]|0;u=4864+(t<<1<<2)|0;do if((g|0)!=(u|0)){if(g>>>0<s>>>0)Wa();if((c[g+12>>2]|0)==(o|0))break;Wa()}while(0);if((r|0)==(g|0)){c[1206]=c[1206]&~(1<<t);break}do if((r|0)==(u|0))l=r+8|0;else{if(r>>>0<s>>>0)Wa();s=r+8|0;if((c[s>>2]|0)==(o|0)){l=s;break}Wa()}while(0);c[g+12>>2]=r;c[l>>2]=g}while(0);o=p+((a|n)+q)|0;m=a+m|0}g=o+4|0;c[g>>2]=c[g>>2]&-2;c[p+(k+4)>>2]=m|1;c[p+(m+k)>>2]=m;g=m>>>3;if(m>>>0<256){l=g<<1;d=4864+(l<<2)|0;m=c[1206]|0;g=1<<g;do if(!(m&g)){c[1206]=m|g;f=4864+(l+2<<2)|0;e=d}else{l=4864+(l+2<<2)|0;g=c[l>>2]|0;if(g>>>0>=(c[1210]|0)>>>0){f=l;e=g;break}Wa()}while(0);c[f>>2]=j;c[e+12>>2]=j;c[p+(k+8)>>2]=e;c[p+(k+12)>>2]=d;break}e=m>>>8;do if(!e)e=0;else{if(m>>>0>16777215){e=31;break}G=(e+1048320|0)>>>16&8;H=e<<G;F=(H+520192|0)>>>16&4;H=H<<F;e=(H+245760|0)>>>16&2;e=14-(F|G|e)+(H<<e>>>15)|0;e=m>>>(e+7|0)&1|e<<1}while(0);l=5128+(e<<2)|0;c[p+(k+28)>>2]=e;c[p+(k+20)>>2]=0;c[p+(k+16)>>2]=0;g=c[1207]|0;f=1<<e;if(!(g&f)){c[1207]=g|f;c[l>>2]=j;c[p+(k+24)>>2]=l;c[p+(k+12)>>2]=j;c[p+(k+8)>>2]=j;break}f=c[l>>2]|0;if((e|0)==31)e=0;else e=25-(e>>>1)|0;j:do if((c[f+4>>2]&-8|0)!=(m|0)){e=m<<e;while(1){g=f+(e>>>31<<2)+16|0;l=c[g>>2]|0;if(!l)break;if((c[l+4>>2]&-8|0)==(m|0)){d=l;break j}else{e=e<<1;f=l}}if(g>>>0<(c[1210]|0)>>>0)Wa();else{c[g>>2]=j;c[p+(k+24)>>2]=f;c[p+(k+12)>>2]=j;c[p+(k+8)>>2]=j;break h}}else d=f;while(0);e=d+8|0;f=c[e>>2]|0;H=c[1210]|0;if(d>>>0>=H>>>0&f>>>0>=H>>>0){c[f+12>>2]=j;c[e>>2]=j;c[p+(k+8)>>2]=f;c[p+(k+12)>>2]=d;c[p+(k+24)>>2]=0;break}else Wa()}else{H=(c[1209]|0)+m|0;c[1209]=H;c[1212]=j;c[p+(k+4)>>2]=H|1}while(0);H=p+(h|8)|0;i=b;return H|0}e=5272|0;while(1){d=c[e>>2]|0;if(d>>>0<=r>>>0?(n=c[e+4>>2]|0,m=d+n|0,m>>>0>r>>>0):0)break;e=c[e+8>>2]|0}e=d+(n+ -39)|0;if(!(e&7))e=0;else e=0-e&7;d=d+(n+ -47+e)|0;d=d>>>0<(r+16|0)>>>0?r:d;e=d+8|0;f=p+8|0;if(!(f&7))f=0;else f=0-f&7;H=q+ -40-f|0;c[1212]=p+f;c[1209]=H;c[p+(f+4)>>2]=H|1;c[p+(q+ -36)>>2]=40;c[1213]=c[1328];c[d+4>>2]=27;c[e+0>>2]=c[1318];c[e+4>>2]=c[1319];c[e+8>>2]=c[1320];c[e+12>>2]=c[1321];c[1318]=p;c[1319]=q;c[1321]=0;c[1320]=e;e=d+28|0;c[e>>2]=7;if((d+32|0)>>>0<m>>>0)do{H=e;e=e+4|0;c[e>>2]=7}while((H+8|0)>>>0<m>>>0);if((d|0)!=(r|0)){d=d-r|0;e=r+(d+4)|0;c[e>>2]=c[e>>2]&-2;c[r+4>>2]=d|1;c[r+d>>2]=d;e=d>>>3;if(d>>>0<256){f=e<<1;d=4864+(f<<2)|0;g=c[1206]|0;e=1<<e;do if(!(g&e)){c[1206]=g|e;k=4864+(f+2<<2)|0;j=d}else{f=4864+(f+2<<2)|0;e=c[f>>2]|0;if(e>>>0>=(c[1210]|0)>>>0){k=f;j=e;break}Wa()}while(0);c[k>>2]=r;c[j+12>>2]=r;c[r+8>>2]=j;c[r+12>>2]=d;break}e=d>>>8;if(e)if(d>>>0>16777215)e=31;else{G=(e+1048320|0)>>>16&8;H=e<<G;F=(H+520192|0)>>>16&4;H=H<<F;e=(H+245760|0)>>>16&2;e=14-(F|G|e)+(H<<e>>>15)|0;e=d>>>(e+7|0)&1|e<<1}else e=0;j=5128+(e<<2)|0;c[r+28>>2]=e;c[r+20>>2]=0;c[r+16>>2]=0;f=c[1207]|0;g=1<<e;if(!(f&g)){c[1207]=f|g;c[j>>2]=r;c[r+24>>2]=j;c[r+12>>2]=r;c[r+8>>2]=r;break}f=c[j>>2]|0;if((e|0)==31)e=0;else e=25-(e>>>1)|0;k:do if((c[f+4>>2]&-8|0)!=(d|0)){e=d<<e;j=f;while(1){f=j+(e>>>31<<2)+16|0;g=c[f>>2]|0;if(!g)break;if((c[g+4>>2]&-8|0)==(d|0)){h=g;break k}else{e=e<<1;j=g}}if(f>>>0<(c[1210]|0)>>>0)Wa();else{c[f>>2]=r;c[r+24>>2]=j;c[r+12>>2]=r;c[r+8>>2]=r;break g}}else h=f;while(0);e=h+8|0;d=c[e>>2]|0;H=c[1210]|0;if(h>>>0>=H>>>0&d>>>0>=H>>>0){c[d+12>>2]=r;c[e>>2]=r;c[r+8>>2]=d;c[r+12>>2]=h;c[r+24>>2]=0;break}else Wa()}}else{H=c[1210]|0;if((H|0)==0|p>>>0<H>>>0)c[1210]=p;c[1318]=p;c[1319]=q;c[1321]=0;c[1215]=c[1324];c[1214]=-1;d=0;do{H=d<<1;G=4864+(H<<2)|0;c[4864+(H+3<<2)>>2]=G;c[4864+(H+2<<2)>>2]=G;d=d+1|0}while((d|0)!=32);d=p+8|0;if(!(d&7))d=0;else d=0-d&7;H=q+ -40-d|0;c[1212]=p+d;c[1209]=H;c[p+(d+4)>>2]=H|1;c[p+(q+ -36)>>2]=40;c[1213]=c[1328]}while(0);d=c[1209]|0;if(d>>>0>a>>>0){G=d-a|0;c[1209]=G;H=c[1212]|0;c[1212]=H+a;c[H+(a+4)>>2]=G|1;c[H+4>>2]=a|3;H=H+8|0;i=b;return H|0}}c[(Oa()|0)>>2]=12;H=0;i=b;return H|0}function Td(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;b=i;if(!a){i=b;return}q=a+ -8|0;r=c[1210]|0;if(q>>>0<r>>>0)Wa();n=c[a+ -4>>2]|0;m=n&3;if((m|0)==1)Wa();j=n&-8;h=a+(j+ -8)|0;do if(!(n&1)){u=c[q>>2]|0;if(!m){i=b;return}q=-8-u|0;n=a+q|0;m=u+j|0;if(n>>>0<r>>>0)Wa();if((n|0)==(c[1211]|0)){e=a+(j+ -4)|0;o=c[e>>2]|0;if((o&3|0)!=3){e=n;o=m;break}c[1208]=m;c[e>>2]=o&-2;c[a+(q+4)>>2]=m|1;c[h>>2]=m;i=b;return}t=u>>>3;if(u>>>0<256){e=c[a+(q+8)>>2]|0;o=c[a+(q+12)>>2]|0;p=4864+(t<<1<<2)|0;if((e|0)!=(p|0)){if(e>>>0<r>>>0)Wa();if((c[e+12>>2]|0)!=(n|0))Wa()}if((o|0)==(e|0)){c[1206]=c[1206]&~(1<<t);e=n;o=m;break}if((o|0)!=(p|0)){if(o>>>0<r>>>0)Wa();p=o+8|0;if((c[p>>2]|0)==(n|0))s=p;else Wa()}else s=o+8|0;c[e+12>>2]=o;c[s>>2]=e;e=n;o=m;break}s=c[a+(q+24)>>2]|0;t=c[a+(q+12)>>2]|0;do if((t|0)==(n|0)){u=a+(q+20)|0;t=c[u>>2]|0;if(!t){u=a+(q+16)|0;t=c[u>>2]|0;if(!t){p=0;break}}while(1){v=t+20|0;w=c[v>>2]|0;if(w){t=w;u=v;continue}v=t+16|0;w=c[v>>2]|0;if(!w)break;else{t=w;u=v}}if(u>>>0<r>>>0)Wa();else{c[u>>2]=0;p=t;break}}else{u=c[a+(q+8)>>2]|0;if(u>>>0<r>>>0)Wa();r=u+12|0;if((c[r>>2]|0)!=(n|0))Wa();v=t+8|0;if((c[v>>2]|0)==(n|0)){c[r>>2]=t;c[v>>2]=u;p=t;break}else Wa()}while(0);if(s){r=c[a+(q+28)>>2]|0;t=5128+(r<<2)|0;if((n|0)==(c[t>>2]|0)){c[t>>2]=p;if(!p){c[1207]=c[1207]&~(1<<r);e=n;o=m;break}}else{if(s>>>0<(c[1210]|0)>>>0)Wa();r=s+16|0;if((c[r>>2]|0)==(n|0))c[r>>2]=p;else c[s+20>>2]=p;if(!p){e=n;o=m;break}}r=c[1210]|0;if(p>>>0<r>>>0)Wa();c[p+24>>2]=s;s=c[a+(q+16)>>2]|0;do if(s)if(s>>>0<r>>>0)Wa();else{c[p+16>>2]=s;c[s+24>>2]=p;break}while(0);q=c[a+(q+20)>>2]|0;if(q)if(q>>>0<(c[1210]|0)>>>0)Wa();else{c[p+20>>2]=q;c[q+24>>2]=p;e=n;o=m;break}else{e=n;o=m}}else{e=n;o=m}}else{e=q;o=j}while(0);if(e>>>0>=h>>>0)Wa();m=a+(j+ -4)|0;n=c[m>>2]|0;if(!(n&1))Wa();if(!(n&2)){if((h|0)==(c[1212]|0)){w=(c[1209]|0)+o|0;c[1209]=w;c[1212]=e;c[e+4>>2]=w|1;if((e|0)!=(c[1211]|0)){i=b;return}c[1211]=0;c[1208]=0;i=b;return}if((h|0)==(c[1211]|0)){w=(c[1208]|0)+o|0;c[1208]=w;c[1211]=e;c[e+4>>2]=w|1;c[e+w>>2]=w;i=b;return}o=(n&-8)+o|0;m=n>>>3;do if(n>>>0>=256){l=c[a+(j+16)>>2]|0;m=c[a+(j|4)>>2]|0;do if((m|0)==(h|0)){n=a+(j+12)|0;m=c[n>>2]|0;if(!m){n=a+(j+8)|0;m=c[n>>2]|0;if(!m){k=0;break}}while(1){q=m+20|0;p=c[q>>2]|0;if(p){m=p;n=q;continue}p=m+16|0;q=c[p>>2]|0;if(!q)break;else{m=q;n=p}}if(n>>>0<(c[1210]|0)>>>0)Wa();else{c[n>>2]=0;k=m;break}}else{n=c[a+j>>2]|0;if(n>>>0<(c[1210]|0)>>>0)Wa();p=n+12|0;if((c[p>>2]|0)!=(h|0))Wa();q=m+8|0;if((c[q>>2]|0)==(h|0)){c[p>>2]=m;c[q>>2]=n;k=m;break}else Wa()}while(0);if(l){m=c[a+(j+20)>>2]|0;n=5128+(m<<2)|0;if((h|0)==(c[n>>2]|0)){c[n>>2]=k;if(!k){c[1207]=c[1207]&~(1<<m);break}}else{if(l>>>0<(c[1210]|0)>>>0)Wa();m=l+16|0;if((c[m>>2]|0)==(h|0))c[m>>2]=k;else c[l+20>>2]=k;if(!k)break}h=c[1210]|0;if(k>>>0<h>>>0)Wa();c[k+24>>2]=l;l=c[a+(j+8)>>2]|0;do if(l)if(l>>>0<h>>>0)Wa();else{c[k+16>>2]=l;c[l+24>>2]=k;break}while(0);h=c[a+(j+12)>>2]|0;if(h)if(h>>>0<(c[1210]|0)>>>0)Wa();else{c[k+20>>2]=h;c[h+24>>2]=k;break}}}else{k=c[a+j>>2]|0;j=c[a+(j|4)>>2]|0;a=4864+(m<<1<<2)|0;if((k|0)!=(a|0)){if(k>>>0<(c[1210]|0)>>>0)Wa();if((c[k+12>>2]|0)!=(h|0))Wa()}if((j|0)==(k|0)){c[1206]=c[1206]&~(1<<m);break}if((j|0)!=(a|0)){if(j>>>0<(c[1210]|0)>>>0)Wa();a=j+8|0;if((c[a>>2]|0)==(h|0))l=a;else Wa()}else l=j+8|0;c[k+12>>2]=j;c[l>>2]=k}while(0);c[e+4>>2]=o|1;c[e+o>>2]=o;if((e|0)==(c[1211]|0)){c[1208]=o;i=b;return}}else{c[m>>2]=n&-2;c[e+4>>2]=o|1;c[e+o>>2]=o}h=o>>>3;if(o>>>0<256){j=h<<1;d=4864+(j<<2)|0;k=c[1206]|0;h=1<<h;if(k&h){j=4864+(j+2<<2)|0;h=c[j>>2]|0;if(h>>>0<(c[1210]|0)>>>0)Wa();else{f=j;g=h}}else{c[1206]=k|h;f=4864+(j+2<<2)|0;g=d}c[f>>2]=e;c[g+12>>2]=e;c[e+8>>2]=g;c[e+12>>2]=d;i=b;return}f=o>>>8;if(f)if(o>>>0>16777215)f=31;else{v=(f+1048320|0)>>>16&8;w=f<<v;u=(w+520192|0)>>>16&4;w=w<<u;f=(w+245760|0)>>>16&2;f=14-(u|v|f)+(w<<f>>>15)|0;f=o>>>(f+7|0)&1|f<<1}else f=0;g=5128+(f<<2)|0;c[e+28>>2]=f;c[e+20>>2]=0;c[e+16>>2]=0;j=c[1207]|0;h=1<<f;a:do if(j&h){g=c[g>>2]|0;if((f|0)==31)f=0;else f=25-(f>>>1)|0;b:do if((c[g+4>>2]&-8|0)!=(o|0)){f=o<<f;while(1){j=g+(f>>>31<<2)+16|0;h=c[j>>2]|0;if(!h)break;if((c[h+4>>2]&-8|0)==(o|0)){d=h;break b}else{f=f<<1;g=h}}if(j>>>0<(c[1210]|0)>>>0)Wa();else{c[j>>2]=e;c[e+24>>2]=g;c[e+12>>2]=e;c[e+8>>2]=e;break a}}else d=g;while(0);g=d+8|0;f=c[g>>2]|0;w=c[1210]|0;if(d>>>0>=w>>>0&f>>>0>=w>>>0){c[f+12>>2]=e;c[g>>2]=e;c[e+8>>2]=f;c[e+12>>2]=d;c[e+24>>2]=0;break}else Wa()}else{c[1207]=j|h;c[g>>2]=e;c[e+24>>2]=g;c[e+12>>2]=e;c[e+8>>2]=e}while(0);w=(c[1214]|0)+ -1|0;c[1214]=w;if(!w)d=5280|0;else{i=b;return}while(1){d=c[d>>2]|0;if(!d)break;else d=d+8|0}c[1214]=-1;i=b;return}function Ud(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=i;do if(a){if(b>>>0>4294967231){c[(Oa()|0)>>2]=12;e=0;break}if(b>>>0<11)e=16;else e=b+11&-8;e=fe(a+ -8|0,e)|0;if(e){e=e+8|0;break}e=Sd(b)|0;if(!e)e=0;else{f=c[a+ -4>>2]|0;f=(f&-8)-((f&3|0)==0?8:4)|0;pe(e|0,a|0,(f>>>0<b>>>0?f:b)|0)|0;Td(a)}}else e=Sd(b)|0;while(0);i=d;return e|0}function Vd(a){a=a|0;if((a|0)==32)a=1;else a=(a+ -9|0)>>>0<5;return a&1|0}function Wd(b,e,f,g,h){b=b|0;e=e|0;f=f|0;g=g|0;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0;j=i;if(e>>>0>36){c[(Oa()|0)>>2]=22;s=0;t=0;F=s;i=j;return t|0}k=b+4|0;l=b+100|0;do{m=c[k>>2]|0;if(m>>>0<(c[l>>2]|0)>>>0){c[k>>2]=m+1;o=d[m>>0]|0}else o=Zd(b)|0}while((Vd(o)|0)!=0);do if((o|0)==43|(o|0)==45){m=((o|0)==45)<<31>>31;n=c[k>>2]|0;if(n>>>0<(c[l>>2]|0)>>>0){c[k>>2]=n+1;o=d[n>>0]|0;break}else{o=Zd(b)|0;break}}else m=0;while(0);n=(e|0)==0;do if((e&-17|0)==0&(o|0)==48){o=c[k>>2]|0;if(o>>>0<(c[l>>2]|0)>>>0){c[k>>2]=o+1;o=d[o>>0]|0}else o=Zd(b)|0;if((o|32|0)!=120)if(n){e=8;f=46;break}else{f=32;break}e=c[k>>2]|0;if(e>>>0<(c[l>>2]|0)>>>0){c[k>>2]=e+1;o=d[e>>0]|0}else o=Zd(b)|0;if((d[o+5321>>0]|0)>15){g=(c[l>>2]|0)==0;if(!g)c[k>>2]=(c[k>>2]|0)+ -1;if(!f){Yd(b,0);s=0;t=0;F=s;i=j;return t|0}if(g){s=0;t=0;F=s;i=j;return t|0}c[k>>2]=(c[k>>2]|0)+ -1;s=0;t=0;F=s;i=j;return t|0}else{e=16;f=46}}else{e=n?10:e;if((d[o+5321>>0]|0)>>>0<e>>>0)f=32;else{if(c[l>>2]|0)c[k>>2]=(c[k>>2]|0)+ -1;Yd(b,0);c[(Oa()|0)>>2]=22;s=0;t=0;F=s;i=j;return t|0}}while(0);if((f|0)==32)if((e|0)==10){e=o+ -48|0;if(e>>>0<10){n=0;do{n=(n*10|0)+e|0;e=c[k>>2]|0;if(e>>>0<(c[l>>2]|0)>>>0){c[k>>2]=e+1;o=d[e>>0]|0}else o=Zd(b)|0;e=o+ -48|0}while(e>>>0<10&n>>>0<429496729);p=0}else{n=0;p=0}e=o+ -48|0;if(e>>>0<10){do{q=we(n|0,p|0,10,0)|0;r=F;s=((e|0)<0)<<31>>31;t=~s;if(r>>>0>t>>>0|(r|0)==(t|0)&q>>>0>~e>>>0)break;n=ne(q|0,r|0,e|0,s|0)|0;p=F;e=c[k>>2]|0;if(e>>>0<(c[l>>2]|0)>>>0){c[k>>2]=e+1;o=d[e>>0]|0}else o=Zd(b)|0;e=o+ -48|0}while(e>>>0<10&(p>>>0<429496729|(p|0)==429496729&n>>>0<2576980378));if(e>>>0<=9){e=10;f=72}}}else f=46;a:do if((f|0)==46){if(!(e+ -1&e)){f=a[5584+((e*23|0)>>>5&7)>>0]|0;r=a[o+5321>>0]|0;n=r&255;if(n>>>0<e>>>0){o=n;n=0;do{n=o|n<<f;o=c[k>>2]|0;if(o>>>0<(c[l>>2]|0)>>>0){c[k>>2]=o+1;s=d[o>>0]|0}else s=Zd(b)|0;r=a[s+5321>>0]|0;o=r&255}while(o>>>0<e>>>0&n>>>0<134217728);p=0}else{p=0;n=0;s=o}o=oe(-1,-1,f|0)|0;q=F;if((r&255)>>>0>=e>>>0|(p>>>0>q>>>0|(p|0)==(q|0)&n>>>0>o>>>0)){o=s;f=72;break}while(1){n=le(n|0,p|0,f|0)|0;p=F;n=r&255|n;r=c[k>>2]|0;if(r>>>0<(c[l>>2]|0)>>>0){c[k>>2]=r+1;s=d[r>>0]|0}else s=Zd(b)|0;r=a[s+5321>>0]|0;if((r&255)>>>0>=e>>>0|(p>>>0>q>>>0|(p|0)==(q|0)&n>>>0>o>>>0)){o=s;f=72;break a}}}r=a[o+5321>>0]|0;f=r&255;if(f>>>0<e>>>0){n=0;do{n=f+(ba(n,e)|0)|0;f=c[k>>2]|0;if(f>>>0<(c[l>>2]|0)>>>0){c[k>>2]=f+1;q=d[f>>0]|0}else q=Zd(b)|0;r=a[q+5321>>0]|0;f=r&255}while(f>>>0<e>>>0&n>>>0<119304647);p=0}else{n=0;p=0;q=o}if((r&255)>>>0<e>>>0){f=xe(-1,-1,e|0,0)|0;o=F;while(1){if(p>>>0>o>>>0|(p|0)==(o|0)&n>>>0>f>>>0){o=q;f=72;break a}s=we(n|0,p|0,e|0,0)|0;t=F;r=r&255;if(t>>>0>4294967295|(t|0)==-1&s>>>0>~r>>>0){o=q;f=72;break a}n=ne(r|0,0,s|0,t|0)|0;p=F;q=c[k>>2]|0;if(q>>>0<(c[l>>2]|0)>>>0){c[k>>2]=q+1;q=d[q>>0]|0}else q=Zd(b)|0;r=a[q+5321>>0]|0;if((r&255)>>>0>=e>>>0){o=q;f=72;break}}}else{o=q;f=72}}while(0);if((f|0)==72)if((d[o+5321>>0]|0)>>>0<e>>>0){do{f=c[k>>2]|0;if(f>>>0<(c[l>>2]|0)>>>0){c[k>>2]=f+1;f=d[f>>0]|0}else f=Zd(b)|0}while((d[f+5321>>0]|0)>>>0<e>>>0);c[(Oa()|0)>>2]=34;p=h;n=g}if(c[l>>2]|0)c[k>>2]=(c[k>>2]|0)+ -1;if(!(p>>>0<h>>>0|(p|0)==(h|0)&n>>>0<g>>>0)){if(!((g&1|0)!=0|0!=0|(m|0)!=0)){c[(Oa()|0)>>2]=34;t=ne(g|0,h|0,-1,-1)|0;s=F;F=s;i=j;return t|0}if(p>>>0>h>>>0|(p|0)==(h|0)&n>>>0>g>>>0){c[(Oa()|0)>>2]=34;s=h;t=g;F=s;i=j;return t|0}}t=((m|0)<0)<<31>>31;t=je(n^m|0,p^t|0,m|0,t|0)|0;s=F;F=s;i=j;return t|0}



  function Xd(b,e,f){b=b|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0.0,r=0,s=0,t=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0.0,H=0,I=0.0,J=0.0,K=0.0,L=0.0;g=i;i=i+512|0;k=g;if(!e){e=24;j=-149}else if((e|0)==2){e=53;j=-1074}else if((e|0)==1){e=53;j=-1074}else{J=0.0;i=g;return+J}n=b+4|0;o=b+100|0;do{h=c[n>>2]|0;if(h>>>0<(c[o>>2]|0)>>>0){c[n>>2]=h+1;w=d[h>>0]|0}else w=Zd(b)|0}while((Vd(w)|0)!=0);do if((w|0)==43|(w|0)==45){h=1-(((w|0)==45&1)<<1)|0;m=c[n>>2]|0;if(m>>>0<(c[o>>2]|0)>>>0){c[n>>2]=m+1;w=d[m>>0]|0;break}else{w=Zd(b)|0;break}}else h=1;while(0);r=0;do{if((w|32|0)!=(a[5600+r>>0]|0))break;do if(r>>>0<7){m=c[n>>2]|0;if(m>>>0<(c[o>>2]|0)>>>0){c[n>>2]=m+1;w=d[m>>0]|0;break}else{w=Zd(b)|0;break}}while(0);r=r+1|0}while(r>>>0<8);do if((r|0)==3)p=23;else if((r|0)!=8){m=(f|0)!=0;if(r>>>0>3&m)if((r|0)==8)break;else{p=23;break}a:do if(!r){r=0;do{if((w|32|0)!=(a[5616+r>>0]|0))break a;do if(r>>>0<2){s=c[n>>2]|0;if(s>>>0<(c[o>>2]|0)>>>0){c[n>>2]=s+1;w=d[s>>0]|0;break}else{w=Zd(b)|0;break}}while(0);r=r+1|0}while(r>>>0<3)}while(0);if(!r){do if((w|0)==48){m=c[n>>2]|0;if(m>>>0<(c[o>>2]|0)>>>0){c[n>>2]=m+1;m=d[m>>0]|0}else m=Zd(b)|0;if((m|32|0)!=120){if(!(c[o>>2]|0)){w=48;break}c[n>>2]=(c[n>>2]|0)+ -1;w=48;break}k=c[n>>2]|0;if(k>>>0<(c[o>>2]|0)>>>0){c[n>>2]=k+1;z=d[k>>0]|0;x=0}else{z=Zd(b)|0;x=0}while(1){if((z|0)==46){p=70;break}else if((z|0)!=48){k=0;m=0;s=0;r=0;w=0;y=0;G=1.0;t=0;q=0.0;break}k=c[n>>2]|0;if(k>>>0<(c[o>>2]|0)>>>0){c[n>>2]=k+1;z=d[k>>0]|0;x=1;continue}else{z=Zd(b)|0;x=1;continue}}if((p|0)==70){k=c[n>>2]|0;if(k>>>0<(c[o>>2]|0)>>>0){c[n>>2]=k+1;z=d[k>>0]|0}else z=Zd(b)|0;if((z|0)==48){s=0;r=0;do{k=c[n>>2]|0;if(k>>>0<(c[o>>2]|0)>>>0){c[n>>2]=k+1;z=d[k>>0]|0}else z=Zd(b)|0;s=ne(s|0,r|0,-1,-1)|0;r=F}while((z|0)==48);k=0;m=0;x=1;w=1;y=0;G=1.0;t=0;q=0.0}else{k=0;m=0;s=0;r=0;w=1;y=0;G=1.0;t=0;q=0.0}}b:while(1){B=z+ -48|0;do if(B>>>0>=10){A=z|32;C=(z|0)==46;if(!((A+ -97|0)>>>0<6|C))break b;if(C)if(!w){s=m;r=k;w=1;break}else{z=46;break b}else{B=(z|0)>57?A+ -87|0:B;p=83;break}}else p=83;while(0);if((p|0)==83){p=0;do if(!((k|0)<0|(k|0)==0&m>>>0<8)){if((k|0)<0|(k|0)==0&m>>>0<14){J=G*.0625;I=J;q=q+J*+(B|0);break}if((B|0)==0|(y|0)!=0)I=G;else{y=1;I=G;q=q+G*.5}}else{I=G;t=B+(t<<4)|0}while(0);m=ne(m|0,k|0,1,0)|0;k=F;x=1;G=I}z=c[n>>2]|0;if(z>>>0<(c[o>>2]|0)>>>0){c[n>>2]=z+1;z=d[z>>0]|0;continue}else{z=Zd(b)|0;continue}}if(!x){e=(c[o>>2]|0)==0;if(!e)c[n>>2]=(c[n>>2]|0)+ -1;if(f){if(!e?(l=c[n>>2]|0,c[n>>2]=l+ -1,(w|0)!=0):0)c[n>>2]=l+ -2}else Yd(b,0);J=+(h|0)*0.0;i=g;return+J}p=(w|0)==0;l=p?m:s;p=p?k:r;if((k|0)<0|(k|0)==0&m>>>0<8)do{t=t<<4;m=ne(m|0,k|0,1,0)|0;k=F}while((k|0)<0|(k|0)==0&m>>>0<8);do if((z|32|0)==112){m=he(b,f)|0;k=F;if((m|0)==0&(k|0)==-2147483648)if(!f){Yd(b,0);J=0.0;i=g;return+J}else{if(!(c[o>>2]|0)){m=0;k=0;break}c[n>>2]=(c[n>>2]|0)+ -1;m=0;k=0;break}}else if(!(c[o>>2]|0)){m=0;k=0}else{c[n>>2]=(c[n>>2]|0)+ -1;m=0;k=0}while(0);l=le(l|0,p|0,2)|0;l=ne(l|0,F|0,-32,-1)|0;k=ne(l|0,F|0,m|0,k|0)|0;l=F;if(!t){J=+(h|0)*0.0;i=g;return+J}if((l|0)>0|(l|0)==0&k>>>0>(0-j|0)>>>0){c[(Oa()|0)>>2]=34;J=+(h|0)*1.7976931348623157e+308*1.7976931348623157e+308;i=g;return+J}H=j+ -106|0;E=((H|0)<0)<<31>>31;if((l|0)<(E|0)|(l|0)==(E|0)&k>>>0<H>>>0){c[(Oa()|0)>>2]=34;J=+(h|0)*2.2250738585072014e-308*2.2250738585072014e-308;i=g;return+J}if((t|0)>-1)do{t=t<<1;if(!(q>=.5))G=q;else{G=q+-1.0;t=t|1}q=q+G;k=ne(k|0,l|0,-1,-1)|0;l=F}while((t|0)>-1);j=je(32,0,j|0,((j|0)<0)<<31>>31|0)|0;j=ne(k|0,l|0,j|0,F|0)|0;H=F;if(0>(H|0)|0==(H|0)&e>>>0>j>>>0)if((j|0)<0){e=0;p=126}else{e=j;p=124}else p=124;if((p|0)==124)if((e|0)<53)p=126;else{j=e;G=+(h|0);I=0.0}if((p|0)==126){I=+(h|0);j=e;G=I;I=+Va(+(+_d(1.0,84-e|0)),+I)}H=(j|0)<32&q!=0.0&(t&1|0)==0;q=G*(H?0.0:q)+(I+G*+(((H&1)+t|0)>>>0))-I;if(!(q!=0.0))c[(Oa()|0)>>2]=34;J=+$d(q,k);i=g;return+J}while(0);m=j+e|0;l=0-m|0;B=0;while(1){if((w|0)==46){p=137;break}else if((w|0)!=48){D=0;C=0;A=0;break}r=c[n>>2]|0;if(r>>>0<(c[o>>2]|0)>>>0){c[n>>2]=r+1;w=d[r>>0]|0;B=1;continue}else{w=Zd(b)|0;B=1;continue}}if((p|0)==137){p=c[n>>2]|0;if(p>>>0<(c[o>>2]|0)>>>0){c[n>>2]=p+1;w=d[p>>0]|0}else w=Zd(b)|0;if((w|0)==48){D=0;C=0;do{D=ne(D|0,C|0,-1,-1)|0;C=F;p=c[n>>2]|0;if(p>>>0<(c[o>>2]|0)>>>0){c[n>>2]=p+1;w=d[p>>0]|0}else w=Zd(b)|0}while((w|0)==48);B=1;A=1}else{D=0;C=0;A=1}}c[k>>2]=0;z=w+ -48|0;E=(w|0)==46;c:do if(z>>>0<10|E){p=k+496|0;y=0;x=0;t=0;s=0;r=0;d:while(1){do if(E)if(!A){D=y;C=x;A=1}else break d;else{E=ne(y|0,x|0,1,0)|0;x=F;H=(w|0)!=48;if((s|0)>=125){if(!H){y=E;break}c[p>>2]=c[p>>2]|1;y=E;break}y=k+(s<<2)|0;if(t)z=w+ -48+((c[y>>2]|0)*10|0)|0;c[y>>2]=z;t=t+1|0;z=(t|0)==9;y=E;B=1;t=z?0:t;s=(z&1)+s|0;r=H?E:r}while(0);w=c[n>>2]|0;if(w>>>0<(c[o>>2]|0)>>>0){c[n>>2]=w+1;w=d[w>>0]|0}else w=Zd(b)|0;z=w+ -48|0;E=(w|0)==46;if(!(z>>>0<10|E)){p=160;break c}}z=(B|0)!=0;p=168}else{y=0;x=0;t=0;s=0;r=0;p=160}while(0);do if((p|0)==160){z=(A|0)==0;D=z?y:D;C=z?x:C;z=(B|0)!=0;if(!(z&(w|32|0)==101))if((w|0)>-1){p=168;break}else{p=170;break}z=he(b,f)|0;w=F;do if((z|0)==0&(w|0)==-2147483648)if(!f){Yd(b,0);J=0.0;i=g;return+J}else{if(!(c[o>>2]|0)){z=0;w=0;break}c[n>>2]=(c[n>>2]|0)+ -1;z=0;w=0;break}while(0);b=ne(z|0,w|0,D|0,C|0)|0;C=F}while(0);if((p|0)==168)if(c[o>>2]|0){c[n>>2]=(c[n>>2]|0)+ -1;if(z)b=D;else p=171}else p=170;if((p|0)==170)if(z)b=D;else p=171;if((p|0)==171){c[(Oa()|0)>>2]=22;Yd(b,0);J=0.0;i=g;return+J}n=c[k>>2]|0;if(!n){J=+(h|0)*0.0;i=g;return+J}if((b|0)==(y|0)&(C|0)==(x|0)&((x|0)<0|(x|0)==0&y>>>0<10)?e>>>0>30|(n>>>e|0)==0:0){J=+(h|0)*+(n>>>0);i=g;return+J}H=(j|0)/-2|0;E=((H|0)<0)<<31>>31;if((C|0)>(E|0)|(C|0)==(E|0)&b>>>0>H>>>0){c[(Oa()|0)>>2]=34;J=+(h|0)*1.7976931348623157e+308*1.7976931348623157e+308;i=g;return+J}H=j+ -106|0;E=((H|0)<0)<<31>>31;if((C|0)<(E|0)|(C|0)==(E|0)&b>>>0<H>>>0){c[(Oa()|0)>>2]=34;J=+(h|0)*2.2250738585072014e-308*2.2250738585072014e-308;i=g;return+J}if(t){if((t|0)<9){n=k+(s<<2)|0;o=c[n>>2]|0;do{o=o*10|0;t=t+1|0}while((t|0)!=9);c[n>>2]=o}s=s+1|0}if((r|0)<9?(r|0)<=(b|0)&(b|0)<18:0){if((b|0)==9){J=+(h|0)*+((c[k>>2]|0)>>>0);i=g;return+J}if((b|0)<9){J=+(h|0)*+((c[k>>2]|0)>>>0)/+(c[5632+(8-b<<2)>>2]|0);i=g;return+J}H=e+27+(ba(b,-3)|0)|0;n=c[k>>2]|0;if((H|0)>30|(n>>>H|0)==0){J=+(h|0)*+(n>>>0)*+(c[5632+(b+ -10<<2)>>2]|0);i=g;return+J}}n=(b|0)%9|0;if(!n){n=0;o=0}else{f=(b|0)>-1?n:n+9|0;p=c[5632+(8-f<<2)>>2]|0;if(s){r=1e9/(p|0)|0;n=0;o=0;t=0;do{D=k+(t<<2)|0;E=c[D>>2]|0;H=((E>>>0)/(p>>>0)|0)+o|0;c[D>>2]=H;o=ba((E>>>0)%(p>>>0)|0,r)|0;E=t;t=t+1|0;if((E|0)==(n|0)&(H|0)==0){n=t&127;b=b+ -9|0}}while((t|0)!=(s|0));if(o){c[k+(s<<2)>>2]=o;s=s+1|0}}else{n=0;s=0}o=0;b=9-f+b|0}e:while(1){f=k+(n<<2)|0;if((b|0)<18){do{r=0;f=s+127|0;while(1){f=f&127;p=k+(f<<2)|0;t=le(c[p>>2]|0,0,29)|0;t=ne(t|0,F|0,r|0,0)|0;r=F;if(r>>>0>0|(r|0)==0&t>>>0>1e9){H=xe(t|0,r|0,1e9,0)|0;t=ye(t|0,r|0,1e9,0)|0;r=H}else r=0;c[p>>2]=t;p=(f|0)==(n|0);if(!((f|0)!=(s+127&127|0)|p))s=(t|0)==0?f:s;if(p)break;else f=f+ -1|0}o=o+ -29|0}while((r|0)==0)}else{if((b|0)!=18)break;do{if((c[f>>2]|0)>>>0>=9007199){b=18;break e}r=0;p=s+127|0;while(1){p=p&127;t=k+(p<<2)|0;w=le(c[t>>2]|0,0,29)|0;w=ne(w|0,F|0,r|0,0)|0;r=F;if(r>>>0>0|(r|0)==0&w>>>0>1e9){H=xe(w|0,r|0,1e9,0)|0;w=ye(w|0,r|0,1e9,0)|0;r=H}else r=0;c[t>>2]=w;t=(p|0)==(n|0);if(!((p|0)!=(s+127&127|0)|t))s=(w|0)==0?p:s;if(t)break;else p=p+ -1|0}o=o+ -29|0}while((r|0)==0)}n=n+127&127;if((n|0)==(s|0)){H=s+127&127;s=k+((s+126&127)<<2)|0;c[s>>2]=c[s>>2]|c[k+(H<<2)>>2];s=H}c[k+(n<<2)>>2]=r;b=b+9|0}f:while(1){f=s+1&127;p=k+((s+127&127)<<2)|0;while(1){t=(b|0)==18;r=(b|0)>27?9:1;while(1){w=0;while(1){x=w+n&127;if((x|0)==(s|0)){w=2;break}y=c[k+(x<<2)>>2]|0;z=c[5624+(w<<2)>>2]|0;if(y>>>0<z>>>0){w=2;break}x=w+1|0;if(y>>>0>z>>>0)break;if((x|0)<2)w=x;else{w=x;break}}if((w|0)==2&t)break f;o=r+o|0;if((n|0)==(s|0))n=s;else break}t=(1<<r)+ -1|0;w=1e9>>>r;x=n;y=0;do{D=k+(n<<2)|0;E=c[D>>2]|0;H=(E>>>r)+y|0;c[D>>2]=H;y=ba(E&t,w)|0;H=(n|0)==(x|0)&(H|0)==0;n=n+1&127;b=H?b+ -9|0:b;x=H?n:x}while((n|0)!=(s|0));if(!y){n=x;continue}if((f|0)!=(x|0))break;c[p>>2]=c[p>>2]|1;n=x}c[k+(s<<2)>>2]=y;n=x;s=f}b=n&127;if((b|0)==(s|0)){c[k+(f+ -1<<2)>>2]=0;s=f}G=+((c[k+(b<<2)>>2]|0)>>>0);b=n+1&127;if((b|0)==(s|0)){s=s+1&127;c[k+(s+ -1<<2)>>2]=0}q=+(h|0);I=q*(G*1.0e9+ +((c[k+(b<<2)>>2]|0)>>>0));h=o+53|0;j=h-j|0;if((j|0)<(e|0))if((j|0)<0){e=0;b=1;p=244}else{e=j;b=1;p=243}else{b=0;p=243}if((p|0)==243)if((e|0)<53)p=244;else{G=0.0;J=0.0}if((p|0)==244){L=+Va(+(+_d(1.0,105-e|0)),+I);K=+cb(+I,+(+_d(1.0,53-e|0)));G=L;J=K;I=L+(I-K)}f=n+2&127;do if((f|0)!=(s|0)){k=c[k+(f<<2)>>2]|0;do if(k>>>0>=5e8){if(k>>>0>5e8){J=q*.75+J;break}if((n+3&127|0)==(s|0)){J=q*.5+J;break}else{J=q*.75+J;break}}else{if((k|0)==0?(n+3&127|0)==(s|0):0)break;J=q*.25+J}while(0);if((53-e|0)<=1)break;if(+cb(+J,1.0)!=0.0)break;J=J+1.0}while(0);q=I+J-G;do if((h&2147483647|0)>(-2-m|0)){if(+Q(+q)>=9007199254740992.0){b=(b|0)!=0&(e|0)==(j|0)?0:b;o=o+1|0;q=q*.5}if((o+50|0)<=(l|0)?!((b|0)!=0&J!=0.0):0)break;c[(Oa()|0)>>2]=34}while(0);L=+$d(q,o);i=g;return+L}else if((r|0)==3){e=c[n>>2]|0;if(e>>>0<(c[o>>2]|0)>>>0){c[n>>2]=e+1;e=d[e>>0]|0}else e=Zd(b)|0;if((e|0)==40)e=1;else{if(!(c[o>>2]|0)){L=u;i=g;return+L}c[n>>2]=(c[n>>2]|0)+ -1;L=u;i=g;return+L}while(1){h=c[n>>2]|0;if(h>>>0<(c[o>>2]|0)>>>0){c[n>>2]=h+1;h=d[h>>0]|0}else h=Zd(b)|0;if(!((h+ -48|0)>>>0<10|(h+ -65|0)>>>0<26)?!((h+ -97|0)>>>0<26|(h|0)==95):0)break;e=e+1|0}if((h|0)==41){L=u;i=g;return+L}h=(c[o>>2]|0)==0;if(!h)c[n>>2]=(c[n>>2]|0)+ -1;if(!m){c[(Oa()|0)>>2]=22;Yd(b,0);L=0.0;i=g;return+L}if((e|0)==0|h){L=u;i=g;return+L}do{e=e+ -1|0;c[n>>2]=(c[n>>2]|0)+ -1}while((e|0)!=0);q=u;i=g;return+q}else{if(c[o>>2]|0)c[n>>2]=(c[n>>2]|0)+ -1;c[(Oa()|0)>>2]=22;Yd(b,0);L=0.0;i=g;return+L}}while(0);if((p|0)==23){e=(c[o>>2]|0)==0;if(!e)c[n>>2]=(c[n>>2]|0)+ -1;if(!(r>>>0<4|(f|0)==0|e))do{c[n>>2]=(c[n>>2]|0)+ -1;r=r+ -1|0}while(r>>>0>3)}L=+(h|0)*v;i=g;return+L}function Yd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;c[a+104>>2]=b;f=c[a+8>>2]|0;e=c[a+4>>2]|0;g=f-e|0;c[a+108>>2]=g;if((b|0)!=0&(g|0)>(b|0)){c[a+100>>2]=e+b;i=d;return}else{c[a+100>>2]=f;i=d;return}}function Zd(b){b=b|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0;f=i;j=b+104|0;l=c[j>>2]|0;if(!((l|0)!=0?(c[b+108>>2]|0)>=(l|0):0))k=3;if((k|0)==3?(e=be(b)|0,(e|0)>=0):0){k=c[j>>2]|0;j=c[b+8>>2]|0;if((k|0)!=0?(g=c[b+4>>2]|0,h=k-(c[b+108>>2]|0)+ -1|0,(j-g|0)>(h|0)):0)c[b+100>>2]=g+h;else c[b+100>>2]=j;g=c[b+4>>2]|0;if(j){l=b+108|0;c[l>>2]=j+1-g+(c[l>>2]|0)}b=g+ -1|0;if((d[b>>0]|0|0)==(e|0)){l=e;i=f;return l|0}a[b>>0]=e;l=e;i=f;return l|0}c[b+100>>2]=0;l=-1;i=f;return l|0}function _d(a,b){a=+a;b=b|0;var d=0,e=0;d=i;if((b|0)>1023){a=a*8.98846567431158e+307;e=b+ -1023|0;if((e|0)>1023){b=b+ -2046|0;b=(b|0)>1023?1023:b;a=a*8.98846567431158e+307}else b=e}else if((b|0)<-1022){a=a*2.2250738585072014e-308;e=b+1022|0;if((e|0)<-1022){b=b+2044|0;b=(b|0)<-1022?-1022:b;a=a*2.2250738585072014e-308}else b=e}b=le(b+1023|0,0,52)|0;e=F;c[k>>2]=b;c[k+4>>2]=e;a=a*+h[k>>3];i=d;return+a}function $d(a,b){a=+a;b=b|0;var c=0;c=i;a=+_d(a,b);i=c;return+a}function ae(b){b=b|0;var d=0,e=0,f=0;e=i;f=b+74|0;d=a[f>>0]|0;a[f>>0]=d+255|d;f=b+20|0;d=b+44|0;if((c[f>>2]|0)>>>0>(c[d>>2]|0)>>>0)eb[c[b+36>>2]&1](b,0,0)|0;c[b+16>>2]=0;c[b+28>>2]=0;c[f>>2]=0;f=c[b>>2]|0;if(!(f&20)){f=c[d>>2]|0;c[b+8>>2]=f;c[b+4>>2]=f;f=0;i=e;return f|0}if(!(f&4)){f=-1;i=e;return f|0}c[b>>2]=f|32;f=-1;i=e;return f|0}function be(a){a=a|0;var b=0,e=0;b=i;i=i+16|0;e=b;if((c[a+8>>2]|0)==0?(ae(a)|0)!=0:0)a=-1;else if((eb[c[a+32>>2]&1](a,e,1)|0)==1)a=d[e>>0]|0;else a=-1;i=b;return a|0}function ce(a,b){a=a|0;b=b|0;var d=0,e=0,f=0.0,g=0,h=0;d=i;i=i+112|0;e=d;h=e+0|0;g=h+112|0;do{c[h>>2]=0;h=h+4|0}while((h|0)<(g|0));g=e+4|0;c[g>>2]=a;h=e+8|0;c[h>>2]=-1;c[e+44>>2]=a;c[e+76>>2]=-1;Yd(e,0);f=+Xd(e,1,1);e=(c[g>>2]|0)-(c[h>>2]|0)+(c[e+108>>2]|0)|0;if(!b){i=d;return+f}if(e)a=a+e|0;c[b>>2]=a;i=d;return+f}function de(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=i;i=i+112|0;g=e;c[g>>2]=0;f=g+4|0;c[f>>2]=a;c[g+44>>2]=a;if((a|0)<0)c[g+8>>2]=-1;else c[g+8>>2]=a+2147483647;c[g+76>>2]=-1;Yd(g,0);d=Wd(g,d,1,-2147483648,0)|0;if(!b){i=e;return d|0}c[b>>2]=a+((c[f>>2]|0)+(c[g+108>>2]|0)-(c[g+8>>2]|0));i=e;return d|0}function ee(b,c){b=b|0;c=c|0;var d=0,e=0,f=0;d=i;f=a[b>>0]|0;e=a[c>>0]|0;if(f<<24>>24==0?1:f<<24>>24!=e<<24>>24)c=f;else{do{b=b+1|0;c=c+1|0;f=a[b>>0]|0;e=a[c>>0]|0}while(!(f<<24>>24==0?1:f<<24>>24!=e<<24>>24));c=f}i=d;return(c&255)-(e&255)|0}function fe(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;d=i;f=a+4|0;e=c[f>>2]|0;l=e&-8;j=a+l|0;m=c[1210]|0;h=e&3;if(!((h|0)!=1&a>>>0>=m>>>0&a>>>0<j>>>0))Wa();g=a+(l|4)|0;p=c[g>>2]|0;if(!(p&1))Wa();if(!h){if(b>>>0<256){r=0;i=d;return r|0}if(l>>>0>=(b+4|0)>>>0?(l-b|0)>>>0<=c[1326]<<1>>>0:0){r=a;i=d;return r|0}r=0;i=d;return r|0}if(l>>>0>=b>>>0){h=l-b|0;if(h>>>0<=15){r=a;i=d;return r|0}c[f>>2]=e&1|b|2;c[a+(b+4)>>2]=h|3;c[g>>2]=c[g>>2]|1;ge(a+b|0,h);r=a;i=d;return r|0}if((j|0)==(c[1212]|0)){g=(c[1209]|0)+l|0;if(g>>>0<=b>>>0){r=0;i=d;return r|0}r=g-b|0;c[f>>2]=e&1|b|2;c[a+(b+4)>>2]=r|1;c[1212]=a+b;c[1209]=r;r=a;i=d;return r|0}if((j|0)==(c[1211]|0)){h=(c[1208]|0)+l|0;if(h>>>0<b>>>0){r=0;i=d;return r|0}g=h-b|0;if(g>>>0>15){c[f>>2]=e&1|b|2;c[a+(b+4)>>2]=g|1;c[a+h>>2]=g;e=a+(h+4)|0;c[e>>2]=c[e>>2]&-2;e=a+b|0}else{c[f>>2]=e&1|h|2;e=a+(h+4)|0;c[e>>2]=c[e>>2]|1;e=0;g=0}c[1208]=g;c[1211]=e;r=a;i=d;return r|0}if(p&2){r=0;i=d;return r|0}g=(p&-8)+l|0;if(g>>>0<b>>>0){r=0;i=d;return r|0}h=g-b|0;o=p>>>3;do if(p>>>0>=256){n=c[a+(l+24)>>2]|0;o=c[a+(l+12)>>2]|0;do if((o|0)==(j|0)){p=a+(l+20)|0;o=c[p>>2]|0;if(!o){p=a+(l+16)|0;o=c[p>>2]|0;if(!o){k=0;break}}while(1){r=o+20|0;q=c[r>>2]|0;if(q){o=q;p=r;continue}q=o+16|0;r=c[q>>2]|0;if(!r)break;else{o=r;p=q}}if(p>>>0<m>>>0)Wa();else{c[p>>2]=0;k=o;break}}else{p=c[a+(l+8)>>2]|0;if(p>>>0<m>>>0)Wa();m=p+12|0;if((c[m>>2]|0)!=(j|0))Wa();q=o+8|0;if((c[q>>2]|0)==(j|0)){c[m>>2]=o;c[q>>2]=p;k=o;break}else Wa()}while(0);if(n){m=c[a+(l+28)>>2]|0;o=5128+(m<<2)|0;if((j|0)==(c[o>>2]|0)){c[o>>2]=k;if(!k){c[1207]=c[1207]&~(1<<m);break}}else{if(n>>>0<(c[1210]|0)>>>0)Wa();m=n+16|0;if((c[m>>2]|0)==(j|0))c[m>>2]=k;else c[n+20>>2]=k;if(!k)break}j=c[1210]|0;if(k>>>0<j>>>0)Wa();c[k+24>>2]=n;m=c[a+(l+16)>>2]|0;do if(m)if(m>>>0<j>>>0)Wa();else{c[k+16>>2]=m;c[m+24>>2]=k;break}while(0);j=c[a+(l+20)>>2]|0;if(j)if(j>>>0<(c[1210]|0)>>>0)Wa();else{c[k+20>>2]=j;c[j+24>>2]=k;break}}}else{k=c[a+(l+8)>>2]|0;l=c[a+(l+12)>>2]|0;p=4864+(o<<1<<2)|0;if((k|0)!=(p|0)){if(k>>>0<m>>>0)Wa();if((c[k+12>>2]|0)!=(j|0))Wa()}if((l|0)==(k|0)){c[1206]=c[1206]&~(1<<o);break}if((l|0)!=(p|0)){if(l>>>0<m>>>0)Wa();m=l+8|0;if((c[m>>2]|0)==(j|0))n=m;else Wa()}else n=l+8|0;c[k+12>>2]=l;c[n>>2]=k}while(0);if(h>>>0<16){c[f>>2]=g|e&1|2;r=a+(g|4)|0;c[r>>2]=c[r>>2]|1;r=a;i=d;return r|0}else{c[f>>2]=e&1|b|2;c[a+(b+4)>>2]=h|3;r=a+(g|4)|0;c[r>>2]=c[r>>2]|1;ge(a+b|0,h);r=a;i=d;return r|0}return 0}function ge(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;d=i;h=a+b|0;l=c[a+4>>2]|0;do if(!(l&1)){p=c[a>>2]|0;if(!(l&3)){i=d;return}l=a+(0-p)|0;m=p+b|0;r=c[1210]|0;if(l>>>0<r>>>0)Wa();if((l|0)==(c[1211]|0)){e=a+(b+4)|0;n=c[e>>2]|0;if((n&3|0)!=3){e=l;n=m;break}c[1208]=m;c[e>>2]=n&-2;c[a+(4-p)>>2]=m|1;c[h>>2]=m;i=d;return}s=p>>>3;if(p>>>0<256){e=c[a+(8-p)>>2]|0;n=c[a+(12-p)>>2]|0;o=4864+(s<<1<<2)|0;if((e|0)!=(o|0)){if(e>>>0<r>>>0)Wa();if((c[e+12>>2]|0)!=(l|0))Wa()}if((n|0)==(e|0)){c[1206]=c[1206]&~(1<<s);e=l;n=m;break}if((n|0)!=(o|0)){if(n>>>0<r>>>0)Wa();o=n+8|0;if((c[o>>2]|0)==(l|0))q=o;else Wa()}else q=n+8|0;c[e+12>>2]=n;c[q>>2]=e;e=l;n=m;break}q=c[a+(24-p)>>2]|0;s=c[a+(12-p)>>2]|0;do if((s|0)==(l|0)){u=16-p|0;t=a+(u+4)|0;s=c[t>>2]|0;if(!s){t=a+u|0;s=c[t>>2]|0;if(!s){o=0;break}}while(1){v=s+20|0;u=c[v>>2]|0;if(u){s=u;t=v;continue}u=s+16|0;v=c[u>>2]|0;if(!v)break;else{s=v;t=u}}if(t>>>0<r>>>0)Wa();else{c[t>>2]=0;o=s;break}}else{t=c[a+(8-p)>>2]|0;if(t>>>0<r>>>0)Wa();r=t+12|0;if((c[r>>2]|0)!=(l|0))Wa();u=s+8|0;if((c[u>>2]|0)==(l|0)){c[r>>2]=s;c[u>>2]=t;o=s;break}else Wa()}while(0);if(q){s=c[a+(28-p)>>2]|0;r=5128+(s<<2)|0;if((l|0)==(c[r>>2]|0)){c[r>>2]=o;if(!o){c[1207]=c[1207]&~(1<<s);e=l;n=m;break}}else{if(q>>>0<(c[1210]|0)>>>0)Wa();r=q+16|0;if((c[r>>2]|0)==(l|0))c[r>>2]=o;else c[q+20>>2]=o;if(!o){e=l;n=m;break}}r=c[1210]|0;if(o>>>0<r>>>0)Wa();c[o+24>>2]=q;p=16-p|0;q=c[a+p>>2]|0;do if(q)if(q>>>0<r>>>0)Wa();else{c[o+16>>2]=q;c[q+24>>2]=o;break}while(0);p=c[a+(p+4)>>2]|0;if(p)if(p>>>0<(c[1210]|0)>>>0)Wa();else{c[o+20>>2]=p;c[p+24>>2]=o;e=l;n=m;break}else{e=l;n=m}}else{e=l;n=m}}else{e=a;n=b}while(0);l=c[1210]|0;if(h>>>0<l>>>0)Wa();m=a+(b+4)|0;o=c[m>>2]|0;if(!(o&2)){if((h|0)==(c[1212]|0)){v=(c[1209]|0)+n|0;c[1209]=v;c[1212]=e;c[e+4>>2]=v|1;if((e|0)!=(c[1211]|0)){i=d;return}c[1211]=0;c[1208]=0;i=d;return}if((h|0)==(c[1211]|0)){v=(c[1208]|0)+n|0;c[1208]=v;c[1211]=e;c[e+4>>2]=v|1;c[e+v>>2]=v;i=d;return}n=(o&-8)+n|0;m=o>>>3;do if(o>>>0>=256){k=c[a+(b+24)>>2]|0;o=c[a+(b+12)>>2]|0;do if((o|0)==(h|0)){o=a+(b+20)|0;m=c[o>>2]|0;if(!m){o=a+(b+16)|0;m=c[o>>2]|0;if(!m){j=0;break}}while(1){p=m+20|0;q=c[p>>2]|0;if(q){m=q;o=p;continue}q=m+16|0;p=c[q>>2]|0;if(!p)break;else{m=p;o=q}}if(o>>>0<l>>>0)Wa();else{c[o>>2]=0;j=m;break}}else{m=c[a+(b+8)>>2]|0;if(m>>>0<l>>>0)Wa();p=m+12|0;if((c[p>>2]|0)!=(h|0))Wa();l=o+8|0;if((c[l>>2]|0)==(h|0)){c[p>>2]=o;c[l>>2]=m;j=o;break}else Wa()}while(0);if(k){m=c[a+(b+28)>>2]|0;l=5128+(m<<2)|0;if((h|0)==(c[l>>2]|0)){c[l>>2]=j;if(!j){c[1207]=c[1207]&~(1<<m);break}}else{if(k>>>0<(c[1210]|0)>>>0)Wa();l=k+16|0;if((c[l>>2]|0)==(h|0))c[l>>2]=j;else c[k+20>>2]=j;if(!j)break}h=c[1210]|0;if(j>>>0<h>>>0)Wa();c[j+24>>2]=k;k=c[a+(b+16)>>2]|0;do if(k)if(k>>>0<h>>>0)Wa();else{c[j+16>>2]=k;c[k+24>>2]=j;break}while(0);h=c[a+(b+20)>>2]|0;if(h)if(h>>>0<(c[1210]|0)>>>0)Wa();else{c[j+20>>2]=h;c[h+24>>2]=j;break}}}else{j=c[a+(b+8)>>2]|0;a=c[a+(b+12)>>2]|0;b=4864+(m<<1<<2)|0;if((j|0)!=(b|0)){if(j>>>0<l>>>0)Wa();if((c[j+12>>2]|0)!=(h|0))Wa()}if((a|0)==(j|0)){c[1206]=c[1206]&~(1<<m);break}if((a|0)!=(b|0)){if(a>>>0<l>>>0)Wa();b=a+8|0;if((c[b>>2]|0)==(h|0))k=b;else Wa()}else k=a+8|0;c[j+12>>2]=a;c[k>>2]=j}while(0);c[e+4>>2]=n|1;c[e+n>>2]=n;if((e|0)==(c[1211]|0)){c[1208]=n;i=d;return}}else{c[m>>2]=o&-2;c[e+4>>2]=n|1;c[e+n>>2]=n}b=n>>>3;if(n>>>0<256){a=b<<1;h=4864+(a<<2)|0;j=c[1206]|0;b=1<<b;if(j&b){a=4864+(a+2<<2)|0;j=c[a>>2]|0;if(j>>>0<(c[1210]|0)>>>0)Wa();else{g=a;f=j}}else{c[1206]=j|b;g=4864+(a+2<<2)|0;f=h}c[g>>2]=e;c[f+12>>2]=e;c[e+8>>2]=f;c[e+12>>2]=h;i=d;return}f=n>>>8;if(f)if(n>>>0>16777215)f=31;else{u=(f+1048320|0)>>>16&8;v=f<<u;t=(v+520192|0)>>>16&4;v=v<<t;f=(v+245760|0)>>>16&2;f=14-(t|u|f)+(v<<f>>>15)|0;f=n>>>(f+7|0)&1|f<<1}else f=0;g=5128+(f<<2)|0;c[e+28>>2]=f;c[e+20>>2]=0;c[e+16>>2]=0;a=c[1207]|0;h=1<<f;if(!(a&h)){c[1207]=a|h;c[g>>2]=e;c[e+24>>2]=g;c[e+12>>2]=e;c[e+8>>2]=e;i=d;return}g=c[g>>2]|0;if((f|0)==31)f=0;else f=25-(f>>>1)|0;a:do if((c[g+4>>2]&-8|0)!=(n|0)){f=n<<f;a=g;while(1){h=a+(f>>>31<<2)+16|0;g=c[h>>2]|0;if(!g)break;if((c[g+4>>2]&-8|0)==(n|0))break a;else{f=f<<1;a=g}}if(h>>>0<(c[1210]|0)>>>0)Wa();c[h>>2]=e;c[e+24>>2]=a;c[e+12>>2]=e;c[e+8>>2]=e;i=d;return}while(0);f=g+8|0;h=c[f>>2]|0;v=c[1210]|0;if(!(g>>>0>=v>>>0&h>>>0>=v>>>0))Wa();c[h+12>>2]=e;c[f>>2]=e;c[e+8>>2]=h;c[e+12>>2]=g;c[e+24>>2]=0;i=d;return}function he(a,b){a=a|0;b=b|0;var e=0,f=0,g=0,h=0,j=0,k=0;e=i;g=a+4|0;h=c[g>>2]|0;f=a+100|0;if(h>>>0<(c[f>>2]|0)>>>0){c[g>>2]=h+1;j=d[h>>0]|0}else j=Zd(a)|0;if((j|0)==43|(j|0)==45){k=c[g>>2]|0;h=(j|0)==45&1;if(k>>>0<(c[f>>2]|0)>>>0){c[g>>2]=k+1;j=d[k>>0]|0}else j=Zd(a)|0;if((j+ -48|0)>>>0>9&(b|0)!=0?(c[f>>2]|0)!=0:0)c[g>>2]=(c[g>>2]|0)+ -1}else h=0;if((j+ -48|0)>>>0>9){if(!(c[f>>2]|0)){j=-2147483648;k=0;F=j;i=e;return k|0}c[g>>2]=(c[g>>2]|0)+ -1;j=-2147483648;k=0;F=j;i=e;return k|0}else b=0;do{b=j+ -48+(b*10|0)|0;j=c[g>>2]|0;if(j>>>0<(c[f>>2]|0)>>>0){c[g>>2]=j+1;j=d[j>>0]|0}else j=Zd(a)|0}while((j+ -48|0)>>>0<10&(b|0)<214748364);k=((b|0)<0)<<31>>31;if((j+ -48|0)>>>0<10)do{k=we(b|0,k|0,10,0)|0;b=F;j=ne(j|0,((j|0)<0)<<31>>31|0,-48,-1)|0;b=ne(j|0,F|0,k|0,b|0)|0;k=F;j=c[g>>2]|0;if(j>>>0<(c[f>>2]|0)>>>0){c[g>>2]=j+1;j=d[j>>0]|0}else j=Zd(a)|0}while((j+ -48|0)>>>0<10&((k|0)<21474836|(k|0)==21474836&b>>>0<2061584302));if((j+ -48|0)>>>0<10)do{j=c[g>>2]|0;if(j>>>0<(c[f>>2]|0)>>>0){c[g>>2]=j+1;j=d[j>>0]|0}else j=Zd(a)|0}while((j+ -48|0)>>>0<10);if(c[f>>2]|0)c[g>>2]=(c[g>>2]|0)+ -1;g=(h|0)!=0;h=je(0,0,b|0,k|0)|0;j=g?F:k;k=g?h:b;F=j;i=e;return k|0}function ie(){}function je(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;b=b-d-(c>>>0>a>>>0|0)>>>0;return(F=b,a-c>>>0|0)|0}function ke(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;f=b+e|0;if((e|0)>=20){d=d&255;i=b&3;h=d|d<<8|d<<16|d<<24;g=f&~3;if(i){i=b+4-i|0;while((b|0)<(i|0)){a[b>>0]=d;b=b+1|0}}while((b|0)<(g|0)){c[b>>2]=h;b=b+4|0}}while((b|0)<(f|0)){a[b>>0]=d;b=b+1|0}return b-e|0}function le(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){F=b<<c|(a&(1<<c)-1<<32-c)>>>32-c;return a<<c}F=a<<c-32;return 0}function me(b){b=b|0;var c=0;c=b;while(a[c>>0]|0)c=c+1|0;return c-b|0}function ne(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;c=a+c>>>0;return(F=b+d+(c>>>0<a>>>0|0)>>>0,c|0)|0}function oe(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){F=b>>>c;return a>>>c|(b&(1<<c)-1)<<32-c}F=0;return b>>>c-32|0}function pe(b,d,e){b=b|0;d=d|0;e=e|0;var f=0;if((e|0)>=4096)return Ca(b|0,d|0,e|0)|0;f=b|0;if((b&3)==(d&3)){while(b&3){if(!e)return f|0;a[b>>0]=a[d>>0]|0;b=b+1|0;d=d+1|0;e=e-1|0}while((e|0)>=4){c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;e=e-4|0}}while((e|0)>0){a[b>>0]=a[d>>0]|0;b=b+1|0;d=d+1|0;e=e-1|0}return f|0}function qe(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){F=b>>c;return a>>>c|(b&(1<<c)-1)<<32-c}F=(b|0)<0?-1:0;return b>>c-32|0}function re(b){b=b|0;var c=0;c=a[n+(b>>>24)>>0]|0;if((c|0)<8)return c|0;c=a[n+(b>>16&255)>>0]|0;if((c|0)<8)return c+8|0;c=a[n+(b>>8&255)>>0]|0;if((c|0)<8)return c+16|0;return(a[n+(b&255)>>0]|0)+24|0}function se(b){b=b|0;var c=0;c=a[m+(b&255)>>0]|0;if((c|0)<8)return c|0;c=a[m+(b>>8&255)>>0]|0;if((c|0)<8)return c+8|0;c=a[m+(b>>16&255)>>0]|0;if((c|0)<8)return c+16|0;return(a[m+(b>>>24)>>0]|0)+24|0}function te(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;f=a&65535;d=b&65535;c=ba(d,f)|0;e=a>>>16;d=(c>>>16)+(ba(d,e)|0)|0;b=b>>>16;a=ba(b,f)|0;return(F=(d>>>16)+(ba(b,e)|0)+(((d&65535)+a|0)>>>16)|0,d+a<<16|c&65535|0)|0}function ue(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;j=b>>31|((b|0)<0?-1:0)<<1;i=((b|0)<0?-1:0)>>31|((b|0)<0?-1:0)<<1;f=d>>31|((d|0)<0?-1:0)<<1;e=((d|0)<0?-1:0)>>31|((d|0)<0?-1:0)<<1;h=je(j^a,i^b,j,i)|0;g=F;b=f^j;a=e^i;a=je((ze(h,g,je(f^c,e^d,f,e)|0,F,0)|0)^b,F^a,b,a)|0;return a|0}function ve(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0;f=i;i=i+8|0;j=f|0;h=b>>31|((b|0)<0?-1:0)<<1;g=((b|0)<0?-1:0)>>31|((b|0)<0?-1:0)<<1;l=e>>31|((e|0)<0?-1:0)<<1;k=((e|0)<0?-1:0)>>31|((e|0)<0?-1:0)<<1;b=je(h^a,g^b,h,g)|0;a=F;ze(b,a,je(l^d,k^e,l,k)|0,F,j)|0;a=je(c[j>>2]^h,c[j+4>>2]^g,h,g)|0;b=F;i=f;return(F=b,a)|0}function we(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0;e=a;f=c;a=te(e,f)|0;c=F;return(F=(ba(b,f)|0)+(ba(d,e)|0)+c|c&0,a|0|0)|0}function xe(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;a=ze(a,b,c,d,0)|0;return a|0}function ye(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;g=i;i=i+8|0;f=g|0;ze(a,b,d,e,f)|0;i=g;return(F=c[f+4>>2]|0,c[f>>2]|0)|0}function ze(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;h=a;j=b;i=j;l=d;g=e;k=g;if(!i){g=(f|0)!=0;if(!k){if(g){c[f>>2]=(h>>>0)%(l>>>0);c[f+4>>2]=0}k=0;m=(h>>>0)/(l>>>0)>>>0;return(F=k,m)|0}else{if(!g){l=0;m=0;return(F=l,m)|0}c[f>>2]=a|0;c[f+4>>2]=b&0;l=0;m=0;return(F=l,m)|0}}m=(k|0)==0;do if(l){if(!m){k=(re(k|0)|0)-(re(i|0)|0)|0;if(k>>>0<=31){m=k+1|0;l=31-k|0;a=k-31>>31;j=m;b=h>>>(m>>>0)&a|i<<l;a=i>>>(m>>>0)&a;k=0;l=h<<l;break}if(!f){l=0;m=0;return(F=l,m)|0}c[f>>2]=a|0;c[f+4>>2]=j|b&0;l=0;m=0;return(F=l,m)|0}k=l-1|0;if(k&l){l=(re(l|0)|0)+33-(re(i|0)|0)|0;p=64-l|0;m=32-l|0;n=m>>31;o=l-32|0;a=o>>31;j=l;b=m-1>>31&i>>>(o>>>0)|(i<<m|h>>>(l>>>0))&a;a=a&i>>>(l>>>0);k=h<<p&n;l=(i<<p|h>>>(o>>>0))&n|h<<m&l-33>>31;break}if(f){c[f>>2]=k&h;c[f+4>>2]=0}if((l|0)==1){o=j|b&0;p=a|0|0;return(F=o,p)|0}else{p=se(l|0)|0;o=i>>>(p>>>0)|0;p=i<<32-p|h>>>(p>>>0)|0;return(F=o,p)|0}}else{if(m){if(f){c[f>>2]=(i>>>0)%(l>>>0);c[f+4>>2]=0}o=0;p=(i>>>0)/(l>>>0)>>>0;return(F=o,p)|0}if(!h){if(f){c[f>>2]=0;c[f+4>>2]=(i>>>0)%(k>>>0)}o=0;p=(i>>>0)/(k>>>0)>>>0;return(F=o,p)|0}l=k-1|0;if(!(l&k)){if(f){c[f>>2]=a|0;c[f+4>>2]=l&i|b&0}o=0;p=i>>>((se(k|0)|0)>>>0);return(F=o,p)|0}k=(re(k|0)|0)-(re(i|0)|0)|0;if(k>>>0<=30){a=k+1|0;l=31-k|0;j=a;b=i<<l|h>>>(a>>>0);a=i>>>(a>>>0);k=0;l=h<<l;break}if(!f){o=0;p=0;return(F=o,p)|0}c[f>>2]=a|0;c[f+4>>2]=j|b&0;o=0;p=0;return(F=o,p)|0}while(0);if(!j){g=l;e=0;i=0}else{h=d|0|0;g=g|e&0;e=ne(h,g,-1,-1)|0;d=F;i=0;do{m=l;l=k>>>31|l<<1;k=i|k<<1;m=b<<1|m>>>31|0;n=b>>>31|a<<1|0;je(e,d,m,n)|0;p=F;o=p>>31|((p|0)<0?-1:0)<<1;i=o&1;b=je(m,n,o&h,(((p|0)<0?-1:0)>>31|((p|0)<0?-1:0)<<1)&g)|0;a=F;j=j-1|0}while((j|0)!=0);g=l;e=0}h=0;if(f){c[f>>2]=b;c[f+4>>2]=a}o=(k|0)>>>31|(g|h)<<1|(h<<1|k>>>31)&0|e;p=(k<<1|0>>>31)&-2|i;return(F=o,p)|0}function Ae(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return eb[a&1](b|0,c|0,d|0)|0}function Be(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;fb[a&3](b|0,c|0,d|0,e|0,f|0)}function Ce(a,b){a=a|0;b=b|0;gb[a&31](b|0)}function De(a,b,c){a=a|0;b=b|0;c=c|0;hb[a&3](b|0,c|0)}function Ee(a,b){a=a|0;b=b|0;return ib[a&1](b|0)|0}function Fe(a){a=a|0;jb[a&3]()}function Ge(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;kb[a&3](b|0,c|0,d|0,e|0,f|0,g|0)}function He(a,b,c){a=a|0;b=b|0;c=c|0;return lb[a&3](b|0,c|0)|0}function Ie(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;mb[a&3](b|0,c|0,d|0,e|0)}function Je(a,b,c){a=a|0;b=b|0;c=c|0;ca(0);return 0}function Ke(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;ca(1)}function Le(a){a=a|0;ca(2)}function Me(a,b){a=a|0;b=b|0;ca(3)}function Ne(a){a=a|0;ca(4);return 0}function Oe(){ca(5)}function Pe(){bb()}function Qe(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;ca(6)}function Re(a,b){a=a|0;b=b|0;ca(7);return 0}function Se(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;ca(8)}




  // EMSCRIPTEN_END_FUNCS
  // (start of meteor/midamble.js)
  // This "midamble" is hacked into the output JS in a place
  // where it has access to the inner function generated
  // by Emscripten, the one that starts with "use asm".
  // NOTE: This doesn't work with minification on!
  /////setInnerMalloc = function (hookedMalloc) {
  /////  _malloc = hookedMalloc;
  /////};
  /////setInnerFree = function (hookedFree) {
  /////  _free = hookedFree;
  /////};
  // (end of meteor/midamble.js)
  var eb=[Je,Dd];var fb=[Ke,Kd,Jd,Ke];var gb=[Le,wb,yb,Ab,Db,Ib,Hb,bc,dc,zc,yc,Oc,rd,qd,yd,Bd,zd,Ad,Cd,zb,Rd,Le,Le,Le,Le,Le,Le,Le,Le,Le,Le,Le];var hb=[Me,Cb,Fb,fc];var ib=[Ne,sd];var jb=[Oe,Pe,Pd,Qd];var kb=[Qe,Md,Ld,Qe];var lb=[Re,Bb,Eb,ec];var mb=[Se,Fd,Gd,Se];return{_yo:$c,_strlen:me,_retireVar:id,_bitshift64Lshr:oe,_unyo:ad,_solve:ed,_bitshift64Shl:le,_getSolution:fd,___cxa_is_pointer_type:Od,_memset:ke,_getNumVars:gd,_memcpy:pe,_getConflictClauseSize:jd,_addClause:dd,_i64Subtract:je,_createTheSolver:bd,_realloc:Ud,_i64Add:ne,_solveAssuming:hd,___cxa_can_catch:Nd,_ensureVar:cd,_getConflictClause:kd,_free:Td,_malloc:Sd,__GLOBAL__I_a:cc,__GLOBAL__I_a127:Pc,runPostSets:ie,stackAlloc:nb,stackSave:ob,stackRestore:pb,setThrew:qb,setTempRet0:tb,getTempRet0:ub,dynCall_iiii:Ae,dynCall_viiiii:Be,dynCall_vi:Ce,dynCall_vii:De,dynCall_ii:Ee,dynCall_v:Fe,dynCall_viiiiii:Ge,dynCall_iii:He,dynCall_viiii:Ie}})


  // EMSCRIPTEN_END_ASM
  (Module.asmGlobalArg,Module.asmLibraryArg,buffer);var _yo=Module["_yo"]=asm["_yo"];var _strlen=Module["_strlen"]=asm["_strlen"];var _retireVar=Module["_retireVar"]=asm["_retireVar"];var _bitshift64Lshr=Module["_bitshift64Lshr"]=asm["_bitshift64Lshr"];var _unyo=Module["_unyo"]=asm["_unyo"];var _solve=Module["_solve"]=asm["_solve"];var _bitshift64Shl=Module["_bitshift64Shl"]=asm["_bitshift64Shl"];var _getSolution=Module["_getSolution"]=asm["_getSolution"];var ___cxa_is_pointer_type=Module["___cxa_is_pointer_type"]=asm["___cxa_is_pointer_type"];var _memset=Module["_memset"]=asm["_memset"];var _getNumVars=Module["_getNumVars"]=asm["_getNumVars"];var _memcpy=Module["_memcpy"]=asm["_memcpy"];var _getConflictClauseSize=Module["_getConflictClauseSize"]=asm["_getConflictClauseSize"];var _addClause=Module["_addClause"]=asm["_addClause"];var _i64Subtract=Module["_i64Subtract"]=asm["_i64Subtract"];var _createTheSolver=Module["_createTheSolver"]=asm["_createTheSolver"];var _realloc=Module["_realloc"]=asm["_realloc"];var _i64Add=Module["_i64Add"]=asm["_i64Add"];var _solveAssuming=Module["_solveAssuming"]=asm["_solveAssuming"];var ___cxa_can_catch=Module["___cxa_can_catch"]=asm["___cxa_can_catch"];var _ensureVar=Module["_ensureVar"]=asm["_ensureVar"];var _getConflictClause=Module["_getConflictClause"]=asm["_getConflictClause"];var _free=Module["_free"]=asm["_free"];var _malloc=Module["_malloc"]=asm["_malloc"];var __GLOBAL__I_a=Module["__GLOBAL__I_a"]=asm["__GLOBAL__I_a"];var __GLOBAL__I_a127=Module["__GLOBAL__I_a127"]=asm["__GLOBAL__I_a127"];var runPostSets=Module["runPostSets"]=asm["runPostSets"];var dynCall_iiii=Module["dynCall_iiii"]=asm["dynCall_iiii"];var dynCall_viiiii=Module["dynCall_viiiii"]=asm["dynCall_viiiii"];var dynCall_vi=Module["dynCall_vi"]=asm["dynCall_vi"];var dynCall_vii=Module["dynCall_vii"]=asm["dynCall_vii"];var dynCall_ii=Module["dynCall_ii"]=asm["dynCall_ii"];var dynCall_v=Module["dynCall_v"]=asm["dynCall_v"];var dynCall_viiiiii=Module["dynCall_viiiiii"]=asm["dynCall_viiiiii"];var dynCall_iii=Module["dynCall_iii"]=asm["dynCall_iii"];var dynCall_viiii=Module["dynCall_viiii"]=asm["dynCall_viiii"];Runtime.stackAlloc=asm["stackAlloc"];Runtime.stackSave=asm["stackSave"];Runtime.stackRestore=asm["stackRestore"];Runtime.setTempRet0=asm["setTempRet0"];Runtime.getTempRet0=asm["getTempRet0"];var i64Math=(function(){var goog={math:{}};goog.math.Long=(function(low,high){this.low_=low|0;this.high_=high|0});goog.math.Long.IntCache_={};goog.math.Long.fromInt=(function(value){if(-128<=value&&value<128){var cachedObj=goog.math.Long.IntCache_[value];if(cachedObj){return cachedObj}}var obj=new goog.math.Long(value|0,value<0?-1:0);if(-128<=value&&value<128){goog.math.Long.IntCache_[value]=obj}return obj});goog.math.Long.fromNumber=(function(value){if(isNaN(value)||!isFinite(value)){return goog.math.Long.ZERO}else if(value<=-goog.math.Long.TWO_PWR_63_DBL_){return goog.math.Long.MIN_VALUE}else if(value+1>=goog.math.Long.TWO_PWR_63_DBL_){return goog.math.Long.MAX_VALUE}else if(value<0){return goog.math.Long.fromNumber(-value).negate()}else{return new goog.math.Long(value%goog.math.Long.TWO_PWR_32_DBL_|0,value/goog.math.Long.TWO_PWR_32_DBL_|0)}});goog.math.Long.fromBits=(function(lowBits,highBits){return new goog.math.Long(lowBits,highBits)});goog.math.Long.fromString=(function(str,opt_radix){if(str.length==0){throw Error("number format error: empty string")}var radix=opt_radix||10;if(radix<2||36<radix){throw Error("radix out of range: "+radix)}if(str.charAt(0)=="-"){return goog.math.Long.fromString(str.substring(1),radix).negate()}else if(str.indexOf("-")>=0){throw Error('number format error: interior "-" character: '+str)}var radixToPower=goog.math.Long.fromNumber(Math.pow(radix,8));var result=goog.math.Long.ZERO;for(var i=0;i<str.length;i+=8){var size=Math.min(8,str.length-i);var value=parseInt(str.substring(i,i+size),radix);if(size<8){var power=goog.math.Long.fromNumber(Math.pow(radix,size));result=result.multiply(power).add(goog.math.Long.fromNumber(value))}else{result=result.multiply(radixToPower);result=result.add(goog.math.Long.fromNumber(value))}}return result});goog.math.Long.TWO_PWR_16_DBL_=1<<16;goog.math.Long.TWO_PWR_24_DBL_=1<<24;goog.math.Long.TWO_PWR_32_DBL_=goog.math.Long.TWO_PWR_16_DBL_*goog.math.Long.TWO_PWR_16_DBL_;goog.math.Long.TWO_PWR_31_DBL_=goog.math.Long.TWO_PWR_32_DBL_/2;goog.math.Long.TWO_PWR_48_DBL_=goog.math.Long.TWO_PWR_32_DBL_*goog.math.Long.TWO_PWR_16_DBL_;goog.math.Long.TWO_PWR_64_DBL_=goog.math.Long.TWO_PWR_32_DBL_*goog.math.Long.TWO_PWR_32_DBL_;goog.math.Long.TWO_PWR_63_DBL_=goog.math.Long.TWO_PWR_64_DBL_/2;goog.math.Long.ZERO=goog.math.Long.fromInt(0);goog.math.Long.ONE=goog.math.Long.fromInt(1);goog.math.Long.NEG_ONE=goog.math.Long.fromInt(-1);goog.math.Long.MAX_VALUE=goog.math.Long.fromBits(4294967295|0,2147483647|0);goog.math.Long.MIN_VALUE=goog.math.Long.fromBits(0,2147483648|0);goog.math.Long.TWO_PWR_24_=goog.math.Long.fromInt(1<<24);goog.math.Long.prototype.toInt=(function(){return this.low_});goog.math.Long.prototype.toNumber=(function(){return this.high_*goog.math.Long.TWO_PWR_32_DBL_+this.getLowBitsUnsigned()});goog.math.Long.prototype.toString=(function(opt_radix){var radix=opt_radix||10;if(radix<2||36<radix){throw Error("radix out of range: "+radix)}if(this.isZero()){return"0"}if(this.isNegative()){if(this.equals(goog.math.Long.MIN_VALUE)){var radixLong=goog.math.Long.fromNumber(radix);var div=this.div(radixLong);var rem=div.multiply(radixLong).subtract(this);return div.toString(radix)+rem.toInt().toString(radix)}else{return"-"+this.negate().toString(radix)}}var radixToPower=goog.math.Long.fromNumber(Math.pow(radix,6));var rem=this;var result="";while(true){var remDiv=rem.div(radixToPower);var intval=rem.subtract(remDiv.multiply(radixToPower)).toInt();var digits=intval.toString(radix);rem=remDiv;if(rem.isZero()){return digits+result}else{while(digits.length<6){digits="0"+digits}result=""+digits+result}}});goog.math.Long.prototype.getHighBits=(function(){return this.high_});goog.math.Long.prototype.getLowBits=(function(){return this.low_});goog.math.Long.prototype.getLowBitsUnsigned=(function(){return this.low_>=0?this.low_:goog.math.Long.TWO_PWR_32_DBL_+this.low_});goog.math.Long.prototype.getNumBitsAbs=(function(){if(this.isNegative()){if(this.equals(goog.math.Long.MIN_VALUE)){return 64}else{return this.negate().getNumBitsAbs()}}else{var val=this.high_!=0?this.high_:this.low_;for(var bit=31;bit>0;bit--){if((val&1<<bit)!=0){break}}return this.high_!=0?bit+33:bit+1}});goog.math.Long.prototype.isZero=(function(){return this.high_==0&&this.low_==0});goog.math.Long.prototype.isNegative=(function(){return this.high_<0});goog.math.Long.prototype.isOdd=(function(){return(this.low_&1)==1});goog.math.Long.prototype.equals=(function(other){return this.high_==other.high_&&this.low_==other.low_});goog.math.Long.prototype.notEquals=(function(other){return this.high_!=other.high_||this.low_!=other.low_});goog.math.Long.prototype.lessThan=(function(other){return this.compare(other)<0});goog.math.Long.prototype.lessThanOrEqual=(function(other){return this.compare(other)<=0});goog.math.Long.prototype.greaterThan=(function(other){return this.compare(other)>0});goog.math.Long.prototype.greaterThanOrEqual=(function(other){return this.compare(other)>=0});goog.math.Long.prototype.compare=(function(other){if(this.equals(other)){return 0}var thisNeg=this.isNegative();var otherNeg=other.isNegative();if(thisNeg&&!otherNeg){return-1}if(!thisNeg&&otherNeg){return 1}if(this.subtract(other).isNegative()){return-1}else{return 1}});goog.math.Long.prototype.negate=(function(){if(this.equals(goog.math.Long.MIN_VALUE)){return goog.math.Long.MIN_VALUE}else{return this.not().add(goog.math.Long.ONE)}});goog.math.Long.prototype.add=(function(other){var a48=this.high_>>>16;var a32=this.high_&65535;var a16=this.low_>>>16;var a00=this.low_&65535;var b48=other.high_>>>16;var b32=other.high_&65535;var b16=other.low_>>>16;var b00=other.low_&65535;var c48=0,c32=0,c16=0,c00=0;c00+=a00+b00;c16+=c00>>>16;c00&=65535;c16+=a16+b16;c32+=c16>>>16;c16&=65535;c32+=a32+b32;c48+=c32>>>16;c32&=65535;c48+=a48+b48;c48&=65535;return goog.math.Long.fromBits(c16<<16|c00,c48<<16|c32)});goog.math.Long.prototype.subtract=(function(other){return this.add(other.negate())});goog.math.Long.prototype.multiply=(function(other){if(this.isZero()){return goog.math.Long.ZERO}else if(other.isZero()){return goog.math.Long.ZERO}if(this.equals(goog.math.Long.MIN_VALUE)){return other.isOdd()?goog.math.Long.MIN_VALUE:goog.math.Long.ZERO}else if(other.equals(goog.math.Long.MIN_VALUE)){return this.isOdd()?goog.math.Long.MIN_VALUE:goog.math.Long.ZERO}if(this.isNegative()){if(other.isNegative()){return this.negate().multiply(other.negate())}else{return this.negate().multiply(other).negate()}}else if(other.isNegative()){return this.multiply(other.negate()).negate()}if(this.lessThan(goog.math.Long.TWO_PWR_24_)&&other.lessThan(goog.math.Long.TWO_PWR_24_)){return goog.math.Long.fromNumber(this.toNumber()*other.toNumber())}var a48=this.high_>>>16;var a32=this.high_&65535;var a16=this.low_>>>16;var a00=this.low_&65535;var b48=other.high_>>>16;var b32=other.high_&65535;var b16=other.low_>>>16;var b00=other.low_&65535;var c48=0,c32=0,c16=0,c00=0;c00+=a00*b00;c16+=c00>>>16;c00&=65535;c16+=a16*b00;c32+=c16>>>16;c16&=65535;c16+=a00*b16;c32+=c16>>>16;c16&=65535;c32+=a32*b00;c48+=c32>>>16;c32&=65535;c32+=a16*b16;c48+=c32>>>16;c32&=65535;c32+=a00*b32;c48+=c32>>>16;c32&=65535;c48+=a48*b00+a32*b16+a16*b32+a00*b48;c48&=65535;return goog.math.Long.fromBits(c16<<16|c00,c48<<16|c32)});goog.math.Long.prototype.div=(function(other){if(other.isZero()){throw Error("division by zero")}else if(this.isZero()){return goog.math.Long.ZERO}if(this.equals(goog.math.Long.MIN_VALUE)){if(other.equals(goog.math.Long.ONE)||other.equals(goog.math.Long.NEG_ONE)){return goog.math.Long.MIN_VALUE}else if(other.equals(goog.math.Long.MIN_VALUE)){return goog.math.Long.ONE}else{var halfThis=this.shiftRight(1);var approx=halfThis.div(other).shiftLeft(1);if(approx.equals(goog.math.Long.ZERO)){return other.isNegative()?goog.math.Long.ONE:goog.math.Long.NEG_ONE}else{var rem=this.subtract(other.multiply(approx));var result=approx.add(rem.div(other));return result}}}else if(other.equals(goog.math.Long.MIN_VALUE)){return goog.math.Long.ZERO}if(this.isNegative()){if(other.isNegative()){return this.negate().div(other.negate())}else{return this.negate().div(other).negate()}}else if(other.isNegative()){return this.div(other.negate()).negate()}var res=goog.math.Long.ZERO;var rem=this;while(rem.greaterThanOrEqual(other)){var approx=Math.max(1,Math.floor(rem.toNumber()/other.toNumber()));var log2=Math.ceil(Math.log(approx)/Math.LN2);var delta=log2<=48?1:Math.pow(2,log2-48);var approxRes=goog.math.Long.fromNumber(approx);var approxRem=approxRes.multiply(other);while(approxRem.isNegative()||approxRem.greaterThan(rem)){approx-=delta;approxRes=goog.math.Long.fromNumber(approx);approxRem=approxRes.multiply(other)}if(approxRes.isZero()){approxRes=goog.math.Long.ONE}res=res.add(approxRes);rem=rem.subtract(approxRem)}return res});goog.math.Long.prototype.modulo=(function(other){return this.subtract(this.div(other).multiply(other))});goog.math.Long.prototype.not=(function(){return goog.math.Long.fromBits(~this.low_,~this.high_)});goog.math.Long.prototype.and=(function(other){return goog.math.Long.fromBits(this.low_&other.low_,this.high_&other.high_)});goog.math.Long.prototype.or=(function(other){return goog.math.Long.fromBits(this.low_|other.low_,this.high_|other.high_)});goog.math.Long.prototype.xor=(function(other){return goog.math.Long.fromBits(this.low_^other.low_,this.high_^other.high_)});goog.math.Long.prototype.shiftLeft=(function(numBits){numBits&=63;if(numBits==0){return this}else{var low=this.low_;if(numBits<32){var high=this.high_;return goog.math.Long.fromBits(low<<numBits,high<<numBits|low>>>32-numBits)}else{return goog.math.Long.fromBits(0,low<<numBits-32)}}});goog.math.Long.prototype.shiftRight=(function(numBits){numBits&=63;if(numBits==0){return this}else{var high=this.high_;if(numBits<32){var low=this.low_;return goog.math.Long.fromBits(low>>>numBits|high<<32-numBits,high>>numBits)}else{return goog.math.Long.fromBits(high>>numBits-32,high>=0?0:-1)}}});goog.math.Long.prototype.shiftRightUnsigned=(function(numBits){numBits&=63;if(numBits==0){return this}else{var high=this.high_;if(numBits<32){var low=this.low_;return goog.math.Long.fromBits(low>>>numBits|high<<32-numBits,high>>>numBits)}else if(numBits==32){return goog.math.Long.fromBits(high,0)}else{return goog.math.Long.fromBits(high>>>numBits-32,0)}}});var navigator={appName:"Modern Browser"};var dbits;var canary=0xdeadbeefcafe;var j_lm=(canary&16777215)==15715070;function BigInteger(a,b,c){if(a!=null)if("number"==typeof a)this.fromNumber(a,b,c);else if(b==null&&"string"!=typeof a)this.fromString(a,256);else this.fromString(a,b)}function nbi(){return new BigInteger(null)}function am1(i,x,w,j,c,n){while(--n>=0){var v=x*this[i++]+w[j]+c;c=Math.floor(v/67108864);w[j++]=v&67108863}return c}function am2(i,x,w,j,c,n){var xl=x&32767,xh=x>>15;while(--n>=0){var l=this[i]&32767;var h=this[i++]>>15;var m=xh*l+h*xl;l=xl*l+((m&32767)<<15)+w[j]+(c&1073741823);c=(l>>>30)+(m>>>15)+xh*h+(c>>>30);w[j++]=l&1073741823}return c}function am3(i,x,w,j,c,n){var xl=x&16383,xh=x>>14;while(--n>=0){var l=this[i]&16383;var h=this[i++]>>14;var m=xh*l+h*xl;l=xl*l+((m&16383)<<14)+w[j]+c;c=(l>>28)+(m>>14)+xh*h;w[j++]=l&268435455}return c}if(j_lm&&navigator.appName=="Microsoft Internet Explorer"){BigInteger.prototype.am=am2;dbits=30}else if(j_lm&&navigator.appName!="Netscape"){BigInteger.prototype.am=am1;dbits=26}else{BigInteger.prototype.am=am3;dbits=28}BigInteger.prototype.DB=dbits;BigInteger.prototype.DM=(1<<dbits)-1;BigInteger.prototype.DV=1<<dbits;var BI_FP=52;BigInteger.prototype.FV=Math.pow(2,BI_FP);BigInteger.prototype.F1=BI_FP-dbits;BigInteger.prototype.F2=2*dbits-BI_FP;var BI_RM="0123456789abcdefghijklmnopqrstuvwxyz";var BI_RC=new Array;var rr,vv;rr="0".charCodeAt(0);for(vv=0;vv<=9;++vv)BI_RC[rr++]=vv;rr="a".charCodeAt(0);for(vv=10;vv<36;++vv)BI_RC[rr++]=vv;rr="A".charCodeAt(0);for(vv=10;vv<36;++vv)BI_RC[rr++]=vv;function int2char(n){return BI_RM.charAt(n)}function intAt(s,i){var c=BI_RC[s.charCodeAt(i)];return c==null?-1:c}function bnpCopyTo(r){for(var i=this.t-1;i>=0;--i)r[i]=this[i];r.t=this.t;r.s=this.s}function bnpFromInt(x){this.t=1;this.s=x<0?-1:0;if(x>0)this[0]=x;else if(x<-1)this[0]=x+DV;else this.t=0}function nbv(i){var r=nbi();r.fromInt(i);return r}function bnpFromString(s,b){var k;if(b==16)k=4;else if(b==8)k=3;else if(b==256)k=8;else if(b==2)k=1;else if(b==32)k=5;else if(b==4)k=2;else{this.fromRadix(s,b);return}this.t=0;this.s=0;var i=s.length,mi=false,sh=0;while(--i>=0){var x=k==8?s[i]&255:intAt(s,i);if(x<0){if(s.charAt(i)=="-")mi=true;continue}mi=false;if(sh==0)this[this.t++]=x;else if(sh+k>this.DB){this[this.t-1]|=(x&(1<<this.DB-sh)-1)<<sh;this[this.t++]=x>>this.DB-sh}else this[this.t-1]|=x<<sh;sh+=k;if(sh>=this.DB)sh-=this.DB}if(k==8&&(s[0]&128)!=0){this.s=-1;if(sh>0)this[this.t-1]|=(1<<this.DB-sh)-1<<sh}this.clamp();if(mi)BigInteger.ZERO.subTo(this,this)}function bnpClamp(){var c=this.s&this.DM;while(this.t>0&&this[this.t-1]==c)--this.t}function bnToString(b){if(this.s<0)return"-"+this.negate().toString(b);var k;if(b==16)k=4;else if(b==8)k=3;else if(b==2)k=1;else if(b==32)k=5;else if(b==4)k=2;else return this.toRadix(b);var km=(1<<k)-1,d,m=false,r="",i=this.t;var p=this.DB-i*this.DB%k;if(i-->0){if(p<this.DB&&(d=this[i]>>p)>0){m=true;r=int2char(d)}while(i>=0){if(p<k){d=(this[i]&(1<<p)-1)<<k-p;d|=this[--i]>>(p+=this.DB-k)}else{d=this[i]>>(p-=k)&km;if(p<=0){p+=this.DB;--i}}if(d>0)m=true;if(m)r+=int2char(d)}}return m?r:"0"}function bnNegate(){var r=nbi();BigInteger.ZERO.subTo(this,r);return r}function bnAbs(){return this.s<0?this.negate():this}function bnCompareTo(a){var r=this.s-a.s;if(r!=0)return r;var i=this.t;r=i-a.t;if(r!=0)return this.s<0?-r:r;while(--i>=0)if((r=this[i]-a[i])!=0)return r;return 0}function nbits(x){var r=1,t;if((t=x>>>16)!=0){x=t;r+=16}if((t=x>>8)!=0){x=t;r+=8}if((t=x>>4)!=0){x=t;r+=4}if((t=x>>2)!=0){x=t;r+=2}if((t=x>>1)!=0){x=t;r+=1}return r}function bnBitLength(){if(this.t<=0)return 0;return this.DB*(this.t-1)+nbits(this[this.t-1]^this.s&this.DM)}function bnpDLShiftTo(n,r){var i;for(i=this.t-1;i>=0;--i)r[i+n]=this[i];for(i=n-1;i>=0;--i)r[i]=0;r.t=this.t+n;r.s=this.s}function bnpDRShiftTo(n,r){for(var i=n;i<this.t;++i)r[i-n]=this[i];r.t=Math.max(this.t-n,0);r.s=this.s}function bnpLShiftTo(n,r){var bs=n%this.DB;var cbs=this.DB-bs;var bm=(1<<cbs)-1;var ds=Math.floor(n/this.DB),c=this.s<<bs&this.DM,i;for(i=this.t-1;i>=0;--i){r[i+ds+1]=this[i]>>cbs|c;c=(this[i]&bm)<<bs}for(i=ds-1;i>=0;--i)r[i]=0;r[ds]=c;r.t=this.t+ds+1;r.s=this.s;r.clamp()}function bnpRShiftTo(n,r){r.s=this.s;var ds=Math.floor(n/this.DB);if(ds>=this.t){r.t=0;return}var bs=n%this.DB;var cbs=this.DB-bs;var bm=(1<<bs)-1;r[0]=this[ds]>>bs;for(var i=ds+1;i<this.t;++i){r[i-ds-1]|=(this[i]&bm)<<cbs;r[i-ds]=this[i]>>bs}if(bs>0)r[this.t-ds-1]|=(this.s&bm)<<cbs;r.t=this.t-ds;r.clamp()}function bnpSubTo(a,r){var i=0,c=0,m=Math.min(a.t,this.t);while(i<m){c+=this[i]-a[i];r[i++]=c&this.DM;c>>=this.DB}if(a.t<this.t){c-=a.s;while(i<this.t){c+=this[i];r[i++]=c&this.DM;c>>=this.DB}c+=this.s}else{c+=this.s;while(i<a.t){c-=a[i];r[i++]=c&this.DM;c>>=this.DB}c-=a.s}r.s=c<0?-1:0;if(c<-1)r[i++]=this.DV+c;else if(c>0)r[i++]=c;r.t=i;r.clamp()}function bnpMultiplyTo(a,r){var x=this.abs(),y=a.abs();var i=x.t;r.t=i+y.t;while(--i>=0)r[i]=0;for(i=0;i<y.t;++i)r[i+x.t]=x.am(0,y[i],r,i,0,x.t);r.s=0;r.clamp();if(this.s!=a.s)BigInteger.ZERO.subTo(r,r)}function bnpSquareTo(r){var x=this.abs();var i=r.t=2*x.t;while(--i>=0)r[i]=0;for(i=0;i<x.t-1;++i){var c=x.am(i,x[i],r,2*i,0,1);if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1))>=x.DV){r[i+x.t]-=x.DV;r[i+x.t+1]=1}}if(r.t>0)r[r.t-1]+=x.am(i,x[i],r,2*i,0,1);r.s=0;r.clamp()}function bnpDivRemTo(m,q,r){var pm=m.abs();if(pm.t<=0)return;var pt=this.abs();if(pt.t<pm.t){if(q!=null)q.fromInt(0);if(r!=null)this.copyTo(r);return}if(r==null)r=nbi();var y=nbi(),ts=this.s,ms=m.s;var nsh=this.DB-nbits(pm[pm.t-1]);if(nsh>0){pm.lShiftTo(nsh,y);pt.lShiftTo(nsh,r)}else{pm.copyTo(y);pt.copyTo(r)}var ys=y.t;var y0=y[ys-1];if(y0==0)return;var yt=y0*(1<<this.F1)+(ys>1?y[ys-2]>>this.F2:0);var d1=this.FV/yt,d2=(1<<this.F1)/yt,e=1<<this.F2;var i=r.t,j=i-ys,t=q==null?nbi():q;y.dlShiftTo(j,t);if(r.compareTo(t)>=0){r[r.t++]=1;r.subTo(t,r)}BigInteger.ONE.dlShiftTo(ys,t);t.subTo(y,y);while(y.t<ys)y[y.t++]=0;while(--j>=0){var qd=r[--i]==y0?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);if((r[i]+=y.am(0,qd,r,j,0,ys))<qd){y.dlShiftTo(j,t);r.subTo(t,r);while(r[i]<--qd)r.subTo(t,r)}}if(q!=null){r.drShiftTo(ys,q);if(ts!=ms)BigInteger.ZERO.subTo(q,q)}r.t=ys;r.clamp();if(nsh>0)r.rShiftTo(nsh,r);if(ts<0)BigInteger.ZERO.subTo(r,r)}function bnMod(a){var r=nbi();this.abs().divRemTo(a,null,r);if(this.s<0&&r.compareTo(BigInteger.ZERO)>0)a.subTo(r,r);return r}function Classic(m){this.m=m}function cConvert(x){if(x.s<0||x.compareTo(this.m)>=0)return x.mod(this.m);else return x}function cRevert(x){return x}function cReduce(x){x.divRemTo(this.m,null,x)}function cMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r)}function cSqrTo(x,r){x.squareTo(r);this.reduce(r)}Classic.prototype.convert=cConvert;Classic.prototype.revert=cRevert;Classic.prototype.reduce=cReduce;Classic.prototype.mulTo=cMulTo;Classic.prototype.sqrTo=cSqrTo;function bnpInvDigit(){if(this.t<1)return 0;var x=this[0];if((x&1)==0)return 0;var y=x&3;y=y*(2-(x&15)*y)&15;y=y*(2-(x&255)*y)&255;y=y*(2-((x&65535)*y&65535))&65535;y=y*(2-x*y%this.DV)%this.DV;return y>0?this.DV-y:-y}function Montgomery(m){this.m=m;this.mp=m.invDigit();this.mpl=this.mp&32767;this.mph=this.mp>>15;this.um=(1<<m.DB-15)-1;this.mt2=2*m.t}function montConvert(x){var r=nbi();x.abs().dlShiftTo(this.m.t,r);r.divRemTo(this.m,null,r);if(x.s<0&&r.compareTo(BigInteger.ZERO)>0)this.m.subTo(r,r);return r}function montRevert(x){var r=nbi();x.copyTo(r);this.reduce(r);return r}function montReduce(x){while(x.t<=this.mt2)x[x.t++]=0;for(var i=0;i<this.m.t;++i){var j=x[i]&32767;var u0=j*this.mpl+((j*this.mph+(x[i]>>15)*this.mpl&this.um)<<15)&x.DM;j=i+this.m.t;x[j]+=this.m.am(0,u0,x,i,0,this.m.t);while(x[j]>=x.DV){x[j]-=x.DV;x[++j]++}}x.clamp();x.drShiftTo(this.m.t,x);if(x.compareTo(this.m)>=0)x.subTo(this.m,x)}function montSqrTo(x,r){x.squareTo(r);this.reduce(r)}function montMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r)}Montgomery.prototype.convert=montConvert;Montgomery.prototype.revert=montRevert;Montgomery.prototype.reduce=montReduce;Montgomery.prototype.mulTo=montMulTo;Montgomery.prototype.sqrTo=montSqrTo;function bnpIsEven(){return(this.t>0?this[0]&1:this.s)==0}function bnpExp(e,z){if(e>4294967295||e<1)return BigInteger.ONE;var r=nbi(),r2=nbi(),g=z.convert(this),i=nbits(e)-1;g.copyTo(r);while(--i>=0){z.sqrTo(r,r2);if((e&1<<i)>0)z.mulTo(r2,g,r);else{var t=r;r=r2;r2=t}}return z.revert(r)}function bnModPowInt(e,m){var z;if(e<256||m.isEven())z=new Classic(m);else z=new Montgomery(m);return this.exp(e,z)}BigInteger.prototype.copyTo=bnpCopyTo;BigInteger.prototype.fromInt=bnpFromInt;BigInteger.prototype.fromString=bnpFromString;BigInteger.prototype.clamp=bnpClamp;BigInteger.prototype.dlShiftTo=bnpDLShiftTo;BigInteger.prototype.drShiftTo=bnpDRShiftTo;BigInteger.prototype.lShiftTo=bnpLShiftTo;BigInteger.prototype.rShiftTo=bnpRShiftTo;BigInteger.prototype.subTo=bnpSubTo;BigInteger.prototype.multiplyTo=bnpMultiplyTo;BigInteger.prototype.squareTo=bnpSquareTo;BigInteger.prototype.divRemTo=bnpDivRemTo;BigInteger.prototype.invDigit=bnpInvDigit;BigInteger.prototype.isEven=bnpIsEven;BigInteger.prototype.exp=bnpExp;BigInteger.prototype.toString=bnToString;BigInteger.prototype.negate=bnNegate;BigInteger.prototype.abs=bnAbs;BigInteger.prototype.compareTo=bnCompareTo;BigInteger.prototype.bitLength=bnBitLength;BigInteger.prototype.mod=bnMod;BigInteger.prototype.modPowInt=bnModPowInt;BigInteger.ZERO=nbv(0);BigInteger.ONE=nbv(1);function bnpFromRadix(s,b){this.fromInt(0);if(b==null)b=10;var cs=this.chunkSize(b);var d=Math.pow(b,cs),mi=false,j=0,w=0;for(var i=0;i<s.length;++i){var x=intAt(s,i);if(x<0){if(s.charAt(i)=="-"&&this.signum()==0)mi=true;continue}w=b*w+x;if(++j>=cs){this.dMultiply(d);this.dAddOffset(w,0);j=0;w=0}}if(j>0){this.dMultiply(Math.pow(b,j));this.dAddOffset(w,0)}if(mi)BigInteger.ZERO.subTo(this,this)}function bnpChunkSize(r){return Math.floor(Math.LN2*this.DB/Math.log(r))}function bnSigNum(){if(this.s<0)return-1;else if(this.t<=0||this.t==1&&this[0]<=0)return 0;else return 1}function bnpDMultiply(n){this[this.t]=this.am(0,n-1,this,0,0,this.t);++this.t;this.clamp()}function bnpDAddOffset(n,w){if(n==0)return;while(this.t<=w)this[this.t++]=0;this[w]+=n;while(this[w]>=this.DV){this[w]-=this.DV;if(++w>=this.t)this[this.t++]=0;++this[w]}}function bnpToRadix(b){if(b==null)b=10;if(this.signum()==0||b<2||b>36)return"0";var cs=this.chunkSize(b);var a=Math.pow(b,cs);var d=nbv(a),y=nbi(),z=nbi(),r="";this.divRemTo(d,y,z);while(y.signum()>0){r=(a+z.intValue()).toString(b).substr(1)+r;y.divRemTo(d,y,z)}return z.intValue().toString(b)+r}function bnIntValue(){if(this.s<0){if(this.t==1)return this[0]-this.DV;else if(this.t==0)return-1}else if(this.t==1)return this[0];else if(this.t==0)return 0;return(this[1]&(1<<32-this.DB)-1)<<this.DB|this[0]}function bnpAddTo(a,r){var i=0,c=0,m=Math.min(a.t,this.t);while(i<m){c+=this[i]+a[i];r[i++]=c&this.DM;c>>=this.DB}if(a.t<this.t){c+=a.s;while(i<this.t){c+=this[i];r[i++]=c&this.DM;c>>=this.DB}c+=this.s}else{c+=this.s;while(i<a.t){c+=a[i];r[i++]=c&this.DM;c>>=this.DB}c+=a.s}r.s=c<0?-1:0;if(c>0)r[i++]=c;else if(c<-1)r[i++]=this.DV+c;r.t=i;r.clamp()}BigInteger.prototype.fromRadix=bnpFromRadix;BigInteger.prototype.chunkSize=bnpChunkSize;BigInteger.prototype.signum=bnSigNum;BigInteger.prototype.dMultiply=bnpDMultiply;BigInteger.prototype.dAddOffset=bnpDAddOffset;BigInteger.prototype.toRadix=bnpToRadix;BigInteger.prototype.intValue=bnIntValue;BigInteger.prototype.addTo=bnpAddTo;var Wrapper={abs:(function(l,h){var x=new goog.math.Long(l,h);var ret;if(x.isNegative()){ret=x.negate()}else{ret=x}HEAP32[tempDoublePtr>>2]=ret.low_;HEAP32[tempDoublePtr+4>>2]=ret.high_}),ensureTemps:(function(){if(Wrapper.ensuredTemps)return;Wrapper.ensuredTemps=true;Wrapper.two32=new BigInteger;Wrapper.two32.fromString("4294967296",10);Wrapper.two64=new BigInteger;Wrapper.two64.fromString("18446744073709551616",10);Wrapper.temp1=new BigInteger;Wrapper.temp2=new BigInteger}),lh2bignum:(function(l,h){var a=new BigInteger;a.fromString(h.toString(),10);var b=new BigInteger;a.multiplyTo(Wrapper.two32,b);var c=new BigInteger;c.fromString(l.toString(),10);var d=new BigInteger;c.addTo(b,d);return d}),stringify:(function(l,h,unsigned){var ret=(new goog.math.Long(l,h)).toString();if(unsigned&&ret[0]=="-"){Wrapper.ensureTemps();var bignum=new BigInteger;bignum.fromString(ret,10);ret=new BigInteger;Wrapper.two64.addTo(bignum,ret);ret=ret.toString(10)}return ret}),fromString:(function(str,base,min,max,unsigned){Wrapper.ensureTemps();var bignum=new BigInteger;bignum.fromString(str,base);var bigmin=new BigInteger;bigmin.fromString(min,10);var bigmax=new BigInteger;bigmax.fromString(max,10);if(unsigned&&bignum.compareTo(BigInteger.ZERO)<0){var temp=new BigInteger;bignum.addTo(Wrapper.two64,temp);bignum=temp}var error=false;if(bignum.compareTo(bigmin)<0){bignum=bigmin;error=true}else if(bignum.compareTo(bigmax)>0){bignum=bigmax;error=true}var ret=goog.math.Long.fromString(bignum.toString());HEAP32[tempDoublePtr>>2]=ret.low_;HEAP32[tempDoublePtr+4>>2]=ret.high_;if(error)throw"range error"})};return Wrapper})();if(memoryInitializer){if(typeof Module["locateFile"]==="function"){memoryInitializer=Module["locateFile"](memoryInitializer)}else if(Module["memoryInitializerPrefixURL"]){memoryInitializer=Module["memoryInitializerPrefixURL"]+memoryInitializer}if(ENVIRONMENT_IS_NODE||ENVIRONMENT_IS_SHELL){var data=Module["readBinary"](memoryInitializer);HEAPU8.set(data,STATIC_BASE)}else{addRunDependency("memory initializer");Browser.asyncLoad(memoryInitializer,(function(data){HEAPU8.set(data,STATIC_BASE);removeRunDependency("memory initializer")}),(function(data){throw"could not load memory initializer "+memoryInitializer}))}}function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status}ExitStatus.prototype=new Error;ExitStatus.prototype.constructor=ExitStatus;var initialStackTop;var preloadStartTime=null;var calledMain=false;dependenciesFulfilled=function runCaller(){if(!Module["calledRun"]&&shouldRunNow)run();if(!Module["calledRun"])dependenciesFulfilled=runCaller};Module["callMain"]=Module.callMain=function callMain(args){assert(runDependencies==0,"cannot call main when async dependencies remain! (listen on __ATMAIN__)");assert(__ATPRERUN__.length==0,"cannot call main when preRun functions remain to be called");args=args||[];ensureInitRuntime();var argc=args.length+1;function pad(){for(var i=0;i<4-1;i++){argv.push(0)}}var argv=[allocate(intArrayFromString(Module["thisProgram"]),"i8",ALLOC_NORMAL)];pad();for(var i=0;i<argc-1;i=i+1){argv.push(allocate(intArrayFromString(args[i]),"i8",ALLOC_NORMAL));pad()}argv.push(0);argv=allocate(argv,"i32",ALLOC_NORMAL);initialStackTop=STACKTOP;try{var ret=Module["_main"](argc,argv,0);exit(ret)}catch(e){if(e instanceof ExitStatus){return}else if(e=="SimulateInfiniteLoop"){Module["noExitRuntime"]=true;return}else{if(e&&typeof e==="object"&&e.stack)Module.printErr("exception thrown: "+[e,e.stack]);throw e}}finally{calledMain=true}};function run(args){args=args||Module["arguments"];if(preloadStartTime===null)preloadStartTime=Date.now();if(runDependencies>0){return}preRun();if(runDependencies>0)return;if(Module["calledRun"])return;function doRun(){if(Module["calledRun"])return;Module["calledRun"]=true;if(ABORT)return;ensureInitRuntime();preMain();if(ENVIRONMENT_IS_WEB&&preloadStartTime!==null){Module.printErr("pre-main prep time: "+(Date.now()-preloadStartTime)+" ms")}if(Module["_main"]&&shouldRunNow){Module["callMain"](args)}postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout((function(){setTimeout((function(){Module["setStatus"]("")}),1);doRun()}),1)}else{doRun()}}Module["run"]=Module.run=run;function exit(status){if(Module["noExitRuntime"]){return}ABORT=true;EXITSTATUS=status;STACKTOP=initialStackTop;exitRuntime();if(ENVIRONMENT_IS_NODE){process["stdout"]["once"]("drain",(function(){process["exit"](status)}));console.log(" ");setTimeout((function(){process["exit"](status)}),500)}else if(ENVIRONMENT_IS_SHELL&&typeof quit==="function"){quit(status)}throw new ExitStatus(status)}Module["exit"]=Module.exit=exit;function abort(text){if(text){Module.print(text);Module.printErr(text)}ABORT=true;EXITSTATUS=1;var extra="\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.";throw"abort() at "+stackTrace()+extra}Module["abort"]=Module.abort=abort;if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}var shouldRunNow=true;if(Module["noInitialRun"]){shouldRunNow=false}run();var origMalloc=Module._malloc;var origFree=Module._free;var MEMSTATS={totalMemory:Module.HEAPU8.length,heapUsed:0};var MEMSTATS_DATA={pointerToSizeMap:{},getSizeOfPointer:(function(ptr){return MEMSTATS_DATA.pointerToSizeMap[ptr]})};Module.MEMSTATS=MEMSTATS;Module.MEMSTATS_DATA=MEMSTATS_DATA;var hookedMalloc=(function(size){var ptr=origMalloc(size);if(!ptr){return 0}MEMSTATS.heapUsed+=size;MEMSTATS_DATA.pointerToSizeMap[ptr]=size;return ptr});var hookedFree=(function(ptr){if(ptr){MEMSTATS.heapUsed-=MEMSTATS_DATA.getSizeOfPointer(ptr)||0;delete MEMSTATS_DATA.pointerToSizeMap[ptr]}return origFree(ptr)});Module._malloc=hookedMalloc;Module._free=hookedFree;_malloc=hookedMalloc;_free=hookedFree;var setInnerMalloc,setInnerFree;if(setInnerMalloc){setInnerMalloc(hookedMalloc);setInnerFree(hookedFree)}return module.exports});if(true){module.exports=C_MINISAT}






  /***/ }),
  /* 248 */
  /***/ (function(module, exports, __webpack_require__) {

  /* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.9.1
  //     http://underscorejs.org
  //     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  //     Underscore may be freely distributed under the MIT license.

  (function() {

    // Baseline setup
    // --------------

    // Establish the root object, `window` (`self`) in the browser, `global`
    // on the server, or `this` in some virtual machines. We use `self`
    // instead of `window` for `WebWorker` support.
    var root = typeof self == 'object' && self.self === self && self ||
              typeof global == 'object' && global.global === global && global ||
              this ||
              {};

    // Save the previous value of the `_` variable.
    var previousUnderscore = root._;

    // Save bytes in the minified (but not gzipped) version:
    var ArrayProto = Array.prototype, ObjProto = Object.prototype;
    var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

    // Create quick reference variables for speed access to core prototypes.
    var push = ArrayProto.push,
        slice = ArrayProto.slice,
        toString = ObjProto.toString,
        hasOwnProperty = ObjProto.hasOwnProperty;

    // All **ECMAScript 5** native function implementations that we hope to use
    // are declared here.
    var nativeIsArray = Array.isArray,
        nativeKeys = Object.keys,
        nativeCreate = Object.create;

    // Naked function reference for surrogate-prototype-swapping.
    var Ctor = function(){};

    // Create a safe reference to the Underscore object for use below.
    var _ = function(obj) {
      if (obj instanceof _) return obj;
      if (!(this instanceof _)) return new _(obj);
      this._wrapped = obj;
    };

    // Export the Underscore object for **Node.js**, with
    // backwards-compatibility for their old module API. If we're in
    // the browser, add `_` as a global object.
    // (`nodeType` is checked to ensure that `module`
    // and `exports` are not HTML elements.)
    if ( true && !exports.nodeType) {
      if ( true && !module.nodeType && module.exports) {
        exports = module.exports = _;
      }
      exports._ = _;
    } else {
      root._ = _;
    }

    // Current version.
    _.VERSION = '1.9.1';

    // Internal function that returns an efficient (for current engines) version
    // of the passed-in callback, to be repeatedly applied in other Underscore
    // functions.
    var optimizeCb = function(func, context, argCount) {
      if (context === void 0) return func;
      switch (argCount == null ? 3 : argCount) {
        case 1: return function(value) {
          return func.call(context, value);
        };
        // The 2-argument case is omitted because we’re not using it.
        case 3: return function(value, index, collection) {
          return func.call(context, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(context, accumulator, value, index, collection);
        };
      }
      return function() {
        return func.apply(context, arguments);
      };
    };

    var builtinIteratee;

    // An internal function to generate callbacks that can be applied to each
    // element in a collection, returning the desired result — either `identity`,
    // an arbitrary callback, a property matcher, or a property accessor.
    var cb = function(value, context, argCount) {
      if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
      if (value == null) return _.identity;
      if (_.isFunction(value)) return optimizeCb(value, context, argCount);
      if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
      return _.property(value);
    };

    // External wrapper for our callback generator. Users may customize
    // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
    // This abstraction hides the internal-only argCount argument.
    _.iteratee = builtinIteratee = function(value, context) {
      return cb(value, context, Infinity);
    };

    // Some functions take a variable number of arguments, or a few expected
    // arguments at the beginning and then a variable number of values to operate
    // on. This helper accumulates all remaining arguments past the function’s
    // argument length (or an explicit `startIndex`), into an array that becomes
    // the last argument. Similar to ES6’s "rest parameter".
    var restArguments = function(func, startIndex) {
      startIndex = startIndex == null ? func.length - 1 : +startIndex;
      return function() {
        var length = Math.max(arguments.length - startIndex, 0),
            rest = Array(length),
            index = 0;
        for (; index < length; index++) {
          rest[index] = arguments[index + startIndex];
        }
        switch (startIndex) {
          case 0: return func.call(this, rest);
          case 1: return func.call(this, arguments[0], rest);
          case 2: return func.call(this, arguments[0], arguments[1], rest);
        }
        var args = Array(startIndex + 1);
        for (index = 0; index < startIndex; index++) {
          args[index] = arguments[index];
        }
        args[startIndex] = rest;
        return func.apply(this, args);
      };
    };

    // An internal function for creating a new object that inherits from another.
    var baseCreate = function(prototype) {
      if (!_.isObject(prototype)) return {};
      if (nativeCreate) return nativeCreate(prototype);
      Ctor.prototype = prototype;
      var result = new Ctor;
      Ctor.prototype = null;
      return result;
    };

    var shallowProperty = function(key) {
      return function(obj) {
        return obj == null ? void 0 : obj[key];
      };
    };

    var has = function(obj, path) {
      return obj != null && hasOwnProperty.call(obj, path);
    }

    var deepGet = function(obj, path) {
      var length = path.length;
      for (var i = 0; i < length; i++) {
        if (obj == null) return void 0;
        obj = obj[path[i]];
      }
      return length ? obj : void 0;
    };

    // Helper for collection methods to determine whether a collection
    // should be iterated as an array or as an object.
    // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
    // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
    var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
    var getLength = shallowProperty('length');
    var isArrayLike = function(collection) {
      var length = getLength(collection);
      return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
    };

    // Collection Functions
    // --------------------

    // The cornerstone, an `each` implementation, aka `forEach`.
    // Handles raw objects in addition to array-likes. Treats all
    // sparse array-likes as if they were dense.
    _.each = _.forEach = function(obj, iteratee, context) {
      iteratee = optimizeCb(iteratee, context);
      var i, length;
      if (isArrayLike(obj)) {
        for (i = 0, length = obj.length; i < length; i++) {
          iteratee(obj[i], i, obj);
        }
      } else {
        var keys = _.keys(obj);
        for (i = 0, length = keys.length; i < length; i++) {
          iteratee(obj[keys[i]], keys[i], obj);
        }
      }
      return obj;
    };

    // Return the results of applying the iteratee to each element.
    _.map = _.collect = function(obj, iteratee, context) {
      iteratee = cb(iteratee, context);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          results = Array(length);
      for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        results[index] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
    };

    // Create a reducing function iterating left or right.
    var createReduce = function(dir) {
      // Wrap code that reassigns argument variables in a separate function than
      // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
      var reducer = function(obj, iteratee, memo, initial) {
        var keys = !isArrayLike(obj) && _.keys(obj),
            length = (keys || obj).length,
            index = dir > 0 ? 0 : length - 1;
        if (!initial) {
          memo = obj[keys ? keys[index] : index];
          index += dir;
        }
        for (; index >= 0 && index < length; index += dir) {
          var currentKey = keys ? keys[index] : index;
          memo = iteratee(memo, obj[currentKey], currentKey, obj);
        }
        return memo;
      };

      return function(obj, iteratee, memo, context) {
        var initial = arguments.length >= 3;
        return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
      };
    };

    // **Reduce** builds up a single result from a list of values, aka `inject`,
    // or `foldl`.
    _.reduce = _.foldl = _.inject = createReduce(1);

    // The right-associative version of reduce, also known as `foldr`.
    _.reduceRight = _.foldr = createReduce(-1);

    // Return the first value which passes a truth test. Aliased as `detect`.
    _.find = _.detect = function(obj, predicate, context) {
      var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
      var key = keyFinder(obj, predicate, context);
      if (key !== void 0 && key !== -1) return obj[key];
    };

    // Return all the elements that pass a truth test.
    // Aliased as `select`.
    _.filter = _.select = function(obj, predicate, context) {
      var results = [];
      predicate = cb(predicate, context);
      _.each(obj, function(value, index, list) {
        if (predicate(value, index, list)) results.push(value);
      });
      return results;
    };

    // Return all the elements for which a truth test fails.
    _.reject = function(obj, predicate, context) {
      return _.filter(obj, _.negate(cb(predicate)), context);
    };

    // Determine whether all of the elements match a truth test.
    // Aliased as `all`.
    _.every = _.all = function(obj, predicate, context) {
      predicate = cb(predicate, context);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length;
      for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        if (!predicate(obj[currentKey], currentKey, obj)) return false;
      }
      return true;
    };

    // Determine if at least one element in the object matches a truth test.
    // Aliased as `any`.
    _.some = _.any = function(obj, predicate, context) {
      predicate = cb(predicate, context);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length;
      for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        if (predicate(obj[currentKey], currentKey, obj)) return true;
      }
      return false;
    };

    // Determine if the array or object contains a given item (using `===`).
    // Aliased as `includes` and `include`.
    _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      if (typeof fromIndex != 'number' || guard) fromIndex = 0;
      return _.indexOf(obj, item, fromIndex) >= 0;
    };

    // Invoke a method (with arguments) on every item in a collection.
    _.invoke = restArguments(function(obj, path, args) {
      var contextPath, func;
      if (_.isFunction(path)) {
        func = path;
      } else if (_.isArray(path)) {
        contextPath = path.slice(0, -1);
        path = path[path.length - 1];
      }
      return _.map(obj, function(context) {
        var method = func;
        if (!method) {
          if (contextPath && contextPath.length) {
            context = deepGet(context, contextPath);
          }
          if (context == null) return void 0;
          method = context[path];
        }
        return method == null ? method : method.apply(context, args);
      });
    });

    // Convenience version of a common use case of `map`: fetching a property.
    _.pluck = function(obj, key) {
      return _.map(obj, _.property(key));
    };

    // Convenience version of a common use case of `filter`: selecting only objects
    // containing specific `key:value` pairs.
    _.where = function(obj, attrs) {
      return _.filter(obj, _.matcher(attrs));
    };

    // Convenience version of a common use case of `find`: getting the first object
    // containing specific `key:value` pairs.
    _.findWhere = function(obj, attrs) {
      return _.find(obj, _.matcher(attrs));
    };

    // Return the maximum element (or element-based computation).
    _.max = function(obj, iteratee, context) {
      var result = -Infinity, lastComputed = -Infinity,
          value, computed;
      if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
        obj = isArrayLike(obj) ? obj : _.values(obj);
        for (var i = 0, length = obj.length; i < length; i++) {
          value = obj[i];
          if (value != null && value > result) {
            result = value;
          }
        }
      } else {
        iteratee = cb(iteratee, context);
        _.each(obj, function(v, index, list) {
          computed = iteratee(v, index, list);
          if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
            result = v;
            lastComputed = computed;
          }
        });
      }
      return result;
    };

    // Return the minimum element (or element-based computation).
    _.min = function(obj, iteratee, context) {
      var result = Infinity, lastComputed = Infinity,
          value, computed;
      if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
        obj = isArrayLike(obj) ? obj : _.values(obj);
        for (var i = 0, length = obj.length; i < length; i++) {
          value = obj[i];
          if (value != null && value < result) {
            result = value;
          }
        }
      } else {
        iteratee = cb(iteratee, context);
        _.each(obj, function(v, index, list) {
          computed = iteratee(v, index, list);
          if (computed < lastComputed || computed === Infinity && result === Infinity) {
            result = v;
            lastComputed = computed;
          }
        });
      }
      return result;
    };

    // Shuffle a collection.
    _.shuffle = function(obj) {
      return _.sample(obj, Infinity);
    };

    // Sample **n** random values from a collection using the modern version of the
    // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
    // If **n** is not specified, returns a single random element.
    // The internal `guard` argument allows it to work with `map`.
    _.sample = function(obj, n, guard) {
      if (n == null || guard) {
        if (!isArrayLike(obj)) obj = _.values(obj);
        return obj[_.random(obj.length - 1)];
      }
      var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
      var length = getLength(sample);
      n = Math.max(Math.min(n, length), 0);
      var last = length - 1;
      for (var index = 0; index < n; index++) {
        var rand = _.random(index, last);
        var temp = sample[index];
        sample[index] = sample[rand];
        sample[rand] = temp;
      }
      return sample.slice(0, n);
    };

    // Sort the object's values by a criterion produced by an iteratee.
    _.sortBy = function(obj, iteratee, context) {
      var index = 0;
      iteratee = cb(iteratee, context);
      return _.pluck(_.map(obj, function(value, key, list) {
        return {
          value: value,
          index: index++,
          criteria: iteratee(value, key, list)
        };
      }).sort(function(left, right) {
        var a = left.criteria;
        var b = right.criteria;
        if (a !== b) {
          if (a > b || a === void 0) return 1;
          if (a < b || b === void 0) return -1;
        }
        return left.index - right.index;
      }), 'value');
    };

    // An internal function used for aggregate "group by" operations.
    var group = function(behavior, partition) {
      return function(obj, iteratee, context) {
        var result = partition ? [[], []] : {};
        iteratee = cb(iteratee, context);
        _.each(obj, function(value, index) {
          var key = iteratee(value, index, obj);
          behavior(result, value, key);
        });
        return result;
      };
    };

    // Groups the object's values by a criterion. Pass either a string attribute
    // to group by, or a function that returns the criterion.
    _.groupBy = group(function(result, value, key) {
      if (has(result, key)) result[key].push(value); else result[key] = [value];
    });

    // Indexes the object's values by a criterion, similar to `groupBy`, but for
    // when you know that your index values will be unique.
    _.indexBy = group(function(result, value, key) {
      result[key] = value;
    });

    // Counts instances of an object that group by a certain criterion. Pass
    // either a string attribute to count by, or a function that returns the
    // criterion.
    _.countBy = group(function(result, value, key) {
      if (has(result, key)) result[key]++; else result[key] = 1;
    });

    var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
    // Safely create a real, live array from anything iterable.
    _.toArray = function(obj) {
      if (!obj) return [];
      if (_.isArray(obj)) return slice.call(obj);
      if (_.isString(obj)) {
        // Keep surrogate pair characters together
        return obj.match(reStrSymbol);
      }
      if (isArrayLike(obj)) return _.map(obj, _.identity);
      return _.values(obj);
    };

    // Return the number of elements in an object.
    _.size = function(obj) {
      if (obj == null) return 0;
      return isArrayLike(obj) ? obj.length : _.keys(obj).length;
    };

    // Split a collection into two arrays: one whose elements all satisfy the given
    // predicate, and one whose elements all do not satisfy the predicate.
    _.partition = group(function(result, value, pass) {
      result[pass ? 0 : 1].push(value);
    }, true);

    // Array Functions
    // ---------------

    // Get the first element of an array. Passing **n** will return the first N
    // values in the array. Aliased as `head` and `take`. The **guard** check
    // allows it to work with `_.map`.
    _.first = _.head = _.take = function(array, n, guard) {
      if (array == null || array.length < 1) return n == null ? void 0 : [];
      if (n == null || guard) return array[0];
      return _.initial(array, array.length - n);
    };

    // Returns everything but the last entry of the array. Especially useful on
    // the arguments object. Passing **n** will return all the values in
    // the array, excluding the last N.
    _.initial = function(array, n, guard) {
      return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
    };

    // Get the last element of an array. Passing **n** will return the last N
    // values in the array.
    _.last = function(array, n, guard) {
      if (array == null || array.length < 1) return n == null ? void 0 : [];
      if (n == null || guard) return array[array.length - 1];
      return _.rest(array, Math.max(0, array.length - n));
    };

    // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
    // Especially useful on the arguments object. Passing an **n** will return
    // the rest N values in the array.
    _.rest = _.tail = _.drop = function(array, n, guard) {
      return slice.call(array, n == null || guard ? 1 : n);
    };

    // Trim out all falsy values from an array.
    _.compact = function(array) {
      return _.filter(array, Boolean);
    };

    // Internal implementation of a recursive `flatten` function.
    var flatten = function(input, shallow, strict, output) {
      output = output || [];
      var idx = output.length;
      for (var i = 0, length = getLength(input); i < length; i++) {
        var value = input[i];
        if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
          // Flatten current level of array or arguments object.
          if (shallow) {
            var j = 0, len = value.length;
            while (j < len) output[idx++] = value[j++];
          } else {
            flatten(value, shallow, strict, output);
            idx = output.length;
          }
        } else if (!strict) {
          output[idx++] = value;
        }
      }
      return output;
    };

    // Flatten out an array, either recursively (by default), or just one level.
    _.flatten = function(array, shallow) {
      return flatten(array, shallow, false);
    };

    // Return a version of the array that does not contain the specified value(s).
    _.without = restArguments(function(array, otherArrays) {
      return _.difference(array, otherArrays);
    });

    // Produce a duplicate-free version of the array. If the array has already
    // been sorted, you have the option of using a faster algorithm.
    // The faster algorithm will not work with an iteratee if the iteratee
    // is not a one-to-one function, so providing an iteratee will disable
    // the faster algorithm.
    // Aliased as `unique`.
    _.uniq = _.unique = function(array, isSorted, iteratee, context) {
      if (!_.isBoolean(isSorted)) {
        context = iteratee;
        iteratee = isSorted;
        isSorted = false;
      }
      if (iteratee != null) iteratee = cb(iteratee, context);
      var result = [];
      var seen = [];
      for (var i = 0, length = getLength(array); i < length; i++) {
        var value = array[i],
            computed = iteratee ? iteratee(value, i, array) : value;
        if (isSorted && !iteratee) {
          if (!i || seen !== computed) result.push(value);
          seen = computed;
        } else if (iteratee) {
          if (!_.contains(seen, computed)) {
            seen.push(computed);
            result.push(value);
          }
        } else if (!_.contains(result, value)) {
          result.push(value);
        }
      }
      return result;
    };

    // Produce an array that contains the union: each distinct element from all of
    // the passed-in arrays.
    _.union = restArguments(function(arrays) {
      return _.uniq(flatten(arrays, true, true));
    });

    // Produce an array that contains every item shared between all the
    // passed-in arrays.
    _.intersection = function(array) {
      var result = [];
      var argsLength = arguments.length;
      for (var i = 0, length = getLength(array); i < length; i++) {
        var item = array[i];
        if (_.contains(result, item)) continue;
        var j;
        for (j = 1; j < argsLength; j++) {
          if (!_.contains(arguments[j], item)) break;
        }
        if (j === argsLength) result.push(item);
      }
      return result;
    };

    // Take the difference between one array and a number of other arrays.
    // Only the elements present in just the first array will remain.
    _.difference = restArguments(function(array, rest) {
      rest = flatten(rest, true, true);
      return _.filter(array, function(value){
        return !_.contains(rest, value);
      });
    });

    // Complement of _.zip. Unzip accepts an array of arrays and groups
    // each array's elements on shared indices.
    _.unzip = function(array) {
      var length = array && _.max(array, getLength).length || 0;
      var result = Array(length);

      for (var index = 0; index < length; index++) {
        result[index] = _.pluck(array, index);
      }
      return result;
    };

    // Zip together multiple lists into a single array -- elements that share
    // an index go together.
    _.zip = restArguments(_.unzip);

    // Converts lists into objects. Pass either a single array of `[key, value]`
    // pairs, or two parallel arrays of the same length -- one of keys, and one of
    // the corresponding values. Passing by pairs is the reverse of _.pairs.
    _.object = function(list, values) {
      var result = {};
      for (var i = 0, length = getLength(list); i < length; i++) {
        if (values) {
          result[list[i]] = values[i];
        } else {
          result[list[i][0]] = list[i][1];
        }
      }
      return result;
    };

    // Generator function to create the findIndex and findLastIndex functions.
    var createPredicateIndexFinder = function(dir) {
      return function(array, predicate, context) {
        predicate = cb(predicate, context);
        var length = getLength(array);
        var index = dir > 0 ? 0 : length - 1;
        for (; index >= 0 && index < length; index += dir) {
          if (predicate(array[index], index, array)) return index;
        }
        return -1;
      };
    };

    // Returns the first index on an array-like that passes a predicate test.
    _.findIndex = createPredicateIndexFinder(1);
    _.findLastIndex = createPredicateIndexFinder(-1);

    // Use a comparator function to figure out the smallest index at which
    // an object should be inserted so as to maintain order. Uses binary search.
    _.sortedIndex = function(array, obj, iteratee, context) {
      iteratee = cb(iteratee, context, 1);
      var value = iteratee(obj);
      var low = 0, high = getLength(array);
      while (low < high) {
        var mid = Math.floor((low + high) / 2);
        if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
      }
      return low;
    };

    // Generator function to create the indexOf and lastIndexOf functions.
    var createIndexFinder = function(dir, predicateFind, sortedIndex) {
      return function(array, item, idx) {
        var i = 0, length = getLength(array);
        if (typeof idx == 'number') {
          if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
          } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
          }
        } else if (sortedIndex && idx && length) {
          idx = sortedIndex(array, item);
          return array[idx] === item ? idx : -1;
        }
        if (item !== item) {
          idx = predicateFind(slice.call(array, i, length), _.isNaN);
          return idx >= 0 ? idx + i : -1;
        }
        for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
          if (array[idx] === item) return idx;
        }
        return -1;
      };
    };

    // Return the position of the first occurrence of an item in an array,
    // or -1 if the item is not included in the array.
    // If the array is large and already in sort order, pass `true`
    // for **isSorted** to use binary search.
    _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
    _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

    // Generate an integer Array containing an arithmetic progression. A port of
    // the native Python `range()` function. See
    // [the Python documentation](http://docs.python.org/library/functions.html#range).
    _.range = function(start, stop, step) {
      if (stop == null) {
        stop = start || 0;
        start = 0;
      }
      if (!step) {
        step = stop < start ? -1 : 1;
      }

      var length = Math.max(Math.ceil((stop - start) / step), 0);
      var range = Array(length);

      for (var idx = 0; idx < length; idx++, start += step) {
        range[idx] = start;
      }

      return range;
    };

    // Chunk a single array into multiple arrays, each containing `count` or fewer
    // items.
    _.chunk = function(array, count) {
      if (count == null || count < 1) return [];
      var result = [];
      var i = 0, length = array.length;
      while (i < length) {
        result.push(slice.call(array, i, i += count));
      }
      return result;
    };

    // Function (ahem) Functions
    // ------------------

    // Determines whether to execute a function as a constructor
    // or a normal function with the provided arguments.
    var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
      if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
      var self = baseCreate(sourceFunc.prototype);
      var result = sourceFunc.apply(self, args);
      if (_.isObject(result)) return result;
      return self;
    };

    // Create a function bound to a given object (assigning `this`, and arguments,
    // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
    // available.
    _.bind = restArguments(function(func, context, args) {
      if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
      var bound = restArguments(function(callArgs) {
        return executeBound(func, bound, context, this, args.concat(callArgs));
      });
      return bound;
    });

    // Partially apply a function by creating a version that has had some of its
    // arguments pre-filled, without changing its dynamic `this` context. _ acts
    // as a placeholder by default, allowing any combination of arguments to be
    // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
    _.partial = restArguments(function(func, boundArgs) {
      var placeholder = _.partial.placeholder;
      var bound = function() {
        var position = 0, length = boundArgs.length;
        var args = Array(length);
        for (var i = 0; i < length; i++) {
          args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
        }
        while (position < arguments.length) args.push(arguments[position++]);
        return executeBound(func, bound, this, this, args);
      };
      return bound;
    });

    _.partial.placeholder = _;

    // Bind a number of an object's methods to that object. Remaining arguments
    // are the method names to be bound. Useful for ensuring that all callbacks
    // defined on an object belong to it.
    _.bindAll = restArguments(function(obj, keys) {
      keys = flatten(keys, false, false);
      var index = keys.length;
      if (index < 1) throw new Error('bindAll must be passed function names');
      while (index--) {
        var key = keys[index];
        obj[key] = _.bind(obj[key], obj);
      }
    });

    // Memoize an expensive function by storing its results.
    _.memoize = function(func, hasher) {
      var memoize = function(key) {
        var cache = memoize.cache;
        var address = '' + (hasher ? hasher.apply(this, arguments) : key);
        if (!has(cache, address)) cache[address] = func.apply(this, arguments);
        return cache[address];
      };
      memoize.cache = {};
      return memoize;
    };

    // Delays a function for the given number of milliseconds, and then calls
    // it with the arguments supplied.
    _.delay = restArguments(function(func, wait, args) {
      return setTimeout(function() {
        return func.apply(null, args);
      }, wait);
    });

    // Defers a function, scheduling it to run after the current call stack has
    // cleared.
    _.defer = _.partial(_.delay, _, 1);

    // Returns a function, that, when invoked, will only be triggered at most once
    // during a given window of time. Normally, the throttled function will run
    // as much as it can, without ever going more than once per `wait` duration;
    // but if you'd like to disable the execution on the leading edge, pass
    // `{leading: false}`. To disable execution on the trailing edge, ditto.
    _.throttle = function(func, wait, options) {
      var timeout, context, args, result;
      var previous = 0;
      if (!options) options = {};

      var later = function() {
        previous = options.leading === false ? 0 : _.now();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      };

      var throttled = function() {
        var now = _.now();
        if (!previous && options.leading === false) previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
          previous = now;
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        } else if (!timeout && options.trailing !== false) {
          timeout = setTimeout(later, remaining);
        }
        return result;
      };

      throttled.cancel = function() {
        clearTimeout(timeout);
        previous = 0;
        timeout = context = args = null;
      };

      return throttled;
    };

    // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds. If `immediate` is passed, trigger the function on the
    // leading edge, instead of the trailing.
    _.debounce = function(func, wait, immediate) {
      var timeout, result;

      var later = function(context, args) {
        timeout = null;
        if (args) result = func.apply(context, args);
      };

      var debounced = restArguments(function(args) {
        if (timeout) clearTimeout(timeout);
        if (immediate) {
          var callNow = !timeout;
          timeout = setTimeout(later, wait);
          if (callNow) result = func.apply(this, args);
        } else {
          timeout = _.delay(later, wait, this, args);
        }

        return result;
      });

      debounced.cancel = function() {
        clearTimeout(timeout);
        timeout = null;
      };

      return debounced;
    };

    // Returns the first function passed as an argument to the second,
    // allowing you to adjust arguments, run code before and after, and
    // conditionally execute the original function.
    _.wrap = function(func, wrapper) {
      return _.partial(wrapper, func);
    };

    // Returns a negated version of the passed-in predicate.
    _.negate = function(predicate) {
      return function() {
        return !predicate.apply(this, arguments);
      };
    };

    // Returns a function that is the composition of a list of functions, each
    // consuming the return value of the function that follows.
    _.compose = function() {
      var args = arguments;
      var start = args.length - 1;
      return function() {
        var i = start;
        var result = args[start].apply(this, arguments);
        while (i--) result = args[i].call(this, result);
        return result;
      };
    };

    // Returns a function that will only be executed on and after the Nth call.
    _.after = function(times, func) {
      return function() {
        if (--times < 1) {
          return func.apply(this, arguments);
        }
      };
    };

    // Returns a function that will only be executed up to (but not including) the Nth call.
    _.before = function(times, func) {
      var memo;
      return function() {
        if (--times > 0) {
          memo = func.apply(this, arguments);
        }
        if (times <= 1) func = null;
        return memo;
      };
    };

    // Returns a function that will be executed at most one time, no matter how
    // often you call it. Useful for lazy initialization.
    _.once = _.partial(_.before, 2);

    _.restArguments = restArguments;

    // Object Functions
    // ----------------

    // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
    var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
    var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

    var collectNonEnumProps = function(obj, keys) {
      var nonEnumIdx = nonEnumerableProps.length;
      var constructor = obj.constructor;
      var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;

      // Constructor is a special case.
      var prop = 'constructor';
      if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

      while (nonEnumIdx--) {
        prop = nonEnumerableProps[nonEnumIdx];
        if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
          keys.push(prop);
        }
      }
    };

    // Retrieve the names of an object's own properties.
    // Delegates to **ECMAScript 5**'s native `Object.keys`.
    _.keys = function(obj) {
      if (!_.isObject(obj)) return [];
      if (nativeKeys) return nativeKeys(obj);
      var keys = [];
      for (var key in obj) if (has(obj, key)) keys.push(key);
      // Ahem, IE < 9.
      if (hasEnumBug) collectNonEnumProps(obj, keys);
      return keys;
    };

    // Retrieve all the property names of an object.
    _.allKeys = function(obj) {
      if (!_.isObject(obj)) return [];
      var keys = [];
      for (var key in obj) keys.push(key);
      // Ahem, IE < 9.
      if (hasEnumBug) collectNonEnumProps(obj, keys);
      return keys;
    };

    // Retrieve the values of an object's properties.
    _.values = function(obj) {
      var keys = _.keys(obj);
      var length = keys.length;
      var values = Array(length);
      for (var i = 0; i < length; i++) {
        values[i] = obj[keys[i]];
      }
      return values;
    };

    // Returns the results of applying the iteratee to each element of the object.
    // In contrast to _.map it returns an object.
    _.mapObject = function(obj, iteratee, context) {
      iteratee = cb(iteratee, context);
      var keys = _.keys(obj),
          length = keys.length,
          results = {};
      for (var index = 0; index < length; index++) {
        var currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
    };

    // Convert an object into a list of `[key, value]` pairs.
    // The opposite of _.object.
    _.pairs = function(obj) {
      var keys = _.keys(obj);
      var length = keys.length;
      var pairs = Array(length);
      for (var i = 0; i < length; i++) {
        pairs[i] = [keys[i], obj[keys[i]]];
      }
      return pairs;
    };

    // Invert the keys and values of an object. The values must be serializable.
    _.invert = function(obj) {
      var result = {};
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        result[obj[keys[i]]] = keys[i];
      }
      return result;
    };

    // Return a sorted list of the function names available on the object.
    // Aliased as `methods`.
    _.functions = _.methods = function(obj) {
      var names = [];
      for (var key in obj) {
        if (_.isFunction(obj[key])) names.push(key);
      }
      return names.sort();
    };

    // An internal function for creating assigner functions.
    var createAssigner = function(keysFunc, defaults) {
      return function(obj) {
        var length = arguments.length;
        if (defaults) obj = Object(obj);
        if (length < 2 || obj == null) return obj;
        for (var index = 1; index < length; index++) {
          var source = arguments[index],
              keys = keysFunc(source),
              l = keys.length;
          for (var i = 0; i < l; i++) {
            var key = keys[i];
            if (!defaults || obj[key] === void 0) obj[key] = source[key];
          }
        }
        return obj;
      };
    };

    // Extend a given object with all the properties in passed-in object(s).
    _.extend = createAssigner(_.allKeys);

    // Assigns a given object with all the own properties in the passed-in object(s).
    // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
    _.extendOwn = _.assign = createAssigner(_.keys);

    // Returns the first key on an object that passes a predicate test.
    _.findKey = function(obj, predicate, context) {
      predicate = cb(predicate, context);
      var keys = _.keys(obj), key;
      for (var i = 0, length = keys.length; i < length; i++) {
        key = keys[i];
        if (predicate(obj[key], key, obj)) return key;
      }
    };

    // Internal pick helper function to determine if `obj` has key `key`.
    var keyInObj = function(value, key, obj) {
      return key in obj;
    };

    // Return a copy of the object only containing the whitelisted properties.
    _.pick = restArguments(function(obj, keys) {
      var result = {}, iteratee = keys[0];
      if (obj == null) return result;
      if (_.isFunction(iteratee)) {
        if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
        keys = _.allKeys(obj);
      } else {
        iteratee = keyInObj;
        keys = flatten(keys, false, false);
        obj = Object(obj);
      }
      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i];
        var value = obj[key];
        if (iteratee(value, key, obj)) result[key] = value;
      }
      return result;
    });

    // Return a copy of the object without the blacklisted properties.
    _.omit = restArguments(function(obj, keys) {
      var iteratee = keys[0], context;
      if (_.isFunction(iteratee)) {
        iteratee = _.negate(iteratee);
        if (keys.length > 1) context = keys[1];
      } else {
        keys = _.map(flatten(keys, false, false), String);
        iteratee = function(value, key) {
          return !_.contains(keys, key);
        };
      }
      return _.pick(obj, iteratee, context);
    });

    // Fill in a given object with default properties.
    _.defaults = createAssigner(_.allKeys, true);

    // Creates an object that inherits from the given prototype object.
    // If additional properties are provided then they will be added to the
    // created object.
    _.create = function(prototype, props) {
      var result = baseCreate(prototype);
      if (props) _.extendOwn(result, props);
      return result;
    };

    // Create a (shallow-cloned) duplicate of an object.
    _.clone = function(obj) {
      if (!_.isObject(obj)) return obj;
      return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
    };

    // Invokes interceptor with the obj, and then returns obj.
    // The primary purpose of this method is to "tap into" a method chain, in
    // order to perform operations on intermediate results within the chain.
    _.tap = function(obj, interceptor) {
      interceptor(obj);
      return obj;
    };

    // Returns whether an object has a given set of `key:value` pairs.
    _.isMatch = function(object, attrs) {
      var keys = _.keys(attrs), length = keys.length;
      if (object == null) return !length;
      var obj = Object(object);
      for (var i = 0; i < length; i++) {
        var key = keys[i];
        if (attrs[key] !== obj[key] || !(key in obj)) return false;
      }
      return true;
    };


    // Internal recursive comparison function for `isEqual`.
    var eq, deepEq;
    eq = function(a, b, aStack, bStack) {
      // Identical objects are equal. `0 === -0`, but they aren't identical.
      // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
      if (a === b) return a !== 0 || 1 / a === 1 / b;
      // `null` or `undefined` only equal to itself (strict comparison).
      if (a == null || b == null) return false;
      // `NaN`s are equivalent, but non-reflexive.
      if (a !== a) return b !== b;
      // Exhaust primitive checks
      var type = typeof a;
      if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
      return deepEq(a, b, aStack, bStack);
    };

    // Internal recursive comparison function for `isEqual`.
    deepEq = function(a, b, aStack, bStack) {
      // Unwrap any wrapped objects.
      if (a instanceof _) a = a._wrapped;
      if (b instanceof _) b = b._wrapped;
      // Compare `[[Class]]` names.
      var className = toString.call(a);
      if (className !== toString.call(b)) return false;
      switch (className) {
        // Strings, numbers, regular expressions, dates, and booleans are compared by value.
        case '[object RegExp]':
        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
        case '[object String]':
          // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
          // equivalent to `new String("5")`.
          return '' + a === '' + b;
        case '[object Number]':
          // `NaN`s are equivalent, but non-reflexive.
          // Object(NaN) is equivalent to NaN.
          if (+a !== +a) return +b !== +b;
          // An `egal` comparison is performed for other numeric values.
          return +a === 0 ? 1 / +a === 1 / b : +a === +b;
        case '[object Date]':
        case '[object Boolean]':
          // Coerce dates and booleans to numeric primitive values. Dates are compared by their
          // millisecond representations. Note that invalid dates with millisecond representations
          // of `NaN` are not equivalent.
          return +a === +b;
        case '[object Symbol]':
          return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
      }

      var areArrays = className === '[object Array]';
      if (!areArrays) {
        if (typeof a != 'object' || typeof b != 'object') return false;

        // Objects with different constructors are not equivalent, but `Object`s or `Array`s
        // from different frames are.
        var aCtor = a.constructor, bCtor = b.constructor;
        if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                                 _.isFunction(bCtor) && bCtor instanceof bCtor)
                            && ('constructor' in a && 'constructor' in b)) {
          return false;
        }
      }
      // Assume equality for cyclic structures. The algorithm for detecting cyclic
      // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

      // Initializing stack of traversed objects.
      // It's done here since we only need them for objects and arrays comparison.
      aStack = aStack || [];
      bStack = bStack || [];
      var length = aStack.length;
      while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        if (aStack[length] === a) return bStack[length] === b;
      }

      // Add the first object to the stack of traversed objects.
      aStack.push(a);
      bStack.push(b);

      // Recursively compare objects and arrays.
      if (areArrays) {
        // Compare array lengths to determine if a deep comparison is necessary.
        length = a.length;
        if (length !== b.length) return false;
        // Deep compare the contents, ignoring non-numeric properties.
        while (length--) {
          if (!eq(a[length], b[length], aStack, bStack)) return false;
        }
      } else {
        // Deep compare objects.
        var keys = _.keys(a), key;
        length = keys.length;
        // Ensure that both objects contain the same number of properties before comparing deep equality.
        if (_.keys(b).length !== length) return false;
        while (length--) {
          // Deep compare each member
          key = keys[length];
          if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
        }
      }
      // Remove the first object from the stack of traversed objects.
      aStack.pop();
      bStack.pop();
      return true;
    };

    // Perform a deep comparison to check if two objects are equal.
    _.isEqual = function(a, b) {
      return eq(a, b);
    };

    // Is a given array, string, or object empty?
    // An "empty" object has no enumerable own-properties.
    _.isEmpty = function(obj) {
      if (obj == null) return true;
      if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
      return _.keys(obj).length === 0;
    };

    // Is a given value a DOM element?
    _.isElement = function(obj) {
      return !!(obj && obj.nodeType === 1);
    };

    // Is a given value an array?
    // Delegates to ECMA5's native Array.isArray
    _.isArray = nativeIsArray || function(obj) {
      return toString.call(obj) === '[object Array]';
    };

    // Is a given variable an object?
    _.isObject = function(obj) {
      var type = typeof obj;
      return type === 'function' || type === 'object' && !!obj;
    };

    // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
    _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {
      _['is' + name] = function(obj) {
        return toString.call(obj) === '[object ' + name + ']';
      };
    });

    // Define a fallback version of the method in browsers (ahem, IE < 9), where
    // there isn't any inspectable "Arguments" type.
    if (!_.isArguments(arguments)) {
      _.isArguments = function(obj) {
        return has(obj, 'callee');
      };
    }

    // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
    // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
    var nodelist = root.document && root.document.childNodes;
    if ( true && typeof Int8Array != 'object' && typeof nodelist != 'function') {
      _.isFunction = function(obj) {
        return typeof obj == 'function' || false;
      };
    }

    // Is a given object a finite number?
    _.isFinite = function(obj) {
      return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
    };

    // Is the given value `NaN`?
    _.isNaN = function(obj) {
      return _.isNumber(obj) && isNaN(obj);
    };

    // Is a given value a boolean?
    _.isBoolean = function(obj) {
      return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
    };

    // Is a given value equal to null?
    _.isNull = function(obj) {
      return obj === null;
    };

    // Is a given variable undefined?
    _.isUndefined = function(obj) {
      return obj === void 0;
    };

    // Shortcut function for checking if an object has a given property directly
    // on itself (in other words, not on a prototype).
    _.has = function(obj, path) {
      if (!_.isArray(path)) {
        return has(obj, path);
      }
      var length = path.length;
      for (var i = 0; i < length; i++) {
        var key = path[i];
        if (obj == null || !hasOwnProperty.call(obj, key)) {
          return false;
        }
        obj = obj[key];
      }
      return !!length;
    };

    // Utility Functions
    // -----------------

    // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
    // previous owner. Returns a reference to the Underscore object.
    _.noConflict = function() {
      root._ = previousUnderscore;
      return this;
    };

    // Keep the identity function around for default iteratees.
    _.identity = function(value) {
      return value;
    };

    // Predicate-generating functions. Often useful outside of Underscore.
    _.constant = function(value) {
      return function() {
        return value;
      };
    };

    _.noop = function(){};

    // Creates a function that, when passed an object, will traverse that object’s
    // properties down the given `path`, specified as an array of keys or indexes.
    _.property = function(path) {
      if (!_.isArray(path)) {
        return shallowProperty(path);
      }
      return function(obj) {
        return deepGet(obj, path);
      };
    };

    // Generates a function for a given object that returns a given property.
    _.propertyOf = function(obj) {
      if (obj == null) {
        return function(){};
      }
      return function(path) {
        return !_.isArray(path) ? obj[path] : deepGet(obj, path);
      };
    };

    // Returns a predicate for checking whether an object has a given set of
    // `key:value` pairs.
    _.matcher = _.matches = function(attrs) {
      attrs = _.extendOwn({}, attrs);
      return function(obj) {
        return _.isMatch(obj, attrs);
      };
    };

    // Run a function **n** times.
    _.times = function(n, iteratee, context) {
      var accum = Array(Math.max(0, n));
      iteratee = optimizeCb(iteratee, context, 1);
      for (var i = 0; i < n; i++) accum[i] = iteratee(i);
      return accum;
    };

    // Return a random integer between min and max (inclusive).
    _.random = function(min, max) {
      if (max == null) {
        max = min;
        min = 0;
      }
      return min + Math.floor(Math.random() * (max - min + 1));
    };

    // A (possibly faster) way to get the current timestamp as an integer.
    _.now = Date.now || function() {
      return new Date().getTime();
    };

    // List of HTML entities for escaping.
    var escapeMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '`': '&#x60;'
    };
    var unescapeMap = _.invert(escapeMap);

    // Functions for escaping and unescaping strings to/from HTML interpolation.
    var createEscaper = function(map) {
      var escaper = function(match) {
        return map[match];
      };
      // Regexes for identifying a key that needs to be escaped.
      var source = '(?:' + _.keys(map).join('|') + ')';
      var testRegexp = RegExp(source);
      var replaceRegexp = RegExp(source, 'g');
      return function(string) {
        string = string == null ? '' : '' + string;
        return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
      };
    };
    _.escape = createEscaper(escapeMap);
    _.unescape = createEscaper(unescapeMap);

    // Traverses the children of `obj` along `path`. If a child is a function, it
    // is invoked with its parent as context. Returns the value of the final
    // child, or `fallback` if any child is undefined.
    _.result = function(obj, path, fallback) {
      if (!_.isArray(path)) path = [path];
      var length = path.length;
      if (!length) {
        return _.isFunction(fallback) ? fallback.call(obj) : fallback;
      }
      for (var i = 0; i < length; i++) {
        var prop = obj == null ? void 0 : obj[path[i]];
        if (prop === void 0) {
          prop = fallback;
          i = length; // Ensure we don't continue iterating.
        }
        obj = _.isFunction(prop) ? prop.call(obj) : prop;
      }
      return obj;
    };

    // Generate a unique integer id (unique within the entire client session).
    // Useful for temporary DOM ids.
    var idCounter = 0;
    _.uniqueId = function(prefix) {
      var id = ++idCounter + '';
      return prefix ? prefix + id : id;
    };

    // By default, Underscore uses ERB-style template delimiters, change the
    // following template settings to use alternative delimiters.
    _.templateSettings = {
      evaluate: /<%([\s\S]+?)%>/g,
      interpolate: /<%=([\s\S]+?)%>/g,
      escape: /<%-([\s\S]+?)%>/g
    };

    // When customizing `templateSettings`, if you don't want to define an
    // interpolation, evaluation or escaping regex, we need one that is
    // guaranteed not to match.
    var noMatch = /(.)^/;

    // Certain characters need to be escaped so that they can be put into a
    // string literal.
    var escapes = {
      "'": "'",
      '\\': '\\',
      '\r': 'r',
      '\n': 'n',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };

    var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

    var escapeChar = function(match) {
      return '\\' + escapes[match];
    };

    // JavaScript micro-templating, similar to John Resig's implementation.
    // Underscore templating handles arbitrary delimiters, preserves whitespace,
    // and correctly escapes quotes within interpolated code.
    // NB: `oldSettings` only exists for backwards compatibility.
    _.template = function(text, settings, oldSettings) {
      if (!settings && oldSettings) settings = oldSettings;
      settings = _.defaults({}, settings, _.templateSettings);

      // Combine delimiters into one regular expression via alternation.
      var matcher = RegExp([
        (settings.escape || noMatch).source,
        (settings.interpolate || noMatch).source,
        (settings.evaluate || noMatch).source
      ].join('|') + '|$', 'g');

      // Compile the template source, escaping string literals appropriately.
      var index = 0;
      var source = "__p+='";
      text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
        source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
        index = offset + match.length;

        if (escape) {
          source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
        } else if (interpolate) {
          source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
        } else if (evaluate) {
          source += "';\n" + evaluate + "\n__p+='";
        }

        // Adobe VMs need the match returned to produce the correct offset.
        return match;
      });
      source += "';\n";

      // If a variable is not specified, place data values in local scope.
      if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

      source = "var __t,__p='',__j=Array.prototype.join," +
        "print=function(){__p+=__j.call(arguments,'');};\n" +
        source + 'return __p;\n';

      var render;
      try {
        render = new Function(settings.variable || 'obj', '_', source);
      } catch (e) {
        e.source = source;
        throw e;
      }

      var template = function(data) {
        return render.call(this, data, _);
      };

      // Provide the compiled source as a convenience for precompilation.
      var argument = settings.variable || 'obj';
      template.source = 'function(' + argument + '){\n' + source + '}';

      return template;
    };

    // Add a "chain" function. Start chaining a wrapped Underscore object.
    _.chain = function(obj) {
      var instance = _(obj);
      instance._chain = true;
      return instance;
    };

    // OOP
    // ---------------
    // If Underscore is called as a function, it returns a wrapped object that
    // can be used OO-style. This wrapper holds altered versions of all the
    // underscore functions. Wrapped objects may be chained.

    // Helper function to continue chaining intermediate results.
    var chainResult = function(instance, obj) {
      return instance._chain ? _(obj).chain() : obj;
    };

    // Add your own custom functions to the Underscore object.
    _.mixin = function(obj) {
      _.each(_.functions(obj), function(name) {
        var func = _[name] = obj[name];
        _.prototype[name] = function() {
          var args = [this._wrapped];
          push.apply(args, arguments);
          return chainResult(this, func.apply(_, args));
        };
      });
      return _;
    };

    // Add all of the Underscore functions to the wrapper object.
    _.mixin(_);

    // Add all mutator Array functions to the wrapper.
    _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        var obj = this._wrapped;
        method.apply(obj, arguments);
        if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
        return chainResult(this, obj);
      };
    });

    // Add all accessor Array functions to the wrapper.
    _.each(['concat', 'join', 'slice'], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        return chainResult(this, method.apply(this._wrapped, arguments));
      };
    });

    // Extracts the result from a wrapped and chained object.
    _.prototype.value = function() {
      return this._wrapped;
    };

    // Provide unwrapping proxy for some methods used in engine operations
    // such as arithmetic and JSON stringification.
    _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

    _.prototype.toString = function() {
      return String(this._wrapped);
    };

    // AMD registration happens at the end for compatibility with AMD loaders
    // that may not enforce next-turn semantics on modules. Even though general
    // practice for AMD registration is to be anonymous, underscore registers
    // as a named module because, like jQuery, it is a base library that is
    // popular enough to be bundled in a third party lib, but not be part of
    // an AMD load request. Those cases could generate an error when an
    // anonymous define() is called outside of a loader request.
    if (true) {
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
        return _;
      }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
  				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
  }());

  /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(216)(module)))

  /***/ }),
  /* 249 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const pTry = __webpack_require__(250);

  const pLimit = concurrency => {
  	if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
  		return Promise.reject(new TypeError('Expected `concurrency` to be a number from 1 and up'));
  	}

  	const queue = [];
  	let activeCount = 0;

  	const next = () => {
  		activeCount--;

  		if (queue.length > 0) {
  			queue.shift()();
  		}
  	};

  	const run = (fn, resolve, ...args) => {
  		activeCount++;

  		const result = pTry(fn, ...args);

  		resolve(result);

  		result.then(next, next);
  	};

  	const enqueue = (fn, resolve, ...args) => {
  		if (activeCount < concurrency) {
  			run(fn, resolve, ...args);
  		} else {
  			queue.push(run.bind(null, fn, resolve, ...args));
  		}
  	};

  	const generator = (fn, ...args) => new Promise(resolve => enqueue(fn, resolve, ...args));
  	Object.defineProperties(generator, {
  		activeCount: {
  			get: () => activeCount
  		},
  		pendingCount: {
  			get: () => queue.length
  		}
  	});

  	return generator;
  };

  module.exports = pLimit;
  module.exports.default = pLimit;


  /***/ }),
  /* 250 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const pTry = (fn, ...arguments_) => new Promise(resolve => {
  	resolve(fn(...arguments_));
  });

  module.exports = pTry;
  // TODO: remove this in the next major version
  module.exports.default = pTry;


  /***/ }),
  /* 251 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      result["default"] = mod;
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const structUtils = __importStar(__webpack_require__(173));
  class AliasResolver {
      constructor(next) {
          this.next = next;
      }
      supportsDescriptor(descriptor, opts) {
          return this.next.supportsDescriptor(descriptor, opts);
      }
      supportsLocator(locator, opts) {
          return this.next.supportsLocator(locator, opts);
      }
      shouldPersistResolution(locator, opts) {
          return this.next.shouldPersistResolution(locator, opts);
      }
      bindDescriptor(descriptor, fromLocator, opts) {
          return this.next.bindDescriptor(descriptor, fromLocator, opts);
      }
      async getCandidates(descriptor, opts) {
          return await this.next.getCandidates(descriptor, opts);
      }
      async resolve(locator, opts) {
          const pkg = await this.next.resolve(locator, opts);
          const topLevelWorkspace = opts.project.topLevelWorkspace;
          for (const descriptor of Array.from(pkg.dependencies.values())) {
              for (const { pattern, reference } of topLevelWorkspace.manifest.resolutions) {
                  if (pattern.from && pattern.from.fullName !== structUtils.requirableIdent(locator))
                      continue;
                  if (pattern.from && pattern.from.description && pattern.from.description !== locator.reference)
                      continue;
                  if (pattern.descriptor.fullName !== structUtils.requirableIdent(descriptor))
                      continue;
                  if (pattern.descriptor.description && pattern.descriptor.description !== descriptor.range)
                      continue;
                  const alias = opts.resolver.bindDescriptor(structUtils.makeDescriptor(descriptor, reference), topLevelWorkspace.anchoredLocator, opts);
                  pkg.dependencies.delete(descriptor.identHash);
                  pkg.dependencies.set(alias.identHash, alias);
              }
          }
          return pkg;
      }
  }
  exports.AliasResolver = AliasResolver;


  /***/ }),
  /* 252 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      result["default"] = mod;
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const structUtils = __importStar(__webpack_require__(173));
  class LockfileResolver {
      supportsDescriptor(descriptor, opts) {
          const resolution = opts.project.storedResolutions.get(descriptor.descriptorHash);
          if (resolution)
              return true;
          // If the descriptor matches a package that's already been used, we can just use it even if we never resolved the range before
          // Ex: foo depends on bar@^1.0.0 that we resolved to foo@1.1.0, then we add a package qux that depends on foo@1.1.0 (without the caret)
          if (opts.project.storedPackages.has(structUtils.convertDescriptorToLocator(descriptor).locatorHash))
              return true;
          return false;
      }
      supportsLocator(locator, opts) {
          if (opts.project.storedPackages.has(locator.locatorHash))
              return true;
          return false;
      }
      shouldPersistResolution(locator, opts) {
          throw new Error(`The shouldPersistResolution method shouldn't be called on the lockfile resolver, which would always answer yes`);
      }
      bindDescriptor(descriptor, fromLocator, opts) {
          return descriptor;
      }
      async getCandidates(descriptor, opts) {
          let pkg = opts.project.storedPackages.get(structUtils.convertDescriptorToLocator(descriptor).locatorHash);
          if (pkg)
              return [pkg];
          const resolution = opts.project.storedResolutions.get(descriptor.descriptorHash);
          if (!resolution)
              throw new Error(`Expected the resolution to have been successful - resolution not found`);
          pkg = opts.project.storedPackages.get(resolution);
          if (!pkg)
              throw new Error(`Expected the resolution to have been successful - package not found`);
          return [pkg];
      }
      async resolve(locator, opts) {
          const pkg = opts.project.storedPackages.get(locator.locatorHash);
          if (!pkg)
              throw new Error(`The lockfile resolver isn't meant to resolve packages - they should already have been stored into a cache`);
          return pkg;
      }
  }
  exports.LockfileResolver = LockfileResolver;


  /***/ }),
  /* 253 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      result["default"] = mod;
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const Report_1 = __webpack_require__(177);
  const structUtils = __importStar(__webpack_require__(173));
  class RunInstallPleaseResolver {
      constructor(resolver) {
          this.resolver = resolver;
      }
      supportsDescriptor(descriptor, opts) {
          return this.resolver.supportsDescriptor(descriptor, opts);
      }
      supportsLocator(locator, opts) {
          return this.resolver.supportsLocator(locator, opts);
      }
      shouldPersistResolution(locator, opts) {
          throw new Error(`Unreachable`);
      }
      bindDescriptor(descriptor, fromLocator, opts) {
          throw new Report_1.ReportError(Report_1.MessageName.MISSING_LOCKFILE_ENTRY, `A dependency (${structUtils.prettyDescriptor(opts.project.configuration, descriptor)}) cannot be retrieved from the lockfile; try to make an install to update your resolutions`);
      }
      async getCandidates(descriptor, opts) {
          throw new Report_1.ReportError(Report_1.MessageName.MISSING_LOCKFILE_ENTRY, `This package doesn't seem to be present in your lockfile; try to make an install to update your resolutions`);
      }
      async resolve(locator, opts) {
          throw new Error(`Unreachable`);
      }
  }
  exports.RunInstallPleaseResolver = RunInstallPleaseResolver;


  /***/ }),
  /* 254 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const Report_1 = __webpack_require__(177);
  class ThrowReport extends Report_1.Report {
      reportCacheHit(locator) {
      }
      reportCacheMiss(locator) {
      }
      startTimerSync(what, cb) {
          return cb();
      }
      async startTimerPromise(what, cb) {
          return await cb();
      }
      reportSeparator() {
      }
      reportInfo(name, text) {
      }
      reportWarning(name, text) {
      }
      reportError(name, text) {
      }
      reportJson(data) {
          // Just ignore the json output
      }
      async finalize() {
      }
  }
  exports.ThrowReport = ThrowReport;


  /***/ }),
  /* 255 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importDefault = (this && this.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      result["default"] = mod;
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const fslib_1 = __webpack_require__(5);
  const crypto_1 = __webpack_require__(9);
  const globby_1 = __importDefault(__webpack_require__(256));
  const semver_1 = __importDefault(__webpack_require__(41));
  const Manifest_1 = __webpack_require__(172);
  const WorkspaceResolver_1 = __webpack_require__(238);
  const structUtils = __importStar(__webpack_require__(173));
  function hashWorkspaceCwd(cwd) {
      return crypto_1.createHmac('sha256', 'berry').update(cwd).digest('hex').substr(0, 6);
  }
  class Workspace {
      constructor(workspaceCwd, { project }) {
          // @ts-ignore: This variable is set during the setup process
          this.workspacesCwds = new Set();
          // Generated at resolution; basically dependencies + devDependencies + child workspaces
          this.dependencies = new Map();
          this.project = project;
          this.cwd = workspaceCwd;
      }
      async setup() {
          // @ts-ignore: It's ok to initialize it now
          this.manifest = await Manifest_1.Manifest.find(this.cwd);
          // We use ppath.relative to guarantee that the default hash will be consistent even if the project is installed on different OS / path
          // @ts-ignore: It's ok to initialize it now, even if it's readonly (setup is called right after construction)
          this.relativeCwd = fslib_1.ppath.relative(this.project.cwd, this.cwd) || fslib_1.PortablePath.dot;
          const ident = this.manifest.name ? this.manifest.name : structUtils.makeIdent(null, `${this.computeCandidateName()}-${hashWorkspaceCwd(this.relativeCwd)}`);
          const reference = this.manifest.version ? this.manifest.version : `0.0.0`;
          // @ts-ignore: It's ok to initialize it now, even if it's readonly (setup is called right after construction)
          this.locator = structUtils.makeLocator(ident, reference);
          // @ts-ignore: It's ok to initialize it now, even if it's readonly (setup is called right after construction)
          this.anchoredDescriptor = structUtils.makeDescriptor(this.locator, `${WorkspaceResolver_1.WorkspaceResolver.protocol}${this.relativeCwd}`);
          // @ts-ignore: It's ok to initialize it now, even if it's readonly (setup is called right after construction)
          this.anchoredLocator = structUtils.makeLocator(this.locator, `${WorkspaceResolver_1.WorkspaceResolver.protocol}${this.relativeCwd}`);
          for (const definition of this.manifest.workspaceDefinitions) {
              const relativeCwds = await globby_1.default(definition.pattern, {
                  absolute: true,
                  cwd: fslib_1.NodeFS.fromPortablePath(this.cwd),
                  expandDirectories: false,
                  onlyDirectories: true,
                  onlyFiles: false,
              });
              // It seems that the return value of globby isn't in any guaranteed order - not even the directory listing order
              relativeCwds.sort();
              for (const relativeCwd of relativeCwds) {
                  const candidateCwd = fslib_1.ppath.resolve(this.cwd, fslib_1.NodeFS.toPortablePath(relativeCwd));
                  if (fslib_1.xfs.existsSync(fslib_1.ppath.join(candidateCwd, fslib_1.toFilename(`package.json`)))) {
                      this.workspacesCwds.add(candidateCwd);
                  }
              }
          }
      }
      accepts(range) {
          const protocolIndex = range.indexOf(`:`);
          const protocol = protocolIndex !== -1
              ? range.slice(0, protocolIndex + 1)
              : null;
          const pathname = protocolIndex !== -1
              ? range.slice(protocolIndex + 1)
              : range;
          if (protocol === WorkspaceResolver_1.WorkspaceResolver.protocol && pathname === this.relativeCwd)
              return true;
          if (protocol === WorkspaceResolver_1.WorkspaceResolver.protocol && pathname === `*`)
              return true;
          if (!semver_1.default.validRange(pathname))
              return false;
          if (protocol === WorkspaceResolver_1.WorkspaceResolver.protocol)
              return semver_1.default.satisfies(this.manifest.version !== null ? this.manifest.version : `0.0.0`, pathname);
          if (this.manifest.version !== null)
              return semver_1.default.satisfies(this.manifest.version, pathname);
          return false;
      }
      computeCandidateName() {
          if (this.cwd === this.project.cwd) {
              return `root-workspace`;
          }
          else {
              return `${fslib_1.ppath.basename(this.cwd)}` || `unnamed-workspace`;
          }
      }
      async persistManifest() {
          const data = {};
          this.manifest.exportTo(data);
          const content = `${JSON.stringify(data, null, this.manifest.indent)}\n`;
          await fslib_1.xfs.changeFilePromise(fslib_1.ppath.join(this.cwd, fslib_1.toFilename(`package.json`)), content);
      }
      async persistRawManifest() {
          const content = `${JSON.stringify(this.manifest.raw, null, this.manifest.indent)}\n`;
          await fslib_1.xfs.changeFilePromise(fslib_1.ppath.join(this.cwd, fslib_1.toFilename(`package.json`)), content);
      }
  }
  exports.Workspace = Workspace;


  /***/ }),
  /* 256 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const arrayUnion = __webpack_require__(257);
  const glob = __webpack_require__(259);
  const fastGlob = __webpack_require__(271);
  const dirGlob = __webpack_require__(429);
  const gitignore = __webpack_require__(433);

  const DEFAULT_FILTER = () => false;

  const isNegative = pattern => pattern[0] === '!';

  const assertPatternsInput = patterns => {
  	if (!patterns.every(x => typeof x === 'string')) {
  		throw new TypeError('Patterns must be a string or an array of strings');
  	}
  };

  const generateGlobTasks = (patterns, taskOpts) => {
  	patterns = [].concat(patterns);
  	assertPatternsInput(patterns);

  	const globTasks = [];

  	taskOpts = Object.assign({
  		ignore: [],
  		expandDirectories: true
  	}, taskOpts);

  	patterns.forEach((pattern, i) => {
  		if (isNegative(pattern)) {
  			return;
  		}

  		const ignore = patterns
  			.slice(i)
  			.filter(isNegative)
  			.map(pattern => pattern.slice(1));

  		const opts = Object.assign({}, taskOpts, {
  			ignore: taskOpts.ignore.concat(ignore)
  		});

  		globTasks.push({pattern, opts});
  	});

  	return globTasks;
  };

  const globDirs = (task, fn) => {
  	let opts = {cwd: task.opts.cwd};

  	if (Array.isArray(task.opts.expandDirectories)) {
  		opts = Object.assign(opts, {files: task.opts.expandDirectories});
  	} else if (typeof task.opts.expandDirectories === 'object') {
  		opts = Object.assign(opts, task.opts.expandDirectories);
  	}

  	return fn(task.pattern, opts);
  };

  const getPattern = (task, fn) => task.opts.expandDirectories ? globDirs(task, fn) : [task.pattern];

  module.exports = (patterns, opts) => {
  	let globTasks;

  	try {
  		globTasks = generateGlobTasks(patterns, opts);
  	} catch (err) {
  		return Promise.reject(err);
  	}

  	const getTasks = Promise.all(globTasks.map(task => Promise.resolve(getPattern(task, dirGlob))
  		.then(globs => Promise.all(globs.map(glob => ({
  			pattern: glob,
  			opts: task.opts
  		}))))
  	))
  		.then(tasks => arrayUnion.apply(null, tasks));

  	const getFilter = () => {
  		return Promise.resolve(
  			opts && opts.gitignore ?
  				gitignore({cwd: opts.cwd, ignore: opts.ignore}) :
  				DEFAULT_FILTER
  		);
  	};

  	return getFilter()
  		.then(filter => {
  			return getTasks
  				.then(tasks => Promise.all(tasks.map(task => fastGlob(task.pattern, task.opts))))
  				.then(paths => arrayUnion.apply(null, paths))
  				.then(paths => paths.filter(p => !filter(p)));
  		});
  };

  module.exports.sync = (patterns, opts) => {
  	const globTasks = generateGlobTasks(patterns, opts);

  	const getFilter = () => {
  		return opts && opts.gitignore ?
  			gitignore.sync({cwd: opts.cwd, ignore: opts.ignore}) :
  			DEFAULT_FILTER;
  	};

  	const tasks = globTasks.reduce((tasks, task) => {
  		const newTask = getPattern(task, dirGlob.sync).map(glob => ({
  			pattern: glob,
  			opts: task.opts
  		}));
  		return tasks.concat(newTask);
  	}, []);

  	const filter = getFilter();

  	return tasks.reduce(
  		(matches, task) => arrayUnion(matches, fastGlob.sync(task.pattern, task.opts)),
  		[]
  	).filter(p => !filter(p));
  };

  module.exports.generateGlobTasks = generateGlobTasks;

  module.exports.hasMagic = (patterns, opts) => []
  	.concat(patterns)
  	.some(pattern => glob.hasMagic(pattern, opts));

  module.exports.gitignore = gitignore;


  /***/ }),
  /* 257 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var arrayUniq = __webpack_require__(258);

  module.exports = function () {
  	return arrayUniq([].concat.apply([], arguments));
  };


  /***/ }),
  /* 258 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  // there's 3 implementations written in increasing order of efficiency

  // 1 - no Set type is defined
  function uniqNoSet(arr) {
  	var ret = [];

  	for (var i = 0; i < arr.length; i++) {
  		if (ret.indexOf(arr[i]) === -1) {
  			ret.push(arr[i]);
  		}
  	}

  	return ret;
  }

  // 2 - a simple Set type is defined
  function uniqSet(arr) {
  	var seen = new Set();
  	return arr.filter(function (el) {
  		if (!seen.has(el)) {
  			seen.add(el);
  			return true;
  		}

  		return false;
  	});
  }

  // 3 - a standard Set type is defined and it has a forEach method
  function uniqSetWithForEach(arr) {
  	var ret = [];

  	(new Set(arr)).forEach(function (el) {
  		ret.push(el);
  	});

  	return ret;
  }

  // V8 currently has a broken implementation
  // https://github.com/joyent/node/issues/8449
  function doesForEachActuallyWork() {
  	var ret = false;

  	(new Set([true])).forEach(function (el) {
  		ret = el;
  	});

  	return ret === true;
  }

  if ('Set' in global) {
  	if (typeof Set.prototype.forEach === 'function' && doesForEachActuallyWork()) {
  		module.exports = uniqSetWithForEach;
  	} else {
  		module.exports = uniqSet;
  	}
  } else {
  	module.exports = uniqNoSet;
  }


  /***/ }),
  /* 259 */
  /***/ (function(module, exports, __webpack_require__) {

  // Approach:
  //
  // 1. Get the minimatch set
  // 2. For each pattern in the set, PROCESS(pattern, false)
  // 3. Store matches per-set, then uniq them
  //
  // PROCESS(pattern, inGlobStar)
  // Get the first [n] items from pattern that are all strings
  // Join these together.  This is PREFIX.
  //   If there is no more remaining, then stat(PREFIX) and
  //   add to matches if it succeeds.  END.
  //
  // If inGlobStar and PREFIX is symlink and points to dir
  //   set ENTRIES = []
  // else readdir(PREFIX) as ENTRIES
  //   If fail, END
  //
  // with ENTRIES
  //   If pattern[n] is GLOBSTAR
  //     // handle the case where the globstar match is empty
  //     // by pruning it out, and testing the resulting pattern
  //     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
  //     // handle other cases.
  //     for ENTRY in ENTRIES (not dotfiles)
  //       // attach globstar + tail onto the entry
  //       // Mark that this entry is a globstar match
  //       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
  //
  //   else // not globstar
  //     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
  //       Test ENTRY against pattern[n]
  //       If fails, continue
  //       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
  //
  // Caveat:
  //   Cache all stats and readdirs results to minimize syscall.  Since all
  //   we ever care about is existence and directory-ness, we can just keep
  //   `true` for files, and [children,...] for directories, or `false` for
  //   things that don't exist.

  module.exports = glob

  var fs = __webpack_require__(7)
  var rp = __webpack_require__(260)
  var minimatch = __webpack_require__(262)
  var Minimatch = minimatch.Minimatch
  var inherits = __webpack_require__(266)
  var EE = __webpack_require__(67).EventEmitter
  var path = __webpack_require__(8)
  var assert = __webpack_require__(127)
  var isAbsolute = __webpack_require__(267)
  var globSync = __webpack_require__(268)
  var common = __webpack_require__(269)
  var alphasort = common.alphasort
  var alphasorti = common.alphasorti
  var setopts = common.setopts
  var ownProp = common.ownProp
  var inflight = __webpack_require__(270)
  var util = __webpack_require__(25)
  var childrenIgnored = common.childrenIgnored
  var isIgnored = common.isIgnored

  var once = __webpack_require__(72)

  function glob (pattern, options, cb) {
    if (typeof options === 'function') cb = options, options = {}
    if (!options) options = {}

    if (options.sync) {
      if (cb)
        throw new TypeError('callback provided to sync glob')
      return globSync(pattern, options)
    }

    return new Glob(pattern, options, cb)
  }

  glob.sync = globSync
  var GlobSync = glob.GlobSync = globSync.GlobSync

  // old api surface
  glob.glob = glob

  function extend (origin, add) {
    if (add === null || typeof add !== 'object') {
      return origin
    }

    var keys = Object.keys(add)
    var i = keys.length
    while (i--) {
      origin[keys[i]] = add[keys[i]]
    }
    return origin
  }

  glob.hasMagic = function (pattern, options_) {
    var options = extend({}, options_)
    options.noprocess = true

    var g = new Glob(pattern, options)
    var set = g.minimatch.set

    if (!pattern)
      return false

    if (set.length > 1)
      return true

    for (var j = 0; j < set[0].length; j++) {
      if (typeof set[0][j] !== 'string')
        return true
    }

    return false
  }

  glob.Glob = Glob
  inherits(Glob, EE)
  function Glob (pattern, options, cb) {
    if (typeof options === 'function') {
      cb = options
      options = null
    }

    if (options && options.sync) {
      if (cb)
        throw new TypeError('callback provided to sync glob')
      return new GlobSync(pattern, options)
    }

    if (!(this instanceof Glob))
      return new Glob(pattern, options, cb)

    setopts(this, pattern, options)
    this._didRealPath = false

    // process each pattern in the minimatch set
    var n = this.minimatch.set.length

    // The matches are stored as {<filename>: true,...} so that
    // duplicates are automagically pruned.
    // Later, we do an Object.keys() on these.
    // Keep them as a list so we can fill in when nonull is set.
    this.matches = new Array(n)

    if (typeof cb === 'function') {
      cb = once(cb)
      this.on('error', cb)
      this.on('end', function (matches) {
        cb(null, matches)
      })
    }

    var self = this
    this._processing = 0

    this._emitQueue = []
    this._processQueue = []
    this.paused = false

    if (this.noprocess)
      return this

    if (n === 0)
      return done()

    var sync = true
    for (var i = 0; i < n; i ++) {
      this._process(this.minimatch.set[i], i, false, done)
    }
    sync = false

    function done () {
      --self._processing
      if (self._processing <= 0) {
        if (sync) {
          process.nextTick(function () {
            self._finish()
          })
        } else {
          self._finish()
        }
      }
    }
  }

  Glob.prototype._finish = function () {
    assert(this instanceof Glob)
    if (this.aborted)
      return

    if (this.realpath && !this._didRealpath)
      return this._realpath()

    common.finish(this)
    this.emit('end', this.found)
  }

  Glob.prototype._realpath = function () {
    if (this._didRealpath)
      return

    this._didRealpath = true

    var n = this.matches.length
    if (n === 0)
      return this._finish()

    var self = this
    for (var i = 0; i < this.matches.length; i++)
      this._realpathSet(i, next)

    function next () {
      if (--n === 0)
        self._finish()
    }
  }

  Glob.prototype._realpathSet = function (index, cb) {
    var matchset = this.matches[index]
    if (!matchset)
      return cb()

    var found = Object.keys(matchset)
    var self = this
    var n = found.length

    if (n === 0)
      return cb()

    var set = this.matches[index] = Object.create(null)
    found.forEach(function (p, i) {
      // If there's a problem with the stat, then it means that
      // one or more of the links in the realpath couldn't be
      // resolved.  just return the abs value in that case.
      p = self._makeAbs(p)
      rp.realpath(p, self.realpathCache, function (er, real) {
        if (!er)
          set[real] = true
        else if (er.syscall === 'stat')
          set[p] = true
        else
          self.emit('error', er) // srsly wtf right here

        if (--n === 0) {
          self.matches[index] = set
          cb()
        }
      })
    })
  }

  Glob.prototype._mark = function (p) {
    return common.mark(this, p)
  }

  Glob.prototype._makeAbs = function (f) {
    return common.makeAbs(this, f)
  }

  Glob.prototype.abort = function () {
    this.aborted = true
    this.emit('abort')
  }

  Glob.prototype.pause = function () {
    if (!this.paused) {
      this.paused = true
      this.emit('pause')
    }
  }

  Glob.prototype.resume = function () {
    if (this.paused) {
      this.emit('resume')
      this.paused = false
      if (this._emitQueue.length) {
        var eq = this._emitQueue.slice(0)
        this._emitQueue.length = 0
        for (var i = 0; i < eq.length; i ++) {
          var e = eq[i]
          this._emitMatch(e[0], e[1])
        }
      }
      if (this._processQueue.length) {
        var pq = this._processQueue.slice(0)
        this._processQueue.length = 0
        for (var i = 0; i < pq.length; i ++) {
          var p = pq[i]
          this._processing--
          this._process(p[0], p[1], p[2], p[3])
        }
      }
    }
  }

  Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
    assert(this instanceof Glob)
    assert(typeof cb === 'function')

    if (this.aborted)
      return

    this._processing++
    if (this.paused) {
      this._processQueue.push([pattern, index, inGlobStar, cb])
      return
    }

    //console.error('PROCESS %d', this._processing, pattern)

    // Get the first [n] parts of pattern that are all strings.
    var n = 0
    while (typeof pattern[n] === 'string') {
      n ++
    }
    // now n is the index of the first one that is *not* a string.

    // see if there's anything else
    var prefix
    switch (n) {
      // if not, then this is rather simple
      case pattern.length:
        this._processSimple(pattern.join('/'), index, cb)
        return

      case 0:
        // pattern *starts* with some non-trivial item.
        // going to readdir(cwd), but not include the prefix in matches.
        prefix = null
        break

      default:
        // pattern has some string bits in the front.
        // whatever it starts with, whether that's 'absolute' like /foo/bar,
        // or 'relative' like '../baz'
        prefix = pattern.slice(0, n).join('/')
        break
    }

    var remain = pattern.slice(n)

    // get the list of entries.
    var read
    if (prefix === null)
      read = '.'
    else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
      if (!prefix || !isAbsolute(prefix))
        prefix = '/' + prefix
      read = prefix
    } else
      read = prefix

    var abs = this._makeAbs(read)

    //if ignored, skip _processing
    if (childrenIgnored(this, read))
      return cb()

    var isGlobStar = remain[0] === minimatch.GLOBSTAR
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
    else
      this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
  }

  Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
    var self = this
    this._readdir(abs, inGlobStar, function (er, entries) {
      return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
    })
  }

  Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

    // if the abs isn't a dir, then nothing can match!
    if (!entries)
      return cb()

    // It will only match dot entries if it starts with a dot, or if
    // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
    var pn = remain[0]
    var negate = !!this.minimatch.negate
    var rawGlob = pn._glob
    var dotOk = this.dot || rawGlob.charAt(0) === '.'

    var matchedEntries = []
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i]
      if (e.charAt(0) !== '.' || dotOk) {
        var m
        if (negate && !prefix) {
          m = !e.match(pn)
        } else {
          m = e.match(pn)
        }
        if (m)
          matchedEntries.push(e)
      }
    }

    //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

    var len = matchedEntries.length
    // If there are no matched entries, then nothing matches.
    if (len === 0)
      return cb()

    // if this is the last remaining pattern bit, then no need for
    // an additional stat *unless* the user has specified mark or
    // stat explicitly.  We know they exist, since readdir returned
    // them.

    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null)

      for (var i = 0; i < len; i ++) {
        var e = matchedEntries[i]
        if (prefix) {
          if (prefix !== '/')
            e = prefix + '/' + e
          else
            e = prefix + e
        }

        if (e.charAt(0) === '/' && !this.nomount) {
          e = path.join(this.root, e)
        }
        this._emitMatch(index, e)
      }
      // This was the last one, and no stats were needed
      return cb()
    }

    // now test all matched entries as stand-ins for that part
    // of the pattern.
    remain.shift()
    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      var newPattern
      if (prefix) {
        if (prefix !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }
      this._process([e].concat(remain), index, inGlobStar, cb)
    }
    cb()
  }

  Glob.prototype._emitMatch = function (index, e) {
    if (this.aborted)
      return

    if (isIgnored(this, e))
      return

    if (this.paused) {
      this._emitQueue.push([index, e])
      return
    }

    var abs = isAbsolute(e) ? e : this._makeAbs(e)

    if (this.mark)
      e = this._mark(e)

    if (this.absolute)
      e = abs

    if (this.matches[index][e])
      return

    if (this.nodir) {
      var c = this.cache[abs]
      if (c === 'DIR' || Array.isArray(c))
        return
    }

    this.matches[index][e] = true

    var st = this.statCache[abs]
    if (st)
      this.emit('stat', e, st)

    this.emit('match', e)
  }

  Glob.prototype._readdirInGlobStar = function (abs, cb) {
    if (this.aborted)
      return

    // follow all symlinked directories forever
    // just proceed as if this is a non-globstar situation
    if (this.follow)
      return this._readdir(abs, false, cb)

    var lstatkey = 'lstat\0' + abs
    var self = this
    var lstatcb = inflight(lstatkey, lstatcb_)

    if (lstatcb)
      fs.lstat(abs, lstatcb)

    function lstatcb_ (er, lstat) {
      if (er && er.code === 'ENOENT')
        return cb()

      var isSym = lstat && lstat.isSymbolicLink()
      self.symlinks[abs] = isSym

      // If it's not a symlink or a dir, then it's definitely a regular file.
      // don't bother doing a readdir in that case.
      if (!isSym && lstat && !lstat.isDirectory()) {
        self.cache[abs] = 'FILE'
        cb()
      } else
        self._readdir(abs, false, cb)
    }
  }

  Glob.prototype._readdir = function (abs, inGlobStar, cb) {
    if (this.aborted)
      return

    cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
    if (!cb)
      return

    //console.error('RD %j %j', +inGlobStar, abs)
    if (inGlobStar && !ownProp(this.symlinks, abs))
      return this._readdirInGlobStar(abs, cb)

    if (ownProp(this.cache, abs)) {
      var c = this.cache[abs]
      if (!c || c === 'FILE')
        return cb()

      if (Array.isArray(c))
        return cb(null, c)
    }

    var self = this
    fs.readdir(abs, readdirCb(this, abs, cb))
  }

  function readdirCb (self, abs, cb) {
    return function (er, entries) {
      if (er)
        self._readdirError(abs, er, cb)
      else
        self._readdirEntries(abs, entries, cb)
    }
  }

  Glob.prototype._readdirEntries = function (abs, entries, cb) {
    if (this.aborted)
      return

    // if we haven't asked to stat everything, then just
    // assume that everything in there exists, so we can avoid
    // having to stat it a second time.
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i ++) {
        var e = entries[i]
        if (abs === '/')
          e = abs + e
        else
          e = abs + '/' + e
        this.cache[e] = true
      }
    }

    this.cache[abs] = entries
    return cb(null, entries)
  }

  Glob.prototype._readdirError = function (f, er, cb) {
    if (this.aborted)
      return

    // handle errors, and cache the information
    switch (er.code) {
      case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
      case 'ENOTDIR': // totally normal. means it *does* exist.
        var abs = this._makeAbs(f)
        this.cache[abs] = 'FILE'
        if (abs === this.cwdAbs) {
          var error = new Error(er.code + ' invalid cwd ' + this.cwd)
          error.path = this.cwd
          error.code = er.code
          this.emit('error', error)
          this.abort()
        }
        break

      case 'ENOENT': // not terribly unusual
      case 'ELOOP':
      case 'ENAMETOOLONG':
      case 'UNKNOWN':
        this.cache[this._makeAbs(f)] = false
        break

      default: // some unusual error.  Treat as failure.
        this.cache[this._makeAbs(f)] = false
        if (this.strict) {
          this.emit('error', er)
          // If the error is handled, then we abort
          // if not, we threw out of here
          this.abort()
        }
        if (!this.silent)
          console.error('glob error', er)
        break
    }

    return cb()
  }

  Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
    var self = this
    this._readdir(abs, inGlobStar, function (er, entries) {
      self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
    })
  }


  Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    //console.error('pgs2', prefix, remain[0], entries)

    // no entries means not a dir, so it can never have matches
    // foo.txt/** doesn't match foo.txt
    if (!entries)
      return cb()

    // test without the globstar, and with every child both below
    // and replacing the globstar.
    var remainWithoutGlobStar = remain.slice(1)
    var gspref = prefix ? [ prefix ] : []
    var noGlobStar = gspref.concat(remainWithoutGlobStar)

    // the noGlobStar pattern exits the inGlobStar state
    this._process(noGlobStar, index, false, cb)

    var isSym = this.symlinks[abs]
    var len = entries.length

    // If it's a symlink, and we're in a globstar, then stop
    if (isSym && inGlobStar)
      return cb()

    for (var i = 0; i < len; i++) {
      var e = entries[i]
      if (e.charAt(0) === '.' && !this.dot)
        continue

      // these two cases enter the inGlobStar state
      var instead = gspref.concat(entries[i], remainWithoutGlobStar)
      this._process(instead, index, true, cb)

      var below = gspref.concat(entries[i], remain)
      this._process(below, index, true, cb)
    }

    cb()
  }

  Glob.prototype._processSimple = function (prefix, index, cb) {
    // XXX review this.  Shouldn't it be doing the mounting etc
    // before doing stat?  kinda weird?
    var self = this
    this._stat(prefix, function (er, exists) {
      self._processSimple2(prefix, index, er, exists, cb)
    })
  }
  Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

    //console.error('ps2', prefix, exists)

    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    // If it doesn't exist, then just mark the lack of results
    if (!exists)
      return cb()

    if (prefix && isAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix)
      if (prefix.charAt(0) === '/') {
        prefix = path.join(this.root, prefix)
      } else {
        prefix = path.resolve(this.root, prefix)
        if (trail)
          prefix += '/'
      }
    }

    if (process.platform === 'win32')
      prefix = prefix.replace(/\\/g, '/')

    // Mark this as a match
    this._emitMatch(index, prefix)
    cb()
  }

  // Returns either 'DIR', 'FILE', or false
  Glob.prototype._stat = function (f, cb) {
    var abs = this._makeAbs(f)
    var needDir = f.slice(-1) === '/'

    if (f.length > this.maxLength)
      return cb()

    if (!this.stat && ownProp(this.cache, abs)) {
      var c = this.cache[abs]

      if (Array.isArray(c))
        c = 'DIR'

      // It exists, but maybe not how we need it
      if (!needDir || c === 'DIR')
        return cb(null, c)

      if (needDir && c === 'FILE')
        return cb()

      // otherwise we have to stat, because maybe c=true
      // if we know it exists, but not what it is.
    }

    var exists
    var stat = this.statCache[abs]
    if (stat !== undefined) {
      if (stat === false)
        return cb(null, stat)
      else {
        var type = stat.isDirectory() ? 'DIR' : 'FILE'
        if (needDir && type === 'FILE')
          return cb()
        else
          return cb(null, type, stat)
      }
    }

    var self = this
    var statcb = inflight('stat\0' + abs, lstatcb_)
    if (statcb)
      fs.lstat(abs, statcb)

    function lstatcb_ (er, lstat) {
      if (lstat && lstat.isSymbolicLink()) {
        // If it's a symlink, then treat it as the target, unless
        // the target does not exist, then treat it as a file.
        return fs.stat(abs, function (er, stat) {
          if (er)
            self._stat2(f, abs, null, lstat, cb)
          else
            self._stat2(f, abs, er, stat, cb)
        })
      } else {
        self._stat2(f, abs, er, lstat, cb)
      }
    }
  }

  Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
    if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
      this.statCache[abs] = false
      return cb()
    }

    var needDir = f.slice(-1) === '/'
    this.statCache[abs] = stat

    if (abs.slice(-1) === '/' && stat && !stat.isDirectory())
      return cb(null, false, stat)

    var c = true
    if (stat)
      c = stat.isDirectory() ? 'DIR' : 'FILE'
    this.cache[abs] = this.cache[abs] || c

    if (needDir && c === 'FILE')
      return cb()

    return cb(null, c, stat)
  }


  /***/ }),
  /* 260 */
  /***/ (function(module, exports, __webpack_require__) {

  module.exports = realpath
  realpath.realpath = realpath
  realpath.sync = realpathSync
  realpath.realpathSync = realpathSync
  realpath.monkeypatch = monkeypatch
  realpath.unmonkeypatch = unmonkeypatch

  var fs = __webpack_require__(7)
  var origRealpath = fs.realpath
  var origRealpathSync = fs.realpathSync

  var version = process.version
  var ok = /^v[0-5]\./.test(version)
  var old = __webpack_require__(261)

  function newError (er) {
    return er && er.syscall === 'realpath' && (
      er.code === 'ELOOP' ||
      er.code === 'ENOMEM' ||
      er.code === 'ENAMETOOLONG'
    )
  }

  function realpath (p, cache, cb) {
    if (ok) {
      return origRealpath(p, cache, cb)
    }

    if (typeof cache === 'function') {
      cb = cache
      cache = null
    }
    origRealpath(p, cache, function (er, result) {
      if (newError(er)) {
        old.realpath(p, cache, cb)
      } else {
        cb(er, result)
      }
    })
  }

  function realpathSync (p, cache) {
    if (ok) {
      return origRealpathSync(p, cache)
    }

    try {
      return origRealpathSync(p, cache)
    } catch (er) {
      if (newError(er)) {
        return old.realpathSync(p, cache)
      } else {
        throw er
      }
    }
  }

  function monkeypatch () {
    fs.realpath = realpath
    fs.realpathSync = realpathSync
  }

  function unmonkeypatch () {
    fs.realpath = origRealpath
    fs.realpathSync = origRealpathSync
  }


  /***/ }),
  /* 261 */
  /***/ (function(module, exports, __webpack_require__) {

  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.

  var pathModule = __webpack_require__(8);
  var isWindows = process.platform === 'win32';
  var fs = __webpack_require__(7);

  // JavaScript implementation of realpath, ported from node pre-v6

  var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);

  function rethrow() {
    // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
    // is fairly slow to generate.
    var callback;
    if (DEBUG) {
      var backtrace = new Error;
      callback = debugCallback;
    } else
      callback = missingCallback;

    return callback;

    function debugCallback(err) {
      if (err) {
        backtrace.message = err.message;
        err = backtrace;
        missingCallback(err);
      }
    }

    function missingCallback(err) {
      if (err) {
        if (process.throwDeprecation)
          throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs
        else if (!process.noDeprecation) {
          var msg = 'fs: missing callback ' + (err.stack || err.message);
          if (process.traceDeprecation)
            console.trace(msg);
          else
            console.error(msg);
        }
      }
    }
  }

  function maybeCallback(cb) {
    return typeof cb === 'function' ? cb : rethrow();
  }

  var normalize = pathModule.normalize;

  // Regexp that finds the next partion of a (partial) path
  // result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
  if (isWindows) {
    var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
  } else {
    var nextPartRe = /(.*?)(?:[\/]+|$)/g;
  }

  // Regex to find the device root, including trailing slash. E.g. 'c:\\'.
  if (isWindows) {
    var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
  } else {
    var splitRootRe = /^[\/]*/;
  }

  exports.realpathSync = function realpathSync(p, cache) {
    // make p is absolute
    p = pathModule.resolve(p);

    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return cache[p];
    }

    var original = p,
        seenLinks = {},
        knownHard = {};

    // current character position in p
    var pos;
    // the partial path so far, including a trailing slash if any
    var current;
    // the partial path without a trailing slash (except when pointing at a root)
    var base;
    // the partial path scanned in the previous round, with slash
    var previous;

    start();

    function start() {
      // Skip over roots
      var m = splitRootRe.exec(p);
      pos = m[0].length;
      current = m[0];
      base = m[0];
      previous = '';

      // On windows, check that the root exists. On unix there is no need.
      if (isWindows && !knownHard[base]) {
        fs.lstatSync(base);
        knownHard[base] = true;
      }
    }

    // walk down the path, swapping out linked pathparts for their real
    // values
    // NB: p.length changes.
    while (pos < p.length) {
      // find the next part
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;

      // continue if not a symlink
      if (knownHard[base] || (cache && cache[base] === base)) {
        continue;
      }

      var resolvedLink;
      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        // some known symbolic link.  no need to stat again.
        resolvedLink = cache[base];
      } else {
        var stat = fs.lstatSync(base);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache) cache[base] = base;
          continue;
        }

        // read the link if it wasn't read before
        // dev/ino always return 0 on windows, so skip the check.
        var linkTarget = null;
        if (!isWindows) {
          var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            linkTarget = seenLinks[id];
          }
        }
        if (linkTarget === null) {
          fs.statSync(base);
          linkTarget = fs.readlinkSync(base);
        }
        resolvedLink = pathModule.resolve(previous, linkTarget);
        // track this, if given a cache.
        if (cache) cache[base] = resolvedLink;
        if (!isWindows) seenLinks[id] = linkTarget;
      }

      // resolve the link, then start over
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }

    if (cache) cache[original] = p;

    return p;
  };


  exports.realpath = function realpath(p, cache, cb) {
    if (typeof cb !== 'function') {
      cb = maybeCallback(cache);
      cache = null;
    }

    // make p is absolute
    p = pathModule.resolve(p);

    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return process.nextTick(cb.bind(null, null, cache[p]));
    }

    var original = p,
        seenLinks = {},
        knownHard = {};

    // current character position in p
    var pos;
    // the partial path so far, including a trailing slash if any
    var current;
    // the partial path without a trailing slash (except when pointing at a root)
    var base;
    // the partial path scanned in the previous round, with slash
    var previous;

    start();

    function start() {
      // Skip over roots
      var m = splitRootRe.exec(p);
      pos = m[0].length;
      current = m[0];
      base = m[0];
      previous = '';

      // On windows, check that the root exists. On unix there is no need.
      if (isWindows && !knownHard[base]) {
        fs.lstat(base, function(err) {
          if (err) return cb(err);
          knownHard[base] = true;
          LOOP();
        });
      } else {
        process.nextTick(LOOP);
      }
    }

    // walk down the path, swapping out linked pathparts for their real
    // values
    function LOOP() {
      // stop if scanned past end of path
      if (pos >= p.length) {
        if (cache) cache[original] = p;
        return cb(null, p);
      }

      // find the next part
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;

      // continue if not a symlink
      if (knownHard[base] || (cache && cache[base] === base)) {
        return process.nextTick(LOOP);
      }

      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        // known symbolic link.  no need to stat again.
        return gotResolvedLink(cache[base]);
      }

      return fs.lstat(base, gotStat);
    }

    function gotStat(err, stat) {
      if (err) return cb(err);

      // if not a symlink, skip to the next path part
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        return process.nextTick(LOOP);
      }

      // stat & read the link if not read before
      // call gotTarget as soon as the link target is known
      // dev/ino always return 0 on windows, so skip the check.
      if (!isWindows) {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          return gotTarget(null, seenLinks[id], base);
        }
      }
      fs.stat(base, function(err) {
        if (err) return cb(err);

        fs.readlink(base, function(err, target) {
          if (!isWindows) seenLinks[id] = target;
          gotTarget(err, target);
        });
      });
    }

    function gotTarget(err, target, base) {
      if (err) return cb(err);

      var resolvedLink = pathModule.resolve(previous, target);
      if (cache) cache[base] = resolvedLink;
      gotResolvedLink(resolvedLink);
    }

    function gotResolvedLink(resolvedLink) {
      // resolve the link, then start over
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }
  };


  /***/ }),
  /* 262 */
  /***/ (function(module, exports, __webpack_require__) {

  module.exports = minimatch
  minimatch.Minimatch = Minimatch

  var path = { sep: '/' }
  try {
    path = __webpack_require__(8)
  } catch (er) {}

  var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
  var expand = __webpack_require__(263)

  var plTypes = {
    '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
    '?': { open: '(?:', close: ')?' },
    '+': { open: '(?:', close: ')+' },
    '*': { open: '(?:', close: ')*' },
    '@': { open: '(?:', close: ')' }
  }

  // any single thing other than /
  // don't need to escape / when using new RegExp()
  var qmark = '[^/]'

  // * => any number of characters
  var star = qmark + '*?'

  // ** when dots are allowed.  Anything goes, except .. and .
  // not (^ or / followed by one or two dots followed by $ or /),
  // followed by anything, any number of times.
  var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

  // not a ^ or / followed by a dot,
  // followed by anything, any number of times.
  var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

  // characters that need to be escaped in RegExp.
  var reSpecials = charSet('().*{}+?[]^$\\!')

  // "abc" -> { a:true, b:true, c:true }
  function charSet (s) {
    return s.split('').reduce(function (set, c) {
      set[c] = true
      return set
    }, {})
  }

  // normalizes slashes.
  var slashSplit = /\/+/

  minimatch.filter = filter
  function filter (pattern, options) {
    options = options || {}
    return function (p, i, list) {
      return minimatch(p, pattern, options)
    }
  }

  function ext (a, b) {
    a = a || {}
    b = b || {}
    var t = {}
    Object.keys(b).forEach(function (k) {
      t[k] = b[k]
    })
    Object.keys(a).forEach(function (k) {
      t[k] = a[k]
    })
    return t
  }

  minimatch.defaults = function (def) {
    if (!def || !Object.keys(def).length) return minimatch

    var orig = minimatch

    var m = function minimatch (p, pattern, options) {
      return orig.minimatch(p, pattern, ext(def, options))
    }

    m.Minimatch = function Minimatch (pattern, options) {
      return new orig.Minimatch(pattern, ext(def, options))
    }

    return m
  }

  Minimatch.defaults = function (def) {
    if (!def || !Object.keys(def).length) return Minimatch
    return minimatch.defaults(def).Minimatch
  }

  function minimatch (p, pattern, options) {
    if (typeof pattern !== 'string') {
      throw new TypeError('glob pattern string required')
    }

    if (!options) options = {}

    // shortcut: comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
      return false
    }

    // "" only matches ""
    if (pattern.trim() === '') return p === ''

    return new Minimatch(pattern, options).match(p)
  }

  function Minimatch (pattern, options) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern, options)
    }

    if (typeof pattern !== 'string') {
      throw new TypeError('glob pattern string required')
    }

    if (!options) options = {}
    pattern = pattern.trim()

    // windows support: need to use /, not \
    if (path.sep !== '/') {
      pattern = pattern.split(path.sep).join('/')
    }

    this.options = options
    this.set = []
    this.pattern = pattern
    this.regexp = null
    this.negate = false
    this.comment = false
    this.empty = false

    // make the set of regexps etc.
    this.make()
  }

  Minimatch.prototype.debug = function () {}

  Minimatch.prototype.make = make
  function make () {
    // don't do it more than once.
    if (this._made) return

    var pattern = this.pattern
    var options = this.options

    // empty patterns and comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
      this.comment = true
      return
    }
    if (!pattern) {
      this.empty = true
      return
    }

    // step 1: figure out negation, etc.
    this.parseNegate()

    // step 2: expand braces
    var set = this.globSet = this.braceExpand()

    if (options.debug) this.debug = console.error

    this.debug(this.pattern, set)

    // step 3: now we have a set, so turn each one into a series of path-portion
    // matching patterns.
    // These will be regexps, except in the case of "**", which is
    // set to the GLOBSTAR object for globstar behavior,
    // and will not contain any / characters
    set = this.globParts = set.map(function (s) {
      return s.split(slashSplit)
    })

    this.debug(this.pattern, set)

    // glob --> regexps
    set = set.map(function (s, si, set) {
      return s.map(this.parse, this)
    }, this)

    this.debug(this.pattern, set)

    // filter out everything that didn't compile properly.
    set = set.filter(function (s) {
      return s.indexOf(false) === -1
    })

    this.debug(this.pattern, set)

    this.set = set
  }

  Minimatch.prototype.parseNegate = parseNegate
  function parseNegate () {
    var pattern = this.pattern
    var negate = false
    var options = this.options
    var negateOffset = 0

    if (options.nonegate) return

    for (var i = 0, l = pattern.length
      ; i < l && pattern.charAt(i) === '!'
      ; i++) {
      negate = !negate
      negateOffset++
    }

    if (negateOffset) this.pattern = pattern.substr(negateOffset)
    this.negate = negate
  }

  // Brace expansion:
  // a{b,c}d -> abd acd
  // a{b,}c -> abc ac
  // a{0..3}d -> a0d a1d a2d a3d
  // a{b,c{d,e}f}g -> abg acdfg acefg
  // a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
  //
  // Invalid sets are not expanded.
  // a{2..}b -> a{2..}b
  // a{b}c -> a{b}c
  minimatch.braceExpand = function (pattern, options) {
    return braceExpand(pattern, options)
  }

  Minimatch.prototype.braceExpand = braceExpand

  function braceExpand (pattern, options) {
    if (!options) {
      if (this instanceof Minimatch) {
        options = this.options
      } else {
        options = {}
      }
    }

    pattern = typeof pattern === 'undefined'
      ? this.pattern : pattern

    if (typeof pattern === 'undefined') {
      throw new TypeError('undefined pattern')
    }

    if (options.nobrace ||
      !pattern.match(/\{.*\}/)) {
      // shortcut. no need to expand.
      return [pattern]
    }

    return expand(pattern)
  }

  // parse a component of the expanded set.
  // At this point, no pattern may contain "/" in it
  // so we're going to return a 2d array, where each entry is the full
  // pattern, split on '/', and then turned into a regular expression.
  // A regexp is made at the end which joins each array with an
  // escaped /, and another full one which joins each regexp with |.
  //
  // Following the lead of Bash 4.1, note that "**" only has special meaning
  // when it is the *only* thing in a path portion.  Otherwise, any series
  // of * is equivalent to a single *.  Globstar behavior is enabled by
  // default, and can be disabled by setting options.noglobstar.
  Minimatch.prototype.parse = parse
  var SUBPARSE = {}
  function parse (pattern, isSub) {
    if (pattern.length > 1024 * 64) {
      throw new TypeError('pattern is too long')
    }

    var options = this.options

    // shortcuts
    if (!options.noglobstar && pattern === '**') return GLOBSTAR
    if (pattern === '') return ''

    var re = ''
    var hasMagic = !!options.nocase
    var escaping = false
    // ? => one single character
    var patternListStack = []
    var negativeLists = []
    var stateChar
    var inClass = false
    var reClassStart = -1
    var classStart = -1
    // . and .. never match anything that doesn't start with .,
    // even when options.dot is set.
    var patternStart = pattern.charAt(0) === '.' ? '' // anything
    // not (start or / followed by . or .. followed by / or end)
    : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
    : '(?!\\.)'
    var self = this

    function clearStateChar () {
      if (stateChar) {
        // we had some state-tracking character
        // that wasn't consumed by this pass.
        switch (stateChar) {
          case '*':
            re += star
            hasMagic = true
          break
          case '?':
            re += qmark
            hasMagic = true
          break
          default:
            re += '\\' + stateChar
          break
        }
        self.debug('clearStateChar %j %j', stateChar, re)
        stateChar = false
      }
    }

    for (var i = 0, len = pattern.length, c
      ; (i < len) && (c = pattern.charAt(i))
      ; i++) {
      this.debug('%s\t%s %s %j', pattern, i, re, c)

      // skip over any that are escaped.
      if (escaping && reSpecials[c]) {
        re += '\\' + c
        escaping = false
        continue
      }

      switch (c) {
        case '/':
          // completely not allowed, even escaped.
          // Should already be path-split by now.
          return false

        case '\\':
          clearStateChar()
          escaping = true
        continue

        // the various stateChar values
        // for the "extglob" stuff.
        case '?':
        case '*':
        case '+':
        case '@':
        case '!':
          this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

          // all of those are literals inside a class, except that
          // the glob [!a] means [^a] in regexp
          if (inClass) {
            this.debug('  in class')
            if (c === '!' && i === classStart + 1) c = '^'
            re += c
            continue
          }

          // if we already have a stateChar, then it means
          // that there was something like ** or +? in there.
          // Handle the stateChar, then proceed with this one.
          self.debug('call clearStateChar %j', stateChar)
          clearStateChar()
          stateChar = c
          // if extglob is disabled, then +(asdf|foo) isn't a thing.
          // just clear the statechar *now*, rather than even diving into
          // the patternList stuff.
          if (options.noext) clearStateChar()
        continue

        case '(':
          if (inClass) {
            re += '('
            continue
          }

          if (!stateChar) {
            re += '\\('
            continue
          }

          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          })
          // negation is (?:(?!js)[^/]*)
          re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
          this.debug('plType %j %j', stateChar, re)
          stateChar = false
        continue

        case ')':
          if (inClass || !patternListStack.length) {
            re += '\\)'
            continue
          }

          clearStateChar()
          hasMagic = true
          var pl = patternListStack.pop()
          // negation is (?:(?!js)[^/]*)
          // The others are (?:<pattern>)<type>
          re += pl.close
          if (pl.type === '!') {
            negativeLists.push(pl)
          }
          pl.reEnd = re.length
        continue

        case '|':
          if (inClass || !patternListStack.length || escaping) {
            re += '\\|'
            escaping = false
            continue
          }

          clearStateChar()
          re += '|'
        continue

        // these are mostly the same in regexp and glob
        case '[':
          // swallow any state-tracking char before the [
          clearStateChar()

          if (inClass) {
            re += '\\' + c
            continue
          }

          inClass = true
          classStart = i
          reClassStart = re.length
          re += c
        continue

        case ']':
          //  a right bracket shall lose its special
          //  meaning and represent itself in
          //  a bracket expression if it occurs
          //  first in the list.  -- POSIX.2 2.8.3.2
          if (i === classStart + 1 || !inClass) {
            re += '\\' + c
            escaping = false
            continue
          }

          // handle the case where we left a class open.
          // "[z-a]" is valid, equivalent to "\[z-a\]"
          if (inClass) {
            // split where the last [ was, make sure we don't have
            // an invalid re. if so, re-walk the contents of the
            // would-be class to re-translate any characters that
            // were passed through as-is
            // TODO: It would probably be faster to determine this
            // without a try/catch and a new RegExp, but it's tricky
            // to do safely.  For now, this is safe and works.
            var cs = pattern.substring(classStart + 1, i)
            try {
              RegExp('[' + cs + ']')
            } catch (er) {
              // not a valid class!
              var sp = this.parse(cs, SUBPARSE)
              re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
              hasMagic = hasMagic || sp[1]
              inClass = false
              continue
            }
          }

          // finish up the class.
          hasMagic = true
          inClass = false
          re += c
        continue

        default:
          // swallow any state char that wasn't consumed
          clearStateChar()

          if (escaping) {
            // no need
            escaping = false
          } else if (reSpecials[c]
            && !(c === '^' && inClass)) {
            re += '\\'
          }

          re += c

      } // switch
    } // for

    // handle the case where we left a class open.
    // "[abc" is valid, equivalent to "\[abc"
    if (inClass) {
      // split where the last [ was, and escape it
      // this is a huge pita.  We now have to re-walk
      // the contents of the would-be class to re-translate
      // any characters that were passed through as-is
      cs = pattern.substr(classStart + 1)
      sp = this.parse(cs, SUBPARSE)
      re = re.substr(0, reClassStart) + '\\[' + sp[0]
      hasMagic = hasMagic || sp[1]
    }

    // handle the case where we had a +( thing at the *end*
    // of the pattern.
    // each pattern list stack adds 3 chars, and we need to go through
    // and escape any | chars that were passed through as-is for the regexp.
    // Go through and escape them, taking care not to double-escape any
    // | chars that were already escaped.
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + pl.open.length)
      this.debug('setting tail', re, pl)
      // maybe some even number of \, then maybe 1 \, followed by a |
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
        if (!$2) {
          // the | isn't already escaped, so escape it.
          $2 = '\\'
        }

        // need to escape all those slashes *again*, without escaping the
        // one that we need for escaping the | character.  As it works out,
        // escaping an even number of slashes can be done by simply repeating
        // it exactly after itself.  That's why this trick works.
        //
        // I am sorry that you have to see this.
        return $1 + $1 + $2 + '|'
      })

      this.debug('tail=%j\n   %s', tail, tail, pl, re)
      var t = pl.type === '*' ? star
        : pl.type === '?' ? qmark
        : '\\' + pl.type

      hasMagic = true
      re = re.slice(0, pl.reStart) + t + '\\(' + tail
    }

    // handle trailing things that only matter at the very end.
    clearStateChar()
    if (escaping) {
      // trailing \\
      re += '\\\\'
    }

    // only need to apply the nodot start if the re starts with
    // something that could conceivably capture a dot
    var addPatternStart = false
    switch (re.charAt(0)) {
      case '.':
      case '[':
      case '(': addPatternStart = true
    }

    // Hack to work around lack of negative lookbehind in JS
    // A pattern like: *.!(x).!(y|z) needs to ensure that a name
    // like 'a.xyz.yz' doesn't match.  So, the first negative
    // lookahead, has to look ALL the way ahead, to the end of
    // the pattern.
    for (var n = negativeLists.length - 1; n > -1; n--) {
      var nl = negativeLists[n]

      var nlBefore = re.slice(0, nl.reStart)
      var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
      var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
      var nlAfter = re.slice(nl.reEnd)

      nlLast += nlAfter

      // Handle nested stuff like *(*.js|!(*.json)), where open parens
      // mean that we should *not* include the ) in the bit that is considered
      // "after" the negated section.
      var openParensBefore = nlBefore.split('(').length - 1
      var cleanAfter = nlAfter
      for (i = 0; i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
      }
      nlAfter = cleanAfter

      var dollar = ''
      if (nlAfter === '' && isSub !== SUBPARSE) {
        dollar = '$'
      }
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
      re = newRe
    }

    // if the re is not "" at this point, then we need to make sure
    // it doesn't match against an empty path part.
    // Otherwise a/* will match a/, which it should not.
    if (re !== '' && hasMagic) {
      re = '(?=.)' + re
    }

    if (addPatternStart) {
      re = patternStart + re
    }

    // parsing just a piece of a larger pattern.
    if (isSub === SUBPARSE) {
      return [re, hasMagic]
    }

    // skip the regexp for non-magical patterns
    // unescape anything in it, though, so that it'll be
    // an exact match against a file etc.
    if (!hasMagic) {
      return globUnescape(pattern)
    }

    var flags = options.nocase ? 'i' : ''
    try {
      var regExp = new RegExp('^' + re + '$', flags)
    } catch (er) {
      // If it was an invalid regular expression, then it can't match
      // anything.  This trick looks for a character after the end of
      // the string, which is of course impossible, except in multi-line
      // mode, but it's not a /m regex.
      return new RegExp('$.')
    }

    regExp._glob = pattern
    regExp._src = re

    return regExp
  }

  minimatch.makeRe = function (pattern, options) {
    return new Minimatch(pattern, options || {}).makeRe()
  }

  Minimatch.prototype.makeRe = makeRe
  function makeRe () {
    if (this.regexp || this.regexp === false) return this.regexp

    // at this point, this.set is a 2d array of partial
    // pattern strings, or "**".
    //
    // It's better to use .match().  This function shouldn't
    // be used, really, but it's pretty convenient sometimes,
    // when you just want to work with a regex.
    var set = this.set

    if (!set.length) {
      this.regexp = false
      return this.regexp
    }
    var options = this.options

    var twoStar = options.noglobstar ? star
      : options.dot ? twoStarDot
      : twoStarNoDot
    var flags = options.nocase ? 'i' : ''

    var re = set.map(function (pattern) {
      return pattern.map(function (p) {
        return (p === GLOBSTAR) ? twoStar
        : (typeof p === 'string') ? regExpEscape(p)
        : p._src
      }).join('\\\/')
    }).join('|')

    // must match entire pattern
    // ending in a * or ** will make it less strict.
    re = '^(?:' + re + ')$'

    // can match anything, as long as it's not this.
    if (this.negate) re = '^(?!' + re + ').*$'

    try {
      this.regexp = new RegExp(re, flags)
    } catch (ex) {
      this.regexp = false
    }
    return this.regexp
  }

  minimatch.match = function (list, pattern, options) {
    options = options || {}
    var mm = new Minimatch(pattern, options)
    list = list.filter(function (f) {
      return mm.match(f)
    })
    if (mm.options.nonull && !list.length) {
      list.push(pattern)
    }
    return list
  }

  Minimatch.prototype.match = match
  function match (f, partial) {
    this.debug('match', f, this.pattern)
    // short-circuit in the case of busted things.
    // comments, etc.
    if (this.comment) return false
    if (this.empty) return f === ''

    if (f === '/' && partial) return true

    var options = this.options

    // windows: need to use /, not \
    if (path.sep !== '/') {
      f = f.split(path.sep).join('/')
    }

    // treat the test path as a set of pathparts.
    f = f.split(slashSplit)
    this.debug(this.pattern, 'split', f)

    // just ONE of the pattern sets in this.set needs to match
    // in order for it to be valid.  If negating, then just one
    // match means that we have failed.
    // Either way, return on the first hit.

    var set = this.set
    this.debug(this.pattern, 'set', set)

    // Find the basename of the path by looking for the last non-empty segment
    var filename
    var i
    for (i = f.length - 1; i >= 0; i--) {
      filename = f[i]
      if (filename) break
    }

    for (i = 0; i < set.length; i++) {
      var pattern = set[i]
      var file = f
      if (options.matchBase && pattern.length === 1) {
        file = [filename]
      }
      var hit = this.matchOne(file, pattern, partial)
      if (hit) {
        if (options.flipNegate) return true
        return !this.negate
      }
    }

    // didn't get any hits.  this is success if it's a negative
    // pattern, failure otherwise.
    if (options.flipNegate) return false
    return this.negate
  }

  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  Minimatch.prototype.matchOne = function (file, pattern, partial) {
    var options = this.options

    this.debug('matchOne',
      { 'this': this, file: file, pattern: pattern })

    this.debug('matchOne', file.length, pattern.length)

    for (var fi = 0,
        pi = 0,
        fl = file.length,
        pl = pattern.length
        ; (fi < fl) && (pi < pl)
        ; fi++, pi++) {
      this.debug('matchOne loop')
      var p = pattern[pi]
      var f = file[fi]

      this.debug(pattern, p, f)

      // should be impossible.
      // some invalid regexp stuff in the set.
      if (p === false) return false

      if (p === GLOBSTAR) {
        this.debug('GLOBSTAR', [pattern, p, f])

        // "**"
        // a/**/b/**/c would match the following:
        // a/b/x/y/z/c
        // a/x/y/z/b/c
        // a/b/x/b/x/c
        // a/b/c
        // To do this, take the rest of the pattern after
        // the **, and see if it would match the file remainder.
        // If so, return success.
        // If not, the ** "swallows" a segment, and try again.
        // This is recursively awful.
        //
        // a/**/b/**/c matching a/b/x/y/z/c
        // - a matches a
        // - doublestar
        //   - matchOne(b/x/y/z/c, b/**/c)
        //     - b matches b
        //     - doublestar
        //       - matchOne(x/y/z/c, c) -> no
        //       - matchOne(y/z/c, c) -> no
        //       - matchOne(z/c, c) -> no
        //       - matchOne(c, c) yes, hit
        var fr = fi
        var pr = pi + 1
        if (pr === pl) {
          this.debug('** at the end')
          // a ** at the end will just swallow the rest.
          // We have found a match.
          // however, it will not swallow /.x, unless
          // options.dot is set.
          // . and .. are *never* matched by **, for explosively
          // exponential reasons.
          for (; fi < fl; fi++) {
            if (file[fi] === '.' || file[fi] === '..' ||
              (!options.dot && file[fi].charAt(0) === '.')) return false
          }
          return true
        }

        // ok, let's see if we can swallow whatever we can.
        while (fr < fl) {
          var swallowee = file[fr]

          this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

          // XXX remove this slice.  Just pass the start index.
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug('globstar found match!', fr, fl, swallowee)
            // found a match.
            return true
          } else {
            // can't swallow "." or ".." ever.
            // can only swallow ".foo" when explicitly asked.
            if (swallowee === '.' || swallowee === '..' ||
              (!options.dot && swallowee.charAt(0) === '.')) {
              this.debug('dot detected!', file, fr, pattern, pr)
              break
            }

            // ** swallows a segment, and continue.
            this.debug('globstar swallow a segment, and continue')
            fr++
          }
        }

        // no match was found.
        // However, in partial mode, we can't say this is necessarily over.
        // If there's more *pattern* left, then
        if (partial) {
          // ran out of file
          this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
          if (fr === fl) return true
        }
        return false
      }

      // something other than **
      // non-magic patterns just have to match exactly
      // patterns with magic have been turned into regexps.
      var hit
      if (typeof p === 'string') {
        if (options.nocase) {
          hit = f.toLowerCase() === p.toLowerCase()
        } else {
          hit = f === p
        }
        this.debug('string match', p, f, hit)
      } else {
        hit = f.match(p)
        this.debug('pattern match', p, f, hit)
      }

      if (!hit) return false
    }

    // Note: ending in / means that we'll get a final ""
    // at the end of the pattern.  This can only match a
    // corresponding "" at the end of the file.
    // If the file ends in /, then it can only match a
    // a pattern that ends in /, unless the pattern just
    // doesn't have any more for it. But, a/b/ should *not*
    // match "a/b/*", even though "" matches against the
    // [^/]*? pattern, except in partial mode, where it might
    // simply not be reached yet.
    // However, a/b/ should still satisfy a/*

    // now either we fell off the end of the pattern, or we're done.
    if (fi === fl && pi === pl) {
      // ran out of pattern and filename at the same time.
      // an exact hit!
      return true
    } else if (fi === fl) {
      // ran out of file, but still had pattern left.
      // this is ok if we're doing the match as part of
      // a glob fs traversal.
      return partial
    } else if (pi === pl) {
      // ran out of pattern, still have file left.
      // this is only acceptable if we're on the very last
      // empty segment of a file with a trailing slash.
      // a/* should match a/b/
      var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
      return emptyFileEnd
    }

    // should be unreachable.
    throw new Error('wtf?')
  }

  // replace stuff like \* with *
  function globUnescape (s) {
    return s.replace(/\\(.)/g, '$1')
  }

  function regExpEscape (s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
  }


  /***/ }),
  /* 263 */
  /***/ (function(module, exports, __webpack_require__) {

  var concatMap = __webpack_require__(264);
  var balanced = __webpack_require__(265);

  module.exports = expandTop;

  var escSlash = '\0SLASH'+Math.random()+'\0';
  var escOpen = '\0OPEN'+Math.random()+'\0';
  var escClose = '\0CLOSE'+Math.random()+'\0';
  var escComma = '\0COMMA'+Math.random()+'\0';
  var escPeriod = '\0PERIOD'+Math.random()+'\0';

  function numeric(str) {
    return parseInt(str, 10) == str
      ? parseInt(str, 10)
      : str.charCodeAt(0);
  }

  function escapeBraces(str) {
    return str.split('\\\\').join(escSlash)
              .split('\\{').join(escOpen)
              .split('\\}').join(escClose)
              .split('\\,').join(escComma)
              .split('\\.').join(escPeriod);
  }

  function unescapeBraces(str) {
    return str.split(escSlash).join('\\')
              .split(escOpen).join('{')
              .split(escClose).join('}')
              .split(escComma).join(',')
              .split(escPeriod).join('.');
  }


  // Basically just str.split(","), but handling cases
  // where we have nested braced sections, which should be
  // treated as individual members, like {a,{b,c},d}
  function parseCommaParts(str) {
    if (!str)
      return [''];

    var parts = [];
    var m = balanced('{', '}', str);

    if (!m)
      return str.split(',');

    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(',');

    p[p.length-1] += '{' + body + '}';
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length-1] += postParts.shift();
      p.push.apply(p, postParts);
    }

    parts.push.apply(parts, p);

    return parts;
  }

  function expandTop(str) {
    if (!str)
      return [];

    // I don't know why Bash 4.3 does this, but it does.
    // Anything starting with {} will have the first two bytes preserved
    // but *only* at the top level, so {},a}b will not expand to anything,
    // but a{},b}c will be expanded to [a}c,abc].
    // One could argue that this is a bug in Bash, but since the goal of
    // this module is to match Bash's rules, we escape a leading {}
    if (str.substr(0, 2) === '{}') {
      str = '\\{\\}' + str.substr(2);
    }

    return expand(escapeBraces(str), true).map(unescapeBraces);
  }

  function identity(e) {
    return e;
  }

  function embrace(str) {
    return '{' + str + '}';
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }

  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }

  function expand(str, isTop) {
    var expansions = [];

    var m = balanced('{', '}', str);
    if (!m || /\$$/.test(m.pre)) return [str];

    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(',') >= 0;
    if (!isSequence && !isOptions) {
      // {a},b}
      if (m.post.match(/,.*\}/)) {
        str = m.pre + '{' + m.body + escClose + m.post;
        return expand(str);
      }
      return [str];
    }

    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1) {
        // x{{a,b}}y ==> x{a}y x{b}y
        n = expand(n[0], false).map(embrace);
        if (n.length === 1) {
          var post = m.post.length
            ? expand(m.post, false)
            : [''];
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }

    // at this point, n is the parts, and we know it's not a comma set
    // with a single entry.

    // no need to expand pre, since it is guaranteed to be free of brace-sets
    var pre = m.pre;
    var post = m.post.length
      ? expand(m.post, false)
      : [''];

    var N;

    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length)
      var incr = n.length == 3
        ? Math.abs(numeric(n[2]))
        : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n.some(isPadded);

      N = [];

      for (var i = x; test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === '\\')
            c = '';
        } else {
          c = String(i);
          if (pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join('0');
              if (i < 0)
                c = '-' + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = concatMap(n, function(el) { return expand(el, false) });
    }

    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }

    return expansions;
  }



  /***/ }),
  /* 264 */
  /***/ (function(module, exports) {

  module.exports = function (xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
          var x = fn(xs[i], i);
          if (isArray(x)) res.push.apply(res, x);
          else res.push(x);
      }
      return res;
  };

  var isArray = Array.isArray || function (xs) {
      return Object.prototype.toString.call(xs) === '[object Array]';
  };


  /***/ }),
  /* 265 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  module.exports = balanced;
  function balanced(a, b, str) {
    if (a instanceof RegExp) a = maybeMatch(a, str);
    if (b instanceof RegExp) b = maybeMatch(b, str);

    var r = range(a, b, str);

    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }

  function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }

  balanced.range = range;
  function range(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;

    if (ai >= 0 && bi > 0) {
      begs = [];
      left = str.length;

      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [ begs.pop(), bi ];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }

          bi = str.indexOf(b, i + 1);
        }

        i = ai < bi && ai >= 0 ? ai : bi;
      }

      if (begs.length) {
        result = [ left, right ];
      }
    }

    return result;
  }


  /***/ }),
  /* 266 */
  /***/ (function(module, exports) {

  if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        })
      }
    };
  } else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor
        var TempCtor = function () {}
        TempCtor.prototype = superCtor.prototype
        ctor.prototype = new TempCtor()
        ctor.prototype.constructor = ctor
      }
    }
  }


  /***/ }),
  /* 267 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  function posix(path) {
  	return path.charAt(0) === '/';
  }

  function win32(path) {
  	// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
  	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
  	var result = splitDeviceRe.exec(path);
  	var device = result[1] || '';
  	var isUnc = Boolean(device && device.charAt(1) !== ':');

  	// UNC paths are always absolute
  	return Boolean(result[2] || isUnc);
  }

  module.exports = process.platform === 'win32' ? win32 : posix;
  module.exports.posix = posix;
  module.exports.win32 = win32;


  /***/ }),
  /* 268 */
  /***/ (function(module, exports, __webpack_require__) {

  module.exports = globSync
  globSync.GlobSync = GlobSync

  var fs = __webpack_require__(7)
  var rp = __webpack_require__(260)
  var minimatch = __webpack_require__(262)
  var Minimatch = minimatch.Minimatch
  var Glob = __webpack_require__(259).Glob
  var util = __webpack_require__(25)
  var path = __webpack_require__(8)
  var assert = __webpack_require__(127)
  var isAbsolute = __webpack_require__(267)
  var common = __webpack_require__(269)
  var alphasort = common.alphasort
  var alphasorti = common.alphasorti
  var setopts = common.setopts
  var ownProp = common.ownProp
  var childrenIgnored = common.childrenIgnored
  var isIgnored = common.isIgnored

  function globSync (pattern, options) {
    if (typeof options === 'function' || arguments.length === 3)
      throw new TypeError('callback provided to sync glob\n'+
                          'See: https://github.com/isaacs/node-glob/issues/167')

    return new GlobSync(pattern, options).found
  }

  function GlobSync (pattern, options) {
    if (!pattern)
      throw new Error('must provide pattern')

    if (typeof options === 'function' || arguments.length === 3)
      throw new TypeError('callback provided to sync glob\n'+
                          'See: https://github.com/isaacs/node-glob/issues/167')

    if (!(this instanceof GlobSync))
      return new GlobSync(pattern, options)

    setopts(this, pattern, options)

    if (this.noprocess)
      return this

    var n = this.minimatch.set.length
    this.matches = new Array(n)
    for (var i = 0; i < n; i ++) {
      this._process(this.minimatch.set[i], i, false)
    }
    this._finish()
  }

  GlobSync.prototype._finish = function () {
    assert(this instanceof GlobSync)
    if (this.realpath) {
      var self = this
      this.matches.forEach(function (matchset, index) {
        var set = self.matches[index] = Object.create(null)
        for (var p in matchset) {
          try {
            p = self._makeAbs(p)
            var real = rp.realpathSync(p, self.realpathCache)
            set[real] = true
          } catch (er) {
            if (er.syscall === 'stat')
              set[self._makeAbs(p)] = true
            else
              throw er
          }
        }
      })
    }
    common.finish(this)
  }


  GlobSync.prototype._process = function (pattern, index, inGlobStar) {
    assert(this instanceof GlobSync)

    // Get the first [n] parts of pattern that are all strings.
    var n = 0
    while (typeof pattern[n] === 'string') {
      n ++
    }
    // now n is the index of the first one that is *not* a string.

    // See if there's anything else
    var prefix
    switch (n) {
      // if not, then this is rather simple
      case pattern.length:
        this._processSimple(pattern.join('/'), index)
        return

      case 0:
        // pattern *starts* with some non-trivial item.
        // going to readdir(cwd), but not include the prefix in matches.
        prefix = null
        break

      default:
        // pattern has some string bits in the front.
        // whatever it starts with, whether that's 'absolute' like /foo/bar,
        // or 'relative' like '../baz'
        prefix = pattern.slice(0, n).join('/')
        break
    }

    var remain = pattern.slice(n)

    // get the list of entries.
    var read
    if (prefix === null)
      read = '.'
    else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
      if (!prefix || !isAbsolute(prefix))
        prefix = '/' + prefix
      read = prefix
    } else
      read = prefix

    var abs = this._makeAbs(read)

    //if ignored, skip processing
    if (childrenIgnored(this, read))
      return

    var isGlobStar = remain[0] === minimatch.GLOBSTAR
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
    else
      this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
  }


  GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar)

    // if the abs isn't a dir, then nothing can match!
    if (!entries)
      return

    // It will only match dot entries if it starts with a dot, or if
    // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
    var pn = remain[0]
    var negate = !!this.minimatch.negate
    var rawGlob = pn._glob
    var dotOk = this.dot || rawGlob.charAt(0) === '.'

    var matchedEntries = []
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i]
      if (e.charAt(0) !== '.' || dotOk) {
        var m
        if (negate && !prefix) {
          m = !e.match(pn)
        } else {
          m = e.match(pn)
        }
        if (m)
          matchedEntries.push(e)
      }
    }

    var len = matchedEntries.length
    // If there are no matched entries, then nothing matches.
    if (len === 0)
      return

    // if this is the last remaining pattern bit, then no need for
    // an additional stat *unless* the user has specified mark or
    // stat explicitly.  We know they exist, since readdir returned
    // them.

    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null)

      for (var i = 0; i < len; i ++) {
        var e = matchedEntries[i]
        if (prefix) {
          if (prefix.slice(-1) !== '/')
            e = prefix + '/' + e
          else
            e = prefix + e
        }

        if (e.charAt(0) === '/' && !this.nomount) {
          e = path.join(this.root, e)
        }
        this._emitMatch(index, e)
      }
      // This was the last one, and no stats were needed
      return
    }

    // now test all matched entries as stand-ins for that part
    // of the pattern.
    remain.shift()
    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      var newPattern
      if (prefix)
        newPattern = [prefix, e]
      else
        newPattern = [e]
      this._process(newPattern.concat(remain), index, inGlobStar)
    }
  }


  GlobSync.prototype._emitMatch = function (index, e) {
    if (isIgnored(this, e))
      return

    var abs = this._makeAbs(e)

    if (this.mark)
      e = this._mark(e)

    if (this.absolute) {
      e = abs
    }

    if (this.matches[index][e])
      return

    if (this.nodir) {
      var c = this.cache[abs]
      if (c === 'DIR' || Array.isArray(c))
        return
    }

    this.matches[index][e] = true

    if (this.stat)
      this._stat(e)
  }


  GlobSync.prototype._readdirInGlobStar = function (abs) {
    // follow all symlinked directories forever
    // just proceed as if this is a non-globstar situation
    if (this.follow)
      return this._readdir(abs, false)

    var entries
    var lstat
    var stat
    try {
      lstat = fs.lstatSync(abs)
    } catch (er) {
      if (er.code === 'ENOENT') {
        // lstat failed, doesn't exist
        return null
      }
    }

    var isSym = lstat && lstat.isSymbolicLink()
    this.symlinks[abs] = isSym

    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && lstat && !lstat.isDirectory())
      this.cache[abs] = 'FILE'
    else
      entries = this._readdir(abs, false)

    return entries
  }

  GlobSync.prototype._readdir = function (abs, inGlobStar) {
    var entries

    if (inGlobStar && !ownProp(this.symlinks, abs))
      return this._readdirInGlobStar(abs)

    if (ownProp(this.cache, abs)) {
      var c = this.cache[abs]
      if (!c || c === 'FILE')
        return null

      if (Array.isArray(c))
        return c
    }

    try {
      return this._readdirEntries(abs, fs.readdirSync(abs))
    } catch (er) {
      this._readdirError(abs, er)
      return null
    }
  }

  GlobSync.prototype._readdirEntries = function (abs, entries) {
    // if we haven't asked to stat everything, then just
    // assume that everything in there exists, so we can avoid
    // having to stat it a second time.
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i ++) {
        var e = entries[i]
        if (abs === '/')
          e = abs + e
        else
          e = abs + '/' + e
        this.cache[e] = true
      }
    }

    this.cache[abs] = entries

    // mark and cache dir-ness
    return entries
  }

  GlobSync.prototype._readdirError = function (f, er) {
    // handle errors, and cache the information
    switch (er.code) {
      case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
      case 'ENOTDIR': // totally normal. means it *does* exist.
        var abs = this._makeAbs(f)
        this.cache[abs] = 'FILE'
        if (abs === this.cwdAbs) {
          var error = new Error(er.code + ' invalid cwd ' + this.cwd)
          error.path = this.cwd
          error.code = er.code
          throw error
        }
        break

      case 'ENOENT': // not terribly unusual
      case 'ELOOP':
      case 'ENAMETOOLONG':
      case 'UNKNOWN':
        this.cache[this._makeAbs(f)] = false
        break

      default: // some unusual error.  Treat as failure.
        this.cache[this._makeAbs(f)] = false
        if (this.strict)
          throw er
        if (!this.silent)
          console.error('glob error', er)
        break
    }
  }

  GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

    var entries = this._readdir(abs, inGlobStar)

    // no entries means not a dir, so it can never have matches
    // foo.txt/** doesn't match foo.txt
    if (!entries)
      return

    // test without the globstar, and with every child both below
    // and replacing the globstar.
    var remainWithoutGlobStar = remain.slice(1)
    var gspref = prefix ? [ prefix ] : []
    var noGlobStar = gspref.concat(remainWithoutGlobStar)

    // the noGlobStar pattern exits the inGlobStar state
    this._process(noGlobStar, index, false)

    var len = entries.length
    var isSym = this.symlinks[abs]

    // If it's a symlink, and we're in a globstar, then stop
    if (isSym && inGlobStar)
      return

    for (var i = 0; i < len; i++) {
      var e = entries[i]
      if (e.charAt(0) === '.' && !this.dot)
        continue

      // these two cases enter the inGlobStar state
      var instead = gspref.concat(entries[i], remainWithoutGlobStar)
      this._process(instead, index, true)

      var below = gspref.concat(entries[i], remain)
      this._process(below, index, true)
    }
  }

  GlobSync.prototype._processSimple = function (prefix, index) {
    // XXX review this.  Shouldn't it be doing the mounting etc
    // before doing stat?  kinda weird?
    var exists = this._stat(prefix)

    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    // If it doesn't exist, then just mark the lack of results
    if (!exists)
      return

    if (prefix && isAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix)
      if (prefix.charAt(0) === '/') {
        prefix = path.join(this.root, prefix)
      } else {
        prefix = path.resolve(this.root, prefix)
        if (trail)
          prefix += '/'
      }
    }

    if (process.platform === 'win32')
      prefix = prefix.replace(/\\/g, '/')

    // Mark this as a match
    this._emitMatch(index, prefix)
  }

  // Returns either 'DIR', 'FILE', or false
  GlobSync.prototype._stat = function (f) {
    var abs = this._makeAbs(f)
    var needDir = f.slice(-1) === '/'

    if (f.length > this.maxLength)
      return false

    if (!this.stat && ownProp(this.cache, abs)) {
      var c = this.cache[abs]

      if (Array.isArray(c))
        c = 'DIR'

      // It exists, but maybe not how we need it
      if (!needDir || c === 'DIR')
        return c

      if (needDir && c === 'FILE')
        return false

      // otherwise we have to stat, because maybe c=true
      // if we know it exists, but not what it is.
    }

    var exists
    var stat = this.statCache[abs]
    if (!stat) {
      var lstat
      try {
        lstat = fs.lstatSync(abs)
      } catch (er) {
        if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
          this.statCache[abs] = false
          return false
        }
      }

      if (lstat && lstat.isSymbolicLink()) {
        try {
          stat = fs.statSync(abs)
        } catch (er) {
          stat = lstat
        }
      } else {
        stat = lstat
      }
    }

    this.statCache[abs] = stat

    var c = true
    if (stat)
      c = stat.isDirectory() ? 'DIR' : 'FILE'

    this.cache[abs] = this.cache[abs] || c

    if (needDir && c === 'FILE')
      return false

    return c
  }

  GlobSync.prototype._mark = function (p) {
    return common.mark(this, p)
  }

  GlobSync.prototype._makeAbs = function (f) {
    return common.makeAbs(this, f)
  }


  /***/ }),
  /* 269 */
  /***/ (function(module, exports, __webpack_require__) {

  exports.alphasort = alphasort
  exports.alphasorti = alphasorti
  exports.setopts = setopts
  exports.ownProp = ownProp
  exports.makeAbs = makeAbs
  exports.finish = finish
  exports.mark = mark
  exports.isIgnored = isIgnored
  exports.childrenIgnored = childrenIgnored

  function ownProp (obj, field) {
    return Object.prototype.hasOwnProperty.call(obj, field)
  }

  var path = __webpack_require__(8)
  var minimatch = __webpack_require__(262)
  var isAbsolute = __webpack_require__(267)
  var Minimatch = minimatch.Minimatch

  function alphasorti (a, b) {
    return a.toLowerCase().localeCompare(b.toLowerCase())
  }

  function alphasort (a, b) {
    return a.localeCompare(b)
  }

  function setupIgnores (self, options) {
    self.ignore = options.ignore || []

    if (!Array.isArray(self.ignore))
      self.ignore = [self.ignore]

    if (self.ignore.length) {
      self.ignore = self.ignore.map(ignoreMap)
    }
  }

  // ignore patterns are always in dot:true mode.
  function ignoreMap (pattern) {
    var gmatcher = null
    if (pattern.slice(-3) === '/**') {
      var gpattern = pattern.replace(/(\/\*\*)+$/, '')
      gmatcher = new Minimatch(gpattern, { dot: true })
    }

    return {
      matcher: new Minimatch(pattern, { dot: true }),
      gmatcher: gmatcher
    }
  }

  function setopts (self, pattern, options) {
    if (!options)
      options = {}

    // base-matching: just use globstar for that.
    if (options.matchBase && -1 === pattern.indexOf("/")) {
      if (options.noglobstar) {
        throw new Error("base matching requires globstar")
      }
      pattern = "**/" + pattern
    }

    self.silent = !!options.silent
    self.pattern = pattern
    self.strict = options.strict !== false
    self.realpath = !!options.realpath
    self.realpathCache = options.realpathCache || Object.create(null)
    self.follow = !!options.follow
    self.dot = !!options.dot
    self.mark = !!options.mark
    self.nodir = !!options.nodir
    if (self.nodir)
      self.mark = true
    self.sync = !!options.sync
    self.nounique = !!options.nounique
    self.nonull = !!options.nonull
    self.nosort = !!options.nosort
    self.nocase = !!options.nocase
    self.stat = !!options.stat
    self.noprocess = !!options.noprocess
    self.absolute = !!options.absolute

    self.maxLength = options.maxLength || Infinity
    self.cache = options.cache || Object.create(null)
    self.statCache = options.statCache || Object.create(null)
    self.symlinks = options.symlinks || Object.create(null)

    setupIgnores(self, options)

    self.changedCwd = false
    var cwd = process.cwd()
    if (!ownProp(options, "cwd"))
      self.cwd = cwd
    else {
      self.cwd = path.resolve(options.cwd)
      self.changedCwd = self.cwd !== cwd
    }

    self.root = options.root || path.resolve(self.cwd, "/")
    self.root = path.resolve(self.root)
    if (process.platform === "win32")
      self.root = self.root.replace(/\\/g, "/")

    // TODO: is an absolute `cwd` supposed to be resolved against `root`?
    // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')
    self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)
    if (process.platform === "win32")
      self.cwdAbs = self.cwdAbs.replace(/\\/g, "/")
    self.nomount = !!options.nomount

    // disable comments and negation in Minimatch.
    // Note that they are not supported in Glob itself anyway.
    options.nonegate = true
    options.nocomment = true

    self.minimatch = new Minimatch(pattern, options)
    self.options = self.minimatch.options
  }

  function finish (self) {
    var nou = self.nounique
    var all = nou ? [] : Object.create(null)

    for (var i = 0, l = self.matches.length; i < l; i ++) {
      var matches = self.matches[i]
      if (!matches || Object.keys(matches).length === 0) {
        if (self.nonull) {
          // do like the shell, and spit out the literal glob
          var literal = self.minimatch.globSet[i]
          if (nou)
            all.push(literal)
          else
            all[literal] = true
        }
      } else {
        // had matches
        var m = Object.keys(matches)
        if (nou)
          all.push.apply(all, m)
        else
          m.forEach(function (m) {
            all[m] = true
          })
      }
    }

    if (!nou)
      all = Object.keys(all)

    if (!self.nosort)
      all = all.sort(self.nocase ? alphasorti : alphasort)

    // at *some* point we statted all of these
    if (self.mark) {
      for (var i = 0; i < all.length; i++) {
        all[i] = self._mark(all[i])
      }
      if (self.nodir) {
        all = all.filter(function (e) {
          var notDir = !(/\/$/.test(e))
          var c = self.cache[e] || self.cache[makeAbs(self, e)]
          if (notDir && c)
            notDir = c !== 'DIR' && !Array.isArray(c)
          return notDir
        })
      }
    }

    if (self.ignore.length)
      all = all.filter(function(m) {
        return !isIgnored(self, m)
      })

    self.found = all
  }

  function mark (self, p) {
    var abs = makeAbs(self, p)
    var c = self.cache[abs]
    var m = p
    if (c) {
      var isDir = c === 'DIR' || Array.isArray(c)
      var slash = p.slice(-1) === '/'

      if (isDir && !slash)
        m += '/'
      else if (!isDir && slash)
        m = m.slice(0, -1)

      if (m !== p) {
        var mabs = makeAbs(self, m)
        self.statCache[mabs] = self.statCache[abs]
        self.cache[mabs] = self.cache[abs]
      }
    }

    return m
  }

  // lotta situps...
  function makeAbs (self, f) {
    var abs = f
    if (f.charAt(0) === '/') {
      abs = path.join(self.root, f)
    } else if (isAbsolute(f) || f === '') {
      abs = f
    } else if (self.changedCwd) {
      abs = path.resolve(self.cwd, f)
    } else {
      abs = path.resolve(f)
    }

    if (process.platform === 'win32')
      abs = abs.replace(/\\/g, '/')

    return abs
  }


  // Return true, if pattern ends with globstar '**', for the accompanying parent directory.
  // Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
  function isIgnored (self, path) {
    if (!self.ignore.length)
      return false

    return self.ignore.some(function(item) {
      return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
    })
  }

  function childrenIgnored (self, path) {
    if (!self.ignore.length)
      return false

    return self.ignore.some(function(item) {
      return !!(item.gmatcher && item.gmatcher.match(path))
    })
  }


  /***/ }),
  /* 270 */
  /***/ (function(module, exports, __webpack_require__) {

  var wrappy = __webpack_require__(73)
  var reqs = Object.create(null)
  var once = __webpack_require__(72)

  module.exports = wrappy(inflight)

  function inflight (key, cb) {
    if (reqs[key]) {
      reqs[key].push(cb)
      return null
    } else {
      reqs[key] = [cb]
      return makeres(key)
    }
  }

  function makeres (key) {
    return once(function RES () {
      var cbs = reqs[key]
      var len = cbs.length
      var args = slice(arguments)

      // XXX It's somewhat ambiguous whether a new callback added in this
      // pass should be queued for later execution if something in the
      // list of callbacks throws, or if it should just be discarded.
      // However, it's such an edge case that it hardly matters, and either
      // choice is likely as surprising as the other.
      // As it happens, we do go ahead and schedule it for later execution.
      try {
        for (var i = 0; i < len; i++) {
          cbs[i].apply(null, args)
        }
      } finally {
        if (cbs.length > len) {
          // added more in the interim.
          // de-zalgo, just in case, but don't call again.
          cbs.splice(0, len)
          process.nextTick(function () {
            RES.apply(null, args)
          })
        } else {
          delete reqs[key]
        }
      }
    })
  }

  function slice (args) {
    var length = args.length
    var array = []

    for (var i = 0; i < length; i++) array[i] = args[i]
    return array
  }


  /***/ }),
  /* 271 */
  /***/ (function(module, exports, __webpack_require__) {

  const pkg = __webpack_require__(272);

  module.exports = pkg.async;
  module.exports.default = pkg.async;

  module.exports.async = pkg.async;
  module.exports.sync = pkg.sync;
  module.exports.stream = pkg.stream;

  module.exports.generateTasks = pkg.generateTasks;


  /***/ }),
  /* 272 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  
  Object.defineProperty(exports, "__esModule", { value: true });
  var optionsManager = __webpack_require__(273);
  var taskManager = __webpack_require__(274);
  var reader_async_1 = __webpack_require__(399);
  var reader_stream_1 = __webpack_require__(423);
  var reader_sync_1 = __webpack_require__(424);
  var arrayUtils = __webpack_require__(426);
  var streamUtils = __webpack_require__(427);
  /**
   * Synchronous API.
   */
  function sync(source, opts) {
      assertPatternsInput(source);
      var works = getWorks(source, reader_sync_1.default, opts);
      return arrayUtils.flatten(works);
  }
  exports.sync = sync;
  /**
   * Asynchronous API.
   */
  function async(source, opts) {
      try {
          assertPatternsInput(source);
      }
      catch (error) {
          return Promise.reject(error);
      }
      var works = getWorks(source, reader_async_1.default, opts);
      return Promise.all(works).then(arrayUtils.flatten);
  }
  exports.async = async;
  /**
   * Stream API.
   */
  function stream(source, opts) {
      assertPatternsInput(source);
      var works = getWorks(source, reader_stream_1.default, opts);
      return streamUtils.merge(works);
  }
  exports.stream = stream;
  /**
   * Return a set of tasks based on provided patterns.
   */
  function generateTasks(source, opts) {
      assertPatternsInput(source);
      var patterns = [].concat(source);
      var options = optionsManager.prepare(opts);
      return taskManager.generate(patterns, options);
  }
  exports.generateTasks = generateTasks;
  /**
   * Returns a set of works based on provided tasks and class of the reader.
   */
  function getWorks(source, _Reader, opts) {
      var patterns = [].concat(source);
      var options = optionsManager.prepare(opts);
      var tasks = taskManager.generate(patterns, options);
      var reader = new _Reader(options);
      return tasks.map(reader.read, reader);
  }
  function assertPatternsInput(source) {
      if ([].concat(source).every(isString)) {
          return;
      }
      throw new TypeError('Patterns must be a string or an array of strings');
  }
  function isString(source) {
      /* tslint:disable-next-line strict-type-predicates */
      return typeof source === 'string';
  }


  /***/ }),
  /* 273 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  
  var __assign = (this && this.__assign) || function () {
      __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                  t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  function prepare(options) {
      var opts = __assign({ cwd: process.cwd(), deep: true, ignore: [], dot: false, stats: false, onlyFiles: true, onlyDirectories: false, followSymlinkedDirectories: true, unique: true, markDirectories: false, absolute: false, nobrace: false, brace: true, noglobstar: false, globstar: true, noext: false, extension: true, nocase: false, case: true, matchBase: false, transform: null }, options);
      if (opts.onlyDirectories) {
          opts.onlyFiles = false;
      }
      opts.brace = !opts.nobrace;
      opts.globstar = !opts.noglobstar;
      opts.extension = !opts.noext;
      opts.case = !opts.nocase;
      if (options) {
          opts.brace = ('brace' in options ? options.brace : opts.brace);
          opts.globstar = ('globstar' in options ? options.globstar : opts.globstar);
          opts.extension = ('extension' in options ? options.extension : opts.extension);
          opts.case = ('case' in options ? options.case : opts.case);
      }
      return opts;
  }
  exports.prepare = prepare;


  /***/ }),
  /* 274 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  
  Object.defineProperty(exports, "__esModule", { value: true });
  var patternUtils = __webpack_require__(275);
  /**
   * Generate tasks based on parent directory of each pattern.
   */
  function generate(patterns, options) {
      var unixPatterns = patterns.map(patternUtils.unixifyPattern);
      var unixIgnore = options.ignore.map(patternUtils.unixifyPattern);
      var positivePatterns = getPositivePatterns(unixPatterns);
      var negativePatterns = getNegativePatternsAsPositive(unixPatterns, unixIgnore);
      /**
       * When the `case` option is disabled, all patterns must be marked as dynamic, because we cannot check filepath
       * directly (without read directory).
       */
      var staticPatterns = !options.case ? [] : positivePatterns.filter(patternUtils.isStaticPattern);
      var dynamicPatterns = !options.case ? positivePatterns : positivePatterns.filter(patternUtils.isDynamicPattern);
      var staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, /* dynamic */ false);
      var dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, /* dynamic */ true);
      return staticTasks.concat(dynamicTasks);
  }
  exports.generate = generate;
  /**
   * Convert patterns to tasks based on parent directory of each pattern.
   */
  function convertPatternsToTasks(positive, negative, dynamic) {
      var positivePatternsGroup = groupPatternsByBaseDirectory(positive);
      // When we have a global group – there is no reason to divide the patterns into independent tasks.
      // In this case, the global task covers the rest.
      if ('.' in positivePatternsGroup) {
          var task = convertPatternGroupToTask('.', positive, negative, dynamic);
          return [task];
      }
      return convertPatternGroupsToTasks(positivePatternsGroup, negative, dynamic);
  }
  exports.convertPatternsToTasks = convertPatternsToTasks;
  /**
   * Return only positive patterns.
   */
  function getPositivePatterns(patterns) {
      return patternUtils.getPositivePatterns(patterns);
  }
  exports.getPositivePatterns = getPositivePatterns;
  /**
   * Return only negative patterns.
   */
  function getNegativePatternsAsPositive(patterns, ignore) {
      var negative = patternUtils.getNegativePatterns(patterns).concat(ignore);
      var positive = negative.map(patternUtils.convertToPositivePattern);
      return positive;
  }
  exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
  /**
   * Group patterns by base directory of each pattern.
   */
  function groupPatternsByBaseDirectory(patterns) {
      return patterns.reduce(function (collection, pattern) {
          var base = patternUtils.getBaseDirectory(pattern);
          if (base in collection) {
              collection[base].push(pattern);
          }
          else {
              collection[base] = [pattern];
          }
          return collection;
      }, {});
  }
  exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
  /**
   * Convert group of patterns to tasks.
   */
  function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map(function (base) {
          return convertPatternGroupToTask(base, positive[base], negative, dynamic);
      });
  }
  exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
  /**
   * Create a task for positive and negative patterns.
   */
  function convertPatternGroupToTask(base, positive, negative, dynamic) {
      return {
          base: base,
          dynamic: dynamic,
          positive: positive,
          negative: negative,
          patterns: [].concat(positive, negative.map(patternUtils.convertToNegativePattern))
      };
  }
  exports.convertPatternGroupToTask = convertPatternGroupToTask;


  /***/ }),
  /* 275 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  
  Object.defineProperty(exports, "__esModule", { value: true });
  var path = __webpack_require__(8);
  var globParent = __webpack_require__(276);
  var isGlob = __webpack_require__(280);
  var micromatch = __webpack_require__(281);
  var GLOBSTAR = '**';
  /**
   * Return true for static pattern.
   */
  function isStaticPattern(pattern) {
      return !isDynamicPattern(pattern);
  }
  exports.isStaticPattern = isStaticPattern;
  /**
   * Return true for pattern that looks like glob.
   */
  function isDynamicPattern(pattern) {
      return isGlob(pattern, { strict: false });
  }
  exports.isDynamicPattern = isDynamicPattern;
  /**
   * Convert a windows «path» to a unix-style «path».
   */
  function unixifyPattern(pattern) {
      return pattern.replace(/\\/g, '/');
  }
  exports.unixifyPattern = unixifyPattern;
  /**
   * Returns negative pattern as positive pattern.
   */
  function convertToPositivePattern(pattern) {
      return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
  }
  exports.convertToPositivePattern = convertToPositivePattern;
  /**
   * Returns positive pattern as negative pattern.
   */
  function convertToNegativePattern(pattern) {
      return '!' + pattern;
  }
  exports.convertToNegativePattern = convertToNegativePattern;
  /**
   * Return true if provided pattern is negative pattern.
   */
  function isNegativePattern(pattern) {
      return pattern.startsWith('!') && pattern[1] !== '(';
  }
  exports.isNegativePattern = isNegativePattern;
  /**
   * Return true if provided pattern is positive pattern.
   */
  function isPositivePattern(pattern) {
      return !isNegativePattern(pattern);
  }
  exports.isPositivePattern = isPositivePattern;
  /**
   * Extracts negative patterns from array of patterns.
   */
  function getNegativePatterns(patterns) {
      return patterns.filter(isNegativePattern);
  }
  exports.getNegativePatterns = getNegativePatterns;
  /**
   * Extracts positive patterns from array of patterns.
   */
  function getPositivePatterns(patterns) {
      return patterns.filter(isPositivePattern);
  }
  exports.getPositivePatterns = getPositivePatterns;
  /**
   * Extract base directory from provided pattern.
   */
  function getBaseDirectory(pattern) {
      return globParent(pattern);
  }
  exports.getBaseDirectory = getBaseDirectory;
  /**
   * Return true if provided pattern has globstar.
   */
  function hasGlobStar(pattern) {
      return pattern.indexOf(GLOBSTAR) !== -1;
  }
  exports.hasGlobStar = hasGlobStar;
  /**
   * Return true if provided pattern ends with slash and globstar.
   */
  function endsWithSlashGlobStar(pattern) {
      return pattern.endsWith('/' + GLOBSTAR);
  }
  exports.endsWithSlashGlobStar = endsWithSlashGlobStar;
  /**
   * Returns «true» when pattern ends with a slash and globstar or the last partial of the pattern is static pattern.
   */
  function isAffectDepthOfReadingPattern(pattern) {
      var basename = path.basename(pattern);
      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
  }
  exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
  /**
   * Return naive depth of provided pattern without depth of the base directory.
   */
  function getNaiveDepth(pattern) {
      var base = getBaseDirectory(pattern);
      var patternDepth = pattern.split('/').length;
      var patternBaseDepth = base.split('/').length;
      /**
       * This is a hack for pattern that has no base directory.
       *
       * This is related to the `*\something\*` pattern.
       */
      if (base === '.') {
          return patternDepth - patternBaseDepth;
      }
      return patternDepth - patternBaseDepth - 1;
  }
  exports.getNaiveDepth = getNaiveDepth;
  /**
   * Return max naive depth of provided patterns without depth of the base directory.
   */
  function getMaxNaivePatternsDepth(patterns) {
      return patterns.reduce(function (max, pattern) {
          var depth = getNaiveDepth(pattern);
          return depth > max ? depth : max;
      }, 0);
  }
  exports.getMaxNaivePatternsDepth = getMaxNaivePatternsDepth;
  /**
   * Make RegExp for provided pattern.
   */
  function makeRe(pattern, options) {
      return micromatch.makeRe(pattern, options);
  }
  exports.makeRe = makeRe;
  /**
   * Convert patterns to regexps.
   */
  function convertPatternsToRe(patterns, options) {
      return patterns.map(function (pattern) { return makeRe(pattern, options); });
  }
  exports.convertPatternsToRe = convertPatternsToRe;
  /**
   * Returns true if the entry match any of the given RegExp's.
   */
  function matchAny(entry, patternsRe) {
      return patternsRe.some(function (patternRe) { return patternRe.test(entry); });
  }
  exports.matchAny = matchAny;


  /***/ }),
  /* 276 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var path = __webpack_require__(8);
  var isglob = __webpack_require__(277);
  var pathDirname = __webpack_require__(279);
  var isWin32 = __webpack_require__(44).platform() === 'win32';

  module.exports = function globParent(str) {
  	// flip windows path separators
  	if (isWin32 && str.indexOf('/') < 0) str = str.split('\\').join('/');

  	// special case for strings ending in enclosure containing path separator
  	if (/[\{\[].*[\/]*.*[\}\]]$/.test(str)) str += '/';

  	// preserves full path in case of trailing path separator
  	str += 'a';

  	// remove path parts that are globby
  	do {str = pathDirname.posix(str)}
  	while (isglob(str) || /(^|[^\\])([\{\[]|\([^\)]+$)/.test(str));

  	// remove escape chars and return result
  	return str.replace(/\\([\*\?\|\[\]\(\)\{\}])/g, '$1');
  };


  /***/ }),
  /* 277 */
  /***/ (function(module, exports, __webpack_require__) {

  /*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   */

  var isExtglob = __webpack_require__(278);

  module.exports = function isGlob(str) {
    if (typeof str !== 'string' || str === '') {
      return false;
    }

    if (isExtglob(str)) return true;

    var regex = /(\\).|([*?]|\[.*\]|\{.*\}|\(.*\|.*\)|^!)/;
    var match;

    while ((match = regex.exec(str))) {
      if (match[2]) return true;
      str = str.slice(match.index + match[0].length);
    }
    return false;
  };


  /***/ }),
  /* 278 */
  /***/ (function(module, exports) {

  /*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   */

  module.exports = function isExtglob(str) {
    if (typeof str !== 'string' || str === '') {
      return false;
    }

    var match;
    while ((match = /(\\).|([@?!+*]\(.*\))/g.exec(str))) {
      if (match[2]) return true;
      str = str.slice(match.index + match[0].length);
    }

    return false;
  };


  /***/ }),
  /* 279 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var path = __webpack_require__(8);
  var inspect = __webpack_require__(25).inspect;

  function assertPath(path) {
    if (typeof path !== 'string') {
      throw new TypeError('Path must be a string. Received ' + inspect(path));
    }
  }

  function posix(path) {
    assertPath(path);
    if (path.length === 0)
      return '.';
    var code = path.charCodeAt(0);
    var hasRoot = (code === 47/*/*/);
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47/*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1)
      return hasRoot ? '/' : '.';
    if (hasRoot && end === 1)
      return '//';
    return path.slice(0, end);
  }

  function win32(path) {
    assertPath(path);
    var len = path.length;
    if (len === 0)
      return '.';
    var rootEnd = -1;
    var end = -1;
    var matchedSlash = true;
    var offset = 0;
    var code = path.charCodeAt(0);

    // Try to match a root
    if (len > 1) {
      if (code === 47/*/*/ || code === 92/*\*/) {
        // Possible UNC root

        rootEnd = offset = 1;

        code = path.charCodeAt(1);
        if (code === 47/*/*/ || code === 92/*\*/) {
          // Matched double path separator at beginning
          var j = 2;
          var last = j;
          // Match 1 or more non-path separators
          for (; j < len; ++j) {
            code = path.charCodeAt(j);
            if (code === 47/*/*/ || code === 92/*\*/)
              break;
          }
          if (j < len && j !== last) {
            // Matched!
            last = j;
            // Match 1 or more path separators
            for (; j < len; ++j) {
              code = path.charCodeAt(j);
              if (code !== 47/*/*/ && code !== 92/*\*/)
                break;
            }
            if (j < len && j !== last) {
              // Matched!
              last = j;
              // Match 1 or more non-path separators
              for (; j < len; ++j) {
                code = path.charCodeAt(j);
                if (code === 47/*/*/ || code === 92/*\*/)
                  break;
              }
              if (j === len) {
                // We matched a UNC root only
                return path;
              }
              if (j !== last) {
                // We matched a UNC root with leftovers

                // Offset by 1 to include the separator after the UNC root to
                // treat it as a "normal root" on top of a (UNC) root
                rootEnd = offset = j + 1;
              }
            }
          }
        }
      } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||
                 (code >= 97/*a*/ && code <= 122/*z*/)) {
        // Possible device root

        code = path.charCodeAt(1);
        if (path.charCodeAt(1) === 58/*:*/) {
          rootEnd = offset = 2;
          if (len > 2) {
            code = path.charCodeAt(2);
            if (code === 47/*/*/ || code === 92/*\*/)
              rootEnd = offset = 3;
          }
        }
      }
    } else if (code === 47/*/*/ || code === 92/*\*/) {
      return path[0];
    }

    for (var i = len - 1; i >= offset; --i) {
      code = path.charCodeAt(i);
      if (code === 47/*/*/ || code === 92/*\*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) {
      if (rootEnd === -1)
        return '.';
      else
        end = rootEnd;
    }
    return path.slice(0, end);
  }

  module.exports = process.platform === 'win32' ? win32 : posix;
  module.exports.posix = posix;
  module.exports.win32 = win32;


  /***/ }),
  /* 280 */
  /***/ (function(module, exports, __webpack_require__) {

  /*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */

  var isExtglob = __webpack_require__(278);
  var chars = { '{': '}', '(': ')', '[': ']'};
  var strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
  var relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;

  module.exports = function isGlob(str, options) {
    if (typeof str !== 'string' || str === '') {
      return false;
    }

    if (isExtglob(str)) {
      return true;
    }

    var regex = strictRegex;
    var match;

    // optionally relax regex
    if (options && options.strict === false) {
      regex = relaxedRegex;
    }

    while ((match = regex.exec(str))) {
      if (match[2]) return true;
      var idx = match.index + match[0].length;

      // if an open bracket/brace/paren is escaped,
      // set the index to the next closing character
      var open = match[1];
      var close = open ? chars[open] : null;
      if (open && close) {
        var n = str.indexOf(close, idx);
        if (n !== -1) {
          idx = n + 1;
        }
      }

      str = str.slice(idx);
    }
    return false;
  };


  /***/ }),
  /* 281 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  /**
   * Module dependencies
   */

  var util = __webpack_require__(25);
  var braces = __webpack_require__(282);
  var toRegex = __webpack_require__(283);
  var extend = __webpack_require__(296);

  /**
   * Local dependencies
   */

  var compilers = __webpack_require__(376);
  var parsers = __webpack_require__(396);
  var cache = __webpack_require__(397);
  var utils = __webpack_require__(398);
  var MAX_LENGTH = 1024 * 64;

  /**
   * The main function takes a list of strings and one or more
   * glob patterns to use for matching.
   *
   * ```js
   * var mm = require('micromatch');
   * mm(list, patterns[, options]);
   *
   * console.log(mm(['a.js', 'a.txt'], ['*.js']));
   * //=> [ 'a.js' ]
   * ```
   * @param {Array} `list` A list of strings to match
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Array} Returns an array of matches
   * @summary false
   * @api public
   */

  function micromatch(list, patterns, options) {
    patterns = utils.arrayify(patterns);
    list = utils.arrayify(list);

    var len = patterns.length;
    if (list.length === 0 || len === 0) {
      return [];
    }

    if (len === 1) {
      return micromatch.match(list, patterns[0], options);
    }

    var omit = [];
    var keep = [];
    var idx = -1;

    while (++idx < len) {
      var pattern = patterns[idx];

      if (typeof pattern === 'string' && pattern.charCodeAt(0) === 33 /* ! */) {
        omit.push.apply(omit, micromatch.match(list, pattern.slice(1), options));
      } else {
        keep.push.apply(keep, micromatch.match(list, pattern, options));
      }
    }

    var matches = utils.diff(keep, omit);
    if (!options || options.nodupes !== false) {
      return utils.unique(matches);
    }

    return matches;
  }

  /**
   * Similar to the main function, but `pattern` must be a string.
   *
   * ```js
   * var mm = require('micromatch');
   * mm.match(list, pattern[, options]);
   *
   * console.log(mm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));
   * //=> ['a.a', 'a.aa']
   * ```
   * @param {Array} `list` Array of strings to match
   * @param {String} `pattern` Glob pattern to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Array} Returns an array of matches
   * @api public
   */

  micromatch.match = function(list, pattern, options) {
    if (Array.isArray(pattern)) {
      throw new TypeError('expected pattern to be a string');
    }

    var unixify = utils.unixify(options);
    var isMatch = memoize('match', pattern, options, micromatch.matcher);
    var matches = [];

    list = utils.arrayify(list);
    var len = list.length;
    var idx = -1;

    while (++idx < len) {
      var ele = list[idx];
      if (ele === pattern || isMatch(ele)) {
        matches.push(utils.value(ele, unixify, options));
      }
    }

    // if no options were passed, uniquify results and return
    if (typeof options === 'undefined') {
      return utils.unique(matches);
    }

    if (matches.length === 0) {
      if (options.failglob === true) {
        throw new Error('no matches found for "' + pattern + '"');
      }
      if (options.nonull === true || options.nullglob === true) {
        return [options.unescape ? utils.unescape(pattern) : pattern];
      }
    }

    // if `opts.ignore` was defined, diff ignored list
    if (options.ignore) {
      matches = micromatch.not(matches, options.ignore, options);
    }

    return options.nodupes !== false ? utils.unique(matches) : matches;
  };

  /**
   * Returns true if the specified `string` matches the given glob `pattern`.
   *
   * ```js
   * var mm = require('micromatch');
   * mm.isMatch(string, pattern[, options]);
   *
   * console.log(mm.isMatch('a.a', '*.a'));
   * //=> true
   * console.log(mm.isMatch('a.b', '*.a'));
   * //=> false
   * ```
   * @param {String} `string` String to match
   * @param {String} `pattern` Glob pattern to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if the string matches the glob pattern.
   * @api public
   */

  micromatch.isMatch = function(str, pattern, options) {
    if (typeof str !== 'string') {
      throw new TypeError('expected a string: "' + util.inspect(str) + '"');
    }

    if (isEmptyString(str) || isEmptyString(pattern)) {
      return false;
    }

    var equals = utils.equalsPattern(options);
    if (equals(str)) {
      return true;
    }

    var isMatch = memoize('isMatch', pattern, options, micromatch.matcher);
    return isMatch(str);
  };

  /**
   * Returns true if some of the strings in the given `list` match any of the
   * given glob `patterns`.
   *
   * ```js
   * var mm = require('micromatch');
   * mm.some(list, patterns[, options]);
   *
   * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
   * // true
   * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
   * // false
   * ```
   * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */

  micromatch.some = function(list, patterns, options) {
    if (typeof list === 'string') {
      list = [list];
    }
    for (var i = 0; i < list.length; i++) {
      if (micromatch(list[i], patterns, options).length === 1) {
        return true;
      }
    }
    return false;
  };

  /**
   * Returns true if every string in the given `list` matches
   * any of the given glob `patterns`.
   *
   * ```js
   * var mm = require('micromatch');
   * mm.every(list, patterns[, options]);
   *
   * console.log(mm.every('foo.js', ['foo.js']));
   * // true
   * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
   * // true
   * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
   * // false
   * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
   * // false
   * ```
   * @param  {String|Array} `list` The string or array of strings to test.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */

  micromatch.every = function(list, patterns, options) {
    if (typeof list === 'string') {
      list = [list];
    }
    for (var i = 0; i < list.length; i++) {
      if (micromatch(list[i], patterns, options).length !== 1) {
        return false;
      }
    }
    return true;
  };

  /**
   * Returns true if **any** of the given glob `patterns`
   * match the specified `string`.
   *
   * ```js
   * var mm = require('micromatch');
   * mm.any(string, patterns[, options]);
   *
   * console.log(mm.any('a.a', ['b.*', '*.a']));
   * //=> true
   * console.log(mm.any('a.a', 'b.*'));
   * //=> false
   * ```
   * @param  {String|Array} `str` The string to test.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */

  micromatch.any = function(str, patterns, options) {
    if (typeof str !== 'string') {
      throw new TypeError('expected a string: "' + util.inspect(str) + '"');
    }

    if (isEmptyString(str) || isEmptyString(patterns)) {
      return false;
    }

    if (typeof patterns === 'string') {
      patterns = [patterns];
    }

    for (var i = 0; i < patterns.length; i++) {
      if (micromatch.isMatch(str, patterns[i], options)) {
        return true;
      }
    }
    return false;
  };

  /**
   * Returns true if **all** of the given `patterns` match
   * the specified string.
   *
   * ```js
   * var mm = require('micromatch');
   * mm.all(string, patterns[, options]);
   *
   * console.log(mm.all('foo.js', ['foo.js']));
   * // true
   *
   * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
   * // false
   *
   * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
   * // true
   *
   * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
   * // true
   * ```
   * @param  {String|Array} `str` The string to test.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */

  micromatch.all = function(str, patterns, options) {
    if (typeof str !== 'string') {
      throw new TypeError('expected a string: "' + util.inspect(str) + '"');
    }
    if (typeof patterns === 'string') {
      patterns = [patterns];
    }
    for (var i = 0; i < patterns.length; i++) {
      if (!micromatch.isMatch(str, patterns[i], options)) {
        return false;
      }
    }
    return true;
  };

  /**
   * Returns a list of strings that _**do not match any**_ of the given `patterns`.
   *
   * ```js
   * var mm = require('micromatch');
   * mm.not(list, patterns[, options]);
   *
   * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
   * //=> ['b.b', 'c.c']
   * ```
   * @param {Array} `list` Array of strings to match.
   * @param {String|Array} `patterns` One or more glob pattern to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Array} Returns an array of strings that **do not match** the given patterns.
   * @api public
   */

  micromatch.not = function(list, patterns, options) {
    var opts = extend({}, options);
    var ignore = opts.ignore;
    delete opts.ignore;

    var unixify = utils.unixify(opts);
    list = utils.arrayify(list).map(unixify);

    var matches = utils.diff(list, micromatch(list, patterns, opts));
    if (ignore) {
      matches = utils.diff(matches, micromatch(list, ignore));
    }

    return opts.nodupes !== false ? utils.unique(matches) : matches;
  };

  /**
   * Returns true if the given `string` contains the given pattern. Similar
   * to [.isMatch](#isMatch) but the pattern can match any part of the string.
   *
   * ```js
   * var mm = require('micromatch');
   * mm.contains(string, pattern[, options]);
   *
   * console.log(mm.contains('aa/bb/cc', '*b'));
   * //=> true
   * console.log(mm.contains('aa/bb/cc', '*d'));
   * //=> false
   * ```
   * @param {String} `str` The string to match.
   * @param {String|Array} `patterns` Glob pattern to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if the patter matches any part of `str`.
   * @api public
   */

  micromatch.contains = function(str, patterns, options) {
    if (typeof str !== 'string') {
      throw new TypeError('expected a string: "' + util.inspect(str) + '"');
    }

    if (typeof patterns === 'string') {
      if (isEmptyString(str) || isEmptyString(patterns)) {
        return false;
      }

      var equals = utils.equalsPattern(patterns, options);
      if (equals(str)) {
        return true;
      }
      var contains = utils.containsPattern(patterns, options);
      if (contains(str)) {
        return true;
      }
    }

    var opts = extend({}, options, {contains: true});
    return micromatch.any(str, patterns, opts);
  };

  /**
   * Returns true if the given pattern and options should enable
   * the `matchBase` option.
   * @return {Boolean}
   * @api private
   */

  micromatch.matchBase = function(pattern, options) {
    if (pattern && pattern.indexOf('/') !== -1 || !options) return false;
    return options.basename === true || options.matchBase === true;
  };

  /**
   * Filter the keys of the given object with the given `glob` pattern
   * and `options`. Does not attempt to match nested keys. If you need this feature,
   * use [glob-object][] instead.
   *
   * ```js
   * var mm = require('micromatch');
   * mm.matchKeys(object, patterns[, options]);
   *
   * var obj = { aa: 'a', ab: 'b', ac: 'c' };
   * console.log(mm.matchKeys(obj, '*b'));
   * //=> { ab: 'b' }
   * ```
   * @param {Object} `object` The object with keys to filter.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Object} Returns an object with only keys that match the given patterns.
   * @api public
   */

  micromatch.matchKeys = function(obj, patterns, options) {
    if (!utils.isObject(obj)) {
      throw new TypeError('expected the first argument to be an object');
    }
    var keys = micromatch(Object.keys(obj), patterns, options);
    return utils.pick(obj, keys);
  };

  /**
   * Returns a memoized matcher function from the given glob `pattern` and `options`.
   * The returned function takes a string to match as its only argument and returns
   * true if the string is a match.
   *
   * ```js
   * var mm = require('micromatch');
   * mm.matcher(pattern[, options]);
   *
   * var isMatch = mm.matcher('*.!(*a)');
   * console.log(isMatch('a.a'));
   * //=> false
   * console.log(isMatch('a.b'));
   * //=> true
   * ```
   * @param {String} `pattern` Glob pattern
   * @param {Object} `options` See available [options](#options) for changing how matches are performed.
   * @return {Function} Returns a matcher function.
   * @api public
   */

  micromatch.matcher = function matcher(pattern, options) {
    if (Array.isArray(pattern)) {
      return compose(pattern, options, matcher);
    }

    // if pattern is a regex
    if (pattern instanceof RegExp) {
      return test(pattern);
    }

    // if pattern is invalid
    if (!utils.isString(pattern)) {
      throw new TypeError('expected pattern to be an array, string or regex');
    }

    // if pattern is a non-glob string
    if (!utils.hasSpecialChars(pattern)) {
      if (options && options.nocase === true) {
        pattern = pattern.toLowerCase();
      }
      return utils.matchPath(pattern, options);
    }

    // if pattern is a glob string
    var re = micromatch.makeRe(pattern, options);

    // if `options.matchBase` or `options.basename` is defined
    if (micromatch.matchBase(pattern, options)) {
      return utils.matchBasename(re, options);
    }

    function test(regex) {
      var equals = utils.equalsPattern(options);
      var unixify = utils.unixify(options);

      return function(str) {
        if (equals(str)) {
          return true;
        }

        if (regex.test(unixify(str))) {
          return true;
        }
        return false;
      };
    }

    var fn = test(re);
    Object.defineProperty(fn, 'result', {
      configurable: true,
      enumerable: false,
      value: re.result
    });
    return fn;
  };

  /**
   * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
   *
   * ```js
   * var mm = require('micromatch');
   * mm.capture(pattern, string[, options]);
   *
   * console.log(mm.capture('test/*.js', 'test/foo.js'));
   * //=> ['foo']
   * console.log(mm.capture('test/*.js', 'foo/bar.css'));
   * //=> null
   * ```
   * @param {String} `pattern` Glob pattern to use for matching.
   * @param {String} `string` String to match
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.
   * @api public
   */

  micromatch.capture = function(pattern, str, options) {
    var re = micromatch.makeRe(pattern, extend({capture: true}, options));
    var unixify = utils.unixify(options);

    function match() {
      return function(string) {
        var match = re.exec(unixify(string));
        if (!match) {
          return null;
        }

        return match.slice(1);
      };
    }

    var capture = memoize('capture', pattern, options, match);
    return capture(str);
  };

  /**
   * Create a regular expression from the given glob `pattern`.
   *
   * ```js
   * var mm = require('micromatch');
   * mm.makeRe(pattern[, options]);
   *
   * console.log(mm.makeRe('*.js'));
   * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
   * ```
   * @param {String} `pattern` A glob pattern to convert to regex.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed.
   * @return {RegExp} Returns a regex created from the given pattern.
   * @api public
   */

  micromatch.makeRe = function(pattern, options) {
    if (typeof pattern !== 'string') {
      throw new TypeError('expected pattern to be a string');
    }

    if (pattern.length > MAX_LENGTH) {
      throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');
    }

    function makeRe() {
      var result = micromatch.create(pattern, options);
      var ast_array = [];
      var output = result.map(function(obj) {
        obj.ast.state = obj.state;
        ast_array.push(obj.ast);
        return obj.output;
      });

      var regex = toRegex(output.join('|'), options);
      Object.defineProperty(regex, 'result', {
        configurable: true,
        enumerable: false,
        value: ast_array
      });
      return regex;
    }

    return memoize('makeRe', pattern, options, makeRe);
  };

  /**
   * Expand the given brace `pattern`.
   *
   * ```js
   * var mm = require('micromatch');
   * console.log(mm.braces('foo/{a,b}/bar'));
   * //=> ['foo/(a|b)/bar']
   *
   * console.log(mm.braces('foo/{a,b}/bar', {expand: true}));
   * //=> ['foo/(a|b)/bar']
   * ```
   * @param {String} `pattern` String with brace pattern to expand.
   * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
   * @return {Array}
   * @api public
   */

  micromatch.braces = function(pattern, options) {
    if (typeof pattern !== 'string' && !Array.isArray(pattern)) {
      throw new TypeError('expected pattern to be an array or string');
    }

    function expand() {
      if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
        return utils.arrayify(pattern);
      }
      return braces(pattern, options);
    }

    return memoize('braces', pattern, options, expand);
  };

  /**
   * Proxy to the [micromatch.braces](#method), for parity with
   * minimatch.
   */

  micromatch.braceExpand = function(pattern, options) {
    var opts = extend({}, options, {expand: true});
    return micromatch.braces(pattern, opts);
  };

  /**
   * Parses the given glob `pattern` and returns an array of abstract syntax
   * trees (ASTs), with the compiled `output` and optional source `map` on
   * each AST.
   *
   * ```js
   * var mm = require('micromatch');
   * mm.create(pattern[, options]);
   *
   * console.log(mm.create('abc/*.js'));
   * // [{ options: { source: 'string', sourcemap: true },
   * //   state: {},
   * //   compilers:
   * //    { ... },
   * //   output: '(\\.[\\\\\\/])?abc\\/(?!\\.)(?=.)[^\\/]*?\\.js',
   * //   ast:
   * //    { type: 'root',
   * //      errors: [],
   * //      nodes:
   * //       [ ... ],
   * //      dot: false,
   * //      input: 'abc/*.js' },
   * //   parsingErrors: [],
   * //   map:
   * //    { version: 3,
   * //      sources: [ 'string' ],
   * //      names: [],
   * //      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',
   * //      sourcesContent: [ 'abc/*.js' ] },
   * //   position: { line: 1, column: 28 },
   * //   content: {},
   * //   files: {},
   * //   idx: 6 }]
   * ```
   * @param {String} `pattern` Glob pattern to parse and compile.
   * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.
   * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.
   * @api public
   */

  micromatch.create = function(pattern, options) {
    return memoize('create', pattern, options, function() {
      function create(str, opts) {
        return micromatch.compile(micromatch.parse(str, opts), opts);
      }

      pattern = micromatch.braces(pattern, options);
      var len = pattern.length;
      var idx = -1;
      var res = [];

      while (++idx < len) {
        res.push(create(pattern[idx], options));
      }
      return res;
    });
  };

  /**
   * Parse the given `str` with the given `options`.
   *
   * ```js
   * var mm = require('micromatch');
   * mm.parse(pattern[, options]);
   *
   * var ast = mm.parse('a/{b,c}/d');
   * console.log(ast);
   * // { type: 'root',
   * //   errors: [],
   * //   input: 'a/{b,c}/d',
   * //   nodes:
   * //    [ { type: 'bos', val: '' },
   * //      { type: 'text', val: 'a/' },
   * //      { type: 'brace',
   * //        nodes:
   * //         [ { type: 'brace.open', val: '{' },
   * //           { type: 'text', val: 'b,c' },
   * //           { type: 'brace.close', val: '}' } ] },
   * //      { type: 'text', val: '/d' },
   * //      { type: 'eos', val: '' } ] }
   * ```
   * @param {String} `str`
   * @param {Object} `options`
   * @return {Object} Returns an AST
   * @api public
   */

  micromatch.parse = function(pattern, options) {
    if (typeof pattern !== 'string') {
      throw new TypeError('expected a string');
    }

    function parse() {
      var snapdragon = utils.instantiate(null, options);
      parsers(snapdragon, options);

      var ast = snapdragon.parse(pattern, options);
      utils.define(ast, 'snapdragon', snapdragon);
      ast.input = pattern;
      return ast;
    }

    return memoize('parse', pattern, options, parse);
  };

  /**
   * Compile the given `ast` or string with the given `options`.
   *
   * ```js
   * var mm = require('micromatch');
   * mm.compile(ast[, options]);
   *
   * var ast = mm.parse('a/{b,c}/d');
   * console.log(mm.compile(ast));
   * // { options: { source: 'string' },
   * //   state: {},
   * //   compilers:
   * //    { eos: [Function],
   * //      noop: [Function],
   * //      bos: [Function],
   * //      brace: [Function],
   * //      'brace.open': [Function],
   * //      text: [Function],
   * //      'brace.close': [Function] },
   * //   output: [ 'a/(b|c)/d' ],
   * //   ast:
   * //    { ... },
   * //   parsingErrors: [] }
   * ```
   * @param {Object|String} `ast`
   * @param {Object} `options`
   * @return {Object} Returns an object that has an `output` property with the compiled string.
   * @api public
   */

  micromatch.compile = function(ast, options) {
    if (typeof ast === 'string') {
      ast = micromatch.parse(ast, options);
    }

    return memoize('compile', ast.input, options, function() {
      var snapdragon = utils.instantiate(ast, options);
      compilers(snapdragon, options);
      return snapdragon.compile(ast, options);
    });
  };

  /**
   * Clear the regex cache.
   *
   * ```js
   * mm.clearCache();
   * ```
   * @api public
   */

  micromatch.clearCache = function() {
    micromatch.cache.caches = {};
  };

  /**
   * Returns true if the given value is effectively an empty string
   */

  function isEmptyString(val) {
    return String(val) === '' || String(val) === './';
  }

  /**
   * Compose a matcher function with the given patterns.
   * This allows matcher functions to be compiled once and
   * called multiple times.
   */

  function compose(patterns, options, matcher) {
    var matchers;

    return memoize('compose', String(patterns), options, function() {
      return function(file) {
        // delay composition until it's invoked the first time,
        // after that it won't be called again
        if (!matchers) {
          matchers = [];
          for (var i = 0; i < patterns.length; i++) {
            matchers.push(matcher(patterns[i], options));
          }
        }

        var len = matchers.length;
        while (len--) {
          if (matchers[len](file) === true) {
            return true;
          }
        }
        return false;
      };
    });
  }

  /**
   * Memoize a generated regex or function. A unique key is generated
   * from the `type` (usually method name), the `pattern`, and
   * user-defined options.
   */

  function memoize(type, pattern, options, fn) {
    var key = utils.createKey(type + '=' + pattern, options);

    if (options && options.cache === false) {
      return fn(pattern, options);
    }

    if (cache.has(type, key)) {
      return cache.get(type, key);
    }

    var val = fn(pattern, options);
    cache.set(type, key, val);
    return val;
  }

  /**
   * Expose compiler, parser and cache on `micromatch`
   */

  micromatch.compilers = compilers;
  micromatch.parsers = parsers;
  micromatch.caches = cache.caches;

  /**
   * Expose `micromatch`
   * @type {Function}
   */

  module.exports = micromatch;


  /***/ }),
  /* 282 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  /**
   * Module dependencies
   */

  var toRegex = __webpack_require__(283);
  var unique = __webpack_require__(301);
  var extend = __webpack_require__(302);

  /**
   * Local dependencies
   */

  var compilers = __webpack_require__(304);
  var parsers = __webpack_require__(315);
  var Braces = __webpack_require__(319);
  var utils = __webpack_require__(305);
  var MAX_LENGTH = 1024 * 64;
  var cache = {};

  /**
   * Convert the given `braces` pattern into a regex-compatible string. By default, only one string is generated for every input string. Set `options.expand` to true to return an array of patterns (similar to Bash or minimatch. Before using `options.expand`, it's recommended that you read the [performance notes](#performance)).
   *
   * ```js
   * var braces = require('braces');
   * console.log(braces('{a,b,c}'));
   * //=> ['(a|b|c)']
   *
   * console.log(braces('{a,b,c}', {expand: true}));
   * //=> ['a', 'b', 'c']
   * ```
   * @param {String} `str`
   * @param {Object} `options`
   * @return {String}
   * @api public
   */

  function braces(pattern, options) {
    var key = utils.createKey(String(pattern), options);
    var arr = [];

    var disabled = options && options.cache === false;
    if (!disabled && cache.hasOwnProperty(key)) {
      return cache[key];
    }

    if (Array.isArray(pattern)) {
      for (var i = 0; i < pattern.length; i++) {
        arr.push.apply(arr, braces.create(pattern[i], options));
      }
    } else {
      arr = braces.create(pattern, options);
    }

    if (options && options.nodupes === true) {
      arr = unique(arr);
    }

    if (!disabled) {
      cache[key] = arr;
    }
    return arr;
  }

  /**
   * Expands a brace pattern into an array. This method is called by the main [braces](#braces) function when `options.expand` is true. Before using this method it's recommended that you read the [performance notes](#performance)) and advantages of using [.optimize](#optimize) instead.
   *
   * ```js
   * var braces = require('braces');
   * console.log(braces.expand('a/{b,c}/d'));
   * //=> ['a/b/d', 'a/c/d'];
   * ```
   * @param {String} `pattern` Brace pattern
   * @param {Object} `options`
   * @return {Array} Returns an array of expanded values.
   * @api public
   */

  braces.expand = function(pattern, options) {
    return braces.create(pattern, extend({}, options, {expand: true}));
  };

  /**
   * Expands a brace pattern into a regex-compatible, optimized string. This method is called by the main [braces](#braces) function by default.
   *
   * ```js
   * var braces = require('braces');
   * console.log(braces.expand('a/{b,c}/d'));
   * //=> ['a/(b|c)/d']
   * ```
   * @param {String} `pattern` Brace pattern
   * @param {Object} `options`
   * @return {Array} Returns an array of expanded values.
   * @api public
   */

  braces.optimize = function(pattern, options) {
    return braces.create(pattern, options);
  };

  /**
   * Processes a brace pattern and returns either an expanded array (if `options.expand` is true), a highly optimized regex-compatible string. This method is called by the main [braces](#braces) function.
   *
   * ```js
   * var braces = require('braces');
   * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
   * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
   * ```
   * @param {String} `pattern` Brace pattern
   * @param {Object} `options`
   * @return {Array} Returns an array of expanded values.
   * @api public
   */

  braces.create = function(pattern, options) {
    if (typeof pattern !== 'string') {
      throw new TypeError('expected a string');
    }

    var maxLength = (options && options.maxLength) || MAX_LENGTH;
    if (pattern.length >= maxLength) {
      throw new Error('expected pattern to be less than ' + maxLength + ' characters');
    }

    function create() {
      if (pattern === '' || pattern.length < 3) {
        return [pattern];
      }

      if (utils.isEmptySets(pattern)) {
        return [];
      }

      if (utils.isQuotedString(pattern)) {
        return [pattern.slice(1, -1)];
      }

      var proto = new Braces(options);
      var result = !options || options.expand !== true
        ? proto.optimize(pattern, options)
        : proto.expand(pattern, options);

      // get the generated pattern(s)
      var arr = result.output;

      // filter out empty strings if specified
      if (options && options.noempty === true) {
        arr = arr.filter(Boolean);
      }

      // filter out duplicates if specified
      if (options && options.nodupes === true) {
        arr = unique(arr);
      }

      Object.defineProperty(arr, 'result', {
        enumerable: false,
        value: result
      });

      return arr;
    }

    return memoize('create', pattern, options, create);
  };

  /**
   * Create a regular expression from the given string `pattern`.
   *
   * ```js
   * var braces = require('braces');
   *
   * console.log(braces.makeRe('id-{200..300}'));
   * //=> /^(?:id-(20[0-9]|2[1-9][0-9]|300))$/
   * ```
   * @param {String} `pattern` The pattern to convert to regex.
   * @param {Object} `options`
   * @return {RegExp}
   * @api public
   */

  braces.makeRe = function(pattern, options) {
    if (typeof pattern !== 'string') {
      throw new TypeError('expected a string');
    }

    var maxLength = (options && options.maxLength) || MAX_LENGTH;
    if (pattern.length >= maxLength) {
      throw new Error('expected pattern to be less than ' + maxLength + ' characters');
    }

    function makeRe() {
      var arr = braces(pattern, options);
      var opts = extend({strictErrors: false}, options);
      return toRegex(arr, opts);
    }

    return memoize('makeRe', pattern, options, makeRe);
  };

  /**
   * Parse the given `str` with the given `options`.
   *
   * ```js
   * var braces = require('braces');
   * var ast = braces.parse('a/{b,c}/d');
   * console.log(ast);
   * // { type: 'root',
   * //   errors: [],
   * //   input: 'a/{b,c}/d',
   * //   nodes:
   * //    [ { type: 'bos', val: '' },
   * //      { type: 'text', val: 'a/' },
   * //      { type: 'brace',
   * //        nodes:
   * //         [ { type: 'brace.open', val: '{' },
   * //           { type: 'text', val: 'b,c' },
   * //           { type: 'brace.close', val: '}' } ] },
   * //      { type: 'text', val: '/d' },
   * //      { type: 'eos', val: '' } ] }
   * ```
   * @param {String} `pattern` Brace pattern to parse
   * @param {Object} `options`
   * @return {Object} Returns an AST
   * @api public
   */

  braces.parse = function(pattern, options) {
    var proto = new Braces(options);
    return proto.parse(pattern, options);
  };

  /**
   * Compile the given `ast` or string with the given `options`.
   *
   * ```js
   * var braces = require('braces');
   * var ast = braces.parse('a/{b,c}/d');
   * console.log(braces.compile(ast));
   * // { options: { source: 'string' },
   * //   state: {},
   * //   compilers:
   * //    { eos: [Function],
   * //      noop: [Function],
   * //      bos: [Function],
   * //      brace: [Function],
   * //      'brace.open': [Function],
   * //      text: [Function],
   * //      'brace.close': [Function] },
   * //   output: [ 'a/(b|c)/d' ],
   * //   ast:
   * //    { ... },
   * //   parsingErrors: [] }
   * ```
   * @param {Object|String} `ast` AST from [.parse](#parse). If a string is passed it will be parsed first.
   * @param {Object} `options`
   * @return {Object} Returns an object that has an `output` property with the compiled string.
   * @api public
   */

  braces.compile = function(ast, options) {
    var proto = new Braces(options);
    return proto.compile(ast, options);
  };

  /**
   * Clear the regex cache.
   *
   * ```js
   * braces.clearCache();
   * ```
   * @api public
   */

  braces.clearCache = function() {
    cache = braces.cache = {};
  };

  /**
   * Memoize a generated regex or function. A unique key is generated
   * from the method name, pattern, and user-defined options. Set
   * options.memoize to false to disable.
   */

  function memoize(type, pattern, options, fn) {
    var key = utils.createKey(type + ':' + pattern, options);
    var disabled = options && options.cache === false;
    if (disabled) {
      braces.clearCache();
      return fn(pattern, options);
    }

    if (cache.hasOwnProperty(key)) {
      return cache[key];
    }

    var res = fn(pattern, options);
    cache[key] = res;
    return res;
  }

  /**
   * Expose `Braces` constructor and methods
   * @type {Function}
   */

  braces.Braces = Braces;
  braces.compilers = compilers;
  braces.parsers = parsers;
  braces.cache = cache;

  /**
   * Expose `braces`
   * @type {Function}
   */

  module.exports = braces;


  /***/ }),
  /* 283 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var safe = __webpack_require__(284);
  var define = __webpack_require__(290);
  var extend = __webpack_require__(296);
  var not = __webpack_require__(300);
  var MAX_LENGTH = 1024 * 64;

  /**
   * Session cache
   */

  var cache = {};

  /**
   * Create a regular expression from the given `pattern` string.
   *
   * @param {String|RegExp} `pattern` Pattern can be a string or regular expression.
   * @param {Object} `options`
   * @return {RegExp}
   * @api public
   */

  module.exports = function(patterns, options) {
    if (!Array.isArray(patterns)) {
      return makeRe(patterns, options);
    }
    return makeRe(patterns.join('|'), options);
  };

  /**
   * Create a regular expression from the given `pattern` string.
   *
   * @param {String|RegExp} `pattern` Pattern can be a string or regular expression.
   * @param {Object} `options`
   * @return {RegExp}
   * @api public
   */

  function makeRe(pattern, options) {
    if (pattern instanceof RegExp) {
      return pattern;
    }

    if (typeof pattern !== 'string') {
      throw new TypeError('expected a string');
    }

    if (pattern.length > MAX_LENGTH) {
      throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');
    }

    var key = pattern;
    // do this before shallow cloning options, it's a lot faster
    if (!options || (options && options.cache !== false)) {
      key = createKey(pattern, options);

      if (cache.hasOwnProperty(key)) {
        return cache[key];
      }
    }

    var opts = extend({}, options);
    if (opts.contains === true) {
      if (opts.negate === true) {
        opts.strictNegate = false;
      } else {
        opts.strict = false;
      }
    }

    if (opts.strict === false) {
      opts.strictOpen = false;
      opts.strictClose = false;
    }

    var open = opts.strictOpen !== false ? '^' : '';
    var close = opts.strictClose !== false ? '$' : '';
    var flags = opts.flags || '';
    var regex;

    if (opts.nocase === true && !/i/.test(flags)) {
      flags += 'i';
    }

    try {
      if (opts.negate || typeof opts.strictNegate === 'boolean') {
        pattern = not.create(pattern, opts);
      }

      var str = open + '(?:' + pattern + ')' + close;
      regex = new RegExp(str, flags);

      if (opts.safe === true && safe(regex) === false) {
        throw new Error('potentially unsafe regular expression: ' + regex.source);
      }

    } catch (err) {
      if (opts.strictErrors === true || opts.safe === true) {
        err.key = key;
        err.pattern = pattern;
        err.originalOptions = options;
        err.createdOptions = opts;
        throw err;
      }

      try {
        regex = new RegExp('^' + pattern.replace(/(\W)/g, '\\$1') + '$');
      } catch (err) {
        regex = /.^/; //<= match nothing
      }
    }

    if (opts.cache !== false) {
      memoize(regex, key, pattern, opts);
    }
    return regex;
  }

  /**
   * Memoize generated regex. This can result in dramatic speed improvements
   * and simplify debugging by adding options and pattern to the regex. It can be
   * disabled by passing setting `options.cache` to false.
   */

  function memoize(regex, key, pattern, options) {
    define(regex, 'cached', true);
    define(regex, 'pattern', pattern);
    define(regex, 'options', options);
    define(regex, 'key', key);
    cache[key] = regex;
  }

  /**
   * Create the key to use for memoization. The key is generated
   * by iterating over the options and concatenating key-value pairs
   * to the pattern string.
   */

  function createKey(pattern, options) {
    if (!options) return pattern;
    var key = pattern;
    for (var prop in options) {
      if (options.hasOwnProperty(prop)) {
        key += ';' + prop + '=' + String(options[prop]);
      }
    }
    return key;
  }

  /**
   * Expose `makeRe`
   */

  module.exports.makeRe = makeRe;


  /***/ }),
  /* 284 */
  /***/ (function(module, exports, __webpack_require__) {

  var parse = __webpack_require__(285);
  var types = parse.types;

  module.exports = function (re, opts) {
      if (!opts) opts = {};
      var replimit = opts.limit === undefined ? 25 : opts.limit;

      if (isRegExp(re)) re = re.source;
      else if (typeof re !== 'string') re = String(re);

      try { re = parse(re) }
      catch (err) { return false }

      var reps = 0;
      return (function walk (node, starHeight) {
          if (node.type === types.REPETITION) {
              starHeight ++;
              reps ++;
              if (starHeight > 1) return false;
              if (reps > replimit) return false;
          }

          if (node.options) {
              for (var i = 0, len = node.options.length; i < len; i++) {
                  var ok = walk({ stack: node.options[i] }, starHeight);
                  if (!ok) return false;
              }
          }
          var stack = node.stack || (node.value && node.value.stack);
          if (!stack) return true;

          for (var i = 0; i < stack.length; i++) {
              var ok = walk(stack[i], starHeight);
              if (!ok) return false;
          }

          return true;
      })(re, 0);
  };

  function isRegExp (x) {
      return {}.toString.call(x) === '[object RegExp]';
  }


  /***/ }),
  /* 285 */
  /***/ (function(module, exports, __webpack_require__) {

  var util      = __webpack_require__(286);
  var types     = __webpack_require__(287);
  var sets      = __webpack_require__(288);
  var positions = __webpack_require__(289);


  module.exports = function(regexpStr) {
    var i = 0, l, c,
        start = { type: types.ROOT, stack: []},

        // Keep track of last clause/group and stack.
        lastGroup = start,
        last = start.stack,
        groupStack = [];


    var repeatErr = function(i) {
      util.error(regexpStr, 'Nothing to repeat at column ' + (i - 1));
    };

    // Decode a few escaped characters.
    var str = util.strToChars(regexpStr);
    l = str.length;

    // Iterate through each character in string.
    while (i < l) {
      c = str[i++];

      switch (c) {
        // Handle escaped characters, inclues a few sets.
        case '\\':
          c = str[i++];

          switch (c) {
            case 'b':
              last.push(positions.wordBoundary());
              break;

            case 'B':
              last.push(positions.nonWordBoundary());
              break;

            case 'w':
              last.push(sets.words());
              break;

            case 'W':
              last.push(sets.notWords());
              break;

            case 'd':
              last.push(sets.ints());
              break;

            case 'D':
              last.push(sets.notInts());
              break;

            case 's':
              last.push(sets.whitespace());
              break;

            case 'S':
              last.push(sets.notWhitespace());
              break;

            default:
              // Check if c is integer.
              // In which case it's a reference.
              if (/\d/.test(c)) {
                last.push({ type: types.REFERENCE, value: parseInt(c, 10) });

              // Escaped character.
              } else {
                last.push({ type: types.CHAR, value: c.charCodeAt(0) });
              }
          }

          break;


        // Positionals.
        case '^':
            last.push(positions.begin());
          break;

        case '$':
            last.push(positions.end());
          break;


        // Handle custom sets.
        case '[':
          // Check if this class is 'anti' i.e. [^abc].
          var not;
          if (str[i] === '^') {
            not = true;
            i++;
          } else {
            not = false;
          }

          // Get all the characters in class.
          var classTokens = util.tokenizeClass(str.slice(i), regexpStr);

          // Increase index by length of class.
          i += classTokens[1];
          last.push({
            type: types.SET,
            set: classTokens[0],
            not: not,
          });

          break;


        // Class of any character except \n.
        case '.':
          last.push(sets.anyChar());
          break;


        // Push group onto stack.
        case '(':
          // Create group.
          var group = {
            type: types.GROUP,
            stack: [],
            remember: true,
          };

          c = str[i];

          // If if this is a special kind of group.
          if (c === '?') {
            c = str[i + 1];
            i += 2;

            // Match if followed by.
            if (c === '=') {
              group.followedBy = true;

            // Match if not followed by.
            } else if (c === '!') {
              group.notFollowedBy = true;

            } else if (c !== ':') {
              util.error(regexpStr,
                'Invalid group, character \'' + c +
                '\' after \'?\' at column ' + (i - 1));
            }

            group.remember = false;
          }

          // Insert subgroup into current group stack.
          last.push(group);

          // Remember the current group for when the group closes.
          groupStack.push(lastGroup);

          // Make this new group the current group.
          lastGroup = group;
          last = group.stack;
          break;


        // Pop group out of stack.
        case ')':
          if (groupStack.length === 0) {
            util.error(regexpStr, 'Unmatched ) at column ' + (i - 1));
          }
          lastGroup = groupStack.pop();

          // Check if this group has a PIPE.
          // To get back the correct last stack.
          last = lastGroup.options ?
            lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
          break;


        // Use pipe character to give more choices.
        case '|':
          // Create array where options are if this is the first PIPE
          // in this clause.
          if (!lastGroup.options) {
            lastGroup.options = [lastGroup.stack];
            delete lastGroup.stack;
          }

          // Create a new stack and add to options for rest of clause.
          var stack = [];
          lastGroup.options.push(stack);
          last = stack;
          break;


        // Repetition.
        // For every repetition, remove last element from last stack
        // then insert back a RANGE object.
        // This design is chosen because there could be more than
        // one repetition symbols in a regex i.e. `a?+{2,3}`.
        case '{':
          var rs = /^(\d+)(,(\d+)?)?\}/.exec(str.slice(i)), min, max;
          if (rs !== null) {
            if (last.length === 0) {
              repeatErr(i);
            }
            min = parseInt(rs[1], 10);
            max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;
            i += rs[0].length;

            last.push({
              type: types.REPETITION,
              min: min,
              max: max,
              value: last.pop(),
            });
          } else {
            last.push({
              type: types.CHAR,
              value: 123,
            });
          }
          break;

        case '?':
          if (last.length === 0) {
            repeatErr(i);
          }
          last.push({
            type: types.REPETITION,
            min: 0,
            max: 1,
            value: last.pop(),
          });
          break;

        case '+':
          if (last.length === 0) {
            repeatErr(i);
          }
          last.push({
            type: types.REPETITION,
            min: 1,
            max: Infinity,
            value: last.pop(),
          });
          break;

        case '*':
          if (last.length === 0) {
            repeatErr(i);
          }
          last.push({
            type: types.REPETITION,
            min: 0,
            max: Infinity,
            value: last.pop(),
          });
          break;


        // Default is a character that is not `\[](){}?+*^$`.
        default:
          last.push({
            type: types.CHAR,
            value: c.charCodeAt(0),
          });
      }

    }

    // Check if any groups have not been closed.
    if (groupStack.length !== 0) {
      util.error(regexpStr, 'Unterminated group');
    }

    return start;
  };

  module.exports.types = types;


  /***/ }),
  /* 286 */
  /***/ (function(module, exports, __webpack_require__) {

  var types = __webpack_require__(287);
  var sets  = __webpack_require__(288);


  // All of these are private and only used by randexp.
  // It's assumed that they will always be called with the correct input.

  var CTRL = '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?';
  var SLSH = { '0': 0, 't': 9, 'n': 10, 'v': 11, 'f': 12, 'r': 13 };

  /**
   * Finds character representations in str and convert all to
   * their respective characters
   *
   * @param {String} str
   * @return {String}
   */
  exports.strToChars = function(str) {
    /* jshint maxlen: false */
    var chars_regex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z\[\\\]\^?])|([0tnvfr]))/g;
    str = str.replace(chars_regex, function(s, b, lbs, a16, b16, c8, dctrl, eslsh) {
      if (lbs) {
        return s;
      }

      var code = b     ? 8 :
                 a16   ? parseInt(a16, 16) :
                 b16   ? parseInt(b16, 16) :
                 c8    ? parseInt(c8,   8) :
                 dctrl ? CTRL.indexOf(dctrl) :
                 SLSH[eslsh];

      var c = String.fromCharCode(code);

      // Escape special regex characters.
      if (/[\[\]{}\^$.|?*+()]/.test(c)) {
        c = '\\' + c;
      }

      return c;
    });

    return str;
  };


  /**
   * turns class into tokens
   * reads str until it encounters a ] not preceeded by a \
   *
   * @param {String} str
   * @param {String} regexpStr
   * @return {Array.<Array.<Object>, Number>}
   */
  exports.tokenizeClass = function(str, regexpStr) {
    /* jshint maxlen: false */
    var tokens = [];
    var regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(?:\\)?([^\]]))|(\])|(?:\\)?(.)/g;
    var rs, c;


    while ((rs = regexp.exec(str)) != null) {
      if (rs[1]) {
        tokens.push(sets.words());

      } else if (rs[2]) {
        tokens.push(sets.ints());

      } else if (rs[3]) {
        tokens.push(sets.whitespace());

      } else if (rs[4]) {
        tokens.push(sets.notWords());

      } else if (rs[5]) {
        tokens.push(sets.notInts());

      } else if (rs[6]) {
        tokens.push(sets.notWhitespace());

      } else if (rs[7]) {
        tokens.push({
          type: types.RANGE,
          from: (rs[8] || rs[9]).charCodeAt(0),
            to: rs[10].charCodeAt(0),
        });

      } else if (c = rs[12]) {
        tokens.push({
          type: types.CHAR,
          value: c.charCodeAt(0),
        });

      } else {
        return [tokens, regexp.lastIndex];
      }
    }

    exports.error(regexpStr, 'Unterminated character class');
  };


  /**
   * Shortcut to throw errors.
   *
   * @param {String} regexp
   * @param {String} msg
   */
  exports.error = function(regexp, msg) {
    throw new SyntaxError('Invalid regular expression: /' + regexp + '/: ' + msg);
  };


  /***/ }),
  /* 287 */
  /***/ (function(module, exports) {

  module.exports = {
    ROOT       : 0,
    GROUP      : 1,
    POSITION   : 2,
    SET        : 3,
    RANGE      : 4,
    REPETITION : 5,
    REFERENCE  : 6,
    CHAR       : 7,
  };


  /***/ }),
  /* 288 */
  /***/ (function(module, exports, __webpack_require__) {

  var types = __webpack_require__(287);

  var INTS = function() {
   return [{ type: types.RANGE , from: 48, to: 57 }];
  };

  var WORDS = function() {
   return [
      { type: types.CHAR, value: 95 },
      { type: types.RANGE, from: 97, to: 122 },
      { type: types.RANGE, from: 65, to: 90 }
    ].concat(INTS());
  };

  var WHITESPACE = function() {
   return [
      { type: types.CHAR, value: 9 },
      { type: types.CHAR, value: 10 },
      { type: types.CHAR, value: 11 },
      { type: types.CHAR, value: 12 },
      { type: types.CHAR, value: 13 },
      { type: types.CHAR, value: 32 },
      { type: types.CHAR, value: 160 },
      { type: types.CHAR, value: 5760 },
      { type: types.CHAR, value: 6158 },
      { type: types.CHAR, value: 8192 },
      { type: types.CHAR, value: 8193 },
      { type: types.CHAR, value: 8194 },
      { type: types.CHAR, value: 8195 },
      { type: types.CHAR, value: 8196 },
      { type: types.CHAR, value: 8197 },
      { type: types.CHAR, value: 8198 },
      { type: types.CHAR, value: 8199 },
      { type: types.CHAR, value: 8200 },
      { type: types.CHAR, value: 8201 },
      { type: types.CHAR, value: 8202 },
      { type: types.CHAR, value: 8232 },
      { type: types.CHAR, value: 8233 },
      { type: types.CHAR, value: 8239 },
      { type: types.CHAR, value: 8287 },
      { type: types.CHAR, value: 12288 },
      { type: types.CHAR, value: 65279 }
    ];
  };

  var NOTANYCHAR = function() {
    return [
      { type: types.CHAR, value: 10 },
      { type: types.CHAR, value: 13 },
      { type: types.CHAR, value: 8232 },
      { type: types.CHAR, value: 8233 },
    ];
  };

  // Predefined class objects.
  exports.words = function() {
    return { type: types.SET, set: WORDS(), not: false };
  };

  exports.notWords = function() {
    return { type: types.SET, set: WORDS(), not: true };
  };

  exports.ints = function() {
    return { type: types.SET, set: INTS(), not: false };
  };

  exports.notInts = function() {
    return { type: types.SET, set: INTS(), not: true };
  };

  exports.whitespace = function() {
    return { type: types.SET, set: WHITESPACE(), not: false };
  };

  exports.notWhitespace = function() {
    return { type: types.SET, set: WHITESPACE(), not: true };
  };

  exports.anyChar = function() {
    return { type: types.SET, set: NOTANYCHAR(), not: true };
  };


  /***/ }),
  /* 289 */
  /***/ (function(module, exports, __webpack_require__) {

  var types = __webpack_require__(287);

  exports.wordBoundary = function() {
    return { type: types.POSITION, value: 'b' };
  };

  exports.nonWordBoundary = function() {
    return { type: types.POSITION, value: 'B' };
  };

  exports.begin = function() {
    return { type: types.POSITION, value: '^' };
  };

  exports.end = function() {
    return { type: types.POSITION, value: '$' };
  };


  /***/ }),
  /* 290 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * define-property <https://github.com/jonschlinkert/define-property>
   *
   * Copyright (c) 2015-2018, Jon Schlinkert.
   * Released under the MIT License.
   */



  var isobject = __webpack_require__(291);
  var isDescriptor = __webpack_require__(292);
  var define = (typeof Reflect !== 'undefined' && Reflect.defineProperty)
    ? Reflect.defineProperty
    : Object.defineProperty;

  module.exports = function defineProperty(obj, key, val) {
    if (!isobject(obj) && typeof obj !== 'function' && !Array.isArray(obj)) {
      throw new TypeError('expected an object, function, or array');
    }

    if (typeof key !== 'string') {
      throw new TypeError('expected "key" to be a string');
    }

    if (isDescriptor(val)) {
      define(obj, key, val);
      return obj;
    }

    define(obj, key, {
      configurable: true,
      enumerable: false,
      writable: true,
      value: val
    });

    return obj;
  };


  /***/ }),
  /* 291 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * isobject <https://github.com/jonschlinkert/isobject>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */



  module.exports = function isObject(val) {
    return val != null && typeof val === 'object' && Array.isArray(val) === false;
  };


  /***/ }),
  /* 292 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * is-descriptor <https://github.com/jonschlinkert/is-descriptor>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */



  var typeOf = __webpack_require__(293);
  var isAccessor = __webpack_require__(294);
  var isData = __webpack_require__(295);

  module.exports = function isDescriptor(obj, key) {
    if (typeOf(obj) !== 'object') {
      return false;
    }
    if ('get' in obj) {
      return isAccessor(obj, key);
    }
    return isData(obj, key);
  };


  /***/ }),
  /* 293 */
  /***/ (function(module, exports) {

  var toString = Object.prototype.toString;

  module.exports = function kindOf(val) {
    if (val === void 0) return 'undefined';
    if (val === null) return 'null';

    var type = typeof val;
    if (type === 'boolean') return 'boolean';
    if (type === 'string') return 'string';
    if (type === 'number') return 'number';
    if (type === 'symbol') return 'symbol';
    if (type === 'function') {
      return isGeneratorFn(val) ? 'generatorfunction' : 'function';
    }

    if (isArray(val)) return 'array';
    if (isBuffer(val)) return 'buffer';
    if (isArguments(val)) return 'arguments';
    if (isDate(val)) return 'date';
    if (isError(val)) return 'error';
    if (isRegexp(val)) return 'regexp';

    switch (ctorName(val)) {
      case 'Symbol': return 'symbol';
      case 'Promise': return 'promise';

      // Set, Map, WeakSet, WeakMap
      case 'WeakMap': return 'weakmap';
      case 'WeakSet': return 'weakset';
      case 'Map': return 'map';
      case 'Set': return 'set';

      // 8-bit typed arrays
      case 'Int8Array': return 'int8array';
      case 'Uint8Array': return 'uint8array';
      case 'Uint8ClampedArray': return 'uint8clampedarray';

      // 16-bit typed arrays
      case 'Int16Array': return 'int16array';
      case 'Uint16Array': return 'uint16array';

      // 32-bit typed arrays
      case 'Int32Array': return 'int32array';
      case 'Uint32Array': return 'uint32array';
      case 'Float32Array': return 'float32array';
      case 'Float64Array': return 'float64array';
    }

    if (isGeneratorObj(val)) {
      return 'generator';
    }

    // Non-plain objects
    type = toString.call(val);
    switch (type) {
      case '[object Object]': return 'object';
      // iterators
      case '[object Map Iterator]': return 'mapiterator';
      case '[object Set Iterator]': return 'setiterator';
      case '[object String Iterator]': return 'stringiterator';
      case '[object Array Iterator]': return 'arrayiterator';
    }

    // other
    return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
  };

  function ctorName(val) {
    return val.constructor ? val.constructor.name : null;
  }

  function isArray(val) {
    if (Array.isArray) return Array.isArray(val);
    return val instanceof Array;
  }

  function isError(val) {
    return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');
  }

  function isDate(val) {
    if (val instanceof Date) return true;
    return typeof val.toDateString === 'function'
      && typeof val.getDate === 'function'
      && typeof val.setDate === 'function';
  }

  function isRegexp(val) {
    if (val instanceof RegExp) return true;
    return typeof val.flags === 'string'
      && typeof val.ignoreCase === 'boolean'
      && typeof val.multiline === 'boolean'
      && typeof val.global === 'boolean';
  }

  function isGeneratorFn(name, val) {
    return ctorName(name) === 'GeneratorFunction';
  }

  function isGeneratorObj(val) {
    return typeof val.throw === 'function'
      && typeof val.return === 'function'
      && typeof val.next === 'function';
  }

  function isArguments(val) {
    try {
      if (typeof val.length === 'number' && typeof val.callee === 'function') {
        return true;
      }
    } catch (err) {
      if (err.message.indexOf('callee') !== -1) {
        return true;
      }
    }
    return false;
  }

  /**
   * If you need to support Safari 5-7 (8-10 yr-old browser),
   * take a look at https://github.com/feross/is-buffer
   */

  function isBuffer(val) {
    if (val.constructor && typeof val.constructor.isBuffer === 'function') {
      return val.constructor.isBuffer(val);
    }
    return false;
  }


  /***/ }),
  /* 294 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * is-accessor-descriptor <https://github.com/jonschlinkert/is-accessor-descriptor>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */



  var typeOf = __webpack_require__(293);

  // accessor descriptor properties
  var accessor = {
    get: 'function',
    set: 'function',
    configurable: 'boolean',
    enumerable: 'boolean'
  };

  function isAccessorDescriptor(obj, prop) {
    if (typeof prop === 'string') {
      var val = Object.getOwnPropertyDescriptor(obj, prop);
      return typeof val !== 'undefined';
    }

    if (typeOf(obj) !== 'object') {
      return false;
    }

    if (has(obj, 'value') || has(obj, 'writable')) {
      return false;
    }

    if (!has(obj, 'get') || typeof obj.get !== 'function') {
      return false;
    }

    // tldr: it's valid to have "set" be undefined
    // "set" might be undefined if `Object.getOwnPropertyDescriptor`
    // was used to get the value, and only `get` was defined by the user
    if (has(obj, 'set') && typeof obj[key] !== 'function' && typeof obj[key] !== 'undefined') {
      return false;
    }

    for (var key in obj) {
      if (!accessor.hasOwnProperty(key)) {
        continue;
      }

      if (typeOf(obj[key]) === accessor[key]) {
        continue;
      }

      if (typeof obj[key] !== 'undefined') {
        return false;
      }
    }
    return true;
  }

  function has(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
  }

  /**
   * Expose `isAccessorDescriptor`
   */

  module.exports = isAccessorDescriptor;


  /***/ }),
  /* 295 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * is-data-descriptor <https://github.com/jonschlinkert/is-data-descriptor>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */



  var typeOf = __webpack_require__(293);

  module.exports = function isDataDescriptor(obj, prop) {
    // data descriptor properties
    var data = {
      configurable: 'boolean',
      enumerable: 'boolean',
      writable: 'boolean'
    };

    if (typeOf(obj) !== 'object') {
      return false;
    }

    if (typeof prop === 'string') {
      var val = Object.getOwnPropertyDescriptor(obj, prop);
      return typeof val !== 'undefined';
    }

    if (!('value' in obj) && !('writable' in obj)) {
      return false;
    }

    for (var key in obj) {
      if (key === 'value') continue;

      if (!data.hasOwnProperty(key)) {
        continue;
      }

      if (typeOf(obj[key]) === data[key]) {
        continue;
      }

      if (typeof obj[key] !== 'undefined') {
        return false;
      }
    }
    return true;
  };


  /***/ }),
  /* 296 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var isExtendable = __webpack_require__(297);
  var assignSymbols = __webpack_require__(299);

  module.exports = Object.assign || function(obj/*, objects*/) {
    if (obj === null || typeof obj === 'undefined') {
      throw new TypeError('Cannot convert undefined or null to object');
    }
    if (!isObject(obj)) {
      obj = {};
    }
    for (var i = 1; i < arguments.length; i++) {
      var val = arguments[i];
      if (isString(val)) {
        val = toObject(val);
      }
      if (isObject(val)) {
        assign(obj, val);
        assignSymbols(obj, val);
      }
    }
    return obj;
  };

  function assign(a, b) {
    for (var key in b) {
      if (hasOwn(b, key)) {
        a[key] = b[key];
      }
    }
  }

  function isString(val) {
    return (val && typeof val === 'string');
  }

  function toObject(str) {
    var obj = {};
    for (var i in str) {
      obj[i] = str[i];
    }
    return obj;
  }

  function isObject(val) {
    return (val && typeof val === 'object') || isExtendable(val);
  }

  /**
   * Returns true if the given `key` is an own property of `obj`.
   */

  function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }

  function isEnum(obj, key) {
    return Object.prototype.propertyIsEnumerable.call(obj, key);
  }


  /***/ }),
  /* 297 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * is-extendable <https://github.com/jonschlinkert/is-extendable>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */



  var isPlainObject = __webpack_require__(298);

  module.exports = function isExtendable(val) {
    return isPlainObject(val) || typeof val === 'function' || Array.isArray(val);
  };


  /***/ }),
  /* 298 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */



  var isObject = __webpack_require__(291);

  function isObjectObject(o) {
    return isObject(o) === true
      && Object.prototype.toString.call(o) === '[object Object]';
  }

  module.exports = function isPlainObject(o) {
    var ctor,prot;

    if (isObjectObject(o) === false) return false;

    // If has modified constructor
    ctor = o.constructor;
    if (typeof ctor !== 'function') return false;

    // If has modified prototype
    prot = ctor.prototype;
    if (isObjectObject(prot) === false) return false;

    // If constructor does not have an Object-specific method
    if (prot.hasOwnProperty('isPrototypeOf') === false) {
      return false;
    }

    // Most likely a plain Object
    return true;
  };


  /***/ }),
  /* 299 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * assign-symbols <https://github.com/jonschlinkert/assign-symbols>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */



  module.exports = function(receiver, objects) {
    if (receiver === null || typeof receiver === 'undefined') {
      throw new TypeError('expected first argument to be an object.');
    }

    if (typeof objects === 'undefined' || typeof Symbol === 'undefined') {
      return receiver;
    }

    if (typeof Object.getOwnPropertySymbols !== 'function') {
      return receiver;
    }

    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var target = Object(receiver);
    var len = arguments.length, i = 0;

    while (++i < len) {
      var provider = Object(arguments[i]);
      var names = Object.getOwnPropertySymbols(provider);

      for (var j = 0; j < names.length; j++) {
        var key = names[j];

        if (isEnumerable.call(provider, key)) {
          target[key] = provider[key];
        }
      }
    }
    return target;
  };


  /***/ }),
  /* 300 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var extend = __webpack_require__(296);
  var safe = __webpack_require__(284);

  /**
   * The main export is a function that takes a `pattern` string and an `options` object.
   *
   * ```js
   & var not = require('regex-not');
   & console.log(not('foo'));
   & //=> /^(?:(?!^(?:foo)$).)*$/
   * ```
   *
   * @param {String} `pattern`
   * @param {Object} `options`
   * @return {RegExp} Converts the given `pattern` to a regex using the specified `options`.
   * @api public
   */

  function toRegex(pattern, options) {
    return new RegExp(toRegex.create(pattern, options));
  }

  /**
   * Create a regex-compatible string from the given `pattern` and `options`.
   *
   * ```js
   & var not = require('regex-not');
   & console.log(not.create('foo'));
   & //=> '^(?:(?!^(?:foo)$).)*$'
   * ```
   * @param {String} `pattern`
   * @param {Object} `options`
   * @return {String}
   * @api public
   */

  toRegex.create = function(pattern, options) {
    if (typeof pattern !== 'string') {
      throw new TypeError('expected a string');
    }

    var opts = extend({}, options);
    if (opts.contains === true) {
      opts.strictNegate = false;
    }

    var open = opts.strictOpen !== false ? '^' : '';
    var close = opts.strictClose !== false ? '$' : '';
    var endChar = opts.endChar ? opts.endChar : '+';
    var str = pattern;

    if (opts.strictNegate === false) {
      str = '(?:(?!(?:' + pattern + ')).)' + endChar;
    } else {
      str = '(?:(?!^(?:' + pattern + ')$).)' + endChar;
    }

    var res = open + str + close;
    if (opts.safe === true && safe(res) === false) {
      throw new Error('potentially unsafe regular expression: ' + res);
    }

    return res;
  };

  /**
   * Expose `toRegex`
   */

  module.exports = toRegex;


  /***/ }),
  /* 301 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * array-unique <https://github.com/jonschlinkert/array-unique>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */



  module.exports = function unique(arr) {
    if (!Array.isArray(arr)) {
      throw new TypeError('array-unique expects an array.');
    }

    var len = arr.length;
    var i = -1;

    while (i++ < len) {
      var j = i + 1;

      for (; j < arr.length; ++j) {
        if (arr[i] === arr[j]) {
          arr.splice(j--, 1);
        }
      }
    }
    return arr;
  };

  module.exports.immutable = function uniqueImmutable(arr) {
    if (!Array.isArray(arr)) {
      throw new TypeError('array-unique expects an array.');
    }

    var arrLen = arr.length;
    var newArr = new Array(arrLen);

    for (var i = 0; i < arrLen; i++) {
      newArr[i] = arr[i];
    }

    return module.exports(newArr);
  };


  /***/ }),
  /* 302 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var isObject = __webpack_require__(303);

  module.exports = function extend(o/*, objects*/) {
    if (!isObject(o)) { o = {}; }

    var len = arguments.length;
    for (var i = 1; i < len; i++) {
      var obj = arguments[i];

      if (isObject(obj)) {
        assign(o, obj);
      }
    }
    return o;
  };

  function assign(a, b) {
    for (var key in b) {
      if (hasOwn(b, key)) {
        a[key] = b[key];
      }
    }
  }

  /**
   * Returns true if the given `key` is an own property of `obj`.
   */

  function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }


  /***/ }),
  /* 303 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * is-extendable <https://github.com/jonschlinkert/is-extendable>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */



  module.exports = function isExtendable(val) {
    return typeof val !== 'undefined' && val !== null
      && (typeof val === 'object' || typeof val === 'function');
  };


  /***/ }),
  /* 304 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var utils = __webpack_require__(305);

  module.exports = function(braces, options) {
    braces.compiler

      /**
       * bos
       */

      .set('bos', function() {
        if (this.output) return;
        this.ast.queue = isEscaped(this.ast) ? [this.ast.val] : [];
        this.ast.count = 1;
      })

      /**
       * Square brackets
       */

      .set('bracket', function(node) {
        var close = node.close;
        var open = !node.escaped ? '[' : '\\[';
        var negated = node.negated;
        var inner = node.inner;

        inner = inner.replace(/\\(?=[\\\w]|$)/g, '\\\\');
        if (inner === ']-') {
          inner = '\\]\\-';
        }

        if (negated && inner.indexOf('.') === -1) {
          inner += '.';
        }
        if (negated && inner.indexOf('/') === -1) {
          inner += '/';
        }

        var val = open + negated + inner + close;
        var queue = node.parent.queue;
        var last = utils.arrayify(queue.pop());

        queue.push(utils.join(last, val));
        queue.push.apply(queue, []);
      })

      /**
       * Brace
       */

      .set('brace', function(node) {
        node.queue = isEscaped(node) ? [node.val] : [];
        node.count = 1;
        return this.mapVisit(node.nodes);
      })

      /**
       * Open
       */

      .set('brace.open', function(node) {
        node.parent.open = node.val;
      })

      /**
       * Inner
       */

      .set('text', function(node) {
        var queue = node.parent.queue;
        var escaped = node.escaped;
        var segs = [node.val];

        if (node.optimize === false) {
          options = utils.extend({}, options, {optimize: false});
        }

        if (node.multiplier > 1) {
          node.parent.count *= node.multiplier;
        }

        if (options.quantifiers === true && utils.isQuantifier(node.val)) {
          escaped = true;

        } else if (node.val.length > 1) {
          if (isType(node.parent, 'brace') && !isEscaped(node)) {
            var expanded = utils.expand(node.val, options);
            segs = expanded.segs;

            if (expanded.isOptimized) {
              node.parent.isOptimized = true;
            }

            // if nothing was expanded, we probably have a literal brace
            if (!segs.length) {
              var val = (expanded.val || node.val);
              if (options.unescape !== false) {
                // unescape unexpanded brace sequence/set separators
                val = val.replace(/\\([,.])/g, '$1');
                // strip quotes
                val = val.replace(/["'`]/g, '');
              }

              segs = [val];
              escaped = true;
            }
          }

        } else if (node.val === ',') {
          if (options.expand) {
            node.parent.queue.push(['']);
            segs = [''];
          } else {
            segs = ['|'];
          }
        } else {
          escaped = true;
        }

        if (escaped && isType(node.parent, 'brace')) {
          if (node.parent.nodes.length <= 4 && node.parent.count === 1) {
            node.parent.escaped = true;
          } else if (node.parent.length <= 3) {
            node.parent.escaped = true;
          }
        }

        if (!hasQueue(node.parent)) {
          node.parent.queue = segs;
          return;
        }

        var last = utils.arrayify(queue.pop());
        if (node.parent.count > 1 && options.expand) {
          last = multiply(last, node.parent.count);
          node.parent.count = 1;
        }

        queue.push(utils.join(utils.flatten(last), segs.shift()));
        queue.push.apply(queue, segs);
      })

      /**
       * Close
       */

      .set('brace.close', function(node) {
        var queue = node.parent.queue;
        var prev = node.parent.parent;
        var last = prev.queue.pop();
        var open = node.parent.open;
        var close = node.val;

        if (open && close && isOptimized(node, options)) {
          open = '(';
          close = ')';
        }

        // if a close brace exists, and the previous segment is one character
        // don't wrap the result in braces or parens
        var ele = utils.last(queue);
        if (node.parent.count > 1 && options.expand) {
          ele = multiply(queue.pop(), node.parent.count);
          node.parent.count = 1;
          queue.push(ele);
        }

        if (close && typeof ele === 'string' && ele.length === 1) {
          open = '';
          close = '';
        }

        if ((isLiteralBrace(node, options) || noInner(node)) && !node.parent.hasEmpty) {
          queue.push(utils.join(open, queue.pop() || ''));
          queue = utils.flatten(utils.join(queue, close));
        }

        if (typeof last === 'undefined') {
          prev.queue = [queue];
        } else {
          prev.queue.push(utils.flatten(utils.join(last, queue)));
        }
      })

      /**
       * eos
       */

      .set('eos', function(node) {
        if (this.input) return;

        if (options.optimize !== false) {
          this.output = utils.last(utils.flatten(this.ast.queue));
        } else if (Array.isArray(utils.last(this.ast.queue))) {
          this.output = utils.flatten(this.ast.queue.pop());
        } else {
          this.output = utils.flatten(this.ast.queue);
        }

        if (node.parent.count > 1 && options.expand) {
          this.output = multiply(this.output, node.parent.count);
        }

        this.output = utils.arrayify(this.output);
        this.ast.queue = [];
      });

  };

  /**
   * Multiply the segments in the current brace level
   */

  function multiply(queue, n, options) {
    return utils.flatten(utils.repeat(utils.arrayify(queue), n));
  }

  /**
   * Return true if `node` is escaped
   */

  function isEscaped(node) {
    return node.escaped === true;
  }

  /**
   * Returns true if regex parens should be used for sets. If the parent `type`
   * is not `brace`, then we're on a root node, which means we should never
   * expand segments and open/close braces should be `{}` (since this indicates
   * a brace is missing from the set)
   */

  function isOptimized(node, options) {
    if (node.parent.isOptimized) return true;
    return isType(node.parent, 'brace')
      && !isEscaped(node.parent)
      && options.expand !== true;
  }

  /**
   * Returns true if the value in `node` should be wrapped in a literal brace.
   * @return {Boolean}
   */

  function isLiteralBrace(node, options) {
    return isEscaped(node.parent) || options.optimize !== false;
  }

  /**
   * Returns true if the given `node` does not have an inner value.
   * @return {Boolean}
   */

  function noInner(node, type) {
    if (node.parent.queue.length === 1) {
      return true;
    }
    var nodes = node.parent.nodes;
    return nodes.length === 3
      && isType(nodes[0], 'brace.open')
      && !isType(nodes[1], 'text')
      && isType(nodes[2], 'brace.close');
  }

  /**
   * Returns true if the given `node` is the given `type`
   * @return {Boolean}
   */

  function isType(node, type) {
    return typeof node !== 'undefined' && node.type === type;
  }

  /**
   * Returns true if the given `node` has a non-empty queue.
   * @return {Boolean}
   */

  function hasQueue(node) {
    return Array.isArray(node.queue) && node.queue.length;
  }


  /***/ }),
  /* 305 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var splitString = __webpack_require__(306);
  var utils = module.exports;

  /**
   * Module dependencies
   */

  utils.extend = __webpack_require__(302);
  utils.flatten = __webpack_require__(307);
  utils.isObject = __webpack_require__(291);
  utils.fillRange = __webpack_require__(308);
  utils.repeat = __webpack_require__(314);
  utils.unique = __webpack_require__(301);

  utils.define = function(obj, key, val) {
    Object.defineProperty(obj, key, {
      writable: true,
      configurable: true,
      enumerable: false,
      value: val
    });
  };

  /**
   * Returns true if the given string contains only empty brace sets.
   */

  utils.isEmptySets = function(str) {
    return /^(?:\{,\})+$/.test(str);
  };

  /**
   * Returns true if the given string contains only empty brace sets.
   */

  utils.isQuotedString = function(str) {
    var open = str.charAt(0);
    if (open === '\'' || open === '"' || open === '`') {
      return str.slice(-1) === open;
    }
    return false;
  };

  /**
   * Create the key to use for memoization. The unique key is generated
   * by iterating over the options and concatenating key-value pairs
   * to the pattern string.
   */

  utils.createKey = function(pattern, options) {
    var id = pattern;
    if (typeof options === 'undefined') {
      return id;
    }
    var keys = Object.keys(options);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      id += ';' + key + '=' + String(options[key]);
    }
    return id;
  };

  /**
   * Normalize options
   */

  utils.createOptions = function(options) {
    var opts = utils.extend.apply(null, arguments);
    if (typeof opts.expand === 'boolean') {
      opts.optimize = !opts.expand;
    }
    if (typeof opts.optimize === 'boolean') {
      opts.expand = !opts.optimize;
    }
    if (opts.optimize === true) {
      opts.makeRe = true;
    }
    return opts;
  };

  /**
   * Join patterns in `a` to patterns in `b`
   */

  utils.join = function(a, b, options) {
    options = options || {};
    a = utils.arrayify(a);
    b = utils.arrayify(b);

    if (!a.length) return b;
    if (!b.length) return a;

    var len = a.length;
    var idx = -1;
    var arr = [];

    while (++idx < len) {
      var val = a[idx];
      if (Array.isArray(val)) {
        for (var i = 0; i < val.length; i++) {
          val[i] = utils.join(val[i], b, options);
        }
        arr.push(val);
        continue;
      }

      for (var j = 0; j < b.length; j++) {
        var bval = b[j];

        if (Array.isArray(bval)) {
          arr.push(utils.join(val, bval, options));
        } else {
          arr.push(val + bval);
        }
      }
    }
    return arr;
  };

  /**
   * Split the given string on `,` if not escaped.
   */

  utils.split = function(str, options) {
    var opts = utils.extend({sep: ','}, options);
    if (typeof opts.keepQuotes !== 'boolean') {
      opts.keepQuotes = true;
    }
    if (opts.unescape === false) {
      opts.keepEscaping = true;
    }
    return splitString(str, opts, utils.escapeBrackets(opts));
  };

  /**
   * Expand ranges or sets in the given `pattern`.
   *
   * @param {String} `str`
   * @param {Object} `options`
   * @return {Object}
   */

  utils.expand = function(str, options) {
    var opts = utils.extend({rangeLimit: 10000}, options);
    var segs = utils.split(str, opts);
    var tok = { segs: segs };

    if (utils.isQuotedString(str)) {
      return tok;
    }

    if (opts.rangeLimit === true) {
      opts.rangeLimit = 10000;
    }

    if (segs.length > 1) {
      if (opts.optimize === false) {
        tok.val = segs[0];
        return tok;
      }

      tok.segs = utils.stringifyArray(tok.segs);
    } else if (segs.length === 1) {
      var arr = str.split('..');

      if (arr.length === 1) {
        tok.val = tok.segs[tok.segs.length - 1] || tok.val || str;
        tok.segs = [];
        return tok;
      }

      if (arr.length === 2 && arr[0] === arr[1]) {
        tok.escaped = true;
        tok.val = arr[0];
        tok.segs = [];
        return tok;
      }

      if (arr.length > 1) {
        if (opts.optimize !== false) {
          opts.optimize = true;
          delete opts.expand;
        }

        if (opts.optimize !== true) {
          var min = Math.min(arr[0], arr[1]);
          var max = Math.max(arr[0], arr[1]);
          var step = arr[2] || 1;

          if (opts.rangeLimit !== false && ((max - min) / step >= opts.rangeLimit)) {
            throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
          }
        }

        arr.push(opts);
        tok.segs = utils.fillRange.apply(null, arr);

        if (!tok.segs.length) {
          tok.escaped = true;
          tok.val = str;
          return tok;
        }

        if (opts.optimize === true) {
          tok.segs = utils.stringifyArray(tok.segs);
        }

        if (tok.segs === '') {
          tok.val = str;
        } else {
          tok.val = tok.segs[0];
        }
        return tok;
      }
    } else {
      tok.val = str;
    }
    return tok;
  };

  /**
   * Ensure commas inside brackets and parens are not split.
   * @param {Object} `tok` Token from the `split-string` module
   * @return {undefined}
   */

  utils.escapeBrackets = function(options) {
    return function(tok) {
      if (tok.escaped && tok.val === 'b') {
        tok.val = '\\b';
        return;
      }

      if (tok.val !== '(' && tok.val !== '[') return;
      var opts = utils.extend({}, options);
      var brackets = [];
      var parens = [];
      var stack = [];
      var val = tok.val;
      var str = tok.str;
      var i = tok.idx - 1;

      while (++i < str.length) {
        var ch = str[i];

        if (ch === '\\') {
          val += (opts.keepEscaping === false ? '' : ch) + str[++i];
          continue;
        }

        if (ch === '(') {
          parens.push(ch);
          stack.push(ch);
        }

        if (ch === '[') {
          brackets.push(ch);
          stack.push(ch);
        }

        if (ch === ')') {
          parens.pop();
          stack.pop();
          if (!stack.length) {
            val += ch;
            break;
          }
        }

        if (ch === ']') {
          brackets.pop();
          stack.pop();
          if (!stack.length) {
            val += ch;
            break;
          }
        }
        val += ch;
      }

      tok.split = false;
      tok.val = val.slice(1);
      tok.idx = i;
    };
  };

  /**
   * Returns true if the given string looks like a regex quantifier
   * @return {Boolean}
   */

  utils.isQuantifier = function(str) {
    return /^(?:[0-9]?,[0-9]|[0-9],)$/.test(str);
  };

  /**
   * Cast `val` to an array.
   * @param {*} `val`
   */

  utils.stringifyArray = function(arr) {
    return [utils.arrayify(arr).join('|')];
  };

  /**
   * Cast `val` to an array.
   * @param {*} `val`
   */

  utils.arrayify = function(arr) {
    if (typeof arr === 'undefined') {
      return [];
    }
    if (typeof arr === 'string') {
      return [arr];
    }
    return arr;
  };

  /**
   * Returns true if the given `str` is a non-empty string
   * @return {Boolean}
   */

  utils.isString = function(str) {
    return str != null && typeof str === 'string';
  };

  /**
   * Get the last element from `array`
   * @param {Array} `array`
   * @return {*}
   */

  utils.last = function(arr, n) {
    return arr[arr.length - (n || 1)];
  };

  utils.escapeRegex = function(str) {
    return str.replace(/\\?([!^*?()[\]{}+?/])/g, '\\$1');
  };


  /***/ }),
  /* 306 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * split-string <https://github.com/jonschlinkert/split-string>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */



  var extend = __webpack_require__(296);

  module.exports = function(str, options, fn) {
    if (typeof str !== 'string') {
      throw new TypeError('expected a string');
    }

    if (typeof options === 'function') {
      fn = options;
      options = null;
    }

    // allow separator to be defined as a string
    if (typeof options === 'string') {
      options = { sep: options };
    }

    var opts = extend({sep: '.'}, options);
    var quotes = opts.quotes || ['"', "'", '`'];
    var brackets;

    if (opts.brackets === true) {
      brackets = {
        '<': '>',
        '(': ')',
        '[': ']',
        '{': '}'
      };
    } else if (opts.brackets) {
      brackets = opts.brackets;
    }

    var tokens = [];
    var stack = [];
    var arr = [''];
    var sep = opts.sep;
    var len = str.length;
    var idx = -1;
    var closeIdx;

    function expected() {
      if (brackets && stack.length) {
        return brackets[stack[stack.length - 1]];
      }
    }

    while (++idx < len) {
      var ch = str[idx];
      var next = str[idx + 1];
      var tok = { val: ch, idx: idx, arr: arr, str: str };
      tokens.push(tok);

      if (ch === '\\') {
        tok.val = keepEscaping(opts, str, idx) === true ? (ch + next) : next;
        tok.escaped = true;
        if (typeof fn === 'function') {
          fn(tok);
        }
        arr[arr.length - 1] += tok.val;
        idx++;
        continue;
      }

      if (brackets && brackets[ch]) {
        stack.push(ch);
        var e = expected();
        var i = idx + 1;

        if (str.indexOf(e, i + 1) !== -1) {
          while (stack.length && i < len) {
            var s = str[++i];
            if (s === '\\') {
              s++;
              continue;
            }

            if (quotes.indexOf(s) !== -1) {
              i = getClosingQuote(str, s, i + 1);
              continue;
            }

            e = expected();
            if (stack.length && str.indexOf(e, i + 1) === -1) {
              break;
            }

            if (brackets[s]) {
              stack.push(s);
              continue;
            }

            if (e === s) {
              stack.pop();
            }
          }
        }

        closeIdx = i;
        if (closeIdx === -1) {
          arr[arr.length - 1] += ch;
          continue;
        }

        ch = str.slice(idx, closeIdx + 1);
        tok.val = ch;
        tok.idx = idx = closeIdx;
      }

      if (quotes.indexOf(ch) !== -1) {
        closeIdx = getClosingQuote(str, ch, idx + 1);
        if (closeIdx === -1) {
          arr[arr.length - 1] += ch;
          continue;
        }

        if (keepQuotes(ch, opts) === true) {
          ch = str.slice(idx, closeIdx + 1);
        } else {
          ch = str.slice(idx + 1, closeIdx);
        }

        tok.val = ch;
        tok.idx = idx = closeIdx;
      }

      if (typeof fn === 'function') {
        fn(tok, tokens);
        ch = tok.val;
        idx = tok.idx;
      }

      if (tok.val === sep && tok.split !== false) {
        arr.push('');
        continue;
      }

      arr[arr.length - 1] += tok.val;
    }

    return arr;
  };

  function getClosingQuote(str, ch, i, brackets) {
    var idx = str.indexOf(ch, i);
    if (str.charAt(idx - 1) === '\\') {
      return getClosingQuote(str, ch, idx + 1);
    }
    return idx;
  }

  function keepQuotes(ch, opts) {
    if (opts.keepDoubleQuotes === true && ch === '"') return true;
    if (opts.keepSingleQuotes === true && ch === "'") return true;
    return opts.keepQuotes;
  }

  function keepEscaping(opts, str, idx) {
    if (typeof opts.keepEscaping === 'function') {
      return opts.keepEscaping(str, idx);
    }
    return opts.keepEscaping === true || str[idx + 1] === '\\';
  }


  /***/ }),
  /* 307 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * arr-flatten <https://github.com/jonschlinkert/arr-flatten>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */



  module.exports = function (arr) {
    return flat(arr, []);
  };

  function flat(arr, res) {
    var i = 0, cur;
    var len = arr.length;
    for (; i < len; i++) {
      cur = arr[i];
      Array.isArray(cur) ? flat(cur, res) : res.push(cur);
    }
    return res;
  }


  /***/ }),
  /* 308 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   */



  var util = __webpack_require__(25);
  var isNumber = __webpack_require__(309);
  var extend = __webpack_require__(302);
  var repeat = __webpack_require__(312);
  var toRegex = __webpack_require__(313);

  /**
   * Return a range of numbers or letters.
   *
   * @param  {String} `start` Start of the range
   * @param  {String} `stop` End of the range
   * @param  {String} `step` Increment or decrement to use.
   * @param  {Function} `fn` Custom function to modify each element in the range.
   * @return {Array}
   */

  function fillRange(start, stop, step, options) {
    if (typeof start === 'undefined') {
      return [];
    }

    if (typeof stop === 'undefined' || start === stop) {
      // special case, for handling negative zero
      var isString = typeof start === 'string';
      if (isNumber(start) && !toNumber(start)) {
        return [isString ? '0' : 0];
      }
      return [start];
    }

    if (typeof step !== 'number' && typeof step !== 'string') {
      options = step;
      step = undefined;
    }

    if (typeof options === 'function') {
      options = { transform: options };
    }

    var opts = extend({step: step}, options);
    if (opts.step && !isValidNumber(opts.step)) {
      if (opts.strictRanges === true) {
        throw new TypeError('expected options.step to be a number');
      }
      return [];
    }

    opts.isNumber = isValidNumber(start) && isValidNumber(stop);
    if (!opts.isNumber && !isValid(start, stop)) {
      if (opts.strictRanges === true) {
        throw new RangeError('invalid range arguments: ' + util.inspect([start, stop]));
      }
      return [];
    }

    opts.isPadded = isPadded(start) || isPadded(stop);
    opts.toString = opts.stringify
      || typeof opts.step === 'string'
      || typeof start === 'string'
      || typeof stop === 'string'
      || !opts.isNumber;

    if (opts.isPadded) {
      opts.maxLength = Math.max(String(start).length, String(stop).length);
    }

    // support legacy minimatch/fill-range options
    if (typeof opts.optimize === 'boolean') opts.toRegex = opts.optimize;
    if (typeof opts.makeRe === 'boolean') opts.toRegex = opts.makeRe;
    return expand(start, stop, opts);
  }

  function expand(start, stop, options) {
    var a = options.isNumber ? toNumber(start) : start.charCodeAt(0);
    var b = options.isNumber ? toNumber(stop) : stop.charCodeAt(0);

    var step = Math.abs(toNumber(options.step)) || 1;
    if (options.toRegex && step === 1) {
      return toRange(a, b, start, stop, options);
    }

    var zero = {greater: [], lesser: []};
    var asc = a < b;
    var arr = new Array(Math.round((asc ? b - a : a - b) / step));
    var idx = 0;

    while (asc ? a <= b : a >= b) {
      var val = options.isNumber ? a : String.fromCharCode(a);
      if (options.toRegex && (val >= 0 || !options.isNumber)) {
        zero.greater.push(val);
      } else {
        zero.lesser.push(Math.abs(val));
      }

      if (options.isPadded) {
        val = zeros(val, options);
      }

      if (options.toString) {
        val = String(val);
      }

      if (typeof options.transform === 'function') {
        arr[idx++] = options.transform(val, a, b, step, idx, arr, options);
      } else {
        arr[idx++] = val;
      }

      if (asc) {
        a += step;
      } else {
        a -= step;
      }
    }

    if (options.toRegex === true) {
      return toSequence(arr, zero, options);
    }
    return arr;
  }

  function toRange(a, b, start, stop, options) {
    if (options.isPadded) {
      return toRegex(start, stop, options);
    }

    if (options.isNumber) {
      return toRegex(Math.min(a, b), Math.max(a, b), options);
    }

    var start = String.fromCharCode(Math.min(a, b));
    var stop = String.fromCharCode(Math.max(a, b));
    return '[' + start + '-' + stop + ']';
  }

  function toSequence(arr, zeros, options) {
    var greater = '', lesser = '';
    if (zeros.greater.length) {
      greater = zeros.greater.join('|');
    }
    if (zeros.lesser.length) {
      lesser = '-(' + zeros.lesser.join('|') + ')';
    }
    var res = greater && lesser
      ? greater + '|' + lesser
      : greater || lesser;

    if (options.capture) {
      return '(' + res + ')';
    }
    return res;
  }

  function zeros(val, options) {
    if (options.isPadded) {
      var str = String(val);
      var len = str.length;
      var dash = '';
      if (str.charAt(0) === '-') {
        dash = '-';
        str = str.slice(1);
      }
      var diff = options.maxLength - len;
      var pad = repeat('0', diff);
      val = (dash + pad + str);
    }
    if (options.stringify) {
      return String(val);
    }
    return val;
  }

  function toNumber(val) {
    return Number(val) || 0;
  }

  function isPadded(str) {
    return /^-?0\d/.test(str);
  }

  function isValid(min, max) {
    return (isValidNumber(min) || isValidLetter(min))
        && (isValidNumber(max) || isValidLetter(max));
  }

  function isValidLetter(ch) {
    return typeof ch === 'string' && ch.length === 1 && /^\w+$/.test(ch);
  }

  function isValidNumber(n) {
    return isNumber(n) && !/\./.test(n);
  }

  /**
   * Expose `fillRange`
   * @type {Function}
   */

  module.exports = fillRange;


  /***/ }),
  /* 309 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */



  var typeOf = __webpack_require__(310);

  module.exports = function isNumber(num) {
    var type = typeOf(num);

    if (type === 'string') {
      if (!num.trim()) return false;
    } else if (type !== 'number') {
      return false;
    }

    return (num - num + 1) >= 0;
  };


  /***/ }),
  /* 310 */
  /***/ (function(module, exports, __webpack_require__) {

  var isBuffer = __webpack_require__(311);
  var toString = Object.prototype.toString;

  /**
   * Get the native `typeof` a value.
   *
   * @param  {*} `val`
   * @return {*} Native javascript type
   */

  module.exports = function kindOf(val) {
    // primitivies
    if (typeof val === 'undefined') {
      return 'undefined';
    }
    if (val === null) {
      return 'null';
    }
    if (val === true || val === false || val instanceof Boolean) {
      return 'boolean';
    }
    if (typeof val === 'string' || val instanceof String) {
      return 'string';
    }
    if (typeof val === 'number' || val instanceof Number) {
      return 'number';
    }

    // functions
    if (typeof val === 'function' || val instanceof Function) {
      return 'function';
    }

    // array
    if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
      return 'array';
    }

    // check for instances of RegExp and Date before calling `toString`
    if (val instanceof RegExp) {
      return 'regexp';
    }
    if (val instanceof Date) {
      return 'date';
    }

    // other objects
    var type = toString.call(val);

    if (type === '[object RegExp]') {
      return 'regexp';
    }
    if (type === '[object Date]') {
      return 'date';
    }
    if (type === '[object Arguments]') {
      return 'arguments';
    }
    if (type === '[object Error]') {
      return 'error';
    }

    // buffer
    if (isBuffer(val)) {
      return 'buffer';
    }

    // es6: Map, WeakMap, Set, WeakSet
    if (type === '[object Set]') {
      return 'set';
    }
    if (type === '[object WeakSet]') {
      return 'weakset';
    }
    if (type === '[object Map]') {
      return 'map';
    }
    if (type === '[object WeakMap]') {
      return 'weakmap';
    }
    if (type === '[object Symbol]') {
      return 'symbol';
    }

    // typed arrays
    if (type === '[object Int8Array]') {
      return 'int8array';
    }
    if (type === '[object Uint8Array]') {
      return 'uint8array';
    }
    if (type === '[object Uint8ClampedArray]') {
      return 'uint8clampedarray';
    }
    if (type === '[object Int16Array]') {
      return 'int16array';
    }
    if (type === '[object Uint16Array]') {
      return 'uint16array';
    }
    if (type === '[object Int32Array]') {
      return 'int32array';
    }
    if (type === '[object Uint32Array]') {
      return 'uint32array';
    }
    if (type === '[object Float32Array]') {
      return 'float32array';
    }
    if (type === '[object Float64Array]') {
      return 'float64array';
    }

    // must be a plain object
    return 'object';
  };


  /***/ }),
  /* 311 */
  /***/ (function(module, exports) {

  /*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */

  // The _isBuffer check is for Safari 5-7 support, because it's missing
  // Object.prototype.constructor. Remove this eventually
  module.exports = function (obj) {
    return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
  }

  function isBuffer (obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
  }

  // For Node v0.10 support. Remove this eventually.
  function isSlowBuffer (obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
  }


  /***/ }),
  /* 312 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * repeat-string <https://github.com/jonschlinkert/repeat-string>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */



  /**
   * Results cache
   */

  var res = '';
  var cache;

  /**
   * Expose `repeat`
   */

  module.exports = repeat;

  /**
   * Repeat the given `string` the specified `number`
   * of times.
   *
   * **Example:**
   *
   * ```js
   * var repeat = require('repeat-string');
   * repeat('A', 5);
   * //=> AAAAA
   * ```
   *
   * @param {String} `string` The string to repeat
   * @param {Number} `number` The number of times to repeat the string
   * @return {String} Repeated string
   * @api public
   */

  function repeat(str, num) {
    if (typeof str !== 'string') {
      throw new TypeError('expected a string');
    }

    // cover common, quick use cases
    if (num === 1) return str;
    if (num === 2) return str + str;

    var max = str.length * num;
    if (cache !== str || typeof cache === 'undefined') {
      cache = str;
      res = '';
    } else if (res.length >= max) {
      return res.substr(0, max);
    }

    while (max > res.length && num > 1) {
      if (num & 1) {
        res += str;
      }

      num >>= 1;
      str += str;
    }

    res += str;
    res = res.substr(0, max);
    return res;
  }


  /***/ }),
  /* 313 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * to-regex-range <https://github.com/jonschlinkert/to-regex-range>
   *
   * Copyright (c) 2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   */



  var repeat = __webpack_require__(312);
  var isNumber = __webpack_require__(309);
  var cache = {};

  function toRegexRange(min, max, options) {
    if (isNumber(min) === false) {
      throw new RangeError('toRegexRange: first argument is invalid.');
    }

    if (typeof max === 'undefined' || min === max) {
      return String(min);
    }

    if (isNumber(max) === false) {
      throw new RangeError('toRegexRange: second argument is invalid.');
    }

    options = options || {};
    var relax = String(options.relaxZeros);
    var shorthand = String(options.shorthand);
    var capture = String(options.capture);
    var key = min + ':' + max + '=' + relax + shorthand + capture;
    if (cache.hasOwnProperty(key)) {
      return cache[key].result;
    }

    var a = Math.min(min, max);
    var b = Math.max(min, max);

    if (Math.abs(a - b) === 1) {
      var result = min + '|' + max;
      if (options.capture) {
        return '(' + result + ')';
      }
      return result;
    }

    var isPadded = padding(min) || padding(max);
    var positives = [];
    var negatives = [];

    var tok = {min: min, max: max, a: a, b: b};
    if (isPadded) {
      tok.isPadded = isPadded;
      tok.maxLen = String(tok.max).length;
    }

    if (a < 0) {
      var newMin = b < 0 ? Math.abs(b) : 1;
      var newMax = Math.abs(a);
      negatives = splitToPatterns(newMin, newMax, tok, options);
      a = tok.a = 0;
    }

    if (b >= 0) {
      positives = splitToPatterns(a, b, tok, options);
    }

    tok.negatives = negatives;
    tok.positives = positives;
    tok.result = siftPatterns(negatives, positives, options);

    if (options.capture && (positives.length + negatives.length) > 1) {
      tok.result = '(' + tok.result + ')';
    }

    cache[key] = tok;
    return tok.result;
  }

  function siftPatterns(neg, pos, options) {
    var onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];
    var onlyPositive = filterPatterns(pos, neg, '', false, options) || [];
    var intersected = filterPatterns(neg, pos, '-?', true, options) || [];
    var subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
    return subpatterns.join('|');
  }

  function splitToRanges(min, max) {
    min = Number(min);
    max = Number(max);

    var nines = 1;
    var stops = [max];
    var stop = +countNines(min, nines);

    while (min <= stop && stop <= max) {
      stops = push(stops, stop);
      nines += 1;
      stop = +countNines(min, nines);
    }

    var zeros = 1;
    stop = countZeros(max + 1, zeros) - 1;

    while (min < stop && stop <= max) {
      stops = push(stops, stop);
      zeros += 1;
      stop = countZeros(max + 1, zeros) - 1;
    }

    stops.sort(compare);
    return stops;
  }

  /**
   * Convert a range to a regex pattern
   * @param {Number} `start`
   * @param {Number} `stop`
   * @return {String}
   */

  function rangeToPattern(start, stop, options) {
    if (start === stop) {
      return {pattern: String(start), digits: []};
    }

    var zipped = zip(String(start), String(stop));
    var len = zipped.length, i = -1;

    var pattern = '';
    var digits = 0;

    while (++i < len) {
      var numbers = zipped[i];
      var startDigit = numbers[0];
      var stopDigit = numbers[1];

      if (startDigit === stopDigit) {
        pattern += startDigit;

      } else if (startDigit !== '0' || stopDigit !== '9') {
        pattern += toCharacterClass(startDigit, stopDigit);

      } else {
        digits += 1;
      }
    }

    if (digits) {
      pattern += options.shorthand ? '\\d' : '[0-9]';
    }

    return { pattern: pattern, digits: [digits] };
  }

  function splitToPatterns(min, max, tok, options) {
    var ranges = splitToRanges(min, max);
    var len = ranges.length;
    var idx = -1;

    var tokens = [];
    var start = min;
    var prev;

    while (++idx < len) {
      var range = ranges[idx];
      var obj = rangeToPattern(start, range, options);
      var zeros = '';

      if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
        if (prev.digits.length > 1) {
          prev.digits.pop();
        }
        prev.digits.push(obj.digits[0]);
        prev.string = prev.pattern + toQuantifier(prev.digits);
        start = range + 1;
        continue;
      }

      if (tok.isPadded) {
        zeros = padZeros(range, tok);
      }

      obj.string = zeros + obj.pattern + toQuantifier(obj.digits);
      tokens.push(obj);
      start = range + 1;
      prev = obj;
    }

    return tokens;
  }

  function filterPatterns(arr, comparison, prefix, intersection, options) {
    var res = [];

    for (var i = 0; i < arr.length; i++) {
      var tok = arr[i];
      var ele = tok.string;

      if (options.relaxZeros !== false) {
        if (prefix === '-' && ele.charAt(0) === '0') {
          if (ele.charAt(1) === '{') {
            ele = '0*' + ele.replace(/^0\{\d+\}/, '');
          } else {
            ele = '0*' + ele.slice(1);
          }
        }
      }

      if (!intersection && !contains(comparison, 'string', ele)) {
        res.push(prefix + ele);
      }

      if (intersection && contains(comparison, 'string', ele)) {
        res.push(prefix + ele);
      }
    }
    return res;
  }

  /**
   * Zip strings (`for in` can be used on string characters)
   */

  function zip(a, b) {
    var arr = [];
    for (var ch in a) arr.push([a[ch], b[ch]]);
    return arr;
  }

  function compare(a, b) {
    return a > b ? 1 : b > a ? -1 : 0;
  }

  function push(arr, ele) {
    if (arr.indexOf(ele) === -1) arr.push(ele);
    return arr;
  }

  function contains(arr, key, val) {
    for (var i = 0; i < arr.length; i++) {
      if (arr[i][key] === val) {
        return true;
      }
    }
    return false;
  }

  function countNines(min, len) {
    return String(min).slice(0, -len) + repeat('9', len);
  }

  function countZeros(integer, zeros) {
    return integer - (integer % Math.pow(10, zeros));
  }

  function toQuantifier(digits) {
    var start = digits[0];
    var stop = digits[1] ? (',' + digits[1]) : '';
    if (!stop && (!start || start === 1)) {
      return '';
    }
    return '{' + start + stop + '}';
  }

  function toCharacterClass(a, b) {
    return '[' + a + ((b - a === 1) ? '' : '-') + b + ']';
  }

  function padding(str) {
    return /^-?(0+)\d/.exec(str);
  }

  function padZeros(val, tok) {
    if (tok.isPadded) {
      var diff = Math.abs(tok.maxLen - String(val).length);
      switch (diff) {
        case 0:
          return '';
        case 1:
          return '0';
        default: {
          return '0{' + diff + '}';
        }
      }
    }
    return val;
  }

  /**
   * Expose `toRegexRange`
   */

  module.exports = toRegexRange;


  /***/ }),
  /* 314 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * repeat-element <https://github.com/jonschlinkert/repeat-element>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Licensed under the MIT license.
   */



  module.exports = function repeat(ele, num) {
    var arr = new Array(num);

    for (var i = 0; i < num; i++) {
      arr[i] = ele;
    }

    return arr;
  };


  /***/ }),
  /* 315 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var Node = __webpack_require__(316);
  var utils = __webpack_require__(305);

  /**
   * Braces parsers
   */

  module.exports = function(braces, options) {
    braces.parser
      .set('bos', function() {
        if (!this.parsed) {
          this.ast = this.nodes[0] = new Node(this.ast);
        }
      })

      /**
       * Character parsers
       */

      .set('escape', function() {
        var pos = this.position();
        var m = this.match(/^(?:\\(.)|\$\{)/);
        if (!m) return;

        var prev = this.prev();
        var last = utils.last(prev.nodes);

        var node = pos(new Node({
          type: 'text',
          multiplier: 1,
          val: m[0]
        }));

        if (node.val === '\\\\') {
          return node;
        }

        if (node.val === '${') {
          var str = this.input;
          var idx = -1;
          var ch;

          while ((ch = str[++idx])) {
            this.consume(1);
            node.val += ch;
            if (ch === '\\') {
              node.val += str[++idx];
              continue;
            }
            if (ch === '}') {
              break;
            }
          }
        }

        if (this.options.unescape !== false) {
          node.val = node.val.replace(/\\([{}])/g, '$1');
        }

        if (last.val === '"' && this.input.charAt(0) === '"') {
          last.val = node.val;
          this.consume(1);
          return;
        }

        return concatNodes.call(this, pos, node, prev, options);
      })

      /**
       * Brackets: "[...]" (basic, this is overridden by
       * other parsers in more advanced implementations)
       */

      .set('bracket', function() {
        var isInside = this.isInside('brace');
        var pos = this.position();
        var m = this.match(/^(?:\[([!^]?)([^\]]{2,}|\]-)(\]|[^*+?]+)|\[)/);
        if (!m) return;

        var prev = this.prev();
        var val = m[0];
        var negated = m[1] ? '^' : '';
        var inner = m[2] || '';
        var close = m[3] || '';

        if (isInside && prev.type === 'brace') {
          prev.text = prev.text || '';
          prev.text += val;
        }

        var esc = this.input.slice(0, 2);
        if (inner === '' && esc === '\\]') {
          inner += esc;
          this.consume(2);

          var str = this.input;
          var idx = -1;
          var ch;

          while ((ch = str[++idx])) {
            this.consume(1);
            if (ch === ']') {
              close = ch;
              break;
            }
            inner += ch;
          }
        }

        return pos(new Node({
          type: 'bracket',
          val: val,
          escaped: close !== ']',
          negated: negated,
          inner: inner,
          close: close
        }));
      })

      /**
       * Empty braces (we capture these early to
       * speed up processing in the compiler)
       */

      .set('multiplier', function() {
        var isInside = this.isInside('brace');
        var pos = this.position();
        var m = this.match(/^\{((?:,|\{,+\})+)\}/);
        if (!m) return;

        this.multiplier = true;
        var prev = this.prev();
        var val = m[0];

        if (isInside && prev.type === 'brace') {
          prev.text = prev.text || '';
          prev.text += val;
        }

        var node = pos(new Node({
          type: 'text',
          multiplier: 1,
          match: m,
          val: val
        }));

        return concatNodes.call(this, pos, node, prev, options);
      })

      /**
       * Open
       */

      .set('brace.open', function() {
        var pos = this.position();
        var m = this.match(/^\{(?!(?:[^\\}]?|,+)\})/);
        if (!m) return;

        var prev = this.prev();
        var last = utils.last(prev.nodes);

        // if the last parsed character was an extglob character
        // we need to _not optimize_ the brace pattern because
        // it might be mistaken for an extglob by a downstream parser
        if (last && last.val && isExtglobChar(last.val.slice(-1))) {
          last.optimize = false;
        }

        var open = pos(new Node({
          type: 'brace.open',
          val: m[0]
        }));

        var node = pos(new Node({
          type: 'brace',
          nodes: []
        }));

        node.push(open);
        prev.push(node);
        this.push('brace', node);
      })

      /**
       * Close
       */

      .set('brace.close', function() {
        var pos = this.position();
        var m = this.match(/^\}/);
        if (!m || !m[0]) return;

        var brace = this.pop('brace');
        var node = pos(new Node({
          type: 'brace.close',
          val: m[0]
        }));

        if (!this.isType(brace, 'brace')) {
          if (this.options.strict) {
            throw new Error('missing opening "{"');
          }
          node.type = 'text';
          node.multiplier = 0;
          node.escaped = true;
          return node;
        }

        var prev = this.prev();
        var last = utils.last(prev.nodes);
        if (last.text) {
          var lastNode = utils.last(last.nodes);
          if (lastNode.val === ')' && /[!@*?+]\(/.test(last.text)) {
            var open = last.nodes[0];
            var text = last.nodes[1];
            if (open.type === 'brace.open' && text && text.type === 'text') {
              text.optimize = false;
            }
          }
        }

        if (brace.nodes.length > 2) {
          var first = brace.nodes[1];
          if (first.type === 'text' && first.val === ',') {
            brace.nodes.splice(1, 1);
            brace.nodes.push(first);
          }
        }

        brace.push(node);
      })

      /**
       * Capture boundary characters
       */

      .set('boundary', function() {
        var pos = this.position();
        var m = this.match(/^[$^](?!\{)/);
        if (!m) return;
        return pos(new Node({
          type: 'text',
          val: m[0]
        }));
      })

      /**
       * One or zero, non-comma characters wrapped in braces
       */

      .set('nobrace', function() {
        var isInside = this.isInside('brace');
        var pos = this.position();
        var m = this.match(/^\{[^,]?\}/);
        if (!m) return;

        var prev = this.prev();
        var val = m[0];

        if (isInside && prev.type === 'brace') {
          prev.text = prev.text || '';
          prev.text += val;
        }

        return pos(new Node({
          type: 'text',
          multiplier: 0,
          val: val
        }));
      })

      /**
       * Text
       */

      .set('text', function() {
        var isInside = this.isInside('brace');
        var pos = this.position();
        var m = this.match(/^((?!\\)[^${}[\]])+/);
        if (!m) return;

        var prev = this.prev();
        var val = m[0];

        if (isInside && prev.type === 'brace') {
          prev.text = prev.text || '';
          prev.text += val;
        }

        var node = pos(new Node({
          type: 'text',
          multiplier: 1,
          val: val
        }));

        return concatNodes.call(this, pos, node, prev, options);
      });
  };

  /**
   * Returns true if the character is an extglob character.
   */

  function isExtglobChar(ch) {
    return ch === '!' || ch === '@' || ch === '*' || ch === '?' || ch === '+';
  }

  /**
   * Combine text nodes, and calculate empty sets (`{,,}`)
   * @param {Function} `pos` Function to calculate node position
   * @param {Object} `node` AST node
   * @return {Object}
   */

  function concatNodes(pos, node, parent, options) {
    node.orig = node.val;
    var prev = this.prev();
    var last = utils.last(prev.nodes);
    var isEscaped = false;

    if (node.val.length > 1) {
      var a = node.val.charAt(0);
      var b = node.val.slice(-1);

      isEscaped = (a === '"' && b === '"')
        || (a === "'" && b === "'")
        || (a === '`' && b === '`');
    }

    if (isEscaped && options.unescape !== false) {
      node.val = node.val.slice(1, node.val.length - 1);
      node.escaped = true;
    }

    if (node.match) {
      var match = node.match[1];
      if (!match || match.indexOf('}') === -1) {
        match = node.match[0];
      }

      // replace each set with a single ","
      var val = match.replace(/\{/g, ',').replace(/\}/g, '');
      node.multiplier *= val.length;
      node.val = '';
    }

    var simpleText = last.type === 'text'
      && last.multiplier === 1
      && node.multiplier === 1
      && node.val;

    if (simpleText) {
      last.val += node.val;
      return;
    }

    prev.push(node);
  }


  /***/ }),
  /* 316 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var isObject = __webpack_require__(291);
  var define = __webpack_require__(317);
  var utils = __webpack_require__(318);
  var ownNames;

  /**
   * Create a new AST `Node` with the given `val` and `type`.
   *
   * ```js
   * var node = new Node('*', 'Star');
   * var node = new Node({type: 'star', val: '*'});
   * ```
   * @name Node
   * @param {String|Object} `val` Pass a matched substring, or an object to merge onto the node.
   * @param {String} `type` The node type to use when `val` is a string.
   * @return {Object} node instance
   * @api public
   */

  function Node(val, type, parent) {
    if (typeof type !== 'string') {
      parent = type;
      type = null;
    }

    define(this, 'parent', parent);
    define(this, 'isNode', true);
    define(this, 'expect', null);

    if (typeof type !== 'string' && isObject(val)) {
      lazyKeys();
      var keys = Object.keys(val);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (ownNames.indexOf(key) === -1) {
          this[key] = val[key];
        }
      }
    } else {
      this.type = type;
      this.val = val;
    }
  }

  /**
   * Returns true if the given value is a node.
   *
   * ```js
   * var Node = require('snapdragon-node');
   * var node = new Node({type: 'foo'});
   * console.log(Node.isNode(node)); //=> true
   * console.log(Node.isNode({})); //=> false
   * ```
   * @param {Object} `node`
   * @returns {Boolean}
   * @api public
   */

  Node.isNode = function(node) {
    return utils.isNode(node);
  };

  /**
   * Define a non-enumberable property on the node instance.
   * Useful for adding properties that shouldn't be extended
   * or visible during debugging.
   *
   * ```js
   * var node = new Node();
   * node.define('foo', 'something non-enumerable');
   * ```
   * @param {String} `name`
   * @param {any} `val`
   * @return {Object} returns the node instance
   * @api public
   */

  Node.prototype.define = function(name, val) {
    define(this, name, val);
    return this;
  };

  /**
   * Returns true if `node.val` is an empty string, or `node.nodes` does
   * not contain any non-empty text nodes.
   *
   * ```js
   * var node = new Node({type: 'text'});
   * node.isEmpty(); //=> true
   * node.val = 'foo';
   * node.isEmpty(); //=> false
   * ```
   * @param {Function} `fn` (optional) Filter function that is called on `node` and/or child nodes. `isEmpty` will return false immediately when the filter function returns false on any nodes.
   * @return {Boolean}
   * @api public
   */

  Node.prototype.isEmpty = function(fn) {
    return utils.isEmpty(this, fn);
  };

  /**
   * Given node `foo` and node `bar`, push node `bar` onto `foo.nodes`, and
   * set `foo` as `bar.parent`.
   *
   * ```js
   * var foo = new Node({type: 'foo'});
   * var bar = new Node({type: 'bar'});
   * foo.push(bar);
   * ```
   * @param {Object} `node`
   * @return {Number} Returns the length of `node.nodes`
   * @api public
   */

  Node.prototype.push = function(node) {
    assert(Node.isNode(node), 'expected node to be an instance of Node');
    define(node, 'parent', this);

    this.nodes = this.nodes || [];
    return this.nodes.push(node);
  };

  /**
   * Given node `foo` and node `bar`, unshift node `bar` onto `foo.nodes`, and
   * set `foo` as `bar.parent`.
   *
   * ```js
   * var foo = new Node({type: 'foo'});
   * var bar = new Node({type: 'bar'});
   * foo.unshift(bar);
   * ```
   * @param {Object} `node`
   * @return {Number} Returns the length of `node.nodes`
   * @api public
   */

  Node.prototype.unshift = function(node) {
    assert(Node.isNode(node), 'expected node to be an instance of Node');
    define(node, 'parent', this);

    this.nodes = this.nodes || [];
    return this.nodes.unshift(node);
  };

  /**
   * Pop a node from `node.nodes`.
   *
   * ```js
   * var node = new Node({type: 'foo'});
   * node.push(new Node({type: 'a'}));
   * node.push(new Node({type: 'b'}));
   * node.push(new Node({type: 'c'}));
   * node.push(new Node({type: 'd'}));
   * console.log(node.nodes.length);
   * //=> 4
   * node.pop();
   * console.log(node.nodes.length);
   * //=> 3
   * ```
   * @return {Number} Returns the popped `node`
   * @api public
   */

  Node.prototype.pop = function() {
    return this.nodes && this.nodes.pop();
  };

  /**
   * Shift a node from `node.nodes`.
   *
   * ```js
   * var node = new Node({type: 'foo'});
   * node.push(new Node({type: 'a'}));
   * node.push(new Node({type: 'b'}));
   * node.push(new Node({type: 'c'}));
   * node.push(new Node({type: 'd'}));
   * console.log(node.nodes.length);
   * //=> 4
   * node.shift();
   * console.log(node.nodes.length);
   * //=> 3
   * ```
   * @return {Object} Returns the shifted `node`
   * @api public
   */

  Node.prototype.shift = function() {
    return this.nodes && this.nodes.shift();
  };

  /**
   * Remove `node` from `node.nodes`.
   *
   * ```js
   * node.remove(childNode);
   * ```
   * @param {Object} `node`
   * @return {Object} Returns the removed node.
   * @api public
   */

  Node.prototype.remove = function(node) {
    assert(Node.isNode(node), 'expected node to be an instance of Node');
    this.nodes = this.nodes || [];
    var idx = node.index;
    if (idx !== -1) {
      node.index = -1;
      return this.nodes.splice(idx, 1);
    }
    return null;
  };

  /**
   * Get the first child node from `node.nodes` that matches the given `type`.
   * If `type` is a number, the child node at that index is returned.
   *
   * ```js
   * var child = node.find(1); //<= index of the node to get
   * var child = node.find('foo'); //<= node.type of a child node
   * var child = node.find(/^(foo|bar)$/); //<= regex to match node.type
   * var child = node.find(['foo', 'bar']); //<= array of node.type(s)
   * ```
   * @param {String} `type`
   * @return {Object} Returns a child node or undefined.
   * @api public
   */

  Node.prototype.find = function(type) {
    return utils.findNode(this.nodes, type);
  };

  /**
   * Return true if the node is the given `type`.
   *
   * ```js
   * var node = new Node({type: 'bar'});
   * cosole.log(node.isType('foo'));          // false
   * cosole.log(node.isType(/^(foo|bar)$/));  // true
   * cosole.log(node.isType(['foo', 'bar'])); // true
   * ```
   * @param {String} `type`
   * @return {Boolean}
   * @api public
   */

  Node.prototype.isType = function(type) {
    return utils.isType(this, type);
  };

  /**
   * Return true if the `node.nodes` has the given `type`.
   *
   * ```js
   * var foo = new Node({type: 'foo'});
   * var bar = new Node({type: 'bar'});
   * foo.push(bar);
   *
   * cosole.log(foo.hasType('qux'));          // false
   * cosole.log(foo.hasType(/^(qux|bar)$/));  // true
   * cosole.log(foo.hasType(['qux', 'bar'])); // true
   * ```
   * @param {String} `type`
   * @return {Boolean}
   * @api public
   */

  Node.prototype.hasType = function(type) {
    return utils.hasType(this, type);
  };

  /**
   * Get the siblings array, or `null` if it doesn't exist.
   *
   * ```js
   * var foo = new Node({type: 'foo'});
   * var bar = new Node({type: 'bar'});
   * var baz = new Node({type: 'baz'});
   * foo.push(bar);
   * foo.push(baz);
   *
   * console.log(bar.siblings.length) // 2
   * console.log(baz.siblings.length) // 2
   * ```
   * @return {Array}
   * @api public
   */

  Object.defineProperty(Node.prototype, 'siblings', {
    set: function() {
      throw new Error('node.siblings is a getter and cannot be defined');
    },
    get: function() {
      return this.parent ? this.parent.nodes : null;
    }
  });

  /**
   * Get the node's current index from `node.parent.nodes`.
   * This should always be correct, even when the parent adds nodes.
   *
   * ```js
   * var foo = new Node({type: 'foo'});
   * var bar = new Node({type: 'bar'});
   * var baz = new Node({type: 'baz'});
   * var qux = new Node({type: 'qux'});
   * foo.push(bar);
   * foo.push(baz);
   * foo.unshift(qux);
   *
   * console.log(bar.index) // 1
   * console.log(baz.index) // 2
   * console.log(qux.index) // 0
   * ```
   * @return {Number}
   * @api public
   */

  Object.defineProperty(Node.prototype, 'index', {
    set: function(index) {
      define(this, 'idx', index);
    },
    get: function() {
      if (!Array.isArray(this.siblings)) {
        return -1;
      }
      var tok = this.idx !== -1 ? this.siblings[this.idx] : null;
      if (tok !== this) {
        this.idx = this.siblings.indexOf(this);
      }
      return this.idx;
    }
  });

  /**
   * Get the previous node from the siblings array or `null`.
   *
   * ```js
   * var foo = new Node({type: 'foo'});
   * var bar = new Node({type: 'bar'});
   * var baz = new Node({type: 'baz'});
   * foo.push(bar);
   * foo.push(baz);
   *
   * console.log(baz.prev.type) // 'bar'
   * ```
   * @return {Object}
   * @api public
   */

  Object.defineProperty(Node.prototype, 'prev', {
    set: function() {
      throw new Error('node.prev is a getter and cannot be defined');
    },
    get: function() {
      if (Array.isArray(this.siblings)) {
        return this.siblings[this.index - 1] || this.parent.prev;
      }
      return null;
    }
  });

  /**
   * Get the siblings array, or `null` if it doesn't exist.
   *
   * ```js
   * var foo = new Node({type: 'foo'});
   * var bar = new Node({type: 'bar'});
   * var baz = new Node({type: 'baz'});
   * foo.push(bar);
   * foo.push(baz);
   *
   * console.log(bar.siblings.length) // 2
   * console.log(baz.siblings.length) // 2
   * ```
   * @return {Object}
   * @api public
   */

  Object.defineProperty(Node.prototype, 'next', {
    set: function() {
      throw new Error('node.next is a getter and cannot be defined');
    },
    get: function() {
      if (Array.isArray(this.siblings)) {
        return this.siblings[this.index + 1] || this.parent.next;
      }
      return null;
    }
  });

  /**
   * Get the first node from `node.nodes`.
   *
   * ```js
   * var foo = new Node({type: 'foo'});
   * var bar = new Node({type: 'bar'});
   * var baz = new Node({type: 'baz'});
   * var qux = new Node({type: 'qux'});
   * foo.push(bar);
   * foo.push(baz);
   * foo.push(qux);
   *
   * console.log(foo.first.type) // 'bar'
   * ```
   * @return {Object} The first node, or undefiend
   * @api public
   */

  Object.defineProperty(Node.prototype, 'first', {
    get: function() {
      return this.nodes ? this.nodes[0] : null;
    }
  });

  /**
   * Get the last node from `node.nodes`.
   *
   * ```js
   * var foo = new Node({type: 'foo'});
   * var bar = new Node({type: 'bar'});
   * var baz = new Node({type: 'baz'});
   * var qux = new Node({type: 'qux'});
   * foo.push(bar);
   * foo.push(baz);
   * foo.push(qux);
   *
   * console.log(foo.last.type) // 'qux'
   * ```
   * @return {Object} The last node, or undefiend
   * @api public
   */

  Object.defineProperty(Node.prototype, 'last', {
    get: function() {
      return this.nodes ? utils.last(this.nodes) : null;
    }
  });

  /**
   * Get the last node from `node.nodes`.
   *
   * ```js
   * var foo = new Node({type: 'foo'});
   * var bar = new Node({type: 'bar'});
   * var baz = new Node({type: 'baz'});
   * var qux = new Node({type: 'qux'});
   * foo.push(bar);
   * foo.push(baz);
   * foo.push(qux);
   *
   * console.log(foo.last.type) // 'qux'
   * ```
   * @return {Object} The last node, or undefiend
   * @api public
   */

  Object.defineProperty(Node.prototype, 'scope', {
    get: function() {
      if (this.isScope !== true) {
        return this.parent ? this.parent.scope : this;
      }
      return this;
    }
  });

  /**
   * Get own property names from Node prototype, but only the
   * first time `Node` is instantiated
   */

  function lazyKeys() {
    if (!ownNames) {
      ownNames = Object.getOwnPropertyNames(Node.prototype);
    }
  }

  /**
   * Simplified assertion. Throws an error is `val` is falsey.
   */

  function assert(val, message) {
    if (!val) throw new Error(message);
  }

  /**
   * Expose `Node`
   */

  exports = module.exports = Node;


  /***/ }),
  /* 317 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * define-property <https://github.com/jonschlinkert/define-property>
   *
   * Copyright (c) 2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   */



  var isDescriptor = __webpack_require__(292);

  module.exports = function defineProperty(obj, prop, val) {
    if (typeof obj !== 'object' && typeof obj !== 'function') {
      throw new TypeError('expected an object or function.');
    }

    if (typeof prop !== 'string') {
      throw new TypeError('expected `prop` to be a string.');
    }

    if (isDescriptor(val) && ('set' in val || 'get' in val)) {
      return Object.defineProperty(obj, prop, val);
    }

    return Object.defineProperty(obj, prop, {
      configurable: true,
      enumerable: false,
      writable: true,
      value: val
    });
  };


  /***/ }),
  /* 318 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var typeOf = __webpack_require__(310);
  var utils = module.exports;

  /**
   * Returns true if the given value is a node.
   *
   * ```js
   * var Node = require('snapdragon-node');
   * var node = new Node({type: 'foo'});
   * console.log(utils.isNode(node)); //=> true
   * console.log(utils.isNode({})); //=> false
   * ```
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @returns {Boolean}
   * @api public
   */

  utils.isNode = function(node) {
    return typeOf(node) === 'object' && node.isNode === true;
  };

  /**
   * Emit an empty string for the given `node`.
   *
   * ```js
   * // do nothing for beginning-of-string
   * snapdragon.compiler.set('bos', utils.noop);
   * ```
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @returns {undefined}
   * @api public
   */

  utils.noop = function(node) {
    append(this, '', node);
  };

  /**
   * Appdend `node.val` to `compiler.output`, exactly as it was created
   * by the parser.
   *
   * ```js
   * snapdragon.compiler.set('text', utils.identity);
   * ```
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @returns {undefined}
   * @api public
   */

  utils.identity = function(node) {
    append(this, node.val, node);
  };

  /**
   * Previously named `.emit`, this method appends the given `val`
   * to `compiler.output` for the given node. Useful when you know
   * what value should be appended advance, regardless of the actual
   * value of `node.val`.
   *
   * ```js
   * snapdragon.compiler
   *   .set('i', function(node) {
   *     this.mapVisit(node);
   *   })
   *   .set('i.open', utils.append('<i>'))
   *   .set('i.close', utils.append('</i>'))
   * ```
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @returns {Function} Returns a compiler middleware function.
   * @api public
   */

  utils.append = function(val) {
    return function(node) {
      append(this, val, node);
    };
  };

  /**
   * Used in compiler middleware, this onverts an AST node into
   * an empty `text` node and deletes `node.nodes` if it exists.
   * The advantage of this method is that, as opposed to completely
   * removing the node, indices will not need to be re-calculated
   * in sibling nodes, and nothing is appended to the output.
   *
   * ```js
   * utils.toNoop(node);
   * // convert `node.nodes` to the given value instead of deleting it
   * utils.toNoop(node, []);
   * ```
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @param {Array} `nodes` Optionally pass a new `nodes` value, to replace the existing `node.nodes` array.
   * @api public
   */

  utils.toNoop = function(node, nodes) {
    if (nodes) {
      node.nodes = nodes;
    } else {
      delete node.nodes;
      node.type = 'text';
      node.val = '';
    }
  };

  /**
   * Visit `node` with the given `fn`. The built-in `.visit` method in snapdragon
   * automatically calls registered compilers, this allows you to pass a visitor
   * function.
   *
   * ```js
   * snapdragon.compiler.set('i', function(node) {
   *   utils.visit(node, function(childNode) {
   *     // do stuff with "childNode"
   *     return childNode;
   *   });
   * });
   * ```
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @param {Function} `fn`
   * @return {Object} returns the node after recursively visiting all child nodes.
   * @api public
   */

  utils.visit = function(node, fn) {
    assert(utils.isNode(node), 'expected node to be an instance of Node');
    assert(isFunction(fn), 'expected a visitor function');
    fn(node);
    return node.nodes ? utils.mapVisit(node, fn) : node;
  };

  /**
   * Map [visit](#visit) the given `fn` over `node.nodes`. This is called by
   * [visit](#visit), use this method if you do not want `fn` to be called on
   * the first node.
   *
   * ```js
   * snapdragon.compiler.set('i', function(node) {
   *   utils.mapVisit(node, function(childNode) {
   *     // do stuff with "childNode"
   *     return childNode;
   *   });
   * });
   * ```
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @param {Object} `options`
   * @param {Function} `fn`
   * @return {Object} returns the node
   * @api public
   */

  utils.mapVisit = function(node, fn) {
    assert(utils.isNode(node), 'expected node to be an instance of Node');
    assert(isArray(node.nodes), 'expected node.nodes to be an array');
    assert(isFunction(fn), 'expected a visitor function');

    for (var i = 0; i < node.nodes.length; i++) {
      utils.visit(node.nodes[i], fn);
    }
    return node;
  };

  /**
   * Unshift an `*.open` node onto `node.nodes`.
   *
   * ```js
   * var Node = require('snapdragon-node');
   * snapdragon.parser.set('brace', function(node) {
   *   var match = this.match(/^{/);
   *   if (match) {
   *     var parent = new Node({type: 'brace'});
   *     utils.addOpen(parent, Node);
   *     console.log(parent.nodes[0]):
   *     // { type: 'brace.open', val: '' };
   *
   *     // push the parent "brace" node onto the stack
   *     this.push(parent);
   *
   *     // return the parent node, so it's also added to the AST
   *     return brace;
   *   }
   * });
   * ```
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].
   * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
   * @return {Object} Returns the created opening node.
   * @api public
   */

  utils.addOpen = function(node, Node, val, filter) {
    assert(utils.isNode(node), 'expected node to be an instance of Node');
    assert(isFunction(Node), 'expected Node to be a constructor function');

    if (typeof val === 'function') {
      filter = val;
      val = '';
    }

    if (typeof filter === 'function' && !filter(node)) return;
    var open = new Node({ type: node.type + '.open', val: val});
    var unshift = node.unshift || node.unshiftNode;
    if (typeof unshift === 'function') {
      unshift.call(node, open);
    } else {
      utils.unshiftNode(node, open);
    }
    return open;
  };

  /**
   * Push a `*.close` node onto `node.nodes`.
   *
   * ```js
   * var Node = require('snapdragon-node');
   * snapdragon.parser.set('brace', function(node) {
   *   var match = this.match(/^}/);
   *   if (match) {
   *     var parent = this.parent();
   *     if (parent.type !== 'brace') {
   *       throw new Error('missing opening: ' + '}');
   *     }
   *
   *     utils.addClose(parent, Node);
   *     console.log(parent.nodes[parent.nodes.length - 1]):
   *     // { type: 'brace.close', val: '' };
   *
   *     // no need to return a node, since the parent
   *     // was already added to the AST
   *     return;
   *   }
   * });
   * ```
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].
   * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
   * @return {Object} Returns the created closing node.
   * @api public
   */

  utils.addClose = function(node, Node, val, filter) {
    assert(utils.isNode(node), 'expected node to be an instance of Node');
    assert(isFunction(Node), 'expected Node to be a constructor function');

    if (typeof val === 'function') {
      filter = val;
      val = '';
    }

    if (typeof filter === 'function' && !filter(node)) return;
    var close = new Node({ type: node.type + '.close', val: val});
    var push = node.push || node.pushNode;
    if (typeof push === 'function') {
      push.call(node, close);
    } else {
      utils.pushNode(node, close);
    }
    return close;
  };

  /**
   * Wraps the given `node` with `*.open` and `*.close` nodes.
   *
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].
   * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
   * @return {Object} Returns the node
   * @api public
   */

  utils.wrapNodes = function(node, Node, filter) {
    assert(utils.isNode(node), 'expected node to be an instance of Node');
    assert(isFunction(Node), 'expected Node to be a constructor function');

    utils.addOpen(node, Node, filter);
    utils.addClose(node, Node, filter);
    return node;
  };

  /**
   * Push the given `node` onto `parent.nodes`, and set `parent` as `node.parent.
   *
   * ```js
   * var parent = new Node({type: 'foo'});
   * var node = new Node({type: 'bar'});
   * utils.pushNode(parent, node);
   * console.log(parent.nodes[0].type) // 'bar'
   * console.log(node.parent.type) // 'foo'
   * ```
   * @param {Object} `parent`
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @return {Object} Returns the child node
   * @api public
   */

  utils.pushNode = function(parent, node) {
    assert(utils.isNode(parent), 'expected parent node to be an instance of Node');
    assert(utils.isNode(node), 'expected node to be an instance of Node');

    node.define('parent', parent);
    parent.nodes = parent.nodes || [];
    parent.nodes.push(node);
    return node;
  };

  /**
   * Unshift `node` onto `parent.nodes`, and set `parent` as `node.parent.
   *
   * ```js
   * var parent = new Node({type: 'foo'});
   * var node = new Node({type: 'bar'});
   * utils.unshiftNode(parent, node);
   * console.log(parent.nodes[0].type) // 'bar'
   * console.log(node.parent.type) // 'foo'
   * ```
   * @param {Object} `parent`
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @return {undefined}
   * @api public
   */

  utils.unshiftNode = function(parent, node) {
    assert(utils.isNode(parent), 'expected parent node to be an instance of Node');
    assert(utils.isNode(node), 'expected node to be an instance of Node');

    node.define('parent', parent);
    parent.nodes = parent.nodes || [];
    parent.nodes.unshift(node);
  };

  /**
   * Pop the last `node` off of `parent.nodes`. The advantage of
   * using this method is that it checks for `node.nodes` and works
   * with any version of `snapdragon-node`.
   *
   * ```js
   * var parent = new Node({type: 'foo'});
   * utils.pushNode(parent, new Node({type: 'foo'}));
   * utils.pushNode(parent, new Node({type: 'bar'}));
   * utils.pushNode(parent, new Node({type: 'baz'}));
   * console.log(parent.nodes.length); //=> 3
   * utils.popNode(parent);
   * console.log(parent.nodes.length); //=> 2
   * ```
   * @param {Object} `parent`
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.
   * @api public
   */

  utils.popNode = function(node) {
    assert(utils.isNode(node), 'expected node to be an instance of Node');
    if (typeof node.pop === 'function') {
      return node.pop();
    }
    return node.nodes && node.nodes.pop();
  };

  /**
   * Shift the first `node` off of `parent.nodes`. The advantage of
   * using this method is that it checks for `node.nodes` and works
   * with any version of `snapdragon-node`.
   *
   * ```js
   * var parent = new Node({type: 'foo'});
   * utils.pushNode(parent, new Node({type: 'foo'}));
   * utils.pushNode(parent, new Node({type: 'bar'}));
   * utils.pushNode(parent, new Node({type: 'baz'}));
   * console.log(parent.nodes.length); //=> 3
   * utils.shiftNode(parent);
   * console.log(parent.nodes.length); //=> 2
   * ```
   * @param {Object} `parent`
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.
   * @api public
   */

  utils.shiftNode = function(node) {
    assert(utils.isNode(node), 'expected node to be an instance of Node');
    if (typeof node.shift === 'function') {
      return node.shift();
    }
    return node.nodes && node.nodes.shift();
  };

  /**
   * Remove the specified `node` from `parent.nodes`.
   *
   * ```js
   * var parent = new Node({type: 'abc'});
   * var foo = new Node({type: 'foo'});
   * utils.pushNode(parent, foo);
   * utils.pushNode(parent, new Node({type: 'bar'}));
   * utils.pushNode(parent, new Node({type: 'baz'}));
   * console.log(parent.nodes.length); //=> 3
   * utils.removeNode(parent, foo);
   * console.log(parent.nodes.length); //=> 2
   * ```
   * @param {Object} `parent`
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @return {Object|undefined} Returns the removed node, if successful, or undefined if it does not exist on `parent.nodes`.
   * @api public
   */

  utils.removeNode = function(parent, node) {
    assert(utils.isNode(parent), 'expected parent.node to be an instance of Node');
    assert(utils.isNode(node), 'expected node to be an instance of Node');

    if (!parent.nodes) {
      return null;
    }

    if (typeof parent.remove === 'function') {
      return parent.remove(node);
    }

    var idx = parent.nodes.indexOf(node);
    if (idx !== -1) {
      return parent.nodes.splice(idx, 1);
    }
  };

  /**
   * Returns true if `node.type` matches the given `type`. Throws a
   * `TypeError` if `node` is not an instance of `Node`.
   *
   * ```js
   * var Node = require('snapdragon-node');
   * var node = new Node({type: 'foo'});
   * console.log(utils.isType(node, 'foo')); // false
   * console.log(utils.isType(node, 'bar')); // true
   * ```
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @param {String} `type`
   * @return {Boolean}
   * @api public
   */

  utils.isType = function(node, type) {
    assert(utils.isNode(node), 'expected node to be an instance of Node');
    switch (typeOf(type)) {
      case 'array':
        var types = type.slice();
        for (var i = 0; i < types.length; i++) {
          if (utils.isType(node, types[i])) {
            return true;
          }
        }
        return false;
      case 'string':
        return node.type === type;
      case 'regexp':
        return type.test(node.type);
      default: {
        throw new TypeError('expected "type" to be an array, string or regexp');
      }
    }
  };

  /**
   * Returns true if the given `node` has the given `type` in `node.nodes`.
   * Throws a `TypeError` if `node` is not an instance of `Node`.
   *
   * ```js
   * var Node = require('snapdragon-node');
   * var node = new Node({
   *   type: 'foo',
   *   nodes: [
   *     new Node({type: 'bar'}),
   *     new Node({type: 'baz'})
   *   ]
   * });
   * console.log(utils.hasType(node, 'xyz')); // false
   * console.log(utils.hasType(node, 'baz')); // true
   * ```
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @param {String} `type`
   * @return {Boolean}
   * @api public
   */

  utils.hasType = function(node, type) {
    assert(utils.isNode(node), 'expected node to be an instance of Node');
    if (!Array.isArray(node.nodes)) return false;
    for (var i = 0; i < node.nodes.length; i++) {
      if (utils.isType(node.nodes[i], type)) {
        return true;
      }
    }
    return false;
  };

  /**
   * Returns the first node from `node.nodes` of the given `type`
   *
   * ```js
   * var node = new Node({
   *   type: 'foo',
   *   nodes: [
   *     new Node({type: 'text', val: 'abc'}),
   *     new Node({type: 'text', val: 'xyz'})
   *   ]
   * });
   *
   * var textNode = utils.firstOfType(node.nodes, 'text');
   * console.log(textNode.val);
   * //=> 'abc'
   * ```
   * @param {Array} `nodes`
   * @param {String} `type`
   * @return {Object|undefined} Returns the first matching node or undefined.
   * @api public
   */

  utils.firstOfType = function(nodes, type) {
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (utils.isType(node, type)) {
        return node;
      }
    }
  };

  /**
   * Returns the node at the specified index, or the first node of the
   * given `type` from `node.nodes`.
   *
   * ```js
   * var node = new Node({
   *   type: 'foo',
   *   nodes: [
   *     new Node({type: 'text', val: 'abc'}),
   *     new Node({type: 'text', val: 'xyz'})
   *   ]
   * });
   *
   * var nodeOne = utils.findNode(node.nodes, 'text');
   * console.log(nodeOne.val);
   * //=> 'abc'
   *
   * var nodeTwo = utils.findNode(node.nodes, 1);
   * console.log(nodeTwo.val);
   * //=> 'xyz'
   * ```
   *
   * @param {Array} `nodes`
   * @param {String|Number} `type` Node type or index.
   * @return {Object} Returns a node or undefined.
   * @api public
   */

  utils.findNode = function(nodes, type) {
    if (!Array.isArray(nodes)) {
      return null;
    }
    if (typeof type === 'number') {
      return nodes[type];
    }
    return utils.firstOfType(nodes, type);
  };

  /**
   * Returns true if the given node is an "*.open" node.
   *
   * ```js
   * var Node = require('snapdragon-node');
   * var brace = new Node({type: 'brace'});
   * var open = new Node({type: 'brace.open'});
   * var close = new Node({type: 'brace.close'});
   *
   * console.log(utils.isOpen(brace)); // false
   * console.log(utils.isOpen(open)); // true
   * console.log(utils.isOpen(close)); // false
   * ```
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @return {Boolean}
   * @api public
   */

  utils.isOpen = function(node) {
    assert(utils.isNode(node), 'expected node to be an instance of Node');
    return node.type.slice(-5) === '.open';
  };

  /**
   * Returns true if the given node is a "*.close" node.
   *
   * ```js
   * var Node = require('snapdragon-node');
   * var brace = new Node({type: 'brace'});
   * var open = new Node({type: 'brace.open'});
   * var close = new Node({type: 'brace.close'});
   *
   * console.log(utils.isClose(brace)); // false
   * console.log(utils.isClose(open)); // false
   * console.log(utils.isClose(close)); // true
   * ```
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @return {Boolean}
   * @api public
   */

  utils.isClose = function(node) {
    assert(utils.isNode(node), 'expected node to be an instance of Node');
    return node.type.slice(-6) === '.close';
  };

  /**
   * Returns true if `node.nodes` **has** an `.open` node
   *
   * ```js
   * var Node = require('snapdragon-node');
   * var brace = new Node({
   *   type: 'brace',
   *   nodes: []
   * });
   *
   * var open = new Node({type: 'brace.open'});
   * console.log(utils.hasOpen(brace)); // false
   *
   * brace.pushNode(open);
   * console.log(utils.hasOpen(brace)); // true
   * ```
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @return {Boolean}
   * @api public
   */

  utils.hasOpen = function(node) {
    assert(utils.isNode(node), 'expected node to be an instance of Node');
    var first = node.first || node.nodes ? node.nodes[0] : null;
    if (utils.isNode(first)) {
      return first.type === node.type + '.open';
    }
    return false;
  };

  /**
   * Returns true if `node.nodes` **has** a `.close` node
   *
   * ```js
   * var Node = require('snapdragon-node');
   * var brace = new Node({
   *   type: 'brace',
   *   nodes: []
   * });
   *
   * var close = new Node({type: 'brace.close'});
   * console.log(utils.hasClose(brace)); // false
   *
   * brace.pushNode(close);
   * console.log(utils.hasClose(brace)); // true
   * ```
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @return {Boolean}
   * @api public
   */

  utils.hasClose = function(node) {
    assert(utils.isNode(node), 'expected node to be an instance of Node');
    var last = node.last || node.nodes ? node.nodes[node.nodes.length - 1] : null;
    if (utils.isNode(last)) {
      return last.type === node.type + '.close';
    }
    return false;
  };

  /**
   * Returns true if `node.nodes` has both `.open` and `.close` nodes
   *
   * ```js
   * var Node = require('snapdragon-node');
   * var brace = new Node({
   *   type: 'brace',
   *   nodes: []
   * });
   *
   * var open = new Node({type: 'brace.open'});
   * var close = new Node({type: 'brace.close'});
   * console.log(utils.hasOpen(brace)); // false
   * console.log(utils.hasClose(brace)); // false
   *
   * brace.pushNode(open);
   * brace.pushNode(close);
   * console.log(utils.hasOpen(brace)); // true
   * console.log(utils.hasClose(brace)); // true
   * ```
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @return {Boolean}
   * @api public
   */

  utils.hasOpenAndClose = function(node) {
    return utils.hasOpen(node) && utils.hasClose(node);
  };

  /**
   * Push the given `node` onto the `state.inside` array for the
   * given type. This array is used as a specialized "stack" for
   * only the given `node.type`.
   *
   * ```js
   * var state = { inside: {}};
   * var node = new Node({type: 'brace'});
   * utils.addType(state, node);
   * console.log(state.inside);
   * //=> { brace: [{type: 'brace'}] }
   * ```
   * @param {Object} `state` The `compiler.state` object or custom state object.
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @return {Array} Returns the `state.inside` stack for the given type.
   * @api public
   */

  utils.addType = function(state, node) {
    assert(utils.isNode(node), 'expected node to be an instance of Node');
    assert(isObject(state), 'expected state to be an object');

    var type = node.parent
      ? node.parent.type
      : node.type.replace(/\.open$/, '');

    if (!state.hasOwnProperty('inside')) {
      state.inside = {};
    }
    if (!state.inside.hasOwnProperty(type)) {
      state.inside[type] = [];
    }

    var arr = state.inside[type];
    arr.push(node);
    return arr;
  };

  /**
   * Remove the given `node` from the `state.inside` array for the
   * given type. This array is used as a specialized "stack" for
   * only the given `node.type`.
   *
   * ```js
   * var state = { inside: {}};
   * var node = new Node({type: 'brace'});
   * utils.addType(state, node);
   * console.log(state.inside);
   * //=> { brace: [{type: 'brace'}] }
   * utils.removeType(state, node);
   * //=> { brace: [] }
   * ```
   * @param {Object} `state` The `compiler.state` object or custom state object.
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @return {Array} Returns the `state.inside` stack for the given type.
   * @api public
   */

  utils.removeType = function(state, node) {
    assert(utils.isNode(node), 'expected node to be an instance of Node');
    assert(isObject(state), 'expected state to be an object');

    var type = node.parent
      ? node.parent.type
      : node.type.replace(/\.close$/, '');

    if (state.inside.hasOwnProperty(type)) {
      return state.inside[type].pop();
    }
  };

  /**
   * Returns true if `node.val` is an empty string, or `node.nodes` does
   * not contain any non-empty text nodes.
   *
   * ```js
   * var node = new Node({type: 'text'});
   * utils.isEmpty(node); //=> true
   * node.val = 'foo';
   * utils.isEmpty(node); //=> false
   * ```
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @param {Function} `fn`
   * @return {Boolean}
   * @api public
   */

  utils.isEmpty = function(node, fn) {
    assert(utils.isNode(node), 'expected node to be an instance of Node');

    if (!Array.isArray(node.nodes)) {
      if (node.type !== 'text') {
        return true;
      }
      if (typeof fn === 'function') {
        return fn(node, node.parent);
      }
      return !utils.trim(node.val);
    }

    for (var i = 0; i < node.nodes.length; i++) {
      var child = node.nodes[i];
      if (utils.isOpen(child) || utils.isClose(child)) {
        continue;
      }
      if (!utils.isEmpty(child, fn)) {
        return false;
      }
    }

    return true;
  };

  /**
   * Returns true if the `state.inside` stack for the given type exists
   * and has one or more nodes on it.
   *
   * ```js
   * var state = { inside: {}};
   * var node = new Node({type: 'brace'});
   * console.log(utils.isInsideType(state, 'brace')); //=> false
   * utils.addType(state, node);
   * console.log(utils.isInsideType(state, 'brace')); //=> true
   * utils.removeType(state, node);
   * console.log(utils.isInsideType(state, 'brace')); //=> false
   * ```
   * @param {Object} `state`
   * @param {String} `type`
   * @return {Boolean}
   * @api public
   */

  utils.isInsideType = function(state, type) {
    assert(isObject(state), 'expected state to be an object');
    assert(isString(type), 'expected type to be a string');

    if (!state.hasOwnProperty('inside')) {
      return false;
    }

    if (!state.inside.hasOwnProperty(type)) {
      return false;
    }

    return state.inside[type].length > 0;
  };

  /**
   * Returns true if `node` is either a child or grand-child of the given `type`,
   * or `state.inside[type]` is a non-empty array.
   *
   * ```js
   * var state = { inside: {}};
   * var node = new Node({type: 'brace'});
   * var open = new Node({type: 'brace.open'});
   * console.log(utils.isInside(state, open, 'brace')); //=> false
   * utils.pushNode(node, open);
   * console.log(utils.isInside(state, open, 'brace')); //=> true
   * ```
   * @param {Object} `state` Either the `compiler.state` object, if it exists, or a user-supplied state object.
   * @param {Object} `node` Instance of [snapdragon-node][]
   * @param {String} `type` The `node.type` to check for.
   * @return {Boolean}
   * @api public
   */

  utils.isInside = function(state, node, type) {
    assert(utils.isNode(node), 'expected node to be an instance of Node');
    assert(isObject(state), 'expected state to be an object');

    if (Array.isArray(type)) {
      for (var i = 0; i < type.length; i++) {
        if (utils.isInside(state, node, type[i])) {
          return true;
        }
      }
      return false;
    }

    var parent = node.parent;
    if (typeof type === 'string') {
      return (parent && parent.type === type) || utils.isInsideType(state, type);
    }

    if (typeOf(type) === 'regexp') {
      if (parent && parent.type && type.test(parent.type)) {
        return true;
      }

      var keys = Object.keys(state.inside);
      var len = keys.length;
      var idx = -1;
      while (++idx < len) {
        var key = keys[idx];
        var val = state.inside[key];

        if (Array.isArray(val) && val.length !== 0 && type.test(key)) {
          return true;
        }
      }
    }
    return false;
  };

  /**
   * Get the last `n` element from the given `array`. Used for getting
   * a node from `node.nodes.`
   *
   * @param {Array} `array`
   * @param {Number} `n`
   * @return {undefined}
   * @api public
   */

  utils.last = function(arr, n) {
    return arr[arr.length - (n || 1)];
  };

  /**
   * Cast the given `val` to an array.
   *
   * ```js
   * console.log(utils.arrayify(''));
   * //=> []
   * console.log(utils.arrayify('foo'));
   * //=> ['foo']
   * console.log(utils.arrayify(['foo']));
   * //=> ['foo']
   * ```
   * @param {any} `val`
   * @return {Array}
   * @api public
   */

  utils.arrayify = function(val) {
    if (typeof val === 'string' && val !== '') {
      return [val];
    }
    if (!Array.isArray(val)) {
      return [];
    }
    return val;
  };

  /**
   * Convert the given `val` to a string by joining with `,`. Useful
   * for creating a cheerio/CSS/DOM-style selector from a list of strings.
   *
   * @param {any} `val`
   * @return {Array}
   * @api public
   */

  utils.stringify = function(val) {
    return utils.arrayify(val).join(',');
  };

  /**
   * Ensure that the given value is a string and call `.trim()` on it,
   * or return an empty string.
   *
   * @param {String} `str`
   * @return {String}
   * @api public
   */

  utils.trim = function(str) {
    return typeof str === 'string' ? str.trim() : '';
  };

  /**
   * Return true if val is an object
   */

  function isObject(val) {
    return typeOf(val) === 'object';
  }

  /**
   * Return true if val is a string
   */

  function isString(val) {
    return typeof val === 'string';
  }

  /**
   * Return true if val is a function
   */

  function isFunction(val) {
    return typeof val === 'function';
  }

  /**
   * Return true if val is an array
   */

  function isArray(val) {
    return Array.isArray(val);
  }

  /**
   * Shim to ensure the `.append` methods work with any version of snapdragon
   */

  function append(compiler, val, node) {
    if (typeof compiler.append !== 'function') {
      return compiler.emit(val, node);
    }
    return compiler.append(val, node);
  }

  /**
   * Simplified assertion. Throws an error is `val` is falsey.
   */

  function assert(val, message) {
    if (!val) throw new Error(message);
  }


  /***/ }),
  /* 319 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var extend = __webpack_require__(302);
  var Snapdragon = __webpack_require__(320);
  var compilers = __webpack_require__(304);
  var parsers = __webpack_require__(315);
  var utils = __webpack_require__(305);

  /**
   * Customize Snapdragon parser and renderer
   */

  function Braces(options) {
    this.options = extend({}, options);
  }

  /**
   * Initialize braces
   */

  Braces.prototype.init = function(options) {
    if (this.isInitialized) return;
    this.isInitialized = true;
    var opts = utils.createOptions({}, this.options, options);
    this.snapdragon = this.options.snapdragon || new Snapdragon(opts);
    this.compiler = this.snapdragon.compiler;
    this.parser = this.snapdragon.parser;

    compilers(this.snapdragon, opts);
    parsers(this.snapdragon, opts);

    /**
     * Call Snapdragon `.parse` method. When AST is returned, we check to
     * see if any unclosed braces are left on the stack and, if so, we iterate
     * over the stack and correct the AST so that compilers are called in the correct
     * order and unbalance braces are properly escaped.
     */

    utils.define(this.snapdragon, 'parse', function(pattern, options) {
      var parsed = Snapdragon.prototype.parse.apply(this, arguments);
      this.parser.ast.input = pattern;

      var stack = this.parser.stack;
      while (stack.length) {
        addParent({type: 'brace.close', val: ''}, stack.pop());
      }

      function addParent(node, parent) {
        utils.define(node, 'parent', parent);
        parent.nodes.push(node);
      }

      // add non-enumerable parser reference
      utils.define(parsed, 'parser', this.parser);
      return parsed;
    });
  };

  /**
   * Decorate `.parse` method
   */

  Braces.prototype.parse = function(ast, options) {
    if (ast && typeof ast === 'object' && ast.nodes) return ast;
    this.init(options);
    return this.snapdragon.parse(ast, options);
  };

  /**
   * Decorate `.compile` method
   */

  Braces.prototype.compile = function(ast, options) {
    if (typeof ast === 'string') {
      ast = this.parse(ast, options);
    } else {
      this.init(options);
    }
    return this.snapdragon.compile(ast, options);
  };

  /**
   * Expand
   */

  Braces.prototype.expand = function(pattern) {
    var ast = this.parse(pattern, {expand: true});
    return this.compile(ast, {expand: true});
  };

  /**
   * Optimize
   */

  Braces.prototype.optimize = function(pattern) {
    var ast = this.parse(pattern, {optimize: true});
    return this.compile(ast, {optimize: true});
  };

  /**
   * Expose `Braces`
   */

  module.exports = Braces;


  /***/ }),
  /* 320 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var Base = __webpack_require__(321);
  var define = __webpack_require__(344);
  var Compiler = __webpack_require__(352);
  var Parser = __webpack_require__(373);
  var utils = __webpack_require__(357);
  var regexCache = {};
  var cache = {};

  /**
   * Create a new instance of `Snapdragon` with the given `options`.
   *
   * ```js
   * var snapdragon = new Snapdragon();
   * ```
   *
   * @param {Object} `options`
   * @api public
   */

  function Snapdragon(options) {
    Base.call(this, null, options);
    this.options = utils.extend({source: 'string'}, this.options);
    this.compiler = new Compiler(this.options);
    this.parser = new Parser(this.options);

    Object.defineProperty(this, 'compilers', {
      get: function() {
        return this.compiler.compilers;
      }
    });

    Object.defineProperty(this, 'parsers', {
      get: function() {
        return this.parser.parsers;
      }
    });

    Object.defineProperty(this, 'regex', {
      get: function() {
        return this.parser.regex;
      }
    });
  }

  /**
   * Inherit Base
   */

  Base.extend(Snapdragon);

  /**
   * Add a parser to `snapdragon.parsers` for capturing the given `type` using
   * the specified regex or parser function. A function is useful if you need
   * to customize how the token is created and/or have access to the parser
   * instance to check options, etc.
   *
   * ```js
   * snapdragon
   *   .capture('slash', /^\//)
   *   .capture('dot', function() {
   *     var pos = this.position();
   *     var m = this.match(/^\./);
   *     if (!m) return;
   *     return pos({
   *       type: 'dot',
   *       val: m[0]
   *     });
   *   });
   * ```
   * @param {String} `type`
   * @param {RegExp|Function} `regex`
   * @return {Object} Returns the parser instance for chaining
   * @api public
   */

  Snapdragon.prototype.capture = function() {
    return this.parser.capture.apply(this.parser, arguments);
  };

  /**
   * Register a plugin `fn`.
   *
   * ```js
   * var snapdragon = new Snapdgragon([options]);
   * snapdragon.use(function() {
   *   console.log(this);          //<= snapdragon instance
   *   console.log(this.parser);   //<= parser instance
   *   console.log(this.compiler); //<= compiler instance
   * });
   * ```
   * @param {Object} `fn`
   * @api public
   */

  Snapdragon.prototype.use = function(fn) {
    fn.call(this, this);
    return this;
  };

  /**
   * Parse the given `str`.
   *
   * ```js
   * var snapdragon = new Snapdgragon([options]);
   * // register parsers
   * snapdragon.parser.use(function() {});
   *
   * // parse
   * var ast = snapdragon.parse('foo/bar');
   * console.log(ast);
   * ```
   * @param {String} `str`
   * @param {Object} `options` Set `options.sourcemap` to true to enable source maps.
   * @return {Object} Returns an AST.
   * @api public
   */

  Snapdragon.prototype.parse = function(str, options) {
    this.options = utils.extend({}, this.options, options);
    var parsed = this.parser.parse(str, this.options);

    // add non-enumerable parser reference
    define(parsed, 'parser', this.parser);
    return parsed;
  };

  /**
   * Compile the given `AST`.
   *
   * ```js
   * var snapdragon = new Snapdgragon([options]);
   * // register plugins
   * snapdragon.use(function() {});
   * // register parser plugins
   * snapdragon.parser.use(function() {});
   * // register compiler plugins
   * snapdragon.compiler.use(function() {});
   *
   * // parse
   * var ast = snapdragon.parse('foo/bar');
   *
   * // compile
   * var res = snapdragon.compile(ast);
   * console.log(res.output);
   * ```
   * @param {Object} `ast`
   * @param {Object} `options`
   * @return {Object} Returns an object with an `output` property with the rendered string.
   * @api public
   */

  Snapdragon.prototype.compile = function(ast, options) {
    this.options = utils.extend({}, this.options, options);
    var compiled = this.compiler.compile(ast, this.options);

    // add non-enumerable compiler reference
    define(compiled, 'compiler', this.compiler);
    return compiled;
  };

  /**
   * Expose `Snapdragon`
   */

  module.exports = Snapdragon;

  /**
   * Expose `Parser` and `Compiler`
   */

  module.exports.Compiler = Compiler;
  module.exports.Parser = Parser;


  /***/ }),
  /* 321 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var util = __webpack_require__(25);
  var define = __webpack_require__(317);
  var CacheBase = __webpack_require__(322);
  var Emitter = __webpack_require__(323);
  var isObject = __webpack_require__(291);
  var merge = __webpack_require__(340);
  var pascal = __webpack_require__(342);
  var cu = __webpack_require__(343);

  /**
   * Optionally define a custom `cache` namespace to use.
   */

  function namespace(name) {
    var Cache = name ? CacheBase.namespace(name) : CacheBase;
    var fns = [];

    /**
     * Create an instance of `Base` with the given `config` and `options`.
     *
     * ```js
     * // initialize with `config` and `options`
     * var app = new Base({isApp: true}, {abc: true});
     * app.set('foo', 'bar');
     *
     * // values defined with the given `config` object will be on the root of the instance
     * console.log(app.baz); //=> undefined
     * console.log(app.foo); //=> 'bar'
     * // or use `.get`
     * console.log(app.get('isApp')); //=> true
     * console.log(app.get('foo')); //=> 'bar'
     *
     * // values defined with the given `options` object will be on `app.options
     * console.log(app.options.abc); //=> true
     * ```
     *
     * @param {Object} `config` If supplied, this object is passed to [cache-base][] to merge onto the the instance upon instantiation.
     * @param {Object} `options` If supplied, this object is used to initialize the `base.options` object.
     * @api public
     */

    function Base(config, options) {
      if (!(this instanceof Base)) {
        return new Base(config, options);
      }
      Cache.call(this, config);
      this.is('base');
      this.initBase(config, options);
    }

    /**
     * Inherit cache-base
     */

    util.inherits(Base, Cache);

    /**
     * Add static emitter methods
     */

    Emitter(Base);

    /**
     * Initialize `Base` defaults with the given `config` object
     */

    Base.prototype.initBase = function(config, options) {
      this.options = merge({}, this.options, options);
      this.cache = this.cache || {};
      this.define('registered', {});
      if (name) this[name] = {};

      // make `app._callbacks` non-enumerable
      this.define('_callbacks', this._callbacks);
      if (isObject(config)) {
        this.visit('set', config);
      }
      Base.run(this, 'use', fns);
    };

    /**
     * Set the given `name` on `app._name` and `app.is*` properties. Used for doing
     * lookups in plugins.
     *
     * ```js
     * app.is('foo');
     * console.log(app._name);
     * //=> 'foo'
     * console.log(app.isFoo);
     * //=> true
     * app.is('bar');
     * console.log(app.isFoo);
     * //=> true
     * console.log(app.isBar);
     * //=> true
     * console.log(app._name);
     * //=> 'bar'
     * ```
     * @name .is
     * @param {String} `name`
     * @return {Boolean}
     * @api public
     */

    Base.prototype.is = function(name) {
      if (typeof name !== 'string') {
        throw new TypeError('expected name to be a string');
      }
      this.define('is' + pascal(name), true);
      this.define('_name', name);
      this.define('_appname', name);
      return this;
    };

    /**
     * Returns true if a plugin has already been registered on an instance.
     *
     * Plugin implementors are encouraged to use this first thing in a plugin
     * to prevent the plugin from being called more than once on the same
     * instance.
     *
     * ```js
     * var base = new Base();
     * base.use(function(app) {
     *   if (app.isRegistered('myPlugin')) return;
     *   // do stuff to `app`
     * });
     *
     * // to also record the plugin as being registered
     * base.use(function(app) {
     *   if (app.isRegistered('myPlugin', true)) return;
     *   // do stuff to `app`
     * });
     * ```
     * @name .isRegistered
     * @emits `plugin` Emits the name of the plugin being registered. Useful for unit tests, to ensure plugins are only registered once.
     * @param {String} `name` The plugin name.
     * @param {Boolean} `register` If the plugin if not already registered, to record it as being registered pass `true` as the second argument.
     * @return {Boolean} Returns true if a plugin is already registered.
     * @api public
     */

    Base.prototype.isRegistered = function(name, register) {
      if (this.registered.hasOwnProperty(name)) {
        return true;
      }
      if (register !== false) {
        this.registered[name] = true;
        this.emit('plugin', name);
      }
      return false;
    };

    /**
     * Define a plugin function to be called immediately upon init. Plugins are chainable
     * and expose the following arguments to the plugin function:
     *
     * - `app`: the current instance of `Base`
     * - `base`: the [first ancestor instance](#base) of `Base`
     *
     * ```js
     * var app = new Base()
     *   .use(foo)
     *   .use(bar)
     *   .use(baz)
     * ```
     * @name .use
     * @param {Function} `fn` plugin function to call
     * @return {Object} Returns the item instance for chaining.
     * @api public
     */

    Base.prototype.use = function(fn) {
      fn.call(this, this);
      return this;
    };

    /**
     * The `.define` method is used for adding non-enumerable property on the instance.
     * Dot-notation is **not supported** with `define`.
     *
     * ```js
     * // arbitrary `render` function using lodash `template`
     * app.define('render', function(str, locals) {
     *   return _.template(str)(locals);
     * });
     * ```
     * @name .define
     * @param {String} `key` The name of the property to define.
     * @param {any} `value`
     * @return {Object} Returns the instance for chaining.
     * @api public
     */

    Base.prototype.define = function(key, val) {
      if (isObject(key)) {
        return this.visit('define', key);
      }
      define(this, key, val);
      return this;
    };

    /**
     * Mix property `key` onto the Base prototype. If base is inherited using
     * `Base.extend` this method will be overridden by a new `mixin` method that will
     * only add properties to the prototype of the inheriting application.
     *
     * ```js
     * app.mixin('foo', function() {
     *   // do stuff
     * });
     * ```
     * @name .mixin
     * @param {String} `key`
     * @param {Object|Array} `val`
     * @return {Object} Returns the `base` instance for chaining.
     * @api public
     */

    Base.prototype.mixin = function(key, val) {
      Base.prototype[key] = val;
      return this;
    };

    /**
     * Non-enumberable mixin array, used by the static [Base.mixin]() method.
     */

    Base.prototype.mixins = Base.prototype.mixins || [];

    /**
     * Getter/setter used when creating nested instances of `Base`, for storing a reference
     * to the first ancestor instance. This works by setting an instance of `Base` on the `parent`
     * property of a "child" instance. The `base` property defaults to the current instance if
     * no `parent` property is defined.
     *
     * ```js
     * // create an instance of `Base`, this is our first ("base") instance
     * var first = new Base();
     * first.foo = 'bar'; // arbitrary property, to make it easier to see what's happening later
     *
     * // create another instance
     * var second = new Base();
     * // create a reference to the first instance (`first`)
     * second.parent = first;
     *
     * // create another instance
     * var third = new Base();
     * // create a reference to the previous instance (`second`)
     * // repeat this pattern every time a "child" instance is created
     * third.parent = second;
     *
     * // we can always access the first instance using the `base` property
     * console.log(first.base.foo);
     * //=> 'bar'
     * console.log(second.base.foo);
     * //=> 'bar'
     * console.log(third.base.foo);
     * //=> 'bar'
     * // and now you know how to get to third base ;)
     * ```
     * @name .base
     * @api public
     */

    Object.defineProperty(Base.prototype, 'base', {
      configurable: true,
      get: function() {
        return this.parent ? this.parent.base : this;
      }
    });

    /**
     * Static method for adding global plugin functions that will
     * be added to an instance when created.
     *
     * ```js
     * Base.use(function(app) {
     *   app.foo = 'bar';
     * });
     * var app = new Base();
     * console.log(app.foo);
     * //=> 'bar'
     * ```
     * @name #use
     * @param {Function} `fn` Plugin function to use on each instance.
     * @return {Object} Returns the `Base` constructor for chaining
     * @api public
     */

    define(Base, 'use', function(fn) {
      fns.push(fn);
      return Base;
    });

    /**
     * Run an array of functions by passing each function
     * to a method on the given object specified by the given property.
     *
     * @param  {Object} `obj` Object containing method to use.
     * @param  {String} `prop` Name of the method on the object to use.
     * @param  {Array} `arr` Array of functions to pass to the method.
     */

    define(Base, 'run', function(obj, prop, arr) {
      var len = arr.length, i = 0;
      while (len--) {
        obj[prop](arr[i++]);
      }
      return Base;
    });

    /**
     * Static method for inheriting the prototype and static methods of the `Base` class.
     * This method greatly simplifies the process of creating inheritance-based applications.
     * See [static-extend][] for more details.
     *
     * ```js
     * var extend = cu.extend(Parent);
     * Parent.extend(Child);
     *
     * // optional methods
     * Parent.extend(Child, {
     *   foo: function() {},
     *   bar: function() {}
     * });
     * ```
     * @name #extend
     * @param {Function} `Ctor` constructor to extend
     * @param {Object} `methods` Optional prototype properties to mix in.
     * @return {Object} Returns the `Base` constructor for chaining
     * @api public
     */

    define(Base, 'extend', cu.extend(Base, function(Ctor, Parent) {
      Ctor.prototype.mixins = Ctor.prototype.mixins || [];

      define(Ctor, 'mixin', function(fn) {
        var mixin = fn(Ctor.prototype, Ctor);
        if (typeof mixin === 'function') {
          Ctor.prototype.mixins.push(mixin);
        }
        return Ctor;
      });

      define(Ctor, 'mixins', function(Child) {
        Base.run(Child, 'mixin', Ctor.prototype.mixins);
        return Ctor;
      });

      Ctor.prototype.mixin = function(key, value) {
        Ctor.prototype[key] = value;
        return this;
      };
      return Base;
    }));

    /**
     * Used for adding methods to the `Base` prototype, and/or to the prototype of child instances.
     * When a mixin function returns a function, the returned function is pushed onto the `.mixins`
     * array, making it available to be used on inheriting classes whenever `Base.mixins()` is
     * called (e.g. `Base.mixins(Child)`).
     *
     * ```js
     * Base.mixin(function(proto) {
     *   proto.foo = function(msg) {
     *     return 'foo ' + msg;
     *   };
     * });
     * ```
     * @name #mixin
     * @param {Function} `fn` Function to call
     * @return {Object} Returns the `Base` constructor for chaining
     * @api public
     */

    define(Base, 'mixin', function(fn) {
      var mixin = fn(Base.prototype, Base);
      if (typeof mixin === 'function') {
        Base.prototype.mixins.push(mixin);
      }
      return Base;
    });

    /**
     * Static method for running global mixin functions against a child constructor.
     * Mixins must be registered before calling this method.
     *
     * ```js
     * Base.extend(Child);
     * Base.mixins(Child);
     * ```
     * @name #mixins
     * @param {Function} `Child` Constructor function of a child class
     * @return {Object} Returns the `Base` constructor for chaining
     * @api public
     */

    define(Base, 'mixins', function(Child) {
      Base.run(Child, 'mixin', Base.prototype.mixins);
      return Base;
    });

    /**
     * Similar to `util.inherit`, but copies all static properties, prototype properties, and
     * getters/setters from `Provider` to `Receiver`. See [class-utils][]{#inherit} for more details.
     *
     * ```js
     * Base.inherit(Foo, Bar);
     * ```
     * @name #inherit
     * @param {Function} `Receiver` Receiving (child) constructor
     * @param {Function} `Provider` Providing (parent) constructor
     * @return {Object} Returns the `Base` constructor for chaining
     * @api public
     */

    define(Base, 'inherit', cu.inherit);
    define(Base, 'bubble', cu.bubble);
    return Base;
  }

  /**
   * Expose `Base` with default settings
   */

  module.exports = namespace();

  /**
   * Allow users to define a namespace
   */

  module.exports.namespace = namespace;


  /***/ }),
  /* 322 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var isObject = __webpack_require__(291);
  var Emitter = __webpack_require__(323);
  var visit = __webpack_require__(324);
  var toPath = __webpack_require__(327);
  var union = __webpack_require__(328);
  var del = __webpack_require__(332);
  var get = __webpack_require__(330);
  var has = __webpack_require__(337);
  var set = __webpack_require__(331);

  /**
   * Create a `Cache` constructor that when instantiated will
   * store values on the given `prop`.
   *
   * ```js
   * var Cache = require('cache-base').namespace('data');
   * var cache = new Cache();
   *
   * cache.set('foo', 'bar');
   * //=> {data: {foo: 'bar'}}
   * ```
   * @param {String} `prop` The property name to use for storing values.
   * @return {Function} Returns a custom `Cache` constructor
   * @api public
   */

  function namespace(prop) {

    /**
     * Create a new `Cache`. Internally the `Cache` constructor is created using
     * the `namespace` function, with `cache` defined as the storage object.
     *
     * ```js
     * var app = new Cache();
     * ```
     * @param {Object} `cache` Optionally pass an object to initialize with.
     * @constructor
     * @api public
     */

    function Cache(cache) {
      if (prop) {
        this[prop] = {};
      }
      if (cache) {
        this.set(cache);
      }
    }

    /**
     * Inherit Emitter
     */

    Emitter(Cache.prototype);

    /**
     * Assign `value` to `key`. Also emits `set` with
     * the key and value.
     *
     * ```js
     * app.on('set', function(key, val) {
     *   // do something when `set` is emitted
     * });
     *
     * app.set(key, value);
     *
     * // also takes an object or array
     * app.set({name: 'Halle'});
     * app.set([{foo: 'bar'}, {baz: 'quux'}]);
     * console.log(app);
     * //=> {name: 'Halle', foo: 'bar', baz: 'quux'}
     * ```
     *
     * @name .set
     * @emits `set` with `key` and `value` as arguments.
     * @param {String} `key`
     * @param {any} `value`
     * @return {Object} Returns the instance for chaining.
     * @api public
     */

    Cache.prototype.set = function(key, val) {
      if (Array.isArray(key) && arguments.length === 2) {
        key = toPath(key);
      }
      if (isObject(key) || Array.isArray(key)) {
        this.visit('set', key);
      } else {
        set(prop ? this[prop] : this, key, val);
        this.emit('set', key, val);
      }
      return this;
    };

    /**
     * Union `array` to `key`. Also emits `set` with
     * the key and value.
     *
     * ```js
     * app.union('a.b', ['foo']);
     * app.union('a.b', ['bar']);
     * console.log(app.get('a'));
     * //=> {b: ['foo', 'bar']}
     * ```
     * @name .union
     * @param {String} `key`
     * @param {any} `value`
     * @return {Object} Returns the instance for chaining.
     * @api public
     */

    Cache.prototype.union = function(key, val) {
      if (Array.isArray(key) && arguments.length === 2) {
        key = toPath(key);
      }
      var ctx = prop ? this[prop] : this;
      union(ctx, key, arrayify(val));
      this.emit('union', val);
      return this;
    };

    /**
     * Return the value of `key`. Dot notation may be used
     * to get [nested property values][get-value].
     *
     * ```js
     * app.set('a.b.c', 'd');
     * app.get('a.b');
     * //=> {c: 'd'}
     *
     * app.get(['a', 'b']);
     * //=> {c: 'd'}
     * ```
     *
     * @name .get
     * @emits `get` with `key` and `value` as arguments.
     * @param {String} `key` The name of the property to get. Dot-notation may be used.
     * @return {any} Returns the value of `key`
     * @api public
     */

    Cache.prototype.get = function(key) {
      key = toPath(arguments);

      var ctx = prop ? this[prop] : this;
      var val = get(ctx, key);

      this.emit('get', key, val);
      return val;
    };

    /**
     * Return true if app has a stored value for `key`,
     * false only if value is `undefined`.
     *
     * ```js
     * app.set('foo', 'bar');
     * app.has('foo');
     * //=> true
     * ```
     *
     * @name .has
     * @emits `has` with `key` and true or false as arguments.
     * @param {String} `key`
     * @return {Boolean}
     * @api public
     */

    Cache.prototype.has = function(key) {
      key = toPath(arguments);

      var ctx = prop ? this[prop] : this;
      var val = get(ctx, key);

      var has = typeof val !== 'undefined';
      this.emit('has', key, has);
      return has;
    };

    /**
     * Delete one or more properties from the instance.
     *
     * ```js
     * app.del(); // delete all
     * // or
     * app.del('foo');
     * // or
     * app.del(['foo', 'bar']);
     * ```
     * @name .del
     * @emits `del` with the `key` as the only argument.
     * @param {String|Array} `key` Property name or array of property names.
     * @return {Object} Returns the instance for chaining.
     * @api public
     */

    Cache.prototype.del = function(key) {
      if (Array.isArray(key)) {
        this.visit('del', key);
      } else {
        del(prop ? this[prop] : this, key);
        this.emit('del', key);
      }
      return this;
    };

    /**
     * Reset the entire cache to an empty object.
     *
     * ```js
     * app.clear();
     * ```
     * @api public
     */

    Cache.prototype.clear = function() {
      if (prop) {
        this[prop] = {};
      }
    };

    /**
     * Visit `method` over the properties in the given object, or map
     * visit over the object-elements in an array.
     *
     * @name .visit
     * @param {String} `method` The name of the `base` method to call.
     * @param {Object|Array} `val` The object or array to iterate over.
     * @return {Object} Returns the instance for chaining.
     * @api public
     */

    Cache.prototype.visit = function(method, val) {
      visit(this, method, val);
      return this;
    };

    return Cache;
  }

  /**
   * Cast val to an array
   */

  function arrayify(val) {
    return val ? (Array.isArray(val) ? val : [val]) : [];
  }

  /**
   * Expose `Cache`
   */

  module.exports = namespace();

  /**
   * Expose `Cache.namespace`
   */

  module.exports.namespace = namespace;


  /***/ }),
  /* 323 */
  /***/ (function(module, exports, __webpack_require__) {

  
  /**
   * Expose `Emitter`.
   */
  
  if (true) {
    module.exports = Emitter;
  }
  
  /**
   * Initialize a new `Emitter`.
   *
   * @api public
   */
  
  function Emitter(obj) {
    if (obj) return mixin(obj);
  };
  
  /**
   * Mixin the emitter properties.
   *
   * @param {Object} obj
   * @return {Object}
   * @api private
   */
  
  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }
    return obj;
  }
  
  /**
   * Listen on the given `event` with `fn`.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */
  
  Emitter.prototype.on =
  Emitter.prototype.addEventListener = function(event, fn){
    this._callbacks = this._callbacks || {};
    (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
      .push(fn);
    return this;
  };
  
  /**
   * Adds an `event` listener that will be invoked a single
   * time then automatically removed.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */
  
  Emitter.prototype.once = function(event, fn){
    function on() {
      this.off(event, on);
      fn.apply(this, arguments);
    }
  
    on.fn = fn;
    this.on(event, on);
    return this;
  };
  
  /**
   * Remove the given callback for `event` or all
   * registered callbacks.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */
  
  Emitter.prototype.off =
  Emitter.prototype.removeListener =
  Emitter.prototype.removeAllListeners =
  Emitter.prototype.removeEventListener = function(event, fn){
    this._callbacks = this._callbacks || {};
  
    // all
    if (0 == arguments.length) {
      this._callbacks = {};
      return this;
    }
  
    // specific event
    var callbacks = this._callbacks['$' + event];
    if (!callbacks) return this;
  
    // remove all handlers
    if (1 == arguments.length) {
      delete this._callbacks['$' + event];
      return this;
    }
  
    // remove specific handler
    var cb;
    for (var i = 0; i < callbacks.length; i++) {
      cb = callbacks[i];
      if (cb === fn || cb.fn === fn) {
        callbacks.splice(i, 1);
        break;
      }
    }
  
    // Remove event specific arrays for event types that no
    // one is subscribed for to avoid memory leak.
    if (callbacks.length === 0) {
      delete this._callbacks['$' + event];
    }
  
    return this;
  };
  
  /**
   * Emit `event` with the given args.
   *
   * @param {String} event
   * @param {Mixed} ...
   * @return {Emitter}
   */
  
  Emitter.prototype.emit = function(event){
    this._callbacks = this._callbacks || {};
  
    var args = new Array(arguments.length - 1)
      , callbacks = this._callbacks['$' + event];
  
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  
    if (callbacks) {
      callbacks = callbacks.slice(0);
      for (var i = 0, len = callbacks.length; i < len; ++i) {
        callbacks[i].apply(this, args);
      }
    }
  
    return this;
  };
  
  /**
   * Return array of callbacks for `event`.
   *
   * @param {String} event
   * @return {Array}
   * @api public
   */
  
  Emitter.prototype.listeners = function(event){
    this._callbacks = this._callbacks || {};
    return this._callbacks['$' + event] || [];
  };
  
  /**
   * Check if this emitter has `event` handlers.
   *
   * @param {String} event
   * @return {Boolean}
   * @api public
   */
  
  Emitter.prototype.hasListeners = function(event){
    return !! this.listeners(event).length;
  };


  /***/ }),
  /* 324 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * collection-visit <https://github.com/jonschlinkert/collection-visit>
   *
   * Copyright (c) 2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   */



  var visit = __webpack_require__(325);
  var mapVisit = __webpack_require__(326);

  module.exports = function(collection, method, val) {
    var result;

    if (typeof val === 'string' && (method in collection)) {
      var args = [].slice.call(arguments, 2);
      result = collection[method].apply(collection, args);
    } else if (Array.isArray(val)) {
      result = mapVisit.apply(null, arguments);
    } else {
      result = visit.apply(null, arguments);
    }

    if (typeof result !== 'undefined') {
      return result;
    }

    return collection;
  };


  /***/ }),
  /* 325 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * object-visit <https://github.com/jonschlinkert/object-visit>
   *
   * Copyright (c) 2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   */



  var isObject = __webpack_require__(291);

  module.exports = function visit(thisArg, method, target, val) {
    if (!isObject(thisArg) && typeof thisArg !== 'function') {
      throw new Error('object-visit expects `thisArg` to be an object.');
    }

    if (typeof method !== 'string') {
      throw new Error('object-visit expects `method` name to be a string');
    }

    if (typeof thisArg[method] !== 'function') {
      return thisArg;
    }

    var args = [].slice.call(arguments, 3);
    target = target || {};

    for (var key in target) {
      var arr = [key, target[key]].concat(args);
      thisArg[method].apply(thisArg, arr);
    }
    return thisArg;
  };


  /***/ }),
  /* 326 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var util = __webpack_require__(25);
  var visit = __webpack_require__(325);

  /**
   * Map `visit` over an array of objects.
   *
   * @param  {Object} `collection` The context in which to invoke `method`
   * @param  {String} `method` Name of the method to call on `collection`
   * @param  {Object} `arr` Array of objects.
   */

  module.exports = function mapVisit(collection, method, val) {
    if (isObject(val)) {
      return visit.apply(null, arguments);
    }

    if (!Array.isArray(val)) {
      throw new TypeError('expected an array: ' + util.inspect(val));
    }

    var args = [].slice.call(arguments, 3);

    for (var i = 0; i < val.length; i++) {
      var ele = val[i];
      if (isObject(ele)) {
        visit.apply(null, [collection, method, ele].concat(args));
      } else {
        collection[method].apply(collection, [ele].concat(args));
      }
    }
  };

  function isObject(val) {
    return val && (typeof val === 'function' || (!Array.isArray(val) && typeof val === 'object'));
  }


  /***/ }),
  /* 327 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * to-object-path <https://github.com/jonschlinkert/to-object-path>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */



  var typeOf = __webpack_require__(310);

  module.exports = function toPath(args) {
    if (typeOf(args) !== 'arguments') {
      args = arguments;
    }
    return filter(args).join('.');
  };

  function filter(arr) {
    var len = arr.length;
    var idx = -1;
    var res = [];

    while (++idx < len) {
      var ele = arr[idx];
      if (typeOf(ele) === 'arguments' || Array.isArray(ele)) {
        res.push.apply(res, filter(ele));
      } else if (typeof ele === 'string') {
        res.push(ele);
      }
    }
    return res;
  }


  /***/ }),
  /* 328 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var isObject = __webpack_require__(303);
  var union = __webpack_require__(329);
  var get = __webpack_require__(330);
  var set = __webpack_require__(331);

  module.exports = function unionValue(obj, prop, value) {
    if (!isObject(obj)) {
      throw new TypeError('union-value expects the first argument to be an object.');
    }

    if (typeof prop !== 'string') {
      throw new TypeError('union-value expects `prop` to be a string.');
    }

    var arr = arrayify(get(obj, prop));
    set(obj, prop, union(arr, arrayify(value)));
    return obj;
  };

  function arrayify(val) {
    if (val === null || typeof val === 'undefined') {
      return [];
    }
    if (Array.isArray(val)) {
      return val;
    }
    return [val];
  }


  /***/ }),
  /* 329 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  module.exports = function union(init) {
    if (!Array.isArray(init)) {
      throw new TypeError('arr-union expects the first argument to be an array.');
    }

    var len = arguments.length;
    var i = 0;

    while (++i < len) {
      var arg = arguments[i];
      if (!arg) continue;

      if (!Array.isArray(arg)) {
        arg = [arg];
      }

      for (var j = 0; j < arg.length; j++) {
        var ele = arg[j];

        if (init.indexOf(ele) >= 0) {
          continue;
        }
        init.push(ele);
      }
    }
    return init;
  };


  /***/ }),
  /* 330 */
  /***/ (function(module, exports) {

  /*!
   * get-value <https://github.com/jonschlinkert/get-value>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */

  module.exports = function(obj, prop, a, b, c) {
    if (!isObject(obj) || !prop) {
      return obj;
    }

    prop = toString(prop);

    // allowing for multiple properties to be passed as
    // a string or array, but much faster (3-4x) than doing
    // `[].slice.call(arguments)`
    if (a) prop += '.' + toString(a);
    if (b) prop += '.' + toString(b);
    if (c) prop += '.' + toString(c);

    if (prop in obj) {
      return obj[prop];
    }

    var segs = prop.split('.');
    var len = segs.length;
    var i = -1;

    while (obj && (++i < len)) {
      var key = segs[i];
      while (key[key.length - 1] === '\\') {
        key = key.slice(0, -1) + '.' + segs[++i];
      }
      obj = obj[key];
    }
    return obj;
  };

  function isObject(val) {
    return val !== null && (typeof val === 'object' || typeof val === 'function');
  }

  function toString(val) {
    if (!val) return '';
    if (Array.isArray(val)) {
      return val.join('.');
    }
    return val;
  }


  /***/ }),
  /* 331 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * set-value <https://github.com/jonschlinkert/set-value>
   *
   * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   */



  var split = __webpack_require__(306);
  var extend = __webpack_require__(302);
  var isPlainObject = __webpack_require__(298);
  var isObject = __webpack_require__(303);

  module.exports = function(obj, prop, val) {
    if (!isObject(obj)) {
      return obj;
    }

    if (Array.isArray(prop)) {
      prop = [].concat.apply([], prop).join('.');
    }

    if (typeof prop !== 'string') {
      return obj;
    }

    var keys = split(prop, {sep: '.', brackets: true}).filter(isValidKey);
    var len = keys.length;
    var idx = -1;
    var current = obj;

    while (++idx < len) {
      var key = keys[idx];
      if (idx !== len - 1) {
        if (!isObject(current[key])) {
          current[key] = {};
        }
        current = current[key];
        continue;
      }

      if (isPlainObject(current[key]) && isPlainObject(val)) {
        current[key] = extend({}, current[key], val);
      } else {
        current[key] = val;
      }
    }

    return obj;
  };

  function isValidKey(key) {
    return key !== '__proto__' && key !== 'constructor' && key !== 'prototype';
  }


  /***/ }),
  /* 332 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * unset-value <https://github.com/jonschlinkert/unset-value>
   *
   * Copyright (c) 2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   */



  var isObject = __webpack_require__(291);
  var has = __webpack_require__(333);

  module.exports = function unset(obj, prop) {
    if (!isObject(obj)) {
      throw new TypeError('expected an object.');
    }
    if (obj.hasOwnProperty(prop)) {
      delete obj[prop];
      return true;
    }

    if (has(obj, prop)) {
      var segs = prop.split('.');
      var last = segs.pop();
      while (segs.length && segs[segs.length - 1].slice(-1) === '\\') {
        last = segs.pop().slice(0, -1) + '.' + last;
      }
      while (segs.length) obj = obj[prop = segs.shift()];
      return (delete obj[last]);
    }
    return true;
  };


  /***/ }),
  /* 333 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * has-value <https://github.com/jonschlinkert/has-value>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   */



  var isObject = __webpack_require__(334);
  var hasValues = __webpack_require__(336);
  var get = __webpack_require__(330);

  module.exports = function(obj, prop, noZero) {
    if (isObject(obj)) {
      return hasValues(get(obj, prop), noZero);
    }
    return hasValues(obj, prop);
  };


  /***/ }),
  /* 334 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * isobject <https://github.com/jonschlinkert/isobject>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */



  var isArray = __webpack_require__(335);

  module.exports = function isObject(val) {
    return val != null && typeof val === 'object' && isArray(val) === false;
  };


  /***/ }),
  /* 335 */
  /***/ (function(module, exports) {

  var toString = {}.toString;

  module.exports = Array.isArray || function (arr) {
    return toString.call(arr) == '[object Array]';
  };


  /***/ }),
  /* 336 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * has-values <https://github.com/jonschlinkert/has-values>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */



  module.exports = function hasValue(o, noZero) {
    if (o === null || o === undefined) {
      return false;
    }

    if (typeof o === 'boolean') {
      return true;
    }

    if (typeof o === 'number') {
      if (o === 0 && noZero === true) {
        return false;
      }
      return true;
    }

    if (o.length !== undefined) {
      return o.length !== 0;
    }

    for (var key in o) {
      if (o.hasOwnProperty(key)) {
        return true;
      }
    }
    return false;
  };


  /***/ }),
  /* 337 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * has-value <https://github.com/jonschlinkert/has-value>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Licensed under the MIT License.
   */



  var isObject = __webpack_require__(291);
  var hasValues = __webpack_require__(338);
  var get = __webpack_require__(330);

  module.exports = function(val, prop) {
    return hasValues(isObject(val) && prop ? get(val, prop) : val);
  };


  /***/ }),
  /* 338 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * has-values <https://github.com/jonschlinkert/has-values>
   *
   * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   */



  var typeOf = __webpack_require__(339);
  var isNumber = __webpack_require__(309);

  module.exports = function hasValue(val) {
    // is-number checks for NaN and other edge cases
    if (isNumber(val)) {
      return true;
    }

    switch (typeOf(val)) {
      case 'null':
      case 'boolean':
      case 'function':
        return true;
      case 'string':
      case 'arguments':
        return val.length !== 0;
      case 'error':
        return val.message !== '';
      case 'array':
        var len = val.length;
        if (len === 0) {
          return false;
        }
        for (var i = 0; i < len; i++) {
          if (hasValue(val[i])) {
            return true;
          }
        }
        return false;
      case 'file':
      case 'map':
      case 'set':
        return val.size !== 0;
      case 'object':
        var keys = Object.keys(val);
        if (keys.length === 0) {
          return false;
        }
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (hasValue(val[key])) {
            return true;
          }
        }
        return false;
      default: {
        return false;
      }
    }
  };


  /***/ }),
  /* 339 */
  /***/ (function(module, exports, __webpack_require__) {

  var isBuffer = __webpack_require__(311);
  var toString = Object.prototype.toString;

  /**
   * Get the native `typeof` a value.
   *
   * @param  {*} `val`
   * @return {*} Native javascript type
   */

  module.exports = function kindOf(val) {
    // primitivies
    if (typeof val === 'undefined') {
      return 'undefined';
    }
    if (val === null) {
      return 'null';
    }
    if (val === true || val === false || val instanceof Boolean) {
      return 'boolean';
    }
    if (typeof val === 'string' || val instanceof String) {
      return 'string';
    }
    if (typeof val === 'number' || val instanceof Number) {
      return 'number';
    }

    // functions
    if (typeof val === 'function' || val instanceof Function) {
      return 'function';
    }

    // array
    if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
      return 'array';
    }

    // check for instances of RegExp and Date before calling `toString`
    if (val instanceof RegExp) {
      return 'regexp';
    }
    if (val instanceof Date) {
      return 'date';
    }

    // other objects
    var type = toString.call(val);

    if (type === '[object RegExp]') {
      return 'regexp';
    }
    if (type === '[object Date]') {
      return 'date';
    }
    if (type === '[object Arguments]') {
      return 'arguments';
    }
    if (type === '[object Error]') {
      return 'error';
    }
    if (type === '[object Promise]') {
      return 'promise';
    }

    // buffer
    if (isBuffer(val)) {
      return 'buffer';
    }

    // es6: Map, WeakMap, Set, WeakSet
    if (type === '[object Set]') {
      return 'set';
    }
    if (type === '[object WeakSet]') {
      return 'weakset';
    }
    if (type === '[object Map]') {
      return 'map';
    }
    if (type === '[object WeakMap]') {
      return 'weakmap';
    }
    if (type === '[object Symbol]') {
      return 'symbol';
    }

    // typed arrays
    if (type === '[object Int8Array]') {
      return 'int8array';
    }
    if (type === '[object Uint8Array]') {
      return 'uint8array';
    }
    if (type === '[object Uint8ClampedArray]') {
      return 'uint8clampedarray';
    }
    if (type === '[object Int16Array]') {
      return 'int16array';
    }
    if (type === '[object Uint16Array]') {
      return 'uint16array';
    }
    if (type === '[object Int32Array]') {
      return 'int32array';
    }
    if (type === '[object Uint32Array]') {
      return 'uint32array';
    }
    if (type === '[object Float32Array]') {
      return 'float32array';
    }
    if (type === '[object Float64Array]') {
      return 'float64array';
    }

    // must be a plain object
    return 'object';
  };


  /***/ }),
  /* 340 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var isExtendable = __webpack_require__(297);
  var forIn = __webpack_require__(341);

  function mixinDeep(target, objects) {
    var len = arguments.length, i = 0;
    while (++i < len) {
      var obj = arguments[i];
      if (isObject(obj)) {
        forIn(obj, copy, target);
      }
    }
    return target;
  }

  /**
   * Copy properties from the source object to the
   * target object.
   *
   * @param  {*} `val`
   * @param  {String} `key`
   */

  function copy(val, key) {
    if (!isValidKey(key)) {
      return;
    }

    var obj = this[key];
    if (isObject(val) && isObject(obj)) {
      mixinDeep(obj, val);
    } else {
      this[key] = val;
    }
  }

  /**
   * Returns true if `val` is an object or function.
   *
   * @param  {any} val
   * @return {Boolean}
   */

  function isObject(val) {
    return isExtendable(val) && !Array.isArray(val);
  }

  /**
   * Returns true if `key` is a valid key to use when extending objects.
   *
   * @param  {String} `key`
   * @return {Boolean}
   */

  function isValidKey(key) {
    return key !== '__proto__' && key !== 'constructor' && key !== 'prototype';
  };

  /**
   * Expose `mixinDeep`
   */

  module.exports = mixinDeep;


  /***/ }),
  /* 341 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * for-in <https://github.com/jonschlinkert/for-in>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */



  module.exports = function forIn(obj, fn, thisArg) {
    for (var key in obj) {
      if (fn.call(thisArg, obj[key], key, obj) === false) {
        break;
      }
    }
  };


  /***/ }),
  /* 342 */
  /***/ (function(module, exports) {

  /*!
   * pascalcase <https://github.com/jonschlinkert/pascalcase>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */

  function pascalcase(str) {
    if (typeof str !== 'string') {
      throw new TypeError('expected a string.');
    }
    str = str.replace(/([A-Z])/g, ' $1');
    if (str.length === 1) { return str.toUpperCase(); }
    str = str.replace(/^[\W_]+|[\W_]+$/g, '').toLowerCase();
    str = str.charAt(0).toUpperCase() + str.slice(1);
    return str.replace(/[\W_]+(\w|$)/g, function (_, ch) {
      return ch.toUpperCase();
    });
  }

  module.exports = pascalcase;


  /***/ }),
  /* 343 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var util = __webpack_require__(25);
  var union = __webpack_require__(329);
  var define = __webpack_require__(344);
  var staticExtend = __webpack_require__(349);
  var isObj = __webpack_require__(291);

  /**
   * Expose class utils
   */

  var cu = module.exports;

  /**
   * Expose class utils: `cu`
   */

  cu.isObject = function isObject(val) {
    return isObj(val) || typeof val === 'function';
  };

  /**
   * Returns true if an array has any of the given elements, or an
   * object has any of the give keys.
   *
   * ```js
   * cu.has(['a', 'b', 'c'], 'c');
   * //=> true
   *
   * cu.has(['a', 'b', 'c'], ['c', 'z']);
   * //=> true
   *
   * cu.has({a: 'b', c: 'd'}, ['c', 'z']);
   * //=> true
   * ```
   * @param {Object} `obj`
   * @param {String|Array} `val`
   * @return {Boolean}
   * @api public
   */

  cu.has = function has(obj, val) {
    val = cu.arrayify(val);
    var len = val.length;

    if (cu.isObject(obj)) {
      for (var key in obj) {
        if (val.indexOf(key) > -1) {
          return true;
        }
      }

      var keys = cu.nativeKeys(obj);
      return cu.has(keys, val);
    }

    if (Array.isArray(obj)) {
      var arr = obj;
      while (len--) {
        if (arr.indexOf(val[len]) > -1) {
          return true;
        }
      }
      return false;
    }

    throw new TypeError('expected an array or object.');
  };

  /**
   * Returns true if an array or object has all of the given values.
   *
   * ```js
   * cu.hasAll(['a', 'b', 'c'], 'c');
   * //=> true
   *
   * cu.hasAll(['a', 'b', 'c'], ['c', 'z']);
   * //=> false
   *
   * cu.hasAll({a: 'b', c: 'd'}, ['c', 'z']);
   * //=> false
   * ```
   * @param {Object|Array} `val`
   * @param {String|Array} `values`
   * @return {Boolean}
   * @api public
   */

  cu.hasAll = function hasAll(val, values) {
    values = cu.arrayify(values);
    var len = values.length;
    while (len--) {
      if (!cu.has(val, values[len])) {
        return false;
      }
    }
    return true;
  };

  /**
   * Cast the given value to an array.
   *
   * ```js
   * cu.arrayify('foo');
   * //=> ['foo']
   *
   * cu.arrayify(['foo']);
   * //=> ['foo']
   * ```
   *
   * @param {String|Array} `val`
   * @return {Array}
   * @api public
   */

  cu.arrayify = function arrayify(val) {
    return val ? (Array.isArray(val) ? val : [val]) : [];
  };

  /**
   * Noop
   */

  cu.noop = function noop() {
    return;
  };

  /**
   * Returns the first argument passed to the function.
   */

  cu.identity = function identity(val) {
    return val;
  };

  /**
   * Returns true if a value has a `contructor`
   *
   * ```js
   * cu.hasConstructor({});
   * //=> true
   *
   * cu.hasConstructor(Object.create(null));
   * //=> false
   * ```
   * @param  {Object} `value`
   * @return {Boolean}
   * @api public
   */

  cu.hasConstructor = function hasConstructor(val) {
    return cu.isObject(val) && typeof val.constructor !== 'undefined';
  };

  /**
   * Get the native `ownPropertyNames` from the constructor of the
   * given `object`. An empty array is returned if the object does
   * not have a constructor.
   *
   * ```js
   * cu.nativeKeys({a: 'b', b: 'c', c: 'd'})
   * //=> ['a', 'b', 'c']
   *
   * cu.nativeKeys(function(){})
   * //=> ['length', 'caller']
   * ```
   *
   * @param  {Object} `obj` Object that has a `constructor`.
   * @return {Array} Array of keys.
   * @api public
   */

  cu.nativeKeys = function nativeKeys(val) {
    if (!cu.hasConstructor(val)) return [];
    var keys = Object.getOwnPropertyNames(val);
    if ('caller' in val) keys.push('caller');
    return keys;
  };

  /**
   * Returns property descriptor `key` if it's an "own" property
   * of the given object.
   *
   * ```js
   * function App() {}
   * Object.defineProperty(App.prototype, 'count', {
   *   get: function() {
   *     return Object.keys(this).length;
   *   }
   * });
   * cu.getDescriptor(App.prototype, 'count');
   * // returns:
   * // {
   * //   get: [Function],
   * //   set: undefined,
   * //   enumerable: false,
   * //   configurable: false
   * // }
   * ```
   *
   * @param {Object} `obj`
   * @param {String} `key`
   * @return {Object} Returns descriptor `key`
   * @api public
   */

  cu.getDescriptor = function getDescriptor(obj, key) {
    if (!cu.isObject(obj)) {
      throw new TypeError('expected an object.');
    }
    if (typeof key !== 'string') {
      throw new TypeError('expected key to be a string.');
    }
    return Object.getOwnPropertyDescriptor(obj, key);
  };

  /**
   * Copy a descriptor from one object to another.
   *
   * ```js
   * function App() {}
   * Object.defineProperty(App.prototype, 'count', {
   *   get: function() {
   *     return Object.keys(this).length;
   *   }
   * });
   * var obj = {};
   * cu.copyDescriptor(obj, App.prototype, 'count');
   * ```
   * @param {Object} `receiver`
   * @param {Object} `provider`
   * @param {String} `name`
   * @return {Object}
   * @api public
   */

  cu.copyDescriptor = function copyDescriptor(receiver, provider, name) {
    if (!cu.isObject(receiver)) {
      throw new TypeError('expected receiving object to be an object.');
    }
    if (!cu.isObject(provider)) {
      throw new TypeError('expected providing object to be an object.');
    }
    if (typeof name !== 'string') {
      throw new TypeError('expected name to be a string.');
    }

    var val = cu.getDescriptor(provider, name);
    if (val) Object.defineProperty(receiver, name, val);
  };

  /**
   * Copy static properties, prototype properties, and descriptors
   * from one object to another.
   *
   * @param {Object} `receiver`
   * @param {Object} `provider`
   * @param {String|Array} `omit` One or more properties to omit
   * @return {Object}
   * @api public
   */

  cu.copy = function copy(receiver, provider, omit) {
    if (!cu.isObject(receiver)) {
      throw new TypeError('expected receiving object to be an object.');
    }
    if (!cu.isObject(provider)) {
      throw new TypeError('expected providing object to be an object.');
    }
    var props = Object.getOwnPropertyNames(provider);
    var keys = Object.keys(provider);
    var len = props.length,
      key;
    omit = cu.arrayify(omit);

    while (len--) {
      key = props[len];

      if (cu.has(keys, key)) {
        define(receiver, key, provider[key]);
      } else if (!(key in receiver) && !cu.has(omit, key)) {
        cu.copyDescriptor(receiver, provider, key);
      }
    }
  };

  /**
   * Inherit the static properties, prototype properties, and descriptors
   * from of an object.
   *
   * @param {Object} `receiver`
   * @param {Object} `provider`
   * @param {String|Array} `omit` One or more properties to omit
   * @return {Object}
   * @api public
   */

  cu.inherit = function inherit(receiver, provider, omit) {
    if (!cu.isObject(receiver)) {
      throw new TypeError('expected receiving object to be an object.');
    }
    if (!cu.isObject(provider)) {
      throw new TypeError('expected providing object to be an object.');
    }

    var keys = [];
    for (var key in provider) {
      keys.push(key);
      receiver[key] = provider[key];
    }

    keys = keys.concat(cu.arrayify(omit));

    var a = provider.prototype || provider;
    var b = receiver.prototype || receiver;
    cu.copy(b, a, keys);
  };

  /**
   * Returns a function for extending the static properties,
   * prototype properties, and descriptors from the `Parent`
   * constructor onto `Child` constructors.
   *
   * ```js
   * var extend = cu.extend(Parent);
   * Parent.extend(Child);
   *
   * // optional methods
   * Parent.extend(Child, {
   *   foo: function() {},
   *   bar: function() {}
   * });
   * ```
   * @param {Function} `Parent` Parent ctor
   * @param {Function} `extend` Optional extend function to handle custom extensions. Useful when updating methods that require a specific prototype.
   *   @param {Function} `Child` Child ctor
   *   @param {Object} `proto` Optionally pass additional prototype properties to inherit.
   *   @return {Object}
   * @api public
   */

  cu.extend = function() {
    // keep it lazy, instead of assigning to `cu.extend`
    return staticExtend.apply(null, arguments);
  };

  /**
   * Bubble up events emitted from static methods on the Parent ctor.
   *
   * @param {Object} `Parent`
   * @param {Array} `events` Event names to bubble up
   * @api public
   */

  cu.bubble = function(Parent, events) {
    events = events || [];
    Parent.bubble = function(Child, arr) {
      if (Array.isArray(arr)) {
        events = union([], events, arr);
      }
      var len = events.length;
      var idx = -1;
      while (++idx < len) {
        var name = events[idx];
        Parent.on(name, Child.emit.bind(Child, name));
      }
      cu.bubble(Child, events);
    };
  };


  /***/ }),
  /* 344 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * define-property <https://github.com/jonschlinkert/define-property>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */



  var isDescriptor = __webpack_require__(345);

  module.exports = function defineProperty(obj, prop, val) {
    if (typeof obj !== 'object' && typeof obj !== 'function') {
      throw new TypeError('expected an object or function.');
    }

    if (typeof prop !== 'string') {
      throw new TypeError('expected `prop` to be a string.');
    }

    if (isDescriptor(val) && ('set' in val || 'get' in val)) {
      return Object.defineProperty(obj, prop, val);
    }

    return Object.defineProperty(obj, prop, {
      configurable: true,
      enumerable: false,
      writable: true,
      value: val
    });
  };


  /***/ }),
  /* 345 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * is-descriptor <https://github.com/jonschlinkert/is-descriptor>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */



  var typeOf = __webpack_require__(346);
  var isAccessor = __webpack_require__(347);
  var isData = __webpack_require__(348);

  module.exports = function isDescriptor(obj, key) {
    if (typeOf(obj) !== 'object') {
      return false;
    }
    if ('get' in obj) {
      return isAccessor(obj, key);
    }
    return isData(obj, key);
  };


  /***/ }),
  /* 346 */
  /***/ (function(module, exports) {

  var toString = Object.prototype.toString;

  /**
   * Get the native `typeof` a value.
   *
   * @param  {*} `val`
   * @return {*} Native javascript type
   */

  module.exports = function kindOf(val) {
    var type = typeof val;

    // primitivies
    if (type === 'undefined') {
      return 'undefined';
    }
    if (val === null) {
      return 'null';
    }
    if (val === true || val === false || val instanceof Boolean) {
      return 'boolean';
    }
    if (type === 'string' || val instanceof String) {
      return 'string';
    }
    if (type === 'number' || val instanceof Number) {
      return 'number';
    }

    // functions
    if (type === 'function' || val instanceof Function) {
      if (typeof val.constructor.name !== 'undefined' && val.constructor.name.slice(0, 9) === 'Generator') {
        return 'generatorfunction';
      }
      return 'function';
    }

    // array
    if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
      return 'array';
    }

    // check for instances of RegExp and Date before calling `toString`
    if (val instanceof RegExp) {
      return 'regexp';
    }
    if (val instanceof Date) {
      return 'date';
    }

    // other objects
    type = toString.call(val);

    if (type === '[object RegExp]') {
      return 'regexp';
    }
    if (type === '[object Date]') {
      return 'date';
    }
    if (type === '[object Arguments]') {
      return 'arguments';
    }
    if (type === '[object Error]') {
      return 'error';
    }
    if (type === '[object Promise]') {
      return 'promise';
    }

    // buffer
    if (isBuffer(val)) {
      return 'buffer';
    }

    // es6: Map, WeakMap, Set, WeakSet
    if (type === '[object Set]') {
      return 'set';
    }
    if (type === '[object WeakSet]') {
      return 'weakset';
    }
    if (type === '[object Map]') {
      return 'map';
    }
    if (type === '[object WeakMap]') {
      return 'weakmap';
    }
    if (type === '[object Symbol]') {
      return 'symbol';
    }

    if (type === '[object Map Iterator]') {
      return 'mapiterator';
    }
    if (type === '[object Set Iterator]') {
      return 'setiterator';
    }
    if (type === '[object String Iterator]') {
      return 'stringiterator';
    }
    if (type === '[object Array Iterator]') {
      return 'arrayiterator';
    }

    // typed arrays
    if (type === '[object Int8Array]') {
      return 'int8array';
    }
    if (type === '[object Uint8Array]') {
      return 'uint8array';
    }
    if (type === '[object Uint8ClampedArray]') {
      return 'uint8clampedarray';
    }
    if (type === '[object Int16Array]') {
      return 'int16array';
    }
    if (type === '[object Uint16Array]') {
      return 'uint16array';
    }
    if (type === '[object Int32Array]') {
      return 'int32array';
    }
    if (type === '[object Uint32Array]') {
      return 'uint32array';
    }
    if (type === '[object Float32Array]') {
      return 'float32array';
    }
    if (type === '[object Float64Array]') {
      return 'float64array';
    }

    // must be a plain object
    return 'object';
  };

  /**
   * If you need to support Safari 5-7 (8-10 yr-old browser),
   * take a look at https://github.com/feross/is-buffer
   */

  function isBuffer(val) {
    return val.constructor
      && typeof val.constructor.isBuffer === 'function'
      && val.constructor.isBuffer(val);
  }


  /***/ }),
  /* 347 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * is-accessor-descriptor <https://github.com/jonschlinkert/is-accessor-descriptor>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */



  var typeOf = __webpack_require__(310);

  // accessor descriptor properties
  var accessor = {
    get: 'function',
    set: 'function',
    configurable: 'boolean',
    enumerable: 'boolean'
  };

  function isAccessorDescriptor(obj, prop) {
    if (typeof prop === 'string') {
      var val = Object.getOwnPropertyDescriptor(obj, prop);
      return typeof val !== 'undefined';
    }

    if (typeOf(obj) !== 'object') {
      return false;
    }

    if (has(obj, 'value') || has(obj, 'writable')) {
      return false;
    }

    if (!has(obj, 'get') || typeof obj.get !== 'function') {
      return false;
    }

    // tldr: it's valid to have "set" be undefined
    // "set" might be undefined if `Object.getOwnPropertyDescriptor`
    // was used to get the value, and only `get` was defined by the user
    if (has(obj, 'set') && typeof obj[key] !== 'function' && typeof obj[key] !== 'undefined') {
      return false;
    }

    for (var key in obj) {
      if (!accessor.hasOwnProperty(key)) {
        continue;
      }

      if (typeOf(obj[key]) === accessor[key]) {
        continue;
      }

      if (typeof obj[key] !== 'undefined') {
        return false;
      }
    }
    return true;
  }

  function has(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
  }

  /**
   * Expose `isAccessorDescriptor`
   */

  module.exports = isAccessorDescriptor;


  /***/ }),
  /* 348 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * is-data-descriptor <https://github.com/jonschlinkert/is-data-descriptor>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */



  var typeOf = __webpack_require__(310);

  // data descriptor properties
  var data = {
    configurable: 'boolean',
    enumerable: 'boolean',
    writable: 'boolean'
  };

  function isDataDescriptor(obj, prop) {
    if (typeOf(obj) !== 'object') {
      return false;
    }

    if (typeof prop === 'string') {
      var val = Object.getOwnPropertyDescriptor(obj, prop);
      return typeof val !== 'undefined';
    }

    if (!('value' in obj) && !('writable' in obj)) {
      return false;
    }

    for (var key in obj) {
      if (key === 'value') continue;

      if (!data.hasOwnProperty(key)) {
        continue;
      }

      if (typeOf(obj[key]) === data[key]) {
        continue;
      }

      if (typeof obj[key] !== 'undefined') {
        return false;
      }
    }
    return true;
  }

  /**
   * Expose `isDataDescriptor`
   */

  module.exports = isDataDescriptor;


  /***/ }),
  /* 349 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * static-extend <https://github.com/jonschlinkert/static-extend>
   *
   * Copyright (c) 2016, Jon Schlinkert.
   * Licensed under the MIT License.
   */



  var copy = __webpack_require__(350);
  var define = __webpack_require__(344);
  var util = __webpack_require__(25);

  /**
   * Returns a function for extending the static properties,
   * prototype properties, and descriptors from the `Parent`
   * constructor onto `Child` constructors.
   *
   * ```js
   * var extend = require('static-extend');
   * Parent.extend = extend(Parent);
   *
   * // optionally pass a custom merge function as the second arg
   * Parent.extend = extend(Parent, function(Child) {
   *   Child.prototype.mixin = function(key, val) {
   *     Child.prototype[key] = val;
   *   };
   * });
   *
   * // extend "child" constructors
   * Parent.extend(Child);
   *
   * // optionally define prototype methods as the second arg
   * Parent.extend(Child, {
   *   foo: function() {},
   *   bar: function() {}
   * });
   * ```
   * @param {Function} `Parent` Parent ctor
   * @param {Function} `extendFn` Optional extend function for handling any necessary custom merging. Useful when updating methods that require a specific prototype.
   *   @param {Function} `Child` Child ctor
   *   @param {Object} `proto` Optionally pass additional prototype properties to inherit.
   *   @return {Object}
   * @api public
   */

  function extend(Parent, extendFn) {
    if (typeof Parent !== 'function') {
      throw new TypeError('expected Parent to be a function.');
    }

    return function(Ctor, proto) {
      if (typeof Ctor !== 'function') {
        throw new TypeError('expected Ctor to be a function.');
      }

      util.inherits(Ctor, Parent);
      copy(Ctor, Parent);

      // proto can be null or a plain object
      if (typeof proto === 'object') {
        var obj = Object.create(proto);

        for (var k in obj) {
          Ctor.prototype[k] = obj[k];
        }
      }

      // keep a reference to the parent prototype
      define(Ctor.prototype, '_parent_', {
        configurable: true,
        set: function() {},
        get: function() {
          return Parent.prototype;
        }
      });

      if (typeof extendFn === 'function') {
        extendFn(Ctor, Parent);
      }

      Ctor.extend = extend(Ctor, extendFn);
    };
  };

  /**
   * Expose `extend`
   */

  module.exports = extend;


  /***/ }),
  /* 350 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var typeOf = __webpack_require__(310);
  var copyDescriptor = __webpack_require__(351);
  var define = __webpack_require__(344);

  /**
   * Copy static properties, prototype properties, and descriptors from one object to another.
   *
   * ```js
   * function App() {}
   * var proto = App.prototype;
   * App.prototype.set = function() {};
   * App.prototype.get = function() {};
   *
   * var obj = {};
   * copy(obj, proto);
   * ```
   * @param {Object} `receiver`
   * @param {Object} `provider`
   * @param {String|Array} `omit` One or more properties to omit
   * @return {Object}
   * @api public
   */

  function copy(receiver, provider, omit) {
    if (!isObject(receiver)) {
      throw new TypeError('expected receiving object to be an object.');
    }
    if (!isObject(provider)) {
      throw new TypeError('expected providing object to be an object.');
    }

    var props = nativeKeys(provider);
    var keys = Object.keys(provider);
    var len = props.length;
    omit = arrayify(omit);

    while (len--) {
      var key = props[len];

      if (has(keys, key)) {
        define(receiver, key, provider[key]);
      } else if (!(key in receiver) && !has(omit, key)) {
        copyDescriptor(receiver, provider, key);
      }
    }
  };

  /**
   * Return true if the given value is an object or function
   */

  function isObject(val) {
    return typeOf(val) === 'object' || typeof val === 'function';
  }

  /**
   * Returns true if an array has any of the given elements, or an
   * object has any of the give keys.
   *
   * ```js
   * has(['a', 'b', 'c'], 'c');
   * //=> true
   *
   * has(['a', 'b', 'c'], ['c', 'z']);
   * //=> true
   *
   * has({a: 'b', c: 'd'}, ['c', 'z']);
   * //=> true
   * ```
   * @param {Object} `obj`
   * @param {String|Array} `val`
   * @return {Boolean}
   */

  function has(obj, val) {
    val = arrayify(val);
    var len = val.length;

    if (isObject(obj)) {
      for (var key in obj) {
        if (val.indexOf(key) > -1) {
          return true;
        }
      }

      var keys = nativeKeys(obj);
      return has(keys, val);
    }

    if (Array.isArray(obj)) {
      var arr = obj;
      while (len--) {
        if (arr.indexOf(val[len]) > -1) {
          return true;
        }
      }
      return false;
    }

    throw new TypeError('expected an array or object.');
  }

  /**
   * Cast the given value to an array.
   *
   * ```js
   * arrayify('foo');
   * //=> ['foo']
   *
   * arrayify(['foo']);
   * //=> ['foo']
   * ```
   *
   * @param {String|Array} `val`
   * @return {Array}
   */

  function arrayify(val) {
    return val ? (Array.isArray(val) ? val : [val]) : [];
  }

  /**
   * Returns true if a value has a `contructor`
   *
   * ```js
   * hasConstructor({});
   * //=> true
   *
   * hasConstructor(Object.create(null));
   * //=> false
   * ```
   * @param  {Object} `value`
   * @return {Boolean}
   */

  function hasConstructor(val) {
    return isObject(val) && typeof val.constructor !== 'undefined';
  }

  /**
   * Get the native `ownPropertyNames` from the constructor of the
   * given `object`. An empty array is returned if the object does
   * not have a constructor.
   *
   * ```js
   * nativeKeys({a: 'b', b: 'c', c: 'd'})
   * //=> ['a', 'b', 'c']
   *
   * nativeKeys(function(){})
   * //=> ['length', 'caller']
   * ```
   *
   * @param  {Object} `obj` Object that has a `constructor`.
   * @return {Array} Array of keys.
   */

  function nativeKeys(val) {
    if (!hasConstructor(val)) return [];
    return Object.getOwnPropertyNames(val);
  }

  /**
   * Expose `copy`
   */

  module.exports = copy;

  /**
   * Expose `copy.has` for tests
   */

  module.exports.has = has;


  /***/ }),
  /* 351 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * copy-descriptor <https://github.com/jonschlinkert/copy-descriptor>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */



  /**
   * Copy a descriptor from one object to another.
   *
   * ```js
   * function App() {
   *   this.cache = {};
   * }
   * App.prototype.set = function(key, val) {
   *   this.cache[key] = val;
   *   return this;
   * };
   * Object.defineProperty(App.prototype, 'count', {
   *   get: function() {
   *     return Object.keys(this.cache).length;
   *   }
   * });
   *
   * copy(App.prototype, 'count', 'len');
   *
   * // create an instance
   * var app = new App();
   *
   * app.set('a', true);
   * app.set('b', true);
   * app.set('c', true);
   *
   * console.log(app.count);
   * //=> 3
   * console.log(app.len);
   * //=> 3
   * ```
   * @name copy
   * @param {Object} `receiver` The target object
   * @param {Object} `provider` The provider object
   * @param {String} `from` The key to copy on provider.
   * @param {String} `to` Optionally specify a new key name to use.
   * @return {Object}
   * @api public
   */

  module.exports = function copyDescriptor(receiver, provider, from, to) {
    if (!isObject(provider) && typeof provider !== 'function') {
      to = from;
      from = provider;
      provider = receiver;
    }
    if (!isObject(receiver) && typeof receiver !== 'function') {
      throw new TypeError('expected the first argument to be an object');
    }
    if (!isObject(provider) && typeof provider !== 'function') {
      throw new TypeError('expected provider to be an object');
    }

    if (typeof to !== 'string') {
      to = from;
    }
    if (typeof from !== 'string') {
      throw new TypeError('expected key to be a string');
    }

    if (!(from in provider)) {
      throw new Error('property "' + from + '" does not exist');
    }

    var val = Object.getOwnPropertyDescriptor(provider, from);
    if (val) Object.defineProperty(receiver, to, val);
  };

  function isObject(val) {
    return {}.toString.call(val) === '[object Object]';
  }



  /***/ }),
  /* 352 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var use = __webpack_require__(353);
  var define = __webpack_require__(344);
  var debug = __webpack_require__(354)('snapdragon:compiler');
  var utils = __webpack_require__(357);

  /**
   * Create a new `Compiler` with the given `options`.
   * @param {Object} `options`
   */

  function Compiler(options, state) {
    debug('initializing', __filename);
    this.options = utils.extend({source: 'string'}, options);
    this.state = state || {};
    this.compilers = {};
    this.output = '';
    this.set('eos', function(node) {
      return this.emit(node.val, node);
    });
    this.set('noop', function(node) {
      return this.emit(node.val, node);
    });
    this.set('bos', function(node) {
      return this.emit(node.val, node);
    });
    use(this);
  }

  /**
   * Prototype methods
   */

  Compiler.prototype = {

    /**
     * Throw an error message with details including the cursor position.
     * @param {String} `msg` Message to use in the Error.
     */

    error: function(msg, node) {
      var pos = node.position || {start: {column: 0}};
      var message = this.options.source + ' column:' + pos.start.column + ': ' + msg;

      var err = new Error(message);
      err.reason = msg;
      err.column = pos.start.column;
      err.source = this.pattern;

      if (this.options.silent) {
        this.errors.push(err);
      } else {
        throw err;
      }
    },

    /**
     * Define a non-enumberable property on the `Compiler` instance.
     *
     * ```js
     * compiler.define('foo', 'bar');
     * ```
     * @name .define
     * @param {String} `key` propery name
     * @param {any} `val` property value
     * @return {Object} Returns the Compiler instance for chaining.
     * @api public
     */

    define: function(key, val) {
      define(this, key, val);
      return this;
    },

    /**
     * Emit `node.val`
     */

    emit: function(str, node) {
      this.output += str;
      return str;
    },

    /**
     * Add a compiler `fn` with the given `name`
     */

    set: function(name, fn) {
      this.compilers[name] = fn;
      return this;
    },

    /**
     * Get compiler `name`.
     */

    get: function(name) {
      return this.compilers[name];
    },

    /**
     * Get the previous AST node.
     */

    prev: function(n) {
      return this.ast.nodes[this.idx - (n || 1)] || { type: 'bos', val: '' };
    },

    /**
     * Get the next AST node.
     */

    next: function(n) {
      return this.ast.nodes[this.idx + (n || 1)] || { type: 'eos', val: '' };
    },

    /**
     * Visit `node`.
     */

    visit: function(node, nodes, i) {
      var fn = this.compilers[node.type];
      this.idx = i;

      if (typeof fn !== 'function') {
        throw this.error('compiler "' + node.type + '" is not registered', node);
      }
      return fn.call(this, node, nodes, i);
    },

    /**
     * Map visit over array of `nodes`.
     */

    mapVisit: function(nodes) {
      if (!Array.isArray(nodes)) {
        throw new TypeError('expected an array');
      }
      var len = nodes.length;
      var idx = -1;
      while (++idx < len) {
        this.visit(nodes[idx], nodes, idx);
      }
      return this;
    },

    /**
     * Compile `ast`.
     */

    compile: function(ast, options) {
      var opts = utils.extend({}, this.options, options);
      this.ast = ast;
      this.parsingErrors = this.ast.errors;
      this.output = '';

      // source map support
      if (opts.sourcemap) {
        var sourcemaps = __webpack_require__(372);
        sourcemaps(this);
        this.mapVisit(this.ast.nodes);
        this.applySourceMaps();
        this.map = opts.sourcemap === 'generator' ? this.map : this.map.toJSON();
        return this;
      }

      this.mapVisit(this.ast.nodes);
      return this;
    }
  };

  /**
   * Expose `Compiler`
   */

  module.exports = Compiler;


  /***/ }),
  /* 353 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * use <https://github.com/jonschlinkert/use>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */



  module.exports = function base(app, options) {
    if (!isObject(app) && typeof app !== 'function') {
      throw new TypeError('expected an object or function');
    }

    var opts = isObject(options) ? options : {};
    var prop = typeof opts.prop === 'string' ? opts.prop : 'fns';
    if (!Array.isArray(app[prop])) {
      define(app, prop, []);
    }

    /**
     * Define a plugin function to be passed to use. The only
     * parameter exposed to the plugin is `app`, the object or function.
     * passed to `use(app)`. `app` is also exposed as `this` in plugins.
     *
     * Additionally, **if a plugin returns a function, the function will
     * be pushed onto the `fns` array**, allowing the plugin to be
     * called at a later point by the `run` method.
     *
     * ```js
     * var use = require('use');
     *
     * // define a plugin
     * function foo(app) {
     *   // do stuff
     * }
     *
     * var app = function(){};
     * use(app);
     *
     * // register plugins
     * app.use(foo);
     * app.use(bar);
     * app.use(baz);
     * ```
     * @name .use
     * @param {Function} `fn` plugin function to call
     * @api public
     */

    define(app, 'use', use);

    /**
     * Run all plugins on `fns`. Any plugin that returns a function
     * when called by `use` is pushed onto the `fns` array.
     *
     * ```js
     * var config = {};
     * app.run(config);
     * ```
     * @name .run
     * @param {Object} `value` Object to be modified by plugins.
     * @return {Object} Returns the object passed to `run`
     * @api public
     */

    define(app, 'run', function(val) {
      if (!isObject(val)) return;

      if (!val.use || !val.run) {
        define(val, prop, val[prop] || []);
        define(val, 'use', use);
      }

      if (!val[prop] || val[prop].indexOf(base) === -1) {
        val.use(base);
      }

      var self = this || app;
      var fns = self[prop];
      var len = fns.length;
      var idx = -1;

      while (++idx < len) {
        val.use(fns[idx]);
      }
      return val;
    });

    /**
     * Call plugin `fn`. If a function is returned push it into the
     * `fns` array to be called by the `run` method.
     */

    function use(type, fn, options) {
      var offset = 1;

      if (typeof type === 'string' || Array.isArray(type)) {
        fn = wrap(type, fn);
        offset++;
      } else {
        options = fn;
        fn = type;
      }

      if (typeof fn !== 'function') {
        throw new TypeError('expected a function');
      }

      var self = this || app;
      var fns = self[prop];

      var args = [].slice.call(arguments, offset);
      args.unshift(self);

      if (typeof opts.hook === 'function') {
        opts.hook.apply(self, args);
      }

      var val = fn.apply(self, args);
      if (typeof val === 'function' && fns.indexOf(val) === -1) {
        fns.push(val);
      }
      return self;
    }

    /**
     * Wrap a named plugin function so that it's only called on objects of the
     * given `type`
     *
     * @param {String} `type`
     * @param {Function} `fn` Plugin function
     * @return {Function}
     */

    function wrap(type, fn) {
      return function plugin() {
        return this.type === type ? fn.apply(this, arguments) : plugin;
      };
    }

    return app;
  };

  function isObject(val) {
    return val && typeof val === 'object' && !Array.isArray(val);
  }

  function define(obj, key, val) {
    Object.defineProperty(obj, key, {
      configurable: true,
      writable: true,
      value: val
    });
  }


  /***/ }),
  /* 354 */
  /***/ (function(module, exports, __webpack_require__) {

  /**
   * This is the web browser implementation of `debug()`.
   *
   * Expose `debug()` as the module.
   */

  exports = module.exports = __webpack_require__(355);
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = 'undefined' != typeof chrome
                 && 'undefined' != typeof chrome.storage
                    ? chrome.storage.local
                    : localstorage();

  /**
   * Colors.
   */

  exports.colors = [
    'lightseagreen',
    'forestgreen',
    'goldenrod',
    'dodgerblue',
    'darkorchid',
    'crimson'
  ];

  /**
   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
   * and the Firebug extension (any Firefox version) are known
   * to support "%c" CSS customizations.
   *
   * TODO: add a `localStorage` variable to explicitly enable/disable colors
   */

  function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
      return true;
    }

    // is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
      // is firebug? http://stackoverflow.com/a/398120/376773
      (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
      // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
      // double check webkit in userAgent just in case we are in a worker
      (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
  }

  /**
   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
   */

  exports.formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (err) {
      return '[UnexpectedJSONParseError]: ' + err.message;
    }
  };


  /**
   * Colorize log arguments if enabled.
   *
   * @api public
   */

  function formatArgs(args) {
    var useColors = this.useColors;

    args[0] = (useColors ? '%c' : '')
      + this.namespace
      + (useColors ? ' %c' : ' ')
      + args[0]
      + (useColors ? '%c ' : ' ')
      + '+' + exports.humanize(this.diff);

    if (!useColors) return;

    var c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit')

    // the final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function(match) {
      if ('%%' === match) return;
      index++;
      if ('%c' === match) {
        // we only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
      }
    });

    args.splice(lastC, 0, c);
  }

  /**
   * Invokes `console.log()` when available.
   * No-op when `console.log` is not a "function".
   *
   * @api public
   */

  function log() {
    // this hackery is required for IE8/9, where
    // the `console.log` function doesn't have 'apply'
    return 'object' === typeof console
      && console.log
      && Function.prototype.apply.call(console.log, console, arguments);
  }

  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */

  function save(namespaces) {
    try {
      if (null == namespaces) {
        exports.storage.removeItem('debug');
      } else {
        exports.storage.debug = namespaces;
      }
    } catch(e) {}
  }

  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */

  function load() {
    var r;
    try {
      r = exports.storage.debug;
    } catch(e) {}

    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof process !== 'undefined' && 'env' in process) {
      r = process.env.DEBUG;
    }

    return r;
  }

  /**
   * Enable namespaces listed in `localStorage.debug` initially.
   */

  exports.enable(load());

  /**
   * Localstorage attempts to return the localstorage.
   *
   * This is necessary because safari throws
   * when a user disables cookies/localstorage
   * and you attempt to access it.
   *
   * @return {LocalStorage}
   * @api private
   */

  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {}
  }


  /***/ }),
  /* 355 */
  /***/ (function(module, exports, __webpack_require__) {


  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   *
   * Expose `debug()` as the module.
   */

  exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
  exports.coerce = coerce;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = __webpack_require__(356);

  /**
   * The currently active debug mode names, and names to skip.
   */

  exports.names = [];
  exports.skips = [];

  /**
   * Map of special "%n" handling functions, for the debug "format" argument.
   *
   * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
   */

  exports.formatters = {};

  /**
   * Previous log timestamp.
   */

  var prevTime;

  /**
   * Select a color.
   * @param {String} namespace
   * @return {Number}
   * @api private
   */

  function selectColor(namespace) {
    var hash = 0, i;

    for (i in namespace) {
      hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return exports.colors[Math.abs(hash) % exports.colors.length];
  }

  /**
   * Create a debugger with the given `namespace`.
   *
   * @param {String} namespace
   * @return {Function}
   * @api public
   */

  function createDebug(namespace) {

    function debug() {
      // disabled?
      if (!debug.enabled) return;

      var self = debug;

      // set `diff` timestamp
      var curr = +new Date();
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;

      // turn the `arguments` into a proper Array
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }

      args[0] = exports.coerce(args[0]);

      if ('string' !== typeof args[0]) {
        // anything else let's inspect with %O
        args.unshift('%O');
      }

      // apply any `formatters` transformations
      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
        // if we encounter an escaped % then don't increase the array index
        if (match === '%%') return match;
        index++;
        var formatter = exports.formatters[format];
        if ('function' === typeof formatter) {
          var val = args[index];
          match = formatter.call(self, val);

          // now we need to remove `args[index]` since it's inlined in the `format`
          args.splice(index, 1);
          index--;
        }
        return match;
      });

      // apply env-specific formatting (colors, etc.)
      exports.formatArgs.call(self, args);

      var logFn = debug.log || exports.log || console.log.bind(console);
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = exports.enabled(namespace);
    debug.useColors = exports.useColors();
    debug.color = selectColor(namespace);

    // env-specific initialization logic for debug instances
    if ('function' === typeof exports.init) {
      exports.init(debug);
    }

    return debug;
  }

  /**
   * Enables a debug mode by namespaces. This can include modes
   * separated by a colon and wildcards.
   *
   * @param {String} namespaces
   * @api public
   */

  function enable(namespaces) {
    exports.save(namespaces);

    exports.names = [];
    exports.skips = [];

    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (var i = 0; i < len; i++) {
      if (!split[i]) continue; // ignore empty strings
      namespaces = split[i].replace(/\*/g, '.*?');
      if (namespaces[0] === '-') {
        exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        exports.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }

  /**
   * Disable debug output.
   *
   * @api public
   */

  function disable() {
    exports.enable('');
  }

  /**
   * Returns true if the given mode name is enabled, false otherwise.
   *
   * @param {String} name
   * @return {Boolean}
   * @api public
   */

  function enabled(name) {
    var i, len;
    for (i = 0, len = exports.skips.length; i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports.names.length; i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Coerce `val`.
   *
   * @param {Mixed} val
   * @return {Mixed}
   * @api private
   */

  function coerce(val) {
    if (val instanceof Error) return val.stack || val.message;
    return val;
  }


  /***/ }),
  /* 356 */
  /***/ (function(module, exports) {

  /**
   * Helpers.
   */

  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;

  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} [options]
   * @throws {Error} throw an error if val is not a non-empty string or a number
   * @return {String|Number}
   * @api public
   */

  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
      return parse(val);
    } else if (type === 'number' && isNaN(val) === false) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      'val is not a non-empty string or a valid number. val=' +
        JSON.stringify(val)
    );
  };

  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */

  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
      default:
        return undefined;
    }
  }

  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtShort(ms) {
    if (ms >= d) {
      return Math.round(ms / d) + 'd';
    }
    if (ms >= h) {
      return Math.round(ms / h) + 'h';
    }
    if (ms >= m) {
      return Math.round(ms / m) + 'm';
    }
    if (ms >= s) {
      return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
  }

  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtLong(ms) {
    return plural(ms, d, 'day') ||
      plural(ms, h, 'hour') ||
      plural(ms, m, 'minute') ||
      plural(ms, s, 'second') ||
      ms + ' ms';
  }

  /**
   * Pluralization helper.
   */

  function plural(ms, n, name) {
    if (ms < n) {
      return;
    }
    if (ms < n * 1.5) {
      return Math.floor(ms / n) + ' ' + name;
    }
    return Math.ceil(ms / n) + ' ' + name + 's';
  }


  /***/ }),
  /* 357 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  /**
   * Module dependencies
   */

  exports.extend = __webpack_require__(302);
  exports.SourceMap = __webpack_require__(358);
  exports.sourceMapResolve = __webpack_require__(369);

  /**
   * Convert backslash in the given string to forward slashes
   */

  exports.unixify = function(fp) {
    return fp.split(/\\+/).join('/');
  };

  /**
   * Return true if `val` is a non-empty string
   *
   * @param {String} `str`
   * @return {Boolean}
   */

  exports.isString = function(str) {
    return str && typeof str === 'string';
  };

  /**
   * Cast `val` to an array
   * @return {Array}
   */

  exports.arrayify = function(val) {
    if (typeof val === 'string') return [val];
    return val ? (Array.isArray(val) ? val : [val]) : [];
  };

  /**
   * Get the last `n` element from the given `array`
   * @param {Array} `array`
   * @return {*}
   */

  exports.last = function(arr, n) {
    return arr[arr.length - (n || 1)];
  };


  /***/ }),
  /* 358 */
  /***/ (function(module, exports, __webpack_require__) {

  /*
   * Copyright 2009-2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE.txt or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  exports.SourceMapGenerator = __webpack_require__(359).SourceMapGenerator;
  exports.SourceMapConsumer = __webpack_require__(365).SourceMapConsumer;
  exports.SourceNode = __webpack_require__(368).SourceNode;


  /***/ }),
  /* 359 */
  /***/ (function(module, exports, __webpack_require__) {

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var base64VLQ = __webpack_require__(360);
  var util = __webpack_require__(362);
  var ArraySet = __webpack_require__(363).ArraySet;
  var MappingList = __webpack_require__(364).MappingList;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }

      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }

      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }

      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent != null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
          this._sourcesContents = Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
            'or the source map\'s "file" property. Both were omitted.'
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "sourceFile" relative if an absolute Url is passed.
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet();
      var newNames = new ArraySet();

      // Find mappings for the "sourceFile"
      this._mappings.unsortedForEach(function (mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            // Copy mapping
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source)
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile = util.join(aSourceMapPath, sourceFile);
          }
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      // When aOriginal is truthy but has empty values for .line and .column,
      // it is most likely a programmer error. In this case we throw a very
      // specific error message to try to guide them the right way.
      // For example: https://github.com/Polymer/polymer-bundler/pull/519
      if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
          throw new Error(
              'original.line and original.column are not numbers -- you probably meant to omit ' +
              'the original mapping entirely and only map the generated position. If so, pass ' +
              'null for the original mapping instead of an object with empty or null values.'
          );
      }

      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;

      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = ''

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ',';
          }
        }

        next += base64VLQ.encode(mapping.generatedColumn
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;

          // lines are stored 0-based in SourceMap spec version 3
          next += base64VLQ.encode(mapping.originalLine - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          next += base64VLQ.encode(mapping.originalColumn
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }

        result += next;
      }

      return result;
    };

  SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };

  exports.SourceMapGenerator = SourceMapGenerator;


  /***/ }),
  /* 360 */
  /***/ (function(module, exports, __webpack_require__) {

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   *
   * Based on the Base 64 VLQ implementation in Closure Compiler:
   * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
   *
   * Copyright 2011 The Closure Compiler Authors. All rights reserved.
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   *  * Redistributions of source code must retain the above copyright
   *    notice, this list of conditions and the following disclaimer.
   *  * Redistributions in binary form must reproduce the above
   *    copyright notice, this list of conditions and the following
   *    disclaimer in the documentation and/or other materials provided
   *    with the distribution.
   *  * Neither the name of Google Inc. nor the names of its
   *    contributors may be used to endorse or promote products derived
   *    from this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */

  var base64 = __webpack_require__(361);

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
      ? -shifted
      : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string via the out parameter.
   */
  exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }

      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }

      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };


  /***/ }),
  /* 361 */
  /***/ (function(module, exports) {

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  exports.encode = function (number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };

  /**
   * Decode a single base 64 character code digit to an integer. Returns -1 on
   * failure.
   */
  exports.decode = function (charCode) {
    var bigA = 65;     // 'A'
    var bigZ = 90;     // 'Z'

    var littleA = 97;  // 'a'
    var littleZ = 122; // 'z'

    var zero = 48;     // '0'
    var nine = 57;     // '9'

    var plus = 43;     // '+'
    var slash = 47;    // '/'

    var littleOffset = 26;
    var numberOffset = 52;

    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
    if (bigA <= charCode && charCode <= bigZ) {
      return (charCode - bigA);
    }

    // 26 - 51: abcdefghijklmnopqrstuvwxyz
    if (littleA <= charCode && charCode <= littleZ) {
      return (charCode - littleA + littleOffset);
    }

    // 52 - 61: 0123456789
    if (zero <= charCode && charCode <= nine) {
      return (charCode - zero + numberOffset);
    }

    // 62: +
    if (charCode == plus) {
      return 62;
    }

    // 63: /
    if (charCode == slash) {
      return 63;
    }

    // Invalid base64 digit.
    return -1;
  };


  /***/ }),
  /* 362 */
  /***/ (function(module, exports) {

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = '';
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
    }
    url += '//';
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  /**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consecutive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */
  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = exports.isAbsolute(path);

    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === '.') {
        parts.splice(i, 1);
      } else if (part === '..') {
        up++;
      } else if (up > 0) {
        if (part === '') {
          // The first part is blank if the path is absolute. Trying to go
          // above the root is a no-op. Therefore we can remove all '..' parts
          // directly after the root.
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join('/');

    if (path === '') {
      path = isAbsolute ? '/' : '.';
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  }
  exports.normalize = normalize;

  /**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
    }

    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined = aPath.charAt(0) === '/'
      ? aPath
      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;

  exports.isAbsolute = function (aPath) {
    return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
  };

  /**
   * Make a path relative to a URL or another path.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be made relative to aRoot.
   */
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    aRoot = aRoot.replace(/\/$/, '');

    // It is possible for the path to be above the root. In this case, simply
    // checking whether the root is a prefix of the path won't work. Instead, we
    // need to remove components from the root one by one, until either we find
    // a prefix that fits, or we run out of components to remove.
    var level = 0;
    while (aPath.indexOf(aRoot + '/') !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }

      // If the only part of the root that is left is the scheme (i.e. http://,
      // file:///, etc.), one or more slashes (/), or simply nothing at all, we
      // have exhausted all components, so the path is not relative to the root.
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }

      ++level;
    }

    // Make sure we add a "../" for each component we removed from the root.
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }
  exports.relative = relative;

  var supportsNullProto = (function () {
    var obj = Object.create(null);
    return !('__proto__' in obj);
  }());

  function identity (s) {
    return s;
  }

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    if (isProtoString(aStr)) {
      return '$' + aStr;
    }

    return aStr;
  }
  exports.toSetString = supportsNullProto ? identity : toSetString;

  function fromSetString(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }

    return aStr;
  }
  exports.fromSetString = supportsNullProto ? identity : fromSetString;

  function isProtoString(s) {
    if (!s) {
      return false;
    }

    var length = s.length;

    if (length < 9 /* "__proto__".length */) {
      return false;
    }

    if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
        s.charCodeAt(length - 2) !== 95  /* '_' */ ||
        s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
        s.charCodeAt(length - 4) !== 116 /* 't' */ ||
        s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
        s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
        s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
        s.charCodeAt(length - 8) !== 95  /* '_' */ ||
        s.charCodeAt(length - 9) !== 95  /* '_' */) {
      return false;
    }

    for (var i = length - 10; i >= 0; i--) {
      if (s.charCodeAt(i) !== 36 /* '$' */) {
        return false;
      }
    }

    return true;
  }

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = mappingA.source - mappingB.source;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    return mappingA.name - mappingB.name;
  }
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings with deflated source and name indices where
   * the generated positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }

    cmp = mappingA.source - mappingB.source;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }

    return mappingA.name - mappingB.name;
  }
  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }

    if (aStr1 > aStr2) {
      return 1;
    }

    return -1;
  }

  /**
   * Comparator between two mappings with inflated source and name strings where
   * the generated positions are compared.
   */
  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;


  /***/ }),
  /* 363 */
  /***/ (function(module, exports, __webpack_require__) {

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var util = __webpack_require__(362);
  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Return how many unique items are in this ArraySet. If duplicates have been
   * added, than those do not count towards the size.
   *
   * @returns Number
   */
  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
          return idx;
      }
    } else {
      var sStr = util.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }

    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  exports.ArraySet = ArraySet;


  /***/ }),
  /* 364 */
  /***/ (function(module, exports, __webpack_require__) {

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2014 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var util = __webpack_require__(362);

  /**
   * Determine whether mappingB is after mappingA with respect to generated
   * position.
   */
  function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA ||
           util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }

  /**
   * A data structure to provide a sorted view of accumulated mappings in a
   * performance conscious manner. It trades a neglibable overhead in general
   * case for a large speedup in case of mappings being added in order.
   */
  function MappingList() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {generatedLine: -1, generatedColumn: 0};
  }

  /**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */
  MappingList.prototype.unsortedForEach =
    function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };

  /**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };

  /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };

  exports.MappingList = MappingList;


  /***/ }),
  /* 365 */
  /***/ (function(module, exports, __webpack_require__) {

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var util = __webpack_require__(362);
  var binarySearch = __webpack_require__(366);
  var ArraySet = __webpack_require__(363).ArraySet;
  var base64VLQ = __webpack_require__(360);
  var quickSort = __webpack_require__(367).quickSort;

  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    return sourceMap.sections != null
      ? new IndexedSourceMapConsumer(sourceMap)
      : new BasicSourceMapConsumer(sourceMap);
  }

  SourceMapConsumer.fromSourceMap = function(aSourceMap) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
  }

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  SourceMapConsumer.prototype._charIsMappingSeparator =
    function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        if (source != null && sourceRoot != null) {
          source = util.join(sourceRoot, source);
        }
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };

  /**
   * Returns all generated line and column information for the original source,
   * line, and column provided. If no column is provided, returns all mappings
   * corresponding to a either the line we are searching for or the next
   * closest line that has any mappings. Otherwise, returns all mappings
   * corresponding to the given line and either the column we are searching for
   * or the next closest column that has any offsets.
   *
   * The only argument is an object with the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: Optional. the column number in the original source.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.allGeneratedPositionsFor =
    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, 'line');

      // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
      // returns the index of the closest mapping less than the needle. By
      // setting needle.originalColumn to 0, we thus find the last mapping for
      // the given line, provided such a mapping exists.
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: line,
        originalColumn: util.getArg(aArgs, 'column', 0)
      };

      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }
      if (!this._sources.has(needle.source)) {
        return [];
      }
      needle.source = this._sources.indexOf(needle.source);

      var mappings = [];

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions,
                                    binarySearch.LEAST_UPPER_BOUND);
      if (index >= 0) {
        var mapping = this._originalMappings[index];

        if (aArgs.column === undefined) {
          var originalLine = mapping.originalLine;

          // Iterate until either we run out of mappings, or we run into
          // a mapping for a different line than the one we found. Since
          // mappings are sorted, this is guaranteed to find all mappings for
          // the line we found.
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, 'generatedLine', null),
              column: util.getArg(mapping, 'generatedColumn', null),
              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
            });

            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;

          // Iterate until either we run out of mappings, or we run into
          // a mapping for a different line than the one we were searching for.
          // Since mappings are sorted, this is guaranteed to find all mappings for
          // the line we are searching for.
          while (mapping &&
                 mapping.originalLine === line &&
                 mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, 'generatedLine', null),
              column: util.getArg(mapping, 'generatedColumn', null),
              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
            });

            mapping = this._originalMappings[++index];
          }
        }
      }

      return mappings;
    };

  exports.SourceMapConsumer = SourceMapConsumer;

  /**
   * A BasicSourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function BasicSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    sources = sources
      .map(String)
      // Some source maps produce relative source paths like "./foo.js" instead of
      // "foo.js".  Normalize these first so that future comparisons will succeed.
      // See bugzil.la/1090768.
      .map(util.normalize)
      // Always ensure that absolute sources are internally stored relative to
      // the source root, if the source root is absolute. Not doing this would
      // be particularly problematic when the source root is a prefix of the
      // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
      .map(function (source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
          ? util.relative(sourceRoot, source)
          : source;
      });

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

  /**
   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns BasicSourceMapConsumer
   */
  BasicSourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);

      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;

      // Because we are modifying the entries (by converting string sources and
      // names to indices into the sources and names ArraySets), we have to make
      // a copy of the entry or else bad things happen. Shared mutable state
      // strikes again! See github issue #191.

      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];

      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping;
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;

        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;

          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }

          destOriginalMappings.push(destMapping);
        }

        destGeneratedMappings.push(destMapping);
      }

      quickSort(smc.__originalMappings, util.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  BasicSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  /**
   * Provide the JIT with a nice shape / hidden class.
   */
  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  BasicSourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;

      while (index < length) {
        if (aStr.charAt(index) === ';') {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        }
        else if (aStr.charAt(index) === ',') {
          index++;
        }
        else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;

          // Because each offset is encoded relative to the previous one,
          // many segments often have the same encoding. We can exploit this
          // fact by caching the parsed variable length fields of each segment,
          // allowing us to avoid a second parse if we encounter the same
          // segment again.
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);

          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }

            if (segment.length === 2) {
              throw new Error('Found a source, but no line and column');
            }

            if (segment.length === 3) {
              throw new Error('Found a source and line, but no column');
            }

            cachedSegments[str] = segment;
          }

          // Generated column.
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;

          if (segment.length > 1) {
            // Original source.
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];

            // Original line.
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;

            // Original column.
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;

            if (segment.length > 4) {
              // Original name.
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }

          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            originalMappings.push(mapping);
          }
        }
      }

      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;

      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  BasicSourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator, aBias) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };

  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */
  BasicSourceMapConsumer.prototype.computeColumnSpans =
    function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];

        // Mappings do not contain a field for the last generated columnt. We
        // can come up with an optimistic estimate, however, by assuming that
        // mappings are contiguous (i.e. given two consecutive mappings, the
        // first mapping ends where the second one starts).
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];

          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }

        // The last mapping for each line spans the entire line.
        mapping.lastGeneratedColumn = Infinity;
      }
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  BasicSourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
      );

      if (index >= 0) {
        var mapping = this._generatedMappings[index];

        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, 'source', null);
          if (source !== null) {
            source = this._sources.at(source);
            if (this.sourceRoot != null) {
              source = util.join(this.sourceRoot, source);
            }
          }
          var name = util.getArg(mapping, 'name', null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source: source,
            line: util.getArg(mapping, 'originalLine', null),
            column: util.getArg(mapping, 'originalColumn', null),
            name: name
          };
        }
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
    function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() &&
        !this.sourcesContent.some(function (sc) { return sc == null; });
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  BasicSourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }

      if (this.sourceRoot != null) {
        aSource = util.relative(this.sourceRoot, aSource);
      }

      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }

      var url;
      if (this.sourceRoot != null
          && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }

      // This function is used recursively from
      // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
      // don't want to throw if we can't find the source - we just want to
      // return null, so we provide a flag to exit gracefully.
      if (nullOnMissing) {
        return null;
      }
      else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  BasicSourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, 'source');
      if (this.sourceRoot != null) {
        source = util.relative(this.sourceRoot, source);
      }
      if (!this._sources.has(source)) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      source = this._sources.indexOf(source);

      var needle = {
        source: source,
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
      );

      if (index >= 0) {
        var mapping = this._originalMappings[index];

        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          };
        }
      }

      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };

  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

  /**
   * An IndexedSourceMapConsumer instance represents a parsed source map which
   * we can query for information. It differs from BasicSourceMapConsumer in
   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
   * input.
   *
   * The only parameter is a raw source map (either as a JSON string, or already
   * parsed to an object). According to the spec for indexed source maps, they
   * have the following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - file: Optional. The generated file this source map is associated with.
   *   - sections: A list of section definitions.
   *
   * Each value under the "sections" field has two fields:
   *   - offset: The offset into the original specified at which this section
   *       begins to apply, defined as an object with a "line" and "column"
   *       field.
   *   - map: A source map definition. This source map could also be indexed,
   *       but doesn't have to be.
   *
   * Instead of the "map" field, it's also possible to have a "url" field
   * specifying a URL to retrieve a source map from, but that's currently
   * unsupported.
   *
   * Here's an example source map, taken from the source map spec[0], but
   * modified to omit a section which uses the "url" field.
   *
   *  {
   *    version : 3,
   *    file: "app.js",
   *    sections: [{
   *      offset: {line:100, column:10},
   *      map: {
   *        version : 3,
   *        file: "section.js",
   *        sources: ["foo.js", "bar.js"],
   *        names: ["src", "maps", "are", "fun"],
   *        mappings: "AAAA,E;;ABCDE;"
   *      }
   *    }],
   *  }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
   */
  function IndexedSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sections = util.getArg(sourceMap, 'sections');

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    this._sources = new ArraySet();
    this._names = new ArraySet();

    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function (s) {
      if (s.url) {
        // The url field will require support for asynchronicity.
        // See https://github.com/mozilla/source-map/issues/16
        throw new Error('Support for url field in sections not implemented.');
      }
      var offset = util.getArg(s, 'offset');
      var offsetLine = util.getArg(offset, 'line');
      var offsetColumn = util.getArg(offset, 'column');

      if (offsetLine < lastOffset.line ||
          (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
        throw new Error('Section offsets must be ordered and non-overlapping.');
      }
      lastOffset = offset;

      return {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, 'map'))
      }
    });
  }

  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

  /**
   * The version of the source mapping spec that we are consuming.
   */
  IndexedSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function () {
      var sources = [];
      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }
      return sources;
    }
  });

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  IndexedSourceMapConsumer.prototype.originalPositionFor =
    function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      // Find the section containing the generated position we're trying to map
      // to an original position.
      var sectionIndex = binarySearch.search(needle, this._sections,
        function(needle, section) {
          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }

          return (needle.generatedColumn -
                  section.generatedOffset.generatedColumn);
        });
      var section = this._sections[sectionIndex];

      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }

      return section.consumer.originalPositionFor({
        line: needle.generatedLine -
          (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn -
          (section.generatedOffset.generatedLine === needle.generatedLine
           ? section.generatedOffset.generatedColumn - 1
           : 0),
        bias: aArgs.bias
      });
    };

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
    function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function (s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  IndexedSourceMapConsumer.prototype.sourceContentFor =
    function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];

        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      }
      else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  IndexedSourceMapConsumer.prototype.generatedPositionFor =
    function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];

        // Only consider this section if the requested source is in the list of
        // sources of the consumer.
        if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line +
              (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column +
              (section.generatedOffset.generatedLine === generatedPosition.line
               ? section.generatedOffset.generatedColumn - 1
               : 0)
          };
          return ret;
        }
      }

      return {
        line: null,
        column: null
      };
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  IndexedSourceMapConsumer.prototype._parseMappings =
    function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];

          var source = section.consumer._sources.at(mapping.source);
          if (section.consumer.sourceRoot !== null) {
            source = util.join(section.consumer.sourceRoot, source);
          }
          this._sources.add(source);
          source = this._sources.indexOf(source);

          var name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);

          // The mappings coming from the consumer for the section have
          // generated positions relative to the start of the section, so we
          // need to offset them to be relative to the start of the concatenated
          // generated file.
          var adjustedMapping = {
            source: source,
            generatedLine: mapping.generatedLine +
              (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn +
              (section.generatedOffset.generatedLine === mapping.generatedLine
              ? section.generatedOffset.generatedColumn - 1
              : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: name
          };

          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === 'number') {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }

      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };

  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;


  /***/ }),
  /* 366 */
  /***/ (function(module, exports) {

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next-closest element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element than the one we are searching for, so we return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return mid;
    }
    else if (cmp > 0) {
      // Our needle is greater than aHaystack[mid].
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }

      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (3) or (2) and return the appropriate thing.
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    }
    else {
      // Our needle is less than aHaystack[mid].
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }

      // we are in termination case (3) or (2) and return the appropriate thing.
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the index of the closest element if there is no exact hit. This is because
   * mappings between original and generated line/col pairs are single points,
   * and there is an implicit region between each of them, so a miss just means
   * that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }

    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                                aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) {
      return -1;
    }

    // We have found either the exact element, or the next-closest element than
    // the one we are searching for. However, there may be more than one such
    // element. Make sure we always return the smallest of these.
    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }
      --index;
    }

    return index;
  };


  /***/ }),
  /* 367 */
  /***/ (function(module, exports) {

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  // It turns out that some (most?) JavaScript engines don't self-host
  // `Array.prototype.sort`. This makes sense because C++ will likely remain
  // faster than JS when doing raw CPU-intensive sorting. However, when using a
  // custom comparator function, calling back and forth between the VM's C++ and
  // JIT'd JS is rather slow *and* loses JIT type information, resulting in
  // worse generated code for the comparator function than would be optimal. In
  // fact, when sorting with a comparator, these costs outweigh the benefits of
  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
  // a ~3500ms mean speed-up in `bench/bench.html`.

  /**
   * Swap the elements indexed by `x` and `y` in the array `ary`.
   *
   * @param {Array} ary
   *        The array.
   * @param {Number} x
   *        The index of the first item.
   * @param {Number} y
   *        The index of the second item.
   */
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }

  /**
   * Returns a random integer within the range `low .. high` inclusive.
   *
   * @param {Number} low
   *        The lower bound on the range.
   * @param {Number} high
   *        The upper bound on the range.
   */
  function randomIntInRange(low, high) {
    return Math.round(low + (Math.random() * (high - low)));
  }

  /**
   * The Quick Sort algorithm.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   * @param {Number} p
   *        Start index of the array
   * @param {Number} r
   *        End index of the array
   */
  function doQuickSort(ary, comparator, p, r) {
    // If our lower bound is less than our upper bound, we (1) partition the
    // array into two pieces and (2) recurse on each half. If it is not, this is
    // the empty array and our base case.

    if (p < r) {
      // (1) Partitioning.
      //
      // The partitioning chooses a pivot between `p` and `r` and moves all
      // elements that are less than or equal to the pivot to the before it, and
      // all the elements that are greater than it after it. The effect is that
      // once partition is done, the pivot is in the exact place it will be when
      // the array is put in sorted order, and it will not need to be moved
      // again. This runs in O(n) time.

      // Always choose a random pivot so that an input array which is reverse
      // sorted does not cause O(n^2) running time.
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;

      swap(ary, pivotIndex, r);
      var pivot = ary[r];

      // Immediately after `j` is incremented in this loop, the following hold
      // true:
      //
      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
      //
      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
      for (var j = p; j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }

      swap(ary, i + 1, j);
      var q = i + 1;

      // (2) Recurse on each half.

      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }

  /**
   * Sort the given array in-place with the given comparator function.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   */
  exports.quickSort = function (ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };


  /***/ }),
  /* 368 */
  /***/ (function(module, exports, __webpack_require__) {

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var SourceMapGenerator = __webpack_require__(359).SourceMapGenerator;
  var util = __webpack_require__(362);

  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
  // operating systems these days (capturing the result).
  var REGEX_NEWLINE = /(\r?\n)/;

  // Newline character code for charCodeAt() comparisons
  var NEWLINE_CODE = 10;

  // Private symbol for identifying `SourceNode`s when multiple versions of
  // the source-map library are loaded. This MUST NOT CHANGE across
  // versions!
  var isSourceNode = "$$$isSourceNode$$$";

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   * @param aRelativePath Optional. The path that relative sources in the
   *        SourceMapConsumer should be relative to.
   */
  SourceNode.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      // The SourceNode we want to fill with the generated code
      // and the SourceMap
      var node = new SourceNode();

      // All even indices of this array are one line of the generated code,
      // while all odd indices are the newlines between two adjacent lines
      // (since `REGEX_NEWLINE` captures its match).
      // Processed fragments are accessed by calling `shiftNextLine`.
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        // The last line of a file might not have a newline.
        var newLine = getNextLine() || "";
        return lineContents + newLine;

        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ?
              remainingLines[remainingLinesIndex++] : undefined;
        }
      };

      // We need to remember the position of "remainingLines"
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

      // The generate SourceNodes we need a code range.
      // To extract it current and last mapping is used.
      // Here we store the last mapping.
      var lastMapping = null;

      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping !== null) {
          // We add the code from "lastMapping" to "mapping":
          // First check if there is a new line in between.
          if (lastGeneratedLine < mapping.generatedLine) {
            // Associate first line with "lastMapping"
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
            // The remaining code is added without mapping
          } else {
            // There is no new line in between.
            // Associate the code between "lastGeneratedColumn" and
            // "mapping.generatedColumn" with "lastMapping"
            var nextLine = remainingLines[remainingLinesIndex];
            var code = nextLine.substr(0, mapping.generatedColumn -
                                          lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                                lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            // No more remaining code, continue
            lastMapping = mapping;
            return;
          }
        }
        // We add the generated code until the first mapping
        // to the SourceNode without any mapping.
        // Each line is added as separate string.
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex];
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      // We have processed all mappings.
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          // Associate the remaining code in the current line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        // and add the remaining lines without any mapping
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }

      // Copy sourcesContent into SourceNode
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });

      return node;

      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          var source = aRelativePath
            ? util.join(aRelativePath, mapping.source)
            : mapping.source;
          node.add(new SourceNode(mapping.originalLine,
                                  mapping.originalColumn,
                                  source,
                                  code,
                                  mapping.name));
        }
      }
    };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length-1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      }
      else {
        if (chunk !== '') {
          aFn(chunk, { source: this.source,
                       line: this.line,
                       column: this.column,
                       name: this.name });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len-1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    }
    else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    }
    else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode.prototype.setSourceContent =
    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }

      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if(lastOriginalSource !== original.source
           || lastOriginalLine !== original.line
           || lastOriginalColumn !== original.column
           || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          // Mappings end at eol
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map: map };
  };

  exports.SourceNode = SourceNode;


  /***/ }),
  /* 369 */
  /***/ (function(module, exports, __webpack_require__) {

  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright 2014, 2015, 2016, 2017 Simon Lydell
  // X11 (“MIT”) Licensed. (See LICENSE.)

  // Note: source-map-resolve.js is generated from source-map-resolve-node.js and
  // source-map-resolve-template.js. Only edit the two latter files, _not_
  // source-map-resolve.js!

  void (function(root, factory) {
    if (true) {
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(370), __webpack_require__(371)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
  				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
  				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
  				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    } else { var resolveUrl, sourceMappingURL; }
  }(this, function(sourceMappingURL, resolveUrl) {

    function callbackAsync(callback, error, result) {
      setImmediate(function() { callback(error, result) })
    }

    function parseMapToJSON(string, data) {
      try {
        return JSON.parse(string.replace(/^\)\]\}'/, ""))
      } catch (error) {
        error.sourceMapData = data
        throw error
      }
    }

    function readSync(read, url, data) {
      var readUrl = url
      try {
        return String(read(readUrl))
      } catch (error) {
        error.sourceMapData = data
        throw error
      }
    }



    function resolveSourceMap(code, codeUrl, read, callback) {
      var mapData
      try {
        mapData = resolveSourceMapHelper(code, codeUrl)
      } catch (error) {
        return callbackAsync(callback, error)
      }
      if (!mapData || mapData.map) {
        return callbackAsync(callback, null, mapData)
      }
      var readUrl = mapData.url
      read(readUrl, function(error, result) {
        if (error) {
          error.sourceMapData = mapData
          return callback(error)
        }
        mapData.map = String(result)
        try {
          mapData.map = parseMapToJSON(mapData.map, mapData)
        } catch (error) {
          return callback(error)
        }
        callback(null, mapData)
      })
    }

    function resolveSourceMapSync(code, codeUrl, read) {
      var mapData = resolveSourceMapHelper(code, codeUrl)
      if (!mapData || mapData.map) {
        return mapData
      }
      mapData.map = readSync(read, mapData.url, mapData)
      mapData.map = parseMapToJSON(mapData.map, mapData)
      return mapData
    }

    var dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/
    var jsonMimeTypeRegex = /^(?:application|text)\/json$/

    function resolveSourceMapHelper(code, codeUrl) {
      var url = sourceMappingURL.getFrom(code)
      if (!url) {
        return null
      }

      var dataUri = url.match(dataUriRegex)
      if (dataUri) {
        var mimeType = dataUri[1]
        var lastParameter = dataUri[2] || ""
        var encoded = dataUri[3] || ""
        var data = {
          sourceMappingURL: url,
          url: null,
          sourcesRelativeTo: codeUrl,
          map: encoded
        }
        if (!jsonMimeTypeRegex.test(mimeType)) {
          var error = new Error("Unuseful data uri mime type: " + (mimeType || "text/plain"))
          error.sourceMapData = data
          throw error
        }
        data.map = parseMapToJSON(
          lastParameter === ";base64" ? atob(encoded) : decodeURIComponent(encoded),
          data
        )
        return data
      }

      var mapUrl = resolveUrl(codeUrl, url)
      return {
        sourceMappingURL: url,
        url: mapUrl,
        sourcesRelativeTo: mapUrl,
        map: null
      }
    }



    function resolveSources(map, mapUrl, read, options, callback) {
      if (typeof options === "function") {
        callback = options
        options = {}
      }
      var pending = map.sources ? map.sources.length : 0
      var result = {
        sourcesResolved: [],
        sourcesContent:  []
      }

      if (pending === 0) {
        callbackAsync(callback, null, result)
        return
      }

      var done = function() {
        pending--
        if (pending === 0) {
          callback(null, result)
        }
      }

      resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
        result.sourcesResolved[index] = fullUrl
        if (typeof sourceContent === "string") {
          result.sourcesContent[index] = sourceContent
          callbackAsync(done, null)
        } else {
          var readUrl = fullUrl
          read(readUrl, function(error, source) {
            result.sourcesContent[index] = error ? error : String(source)
            done()
          })
        }
      })
    }

    function resolveSourcesSync(map, mapUrl, read, options) {
      var result = {
        sourcesResolved: [],
        sourcesContent:  []
      }

      if (!map.sources || map.sources.length === 0) {
        return result
      }

      resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
        result.sourcesResolved[index] = fullUrl
        if (read !== null) {
          if (typeof sourceContent === "string") {
            result.sourcesContent[index] = sourceContent
          } else {
            var readUrl = fullUrl
            try {
              result.sourcesContent[index] = String(read(readUrl))
            } catch (error) {
              result.sourcesContent[index] = error
            }
          }
        }
      })

      return result
    }

    var endingSlash = /\/?$/

    function resolveSourcesHelper(map, mapUrl, options, fn) {
      options = options || {}
      var fullUrl
      var sourceContent
      var sourceRoot
      for (var index = 0, len = map.sources.length; index < len; index++) {
        sourceRoot = null
        if (typeof options.sourceRoot === "string") {
          sourceRoot = options.sourceRoot
        } else if (typeof map.sourceRoot === "string" && options.sourceRoot !== false) {
          sourceRoot = map.sourceRoot
        }
        // If the sourceRoot is the empty string, it is equivalent to not setting
        // the property at all.
        if (sourceRoot === null || sourceRoot === '') {
          fullUrl = resolveUrl(mapUrl, map.sources[index])
        } else {
          // Make sure that the sourceRoot ends with a slash, so that `/scripts/subdir` becomes
          // `/scripts/subdir/<source>`, not `/scripts/<source>`. Pointing to a file as source root
          // does not make sense.
          fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, "/"), map.sources[index])
        }
        sourceContent = (map.sourcesContent || [])[index]
        fn(fullUrl, sourceContent, index)
      }
    }



    function resolve(code, codeUrl, read, options, callback) {
      if (typeof options === "function") {
        callback = options
        options = {}
      }
      if (code === null) {
        var mapUrl = codeUrl
        var data = {
          sourceMappingURL: null,
          url: mapUrl,
          sourcesRelativeTo: mapUrl,
          map: null
        }
        var readUrl = mapUrl
        read(readUrl, function(error, result) {
          if (error) {
            error.sourceMapData = data
            return callback(error)
          }
          data.map = String(result)
          try {
            data.map = parseMapToJSON(data.map, data)
          } catch (error) {
            return callback(error)
          }
          _resolveSources(data)
        })
      } else {
        resolveSourceMap(code, codeUrl, read, function(error, mapData) {
          if (error) {
            return callback(error)
          }
          if (!mapData) {
            return callback(null, null)
          }
          _resolveSources(mapData)
        })
      }

      function _resolveSources(mapData) {
        resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function(error, result) {
          if (error) {
            return callback(error)
          }
          mapData.sourcesResolved = result.sourcesResolved
          mapData.sourcesContent  = result.sourcesContent
          callback(null, mapData)
        })
      }
    }

    function resolveSync(code, codeUrl, read, options) {
      var mapData
      if (code === null) {
        var mapUrl = codeUrl
        mapData = {
          sourceMappingURL: null,
          url: mapUrl,
          sourcesRelativeTo: mapUrl,
          map: null
        }
        mapData.map = readSync(read, mapUrl, mapData)
        mapData.map = parseMapToJSON(mapData.map, mapData)
      } else {
        mapData = resolveSourceMapSync(code, codeUrl, read)
        if (!mapData) {
          return null
        }
      }
      var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options)
      mapData.sourcesResolved = result.sourcesResolved
      mapData.sourcesContent  = result.sourcesContent
      return mapData
    }



    return {
      resolveSourceMap:     resolveSourceMap,
      resolveSourceMapSync: resolveSourceMapSync,
      resolveSources:       resolveSources,
      resolveSourcesSync:   resolveSourcesSync,
      resolve:              resolve,
      resolveSync:          resolveSync,
      parseMapToJSON:       parseMapToJSON
    }

  }));


  /***/ }),
  /* 370 */
  /***/ (function(module, exports, __webpack_require__) {

  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright 2014 Simon Lydell
  // X11 (“MIT”) Licensed. (See LICENSE.)

  void (function(root, factory) {
    if (true) {
      !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
  				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
  				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
  				__WEBPACK_AMD_DEFINE_FACTORY__),
  				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    } else {}
  }(this, function() {

    var innerRegex = /[#@] sourceMappingURL=([^\s'"]*)/

    var regex = RegExp(
      "(?:" +
        "/\\*" +
        "(?:\\s*\r?\n(?://)?)?" +
        "(?:" + innerRegex.source + ")" +
        "\\s*" +
        "\\*/" +
        "|" +
        "//(?:" + innerRegex.source + ")" +
      ")" +
      "\\s*"
    )

    return {

      regex: regex,
      _innerRegex: innerRegex,

      getFrom: function(code) {
        var match = code.match(regex)
        return (match ? match[1] || match[2] || "" : null)
      },

      existsIn: function(code) {
        return regex.test(code)
      },

      removeFrom: function(code) {
        return code.replace(regex, "")
      },

      insertBefore: function(code, string) {
        var match = code.match(regex)
        if (match) {
          return code.slice(0, match.index) + string + code.slice(match.index)
        } else {
          return code + string
        }
      }
    }

  }));


  /***/ }),
  /* 371 */
  /***/ (function(module, exports, __webpack_require__) {

  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright 2014 Simon Lydell
  // X11 (“MIT”) Licensed. (See LICENSE.)
  
  void (function(root, factory) {
    if (true) {
      !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
  				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
  				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
  				__WEBPACK_AMD_DEFINE_FACTORY__),
  				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    } else {}
  }(this, function() {
  
    function resolveUrl(/* ...urls */) {
      var numUrls = arguments.length
  
      if (numUrls === 0) {
        throw new Error("resolveUrl requires at least one argument; got none.")
      }
  
      var base = document.createElement("base")
      base.href = arguments[0]
  
      if (numUrls === 1) {
        return base.href
      }
  
      var head = document.getElementsByTagName("head")[0]
      head.insertBefore(base, head.firstChild)
  
      var a = document.createElement("a")
      var resolved
  
      for (var index = 1; index < numUrls; index++) {
        a.href = arguments[index]
        resolved = a.href
        base.href = resolved
      }
  
      head.removeChild(base)
  
      return resolved
    }
  
    return resolveUrl
  
  }));


  /***/ }),
  /* 372 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var fs = __webpack_require__(7);
  var path = __webpack_require__(8);
  var define = __webpack_require__(344);
  var utils = __webpack_require__(357);

  /**
   * Expose `mixin()`.
   * This code is based on `source-maps-support.js` in reworkcss/css
   * https://github.com/reworkcss/css/blob/master/lib/stringify/source-map-support.js
   * Copyright (c) 2012 TJ Holowaychuk <tj@vision-media.ca>
   */

  module.exports = mixin;

  /**
   * Mixin source map support into `compiler`.
   *
   * @param {Object} `compiler`
   * @api public
   */

  function mixin(compiler) {
    define(compiler, '_comment', compiler.comment);
    compiler.map = new utils.SourceMap.SourceMapGenerator();
    compiler.position = { line: 1, column: 1 };
    compiler.content = {};
    compiler.files = {};

    for (var key in exports) {
      define(compiler, key, exports[key]);
    }
  }

  /**
   * Update position.
   *
   * @param {String} str
   */

  exports.updatePosition = function(str) {
    var lines = str.match(/\n/g);
    if (lines) this.position.line += lines.length;
    var i = str.lastIndexOf('\n');
    this.position.column = ~i ? str.length - i : this.position.column + str.length;
  };

  /**
   * Emit `str` with `position`.
   *
   * @param {String} str
   * @param {Object} [pos]
   * @return {String}
   */

  exports.emit = function(str, node) {
    var position = node.position || {};
    var source = position.source;
    if (source) {
      if (position.filepath) {
        source = utils.unixify(position.filepath);
      }

      this.map.addMapping({
        source: source,
        generated: {
          line: this.position.line,
          column: Math.max(this.position.column - 1, 0)
        },
        original: {
          line: position.start.line,
          column: position.start.column - 1
        }
      });

      if (position.content) {
        this.addContent(source, position);
      }
      if (position.filepath) {
        this.addFile(source, position);
      }

      this.updatePosition(str);
      this.output += str;
    }
    return str;
  };

  /**
   * Adds a file to the source map output if it has not already been added
   * @param {String} `file`
   * @param {Object} `pos`
   */

  exports.addFile = function(file, position) {
    if (typeof position.content !== 'string') return;
    if (Object.prototype.hasOwnProperty.call(this.files, file)) return;
    this.files[file] = position.content;
  };

  /**
   * Adds a content source to the source map output if it has not already been added
   * @param {String} `source`
   * @param {Object} `position`
   */

  exports.addContent = function(source, position) {
    if (typeof position.content !== 'string') return;
    if (Object.prototype.hasOwnProperty.call(this.content, source)) return;
    this.map.setSourceContent(source, position.content);
  };

  /**
   * Applies any original source maps to the output and embeds the source file
   * contents in the source map.
   */

  exports.applySourceMaps = function() {
    Object.keys(this.files).forEach(function(file) {
      var content = this.files[file];
      this.map.setSourceContent(file, content);

      if (this.options.inputSourcemaps === true) {
        var originalMap = utils.sourceMapResolve.resolveSync(content, file, fs.readFileSync);
        if (originalMap) {
          var map = new utils.SourceMap.SourceMapConsumer(originalMap.map);
          var relativeTo = originalMap.sourcesRelativeTo;
          this.map.applySourceMap(map, file, utils.unixify(path.dirname(relativeTo)));
        }
      }
    }, this);
  };

  /**
   * Process comments, drops sourceMap comments.
   * @param {Object} node
   */

  exports.comment = function(node) {
    if (/^# sourceMappingURL=/.test(node.comment)) {
      return this.emit('', node.position);
    }
    return this._comment(node);
  };


  /***/ }),
  /* 373 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var use = __webpack_require__(353);
  var util = __webpack_require__(25);
  var Cache = __webpack_require__(374);
  var define = __webpack_require__(344);
  var debug = __webpack_require__(354)('snapdragon:parser');
  var Position = __webpack_require__(375);
  var utils = __webpack_require__(357);

  /**
   * Create a new `Parser` with the given `input` and `options`.
   * @param {String} `input`
   * @param {Object} `options`
   * @api public
   */

  function Parser(options) {
    debug('initializing', __filename);
    this.options = utils.extend({source: 'string'}, options);
    this.init(this.options);
    use(this);
  }

  /**
   * Prototype methods
   */

  Parser.prototype = {
    constructor: Parser,

    init: function(options) {
      this.orig = '';
      this.input = '';
      this.parsed = '';

      this.column = 1;
      this.line = 1;

      this.regex = new Cache();
      this.errors = this.errors || [];
      this.parsers = this.parsers || {};
      this.types = this.types || [];
      this.sets = this.sets || {};
      this.fns = this.fns || [];
      this.currentType = 'root';

      var pos = this.position();
      this.bos = pos({type: 'bos', val: ''});

      this.ast = {
        type: 'root',
        errors: this.errors,
        nodes: [this.bos]
      };

      define(this.bos, 'parent', this.ast);
      this.nodes = [this.ast];

      this.count = 0;
      this.setCount = 0;
      this.stack = [];
    },

    /**
     * Throw a formatted error with the cursor column and `msg`.
     * @param {String} `msg` Message to use in the Error.
     */

    error: function(msg, node) {
      var pos = node.position || {start: {column: 0, line: 0}};
      var line = pos.start.line;
      var column = pos.start.column;
      var source = this.options.source;

      var message = source + ' <line:' + line + ' column:' + column + '>: ' + msg;
      var err = new Error(message);
      err.source = source;
      err.reason = msg;
      err.pos = pos;

      if (this.options.silent) {
        this.errors.push(err);
      } else {
        throw err;
      }
    },

    /**
     * Define a non-enumberable property on the `Parser` instance.
     *
     * ```js
     * parser.define('foo', 'bar');
     * ```
     * @name .define
     * @param {String} `key` propery name
     * @param {any} `val` property value
     * @return {Object} Returns the Parser instance for chaining.
     * @api public
     */

    define: function(key, val) {
      define(this, key, val);
      return this;
    },

    /**
     * Mark position and patch `node.position`.
     */

    position: function() {
      var start = { line: this.line, column: this.column };
      var self = this;

      return function(node) {
        define(node, 'position', new Position(start, self));
        return node;
      };
    },

    /**
     * Set parser `name` with the given `fn`
     * @param {String} `name`
     * @param {Function} `fn`
     * @api public
     */

    set: function(type, fn) {
      if (this.types.indexOf(type) === -1) {
        this.types.push(type);
      }
      this.parsers[type] = fn.bind(this);
      return this;
    },

    /**
     * Get parser `name`
     * @param {String} `name`
     * @api public
     */

    get: function(name) {
      return this.parsers[name];
    },

    /**
     * Push a `token` onto the `type` stack.
     *
     * @param {String} `type`
     * @return {Object} `token`
     * @api public
     */

    push: function(type, token) {
      this.sets[type] = this.sets[type] || [];
      this.count++;
      this.stack.push(token);
      return this.sets[type].push(token);
    },

    /**
     * Pop a token off of the `type` stack
     * @param {String} `type`
     * @returns {Object} Returns a token
     * @api public
     */

    pop: function(type) {
      this.sets[type] = this.sets[type] || [];
      this.count--;
      this.stack.pop();
      return this.sets[type].pop();
    },

    /**
     * Return true if inside a `stack` node. Types are `braces`, `parens` or `brackets`.
     *
     * @param {String} `type`
     * @return {Boolean}
     * @api public
     */

    isInside: function(type) {
      this.sets[type] = this.sets[type] || [];
      return this.sets[type].length > 0;
    },

    /**
     * Return true if `node` is the given `type`.
     *
     * ```js
     * parser.isType(node, 'brace');
     * ```
     * @param {Object} `node`
     * @param {String} `type`
     * @return {Boolean}
     * @api public
     */

    isType: function(node, type) {
      return node && node.type === type;
    },

    /**
     * Get the previous AST node
     * @return {Object}
     */

    prev: function(n) {
      return this.stack.length > 0
        ? utils.last(this.stack, n)
        : utils.last(this.nodes, n);
    },

    /**
     * Update line and column based on `str`.
     */

    consume: function(len) {
      this.input = this.input.substr(len);
    },

    /**
     * Update column based on `str`.
     */

    updatePosition: function(str, len) {
      var lines = str.match(/\n/g);
      if (lines) this.line += lines.length;
      var i = str.lastIndexOf('\n');
      this.column = ~i ? len - i : this.column + len;
      this.parsed += str;
      this.consume(len);
    },

    /**
     * Match `regex`, return captures, and update the cursor position by `match[0]` length.
     * @param {RegExp} `regex`
     * @return {Object}
     */

    match: function(regex) {
      var m = regex.exec(this.input);
      if (m) {
        this.updatePosition(m[0], m[0].length);
        return m;
      }
    },

    /**
     * Capture `type` with the given regex.
     * @param {String} `type`
     * @param {RegExp} `regex`
     * @return {Function}
     */

    capture: function(type, regex) {
      if (typeof regex === 'function') {
        return this.set.apply(this, arguments);
      }

      this.regex.set(type, regex);
      this.set(type, function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(regex);
        if (!m || !m[0]) return;

        var prev = this.prev();
        var node = pos({
          type: type,
          val: m[0],
          parsed: parsed,
          rest: this.input
        });

        if (m[1]) {
          node.inner = m[1];
        }

        define(node, 'inside', this.stack.length > 0);
        define(node, 'parent', prev);
        prev.nodes.push(node);
      }.bind(this));
      return this;
    },

    /**
     * Create a parser with open and close for parens,
     * brackets or braces
     */

    capturePair: function(type, openRegex, closeRegex, fn) {
      this.sets[type] = this.sets[type] || [];

      /**
       * Open
       */

      this.set(type + '.open', function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(openRegex);
        if (!m || !m[0]) return;

        var val = m[0];
        this.setCount++;
        this.specialChars = true;
        var open = pos({
          type: type + '.open',
          val: val,
          rest: this.input
        });

        if (typeof m[1] !== 'undefined') {
          open.inner = m[1];
        }

        var prev = this.prev();
        var node = pos({
          type: type,
          nodes: [open]
        });

        define(node, 'rest', this.input);
        define(node, 'parsed', parsed);
        define(node, 'prefix', m[1]);
        define(node, 'parent', prev);
        define(open, 'parent', node);

        if (typeof fn === 'function') {
          fn.call(this, open, node);
        }

        this.push(type, node);
        prev.nodes.push(node);
      });

      /**
       * Close
       */

      this.set(type + '.close', function() {
        var pos = this.position();
        var m = this.match(closeRegex);
        if (!m || !m[0]) return;

        var parent = this.pop(type);
        var node = pos({
          type: type + '.close',
          rest: this.input,
          suffix: m[1],
          val: m[0]
        });

        if (!this.isType(parent, type)) {
          if (this.options.strict) {
            throw new Error('missing opening "' + type + '"');
          }

          this.setCount--;
          node.escaped = true;
          return node;
        }

        if (node.suffix === '\\') {
          parent.escaped = true;
          node.escaped = true;
        }

        parent.nodes.push(node);
        define(node, 'parent', parent);
      });

      return this;
    },

    /**
     * Capture end-of-string
     */

    eos: function() {
      var pos = this.position();
      if (this.input) return;
      var prev = this.prev();

      while (prev.type !== 'root' && !prev.visited) {
        if (this.options.strict === true) {
          throw new SyntaxError('invalid syntax:' + util.inspect(prev, null, 2));
        }

        if (!hasDelims(prev)) {
          prev.parent.escaped = true;
          prev.escaped = true;
        }

        visit(prev, function(node) {
          if (!hasDelims(node.parent)) {
            node.parent.escaped = true;
            node.escaped = true;
          }
        });

        prev = prev.parent;
      }

      var tok = pos({
        type: 'eos',
        val: this.append || ''
      });

      define(tok, 'parent', this.ast);
      return tok;
    },

    /**
     * Run parsers to advance the cursor position
     */

    next: function() {
      var parsed = this.parsed;
      var len = this.types.length;
      var idx = -1;
      var tok;

      while (++idx < len) {
        if ((tok = this.parsers[this.types[idx]].call(this))) {
          define(tok, 'rest', this.input);
          define(tok, 'parsed', parsed);
          this.last = tok;
          return tok;
        }
      }
    },

    /**
     * Parse the given string.
     * @return {Array}
     */

    parse: function(input) {
      if (typeof input !== 'string') {
        throw new TypeError('expected a string');
      }

      this.init(this.options);
      this.orig = input;
      this.input = input;
      var self = this;

      function parse() {
        // check input before calling `.next()`
        input = self.input;

        // get the next AST ndoe
        var node = self.next();
        if (node) {
          var prev = self.prev();
          if (prev) {
            define(node, 'parent', prev);
            if (prev.nodes) {
              prev.nodes.push(node);
            }
          }

          if (self.sets.hasOwnProperty(prev.type)) {
            self.currentType = prev.type;
          }
        }

        // if we got here but input is not changed, throw an error
        if (self.input && input === self.input) {
          throw new Error('no parsers registered for: "' + self.input.slice(0, 5) + '"');
        }
      }

      while (this.input) parse();
      if (this.stack.length && this.options.strict) {
        var node = this.stack.pop();
        throw this.error('missing opening ' + node.type + ': "' + this.orig + '"');
      }

      var eos = this.eos();
      var tok = this.prev();
      if (tok.type !== 'eos') {
        this.ast.nodes.push(eos);
      }

      return this.ast;
    }
  };

  /**
   * Visit `node` with the given `fn`
   */

  function visit(node, fn) {
    if (!node.visited) {
      define(node, 'visited', true);
      return node.nodes ? mapVisit(node.nodes, fn) : fn(node);
    }
    return node;
  }

  /**
   * Map visit over array of `nodes`.
   */

  function mapVisit(nodes, fn) {
    var len = nodes.length;
    var idx = -1;
    while (++idx < len) {
      visit(nodes[idx], fn);
    }
  }

  function hasOpen(node) {
    return node.nodes && node.nodes[0].type === (node.type + '.open');
  }

  function hasClose(node) {
    return node.nodes && utils.last(node.nodes).type === (node.type + '.close');
  }

  function hasDelims(node) {
    return hasOpen(node) && hasClose(node);
  }

  /**
   * Expose `Parser`
   */

  module.exports = Parser;


  /***/ }),
  /* 374 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * map-cache <https://github.com/jonschlinkert/map-cache>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */



  var hasOwn = Object.prototype.hasOwnProperty;

  /**
   * Expose `MapCache`
   */

  module.exports = MapCache;

  /**
   * Creates a cache object to store key/value pairs.
   *
   * ```js
   * var cache = new MapCache();
   * ```
   *
   * @api public
   */

  function MapCache(data) {
    this.__data__ = data || {};
  }

  /**
   * Adds `value` to `key` on the cache.
   *
   * ```js
   * cache.set('foo', 'bar');
   * ```
   *
   * @param {String} `key` The key of the value to cache.
   * @param {*} `value` The value to cache.
   * @returns {Object} Returns the `Cache` object for chaining.
   * @api public
   */

  MapCache.prototype.set = function mapSet(key, value) {
    if (key !== '__proto__') {
      this.__data__[key] = value;
    }
    return this;
  };

  /**
   * Gets the cached value for `key`.
   *
   * ```js
   * cache.get('foo');
   * //=> 'bar'
   * ```
   *
   * @param {String} `key` The key of the value to get.
   * @returns {*} Returns the cached value.
   * @api public
   */

  MapCache.prototype.get = function mapGet(key) {
    return key === '__proto__' ? undefined : this.__data__[key];
  };

  /**
   * Checks if a cached value for `key` exists.
   *
   * ```js
   * cache.has('foo');
   * //=> true
   * ```
   *
   * @param {String} `key` The key of the entry to check.
   * @returns {Boolean} Returns `true` if an entry for `key` exists, else `false`.
   * @api public
   */

  MapCache.prototype.has = function mapHas(key) {
    return key !== '__proto__' && hasOwn.call(this.__data__, key);
  };

  /**
   * Removes `key` and its value from the cache.
   *
   * ```js
   * cache.del('foo');
   * ```
   * @title .del
   * @param {String} `key` The key of the value to remove.
   * @returns {Boolean} Returns `true` if the entry was removed successfully, else `false`.
   * @api public
   */

  MapCache.prototype.del = function mapDelete(key) {
    return this.has(key) && delete this.__data__[key];
  };


  /***/ }),
  /* 375 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var define = __webpack_require__(344);

  /**
   * Store position for a node
   */

  module.exports = function Position(start, parser) {
    this.start = start;
    this.end = { line: parser.line, column: parser.column };
    define(this, 'content', parser.orig);
    define(this, 'source', parser.options.source);
  };


  /***/ }),
  /* 376 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var nanomatch = __webpack_require__(377);
  var extglob = __webpack_require__(386);

  module.exports = function(snapdragon) {
    var compilers = snapdragon.compiler.compilers;
    var opts = snapdragon.options;

    // register nanomatch compilers
    snapdragon.use(nanomatch.compilers);

    // get references to some specific nanomatch compilers before they
    // are overridden by the extglob and/or custom compilers
    var escape = compilers.escape;
    var qmark = compilers.qmark;
    var slash = compilers.slash;
    var star = compilers.star;
    var text = compilers.text;
    var plus = compilers.plus;
    var dot = compilers.dot;

    // register extglob compilers or escape exglobs if disabled
    if (opts.extglob === false || opts.noext === true) {
      snapdragon.compiler.use(escapeExtglobs);
    } else {
      snapdragon.use(extglob.compilers);
    }

    snapdragon.use(function() {
      this.options.star = this.options.star || function(/*node*/) {
        return '[^\\\\/]*?';
      };
    });

    // custom micromatch compilers
    snapdragon.compiler

      // reset referenced compiler
      .set('dot', dot)
      .set('escape', escape)
      .set('plus', plus)
      .set('slash', slash)
      .set('qmark', qmark)
      .set('star', star)
      .set('text', text);
  };

  function escapeExtglobs(compiler) {
    compiler.set('paren', function(node) {
      var val = '';
      visit(node, function(tok) {
        if (tok.val) val += (/^\W/.test(tok.val) ? '\\' : '') + tok.val;
      });
      return this.emit(val, node);
    });

    /**
     * Visit `node` with the given `fn`
     */

    function visit(node, fn) {
      return node.nodes ? mapVisit(node.nodes, fn) : fn(node);
    }

    /**
     * Map visit over array of `nodes`.
     */

    function mapVisit(nodes, fn) {
      var len = nodes.length;
      var idx = -1;
      while (++idx < len) {
        visit(nodes[idx], fn);
      }
    }
  }


  /***/ }),
  /* 377 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  /**
   * Module dependencies
   */

  var util = __webpack_require__(25);
  var toRegex = __webpack_require__(283);
  var extend = __webpack_require__(296);

  /**
   * Local dependencies
   */

  var compilers = __webpack_require__(378);
  var parsers = __webpack_require__(379);
  var cache = __webpack_require__(380);
  var utils = __webpack_require__(382);
  var MAX_LENGTH = 1024 * 64;

  /**
   * The main function takes a list of strings and one or more
   * glob patterns to use for matching.
   *
   * ```js
   * var nm = require('nanomatch');
   * nm(list, patterns[, options]);
   *
   * console.log(nm(['a.js', 'a.txt'], ['*.js']));
   * //=> [ 'a.js' ]
   * ```
   * @param {Array} `list` A list of strings to match
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Array} Returns an array of matches
   * @summary false
   * @api public
   */

  function nanomatch(list, patterns, options) {
    patterns = utils.arrayify(patterns);
    list = utils.arrayify(list);

    var len = patterns.length;
    if (list.length === 0 || len === 0) {
      return [];
    }

    if (len === 1) {
      return nanomatch.match(list, patterns[0], options);
    }

    var negated = false;
    var omit = [];
    var keep = [];
    var idx = -1;

    while (++idx < len) {
      var pattern = patterns[idx];

      if (typeof pattern === 'string' && pattern.charCodeAt(0) === 33 /* ! */) {
        omit.push.apply(omit, nanomatch.match(list, pattern.slice(1), options));
        negated = true;
      } else {
        keep.push.apply(keep, nanomatch.match(list, pattern, options));
      }
    }

    // minimatch.match parity
    if (negated && keep.length === 0) {
      if (options && options.unixify === false) {
        keep = list.slice();
      } else {
        var unixify = utils.unixify(options);
        for (var i = 0; i < list.length; i++) {
          keep.push(unixify(list[i]));
        }
      }
    }

    var matches = utils.diff(keep, omit);
    if (!options || options.nodupes !== false) {
      return utils.unique(matches);
    }

    return matches;
  }

  /**
   * Similar to the main function, but `pattern` must be a string.
   *
   * ```js
   * var nm = require('nanomatch');
   * nm.match(list, pattern[, options]);
   *
   * console.log(nm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));
   * //=> ['a.a', 'a.aa']
   * ```
   * @param {Array} `list` Array of strings to match
   * @param {String} `pattern` Glob pattern to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Array} Returns an array of matches
   * @api public
   */

  nanomatch.match = function(list, pattern, options) {
    if (Array.isArray(pattern)) {
      throw new TypeError('expected pattern to be a string');
    }

    var unixify = utils.unixify(options);
    var isMatch = memoize('match', pattern, options, nanomatch.matcher);
    var matches = [];

    list = utils.arrayify(list);
    var len = list.length;
    var idx = -1;

    while (++idx < len) {
      var ele = list[idx];
      if (ele === pattern || isMatch(ele)) {
        matches.push(utils.value(ele, unixify, options));
      }
    }

    // if no options were passed, uniquify results and return
    if (typeof options === 'undefined') {
      return utils.unique(matches);
    }

    if (matches.length === 0) {
      if (options.failglob === true) {
        throw new Error('no matches found for "' + pattern + '"');
      }
      if (options.nonull === true || options.nullglob === true) {
        return [options.unescape ? utils.unescape(pattern) : pattern];
      }
    }

    // if `opts.ignore` was defined, diff ignored list
    if (options.ignore) {
      matches = nanomatch.not(matches, options.ignore, options);
    }

    return options.nodupes !== false ? utils.unique(matches) : matches;
  };

  /**
   * Returns true if the specified `string` matches the given glob `pattern`.
   *
   * ```js
   * var nm = require('nanomatch');
   * nm.isMatch(string, pattern[, options]);
   *
   * console.log(nm.isMatch('a.a', '*.a'));
   * //=> true
   * console.log(nm.isMatch('a.b', '*.a'));
   * //=> false
   * ```
   * @param {String} `string` String to match
   * @param {String} `pattern` Glob pattern to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if the string matches the glob pattern.
   * @api public
   */

  nanomatch.isMatch = function(str, pattern, options) {
    if (typeof str !== 'string') {
      throw new TypeError('expected a string: "' + util.inspect(str) + '"');
    }

    if (utils.isEmptyString(str) || utils.isEmptyString(pattern)) {
      return false;
    }

    var equals = utils.equalsPattern(options);
    if (equals(str)) {
      return true;
    }

    var isMatch = memoize('isMatch', pattern, options, nanomatch.matcher);
    return isMatch(str);
  };

  /**
   * Returns true if some of the elements in the given `list` match any of the
   * given glob `patterns`.
   *
   * ```js
   * var nm = require('nanomatch');
   * nm.some(list, patterns[, options]);
   *
   * console.log(nm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
   * // true
   * console.log(nm.some(['foo.js'], ['*.js', '!foo.js']));
   * // false
   * ```
   * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */

  nanomatch.some = function(list, patterns, options) {
    if (typeof list === 'string') {
      list = [list];
    }

    for (var i = 0; i < list.length; i++) {
      if (nanomatch(list[i], patterns, options).length === 1) {
        return true;
      }
    }

    return false;
  };

  /**
   * Returns true if every element in the given `list` matches
   * at least one of the given glob `patterns`.
   *
   * ```js
   * var nm = require('nanomatch');
   * nm.every(list, patterns[, options]);
   *
   * console.log(nm.every('foo.js', ['foo.js']));
   * // true
   * console.log(nm.every(['foo.js', 'bar.js'], ['*.js']));
   * // true
   * console.log(nm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
   * // false
   * console.log(nm.every(['foo.js'], ['*.js', '!foo.js']));
   * // false
   * ```
   * @param  {String|Array} `list` The string or array of strings to test.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */

  nanomatch.every = function(list, patterns, options) {
    if (typeof list === 'string') {
      list = [list];
    }

    for (var i = 0; i < list.length; i++) {
      if (nanomatch(list[i], patterns, options).length !== 1) {
        return false;
      }
    }

    return true;
  };

  /**
   * Returns true if **any** of the given glob `patterns`
   * match the specified `string`.
   *
   * ```js
   * var nm = require('nanomatch');
   * nm.any(string, patterns[, options]);
   *
   * console.log(nm.any('a.a', ['b.*', '*.a']));
   * //=> true
   * console.log(nm.any('a.a', 'b.*'));
   * //=> false
   * ```
   * @param  {String|Array} `str` The string to test.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */

  nanomatch.any = function(str, patterns, options) {
    if (typeof str !== 'string') {
      throw new TypeError('expected a string: "' + util.inspect(str) + '"');
    }

    if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {
      return false;
    }

    if (typeof patterns === 'string') {
      patterns = [patterns];
    }

    for (var i = 0; i < patterns.length; i++) {
      if (nanomatch.isMatch(str, patterns[i], options)) {
        return true;
      }
    }
    return false;
  };

  /**
   * Returns true if **all** of the given `patterns`
   * match the specified string.
   *
   * ```js
   * var nm = require('nanomatch');
   * nm.all(string, patterns[, options]);
   *
   * console.log(nm.all('foo.js', ['foo.js']));
   * // true
   *
   * console.log(nm.all('foo.js', ['*.js', '!foo.js']));
   * // false
   *
   * console.log(nm.all('foo.js', ['*.js', 'foo.js']));
   * // true
   *
   * console.log(nm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
   * // true
   * ```
   * @param  {String|Array} `str` The string to test.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */

  nanomatch.all = function(str, patterns, options) {
    if (typeof str !== 'string') {
      throw new TypeError('expected a string: "' + util.inspect(str) + '"');
    }

    if (typeof patterns === 'string') {
      patterns = [patterns];
    }

    for (var i = 0; i < patterns.length; i++) {
      if (!nanomatch.isMatch(str, patterns[i], options)) {
        return false;
      }
    }
    return true;
  };

  /**
   * Returns a list of strings that _**do not match any**_ of the given `patterns`.
   *
   * ```js
   * var nm = require('nanomatch');
   * nm.not(list, patterns[, options]);
   *
   * console.log(nm.not(['a.a', 'b.b', 'c.c'], '*.a'));
   * //=> ['b.b', 'c.c']
   * ```
   * @param {Array} `list` Array of strings to match.
   * @param {String|Array} `patterns` One or more glob pattern to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Array} Returns an array of strings that **do not match** the given patterns.
   * @api public
   */

  nanomatch.not = function(list, patterns, options) {
    var opts = extend({}, options);
    var ignore = opts.ignore;
    delete opts.ignore;

    list = utils.arrayify(list);

    var matches = utils.diff(list, nanomatch(list, patterns, opts));
    if (ignore) {
      matches = utils.diff(matches, nanomatch(list, ignore));
    }

    return opts.nodupes !== false ? utils.unique(matches) : matches;
  };

  /**
   * Returns true if the given `string` contains the given pattern. Similar
   * to [.isMatch](#isMatch) but the pattern can match any part of the string.
   *
   * ```js
   * var nm = require('nanomatch');
   * nm.contains(string, pattern[, options]);
   *
   * console.log(nm.contains('aa/bb/cc', '*b'));
   * //=> true
   * console.log(nm.contains('aa/bb/cc', '*d'));
   * //=> false
   * ```
   * @param {String} `str` The string to match.
   * @param {String|Array} `patterns` Glob pattern to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if the patter matches any part of `str`.
   * @api public
   */

  nanomatch.contains = function(str, patterns, options) {
    if (typeof str !== 'string') {
      throw new TypeError('expected a string: "' + util.inspect(str) + '"');
    }

    if (typeof patterns === 'string') {
      if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {
        return false;
      }

      var equals = utils.equalsPattern(patterns, options);
      if (equals(str)) {
        return true;
      }
      var contains = utils.containsPattern(patterns, options);
      if (contains(str)) {
        return true;
      }
    }

    var opts = extend({}, options, {contains: true});
    return nanomatch.any(str, patterns, opts);
  };

  /**
   * Returns true if the given pattern and options should enable
   * the `matchBase` option.
   * @return {Boolean}
   * @api private
   */

  nanomatch.matchBase = function(pattern, options) {
    if (pattern && pattern.indexOf('/') !== -1 || !options) return false;
    return options.basename === true || options.matchBase === true;
  };

  /**
   * Filter the keys of the given object with the given `glob` pattern
   * and `options`. Does not attempt to match nested keys. If you need this feature,
   * use [glob-object][] instead.
   *
   * ```js
   * var nm = require('nanomatch');
   * nm.matchKeys(object, patterns[, options]);
   *
   * var obj = { aa: 'a', ab: 'b', ac: 'c' };
   * console.log(nm.matchKeys(obj, '*b'));
   * //=> { ab: 'b' }
   * ```
   * @param {Object} `object` The object with keys to filter.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Object} Returns an object with only keys that match the given patterns.
   * @api public
   */

  nanomatch.matchKeys = function(obj, patterns, options) {
    if (!utils.isObject(obj)) {
      throw new TypeError('expected the first argument to be an object');
    }
    var keys = nanomatch(Object.keys(obj), patterns, options);
    return utils.pick(obj, keys);
  };

  /**
   * Returns a memoized matcher function from the given glob `pattern` and `options`.
   * The returned function takes a string to match as its only argument and returns
   * true if the string is a match.
   *
   * ```js
   * var nm = require('nanomatch');
   * nm.matcher(pattern[, options]);
   *
   * var isMatch = nm.matcher('*.!(*a)');
   * console.log(isMatch('a.a'));
   * //=> false
   * console.log(isMatch('a.b'));
   * //=> true
   * ```
   * @param {String} `pattern` Glob pattern
   * @param {Object} `options` See available [options](#options) for changing how matches are performed.
   * @return {Function} Returns a matcher function.
   * @api public
   */

  nanomatch.matcher = function matcher(pattern, options) {
    if (utils.isEmptyString(pattern)) {
      return function() {
        return false;
      };
    }

    if (Array.isArray(pattern)) {
      return compose(pattern, options, matcher);
    }

    // if pattern is a regex
    if (pattern instanceof RegExp) {
      return test(pattern);
    }

    // if pattern is invalid
    if (!utils.isString(pattern)) {
      throw new TypeError('expected pattern to be an array, string or regex');
    }

    // if pattern is a non-glob string
    if (!utils.hasSpecialChars(pattern)) {
      if (options && options.nocase === true) {
        pattern = pattern.toLowerCase();
      }
      return utils.matchPath(pattern, options);
    }

    // if pattern is a glob string
    var re = nanomatch.makeRe(pattern, options);

    // if `options.matchBase` or `options.basename` is defined
    if (nanomatch.matchBase(pattern, options)) {
      return utils.matchBasename(re, options);
    }

    function test(regex) {
      var equals = utils.equalsPattern(options);
      var unixify = utils.unixify(options);

      return function(str) {
        if (equals(str)) {
          return true;
        }

        if (regex.test(unixify(str))) {
          return true;
        }
        return false;
      };
    }

    // create matcher function
    var matcherFn = test(re);
    // set result object from compiler on matcher function,
    // as a non-enumerable property. useful for debugging
    utils.define(matcherFn, 'result', re.result);
    return matcherFn;
  };

  /**
   * Returns an array of matches captured by `pattern` in `string, or
   * `null` if the pattern did not match.
   *
   * ```js
   * var nm = require('nanomatch');
   * nm.capture(pattern, string[, options]);
   *
   * console.log(nm.capture('test/*.js', 'test/foo.js'));
   * //=> ['foo']
   * console.log(nm.capture('test/*.js', 'foo/bar.css'));
   * //=> null
   * ```
   * @param {String} `pattern` Glob pattern to use for matching.
   * @param {String} `string` String to match
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.
   * @api public
   */

  nanomatch.capture = function(pattern, str, options) {
    var re = nanomatch.makeRe(pattern, extend({capture: true}, options));
    var unixify = utils.unixify(options);

    function match() {
      return function(string) {
        var match = re.exec(unixify(string));
        if (!match) {
          return null;
        }

        return match.slice(1);
      };
    }

    var capture = memoize('capture', pattern, options, match);
    return capture(str);
  };

  /**
   * Create a regular expression from the given glob `pattern`.
   *
   * ```js
   * var nm = require('nanomatch');
   * nm.makeRe(pattern[, options]);
   *
   * console.log(nm.makeRe('*.js'));
   * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
   * ```
   * @param {String} `pattern` A glob pattern to convert to regex.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed.
   * @return {RegExp} Returns a regex created from the given pattern.
   * @api public
   */

  nanomatch.makeRe = function(pattern, options) {
    if (pattern instanceof RegExp) {
      return pattern;
    }

    if (typeof pattern !== 'string') {
      throw new TypeError('expected pattern to be a string');
    }

    if (pattern.length > MAX_LENGTH) {
      throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');
    }

    function makeRe() {
      var opts = utils.extend({wrap: false}, options);
      var result = nanomatch.create(pattern, opts);
      var regex = toRegex(result.output, opts);
      utils.define(regex, 'result', result);
      return regex;
    }

    return memoize('makeRe', pattern, options, makeRe);
  };

  /**
   * Parses the given glob `pattern` and returns an object with the compiled `output`
   * and optional source `map`.
   *
   * ```js
   * var nm = require('nanomatch');
   * nm.create(pattern[, options]);
   *
   * console.log(nm.create('abc/*.js'));
   * // { options: { source: 'string', sourcemap: true },
   * //   state: {},
   * //   compilers:
   * //    { ... },
   * //   output: '(\\.[\\\\\\/])?abc\\/(?!\\.)(?=.)[^\\/]*?\\.js',
   * //   ast:
   * //    { type: 'root',
   * //      errors: [],
   * //      nodes:
   * //       [ ... ],
   * //      dot: false,
   * //      input: 'abc/*.js' },
   * //   parsingErrors: [],
   * //   map:
   * //    { version: 3,
   * //      sources: [ 'string' ],
   * //      names: [],
   * //      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',
   * //      sourcesContent: [ 'abc/*.js' ] },
   * //   position: { line: 1, column: 28 },
   * //   content: {},
   * //   files: {},
   * //   idx: 6 }
   * ```
   * @param {String} `pattern` Glob pattern to parse and compile.
   * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.
   * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.
   * @api public
   */

  nanomatch.create = function(pattern, options) {
    if (typeof pattern !== 'string') {
      throw new TypeError('expected a string');
    }
    function create() {
      return nanomatch.compile(nanomatch.parse(pattern, options), options);
    }
    return memoize('create', pattern, options, create);
  };

  /**
   * Parse the given `str` with the given `options`.
   *
   * ```js
   * var nm = require('nanomatch');
   * nm.parse(pattern[, options]);
   *
   * var ast = nm.parse('a/{b,c}/d');
   * console.log(ast);
   * // { type: 'root',
   * //   errors: [],
   * //   input: 'a/{b,c}/d',
   * //   nodes:
   * //    [ { type: 'bos', val: '' },
   * //      { type: 'text', val: 'a/' },
   * //      { type: 'brace',
   * //        nodes:
   * //         [ { type: 'brace.open', val: '{' },
   * //           { type: 'text', val: 'b,c' },
   * //           { type: 'brace.close', val: '}' } ] },
   * //      { type: 'text', val: '/d' },
   * //      { type: 'eos', val: '' } ] }
   * ```
   * @param {String} `str`
   * @param {Object} `options`
   * @return {Object} Returns an AST
   * @api public
   */

  nanomatch.parse = function(pattern, options) {
    if (typeof pattern !== 'string') {
      throw new TypeError('expected a string');
    }

    function parse() {
      var snapdragon = utils.instantiate(null, options);
      parsers(snapdragon, options);

      var ast = snapdragon.parse(pattern, options);
      utils.define(ast, 'snapdragon', snapdragon);
      ast.input = pattern;
      return ast;
    }

    return memoize('parse', pattern, options, parse);
  };

  /**
   * Compile the given `ast` or string with the given `options`.
   *
   * ```js
   * var nm = require('nanomatch');
   * nm.compile(ast[, options]);
   *
   * var ast = nm.parse('a/{b,c}/d');
   * console.log(nm.compile(ast));
   * // { options: { source: 'string' },
   * //   state: {},
   * //   compilers:
   * //    { eos: [Function],
   * //      noop: [Function],
   * //      bos: [Function],
   * //      brace: [Function],
   * //      'brace.open': [Function],
   * //      text: [Function],
   * //      'brace.close': [Function] },
   * //   output: [ 'a/(b|c)/d' ],
   * //   ast:
   * //    { ... },
   * //   parsingErrors: [] }
   * ```
   * @param {Object|String} `ast`
   * @param {Object} `options`
   * @return {Object} Returns an object that has an `output` property with the compiled string.
   * @api public
   */

  nanomatch.compile = function(ast, options) {
    if (typeof ast === 'string') {
      ast = nanomatch.parse(ast, options);
    }

    function compile() {
      var snapdragon = utils.instantiate(ast, options);
      compilers(snapdragon, options);
      return snapdragon.compile(ast, options);
    }

    return memoize('compile', ast.input, options, compile);
  };

  /**
   * Clear the regex cache.
   *
   * ```js
   * nm.clearCache();
   * ```
   * @api public
   */

  nanomatch.clearCache = function() {
    nanomatch.cache.__data__ = {};
  };

  /**
   * Compose a matcher function with the given patterns.
   * This allows matcher functions to be compiled once and
   * called multiple times.
   */

  function compose(patterns, options, matcher) {
    var matchers;

    return memoize('compose', String(patterns), options, function() {
      return function(file) {
        // delay composition until it's invoked the first time,
        // after that it won't be called again
        if (!matchers) {
          matchers = [];
          for (var i = 0; i < patterns.length; i++) {
            matchers.push(matcher(patterns[i], options));
          }
        }

        var len = matchers.length;
        while (len--) {
          if (matchers[len](file) === true) {
            return true;
          }
        }
        return false;
      };
    });
  }

  /**
   * Memoize a generated regex or function. A unique key is generated
   * from the `type` (usually method name), the `pattern`, and
   * user-defined options.
   */

  function memoize(type, pattern, options, fn) {
    var key = utils.createKey(type + '=' + pattern, options);

    if (options && options.cache === false) {
      return fn(pattern, options);
    }

    if (cache.has(type, key)) {
      return cache.get(type, key);
    }

    var val = fn(pattern, options);
    cache.set(type, key, val);
    return val;
  }

  /**
   * Expose compiler, parser and cache on `nanomatch`
   */

  nanomatch.compilers = compilers;
  nanomatch.parsers = parsers;
  nanomatch.cache = cache;

  /**
   * Expose `nanomatch`
   * @type {Function}
   */

  module.exports = nanomatch;


  /***/ }),
  /* 378 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  /**
  * Nanomatch compilers
  */

  module.exports = function(nanomatch, options) {
    function slash() {
      if (options && typeof options.slash === 'string') {
        return options.slash;
      }
      if (options && typeof options.slash === 'function') {
        return options.slash.call(nanomatch);
      }
      return '\\\\/';
    }

    function star() {
      if (options && typeof options.star === 'string') {
        return options.star;
      }
      if (options && typeof options.star === 'function') {
        return options.star.call(nanomatch);
      }
      return '[^' + slash() + ']*?';
    }

    var ast = nanomatch.ast = nanomatch.parser.ast;
    ast.state = nanomatch.parser.state;
    nanomatch.compiler.state = ast.state;
    nanomatch.compiler

      /**
       * Negation / escaping
       */

      .set('not', function(node) {
        var prev = this.prev();
        if (this.options.nonegate === true || prev.type !== 'bos') {
          return this.emit('\\' + node.val, node);
        }
        return this.emit(node.val, node);
      })
      .set('escape', function(node) {
        if (this.options.unescape && /^[-\w_.]/.test(node.val)) {
          return this.emit(node.val, node);
        }
        return this.emit('\\' + node.val, node);
      })
      .set('quoted', function(node) {
        return this.emit(node.val, node);
      })

      /**
       * Regex
       */

      .set('dollar', function(node) {
        if (node.parent.type === 'bracket') {
          return this.emit(node.val, node);
        }
        return this.emit('\\' + node.val, node);
      })

      /**
       * Dot: "."
       */

      .set('dot', function(node) {
        if (node.dotfiles === true) this.dotfiles = true;
        return this.emit('\\' + node.val, node);
      })

      /**
       * Slashes: "/" and "\"
       */

      .set('backslash', function(node) {
        return this.emit(node.val, node);
      })
      .set('slash', function(node, nodes, i) {
        var val = '[' + slash() + ']';
        var parent = node.parent;
        var prev = this.prev();

        // set "node.hasSlash" to true on all ancestor parens nodes
        while (parent.type === 'paren' && !parent.hasSlash) {
          parent.hasSlash = true;
          parent = parent.parent;
        }

        if (prev.addQmark) {
          val += '?';
        }

        // word boundary
        if (node.rest.slice(0, 2) === '\\b') {
          return this.emit(val, node);
        }

        // globstars
        if (node.parsed === '**' || node.parsed === './**') {
          this.output = '(?:' + this.output;
          return this.emit(val + ')?', node);
        }

        // negation
        if (node.parsed === '!**' && this.options.nonegate !== true) {
          return this.emit(val + '?\\b', node);
        }
        return this.emit(val, node);
      })

      /**
       * Square brackets
       */

      .set('bracket', function(node) {
        var close = node.close;
        var open = !node.escaped ? '[' : '\\[';
        var negated = node.negated;
        var inner = node.inner;
        var val = node.val;

        if (node.escaped === true) {
          inner = inner.replace(/\\?(\W)/g, '\\$1');
          negated = '';
        }

        if (inner === ']-') {
          inner = '\\]\\-';
        }

        if (negated && inner.indexOf('.') === -1) {
          inner += '.';
        }
        if (negated && inner.indexOf('/') === -1) {
          inner += '/';
        }

        val = open + negated + inner + close;
        return this.emit(val, node);
      })

      /**
       * Square: "[.]" (only matches a single character in brackets)
       */

      .set('square', function(node) {
        var val = (/^\W/.test(node.val) ? '\\' : '') + node.val;
        return this.emit(val, node);
      })

      /**
       * Question mark: "?"
       */

      .set('qmark', function(node) {
        var prev = this.prev();
        // don't use "slash" variable so that we always avoid
        // matching backslashes and slashes with a qmark
        var val = '[^.\\\\/]';
        if (this.options.dot || (prev.type !== 'bos' && prev.type !== 'slash')) {
          val = '[^\\\\/]';
        }

        if (node.parsed.slice(-1) === '(') {
          var ch = node.rest.charAt(0);
          if (ch === '!' || ch === '=' || ch === ':') {
            return this.emit(node.val, node);
          }
        }

        if (node.val.length > 1) {
          val += '{' + node.val.length + '}';
        }
        return this.emit(val, node);
      })

      /**
       * Plus
       */

      .set('plus', function(node) {
        var prev = node.parsed.slice(-1);
        if (prev === ']' || prev === ')') {
          return this.emit(node.val, node);
        }
        if (!this.output || (/[?*+]/.test(ch) && node.parent.type !== 'bracket')) {
          return this.emit('\\+', node);
        }
        var ch = this.output.slice(-1);
        if (/\w/.test(ch) && !node.inside) {
          return this.emit('+\\+?', node);
        }
        return this.emit('+', node);
      })

      /**
       * globstar: '**'
       */

      .set('globstar', function(node, nodes, i) {
        if (!this.output) {
          this.state.leadingGlobstar = true;
        }

        var prev = this.prev();
        var before = this.prev(2);
        var next = this.next();
        var after = this.next(2);
        var type = prev.type;
        var val = node.val;

        if (prev.type === 'slash' && next.type === 'slash') {
          if (before.type === 'text') {
            this.output += '?';

            if (after.type !== 'text') {
              this.output += '\\b';
            }
          }
        }

        var parsed = node.parsed;
        if (parsed.charAt(0) === '!') {
          parsed = parsed.slice(1);
        }

        var isInside = node.isInside.paren || node.isInside.brace;
        if (parsed && type !== 'slash' && type !== 'bos' && !isInside) {
          val = star();
        } else {
          val = this.options.dot !== true
            ? '(?:(?!(?:[' + slash() + ']|^)\\.).)*?'
            : '(?:(?!(?:[' + slash() + ']|^)(?:\\.{1,2})($|[' + slash() + ']))(?!\\.{2}).)*?';
        }

        if ((type === 'slash' || type === 'bos') && this.options.dot !== true) {
          val = '(?!\\.)' + val;
        }

        if (prev.type === 'slash' && next.type === 'slash' && before.type !== 'text') {
          if (after.type === 'text' || after.type === 'star') {
            node.addQmark = true;
          }
        }

        if (this.options.capture) {
          val = '(' + val + ')';
        }

        return this.emit(val, node);
      })

      /**
       * Star: "*"
       */

      .set('star', function(node, nodes, i) {
        var prior = nodes[i - 2] || {};
        var prev = this.prev();
        var next = this.next();
        var type = prev.type;

        function isStart(n) {
          return n.type === 'bos' || n.type === 'slash';
        }

        if (this.output === '' && this.options.contains !== true) {
          this.output = '(?![' + slash() + '])';
        }

        if (type === 'bracket' && this.options.bash === false) {
          var str = next && next.type === 'bracket' ? star() : '*?';
          if (!prev.nodes || prev.nodes[1].type !== 'posix') {
            return this.emit(str, node);
          }
        }

        var prefix = !this.dotfiles && type !== 'text' && type !== 'escape'
          ? (this.options.dot ? '(?!(?:^|[' + slash() + '])\\.{1,2}(?:$|[' + slash() + ']))' : '(?!\\.)')
          : '';

        if (isStart(prev) || (isStart(prior) && type === 'not')) {
          if (prefix !== '(?!\\.)') {
            prefix += '(?!(\\.{2}|\\.[' + slash() + ']))(?=.)';
          } else {
            prefix += '(?=.)';
          }
        } else if (prefix === '(?!\\.)') {
          prefix = '';
        }

        if (prev.type === 'not' && prior.type === 'bos' && this.options.dot === true) {
          this.output = '(?!\\.)' + this.output;
        }

        var output = prefix + star();
        if (this.options.capture) {
          output = '(' + output + ')';
        }

        return this.emit(output, node);
      })

      /**
       * Text
       */

      .set('text', function(node) {
        return this.emit(node.val, node);
      })

      /**
       * End-of-string
       */

      .set('eos', function(node) {
        var prev = this.prev();
        var val = node.val;

        this.output = '(?:\\.[' + slash() + '](?=.))?' + this.output;
        if (this.state.metachar && prev.type !== 'qmark' && prev.type !== 'slash') {
          val += (this.options.contains ? '[' + slash() + ']?' : '(?:[' + slash() + ']|$)');
        }

        return this.emit(val, node);
      });

    /**
     * Allow custom compilers to be passed on options
     */

    if (options && typeof options.compilers === 'function') {
      options.compilers(nanomatch.compiler);
    }
  };



  /***/ }),
  /* 379 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var regexNot = __webpack_require__(300);
  var toRegex = __webpack_require__(283);

  /**
   * Characters to use in negation regex (we want to "not" match
   * characters that are matched by other parsers)
   */

  var cached;
  var NOT_REGEX = '[\\[!*+?$^"\'.\\\\/]+';
  var not = createTextRegex(NOT_REGEX);

  /**
   * Nanomatch parsers
   */

  module.exports = function(nanomatch, options) {
    var parser = nanomatch.parser;
    var opts = parser.options;

    parser.state = {
      slashes: 0,
      paths: []
    };

    parser.ast.state = parser.state;
    parser

      /**
       * Beginning-of-string
       */

      .capture('prefix', function() {
        if (this.parsed) return;
        var m = this.match(/^\.[\\/]/);
        if (!m) return;
        this.state.strictOpen = !!this.options.strictOpen;
        this.state.addPrefix = true;
      })

      /**
       * Escape: "\\."
       */

      .capture('escape', function() {
        if (this.isInside('bracket')) return;
        var pos = this.position();
        var m = this.match(/^(?:\\(.)|([$^]))/);
        if (!m) return;

        return pos({
          type: 'escape',
          val: m[2] || m[1]
        });
      })

      /**
       * Quoted strings
       */

      .capture('quoted', function() {
        var pos = this.position();
        var m = this.match(/^["']/);
        if (!m) return;

        var quote = m[0];
        if (this.input.indexOf(quote) === -1) {
          return pos({
            type: 'escape',
            val: quote
          });
        }

        var tok = advanceTo(this.input, quote);
        this.consume(tok.len);

        return pos({
          type: 'quoted',
          val: tok.esc
        });
      })

      /**
       * Negations: "!"
       */

      .capture('not', function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(this.notRegex || /^!+/);
        if (!m) return;
        var val = m[0];

        var isNegated = (val.length % 2) === 1;
        if (parsed === '' && !isNegated) {
          val = '';
        }

        // if nothing has been parsed, we know `!` is at the start,
        // so we need to wrap the result in a negation regex
        if (parsed === '' && isNegated && this.options.nonegate !== true) {
          this.bos.val = '(?!^(?:';
          this.append = ')$).*';
          val = '';
        }
        return pos({
          type: 'not',
          val: val
        });
      })

      /**
       * Dot: "."
       */

      .capture('dot', function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\.+/);
        if (!m) return;

        var val = m[0];
        this.state.dot = val === '.' && (parsed === '' || parsed.slice(-1) === '/');

        return pos({
          type: 'dot',
          dotfiles: this.state.dot,
          val: val
        });
      })

      /**
       * Plus: "+"
       */

      .capture('plus', /^\+(?!\()/)

      /**
       * Question mark: "?"
       */

      .capture('qmark', function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\?+(?!\()/);
        if (!m) return;

        this.state.metachar = true;
        this.state.qmark = true;

        return pos({
          type: 'qmark',
          parsed: parsed,
          val: m[0]
        });
      })

      /**
       * Globstar: "**"
       */

      .capture('globstar', function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\*{2}(?![*(])(?=[,)/]|$)/);
        if (!m) return;

        var type = opts.noglobstar !== true ? 'globstar' : 'star';
        var node = pos({type: type, parsed: parsed});
        this.state.metachar = true;

        while (this.input.slice(0, 4) === '/**/') {
          this.input = this.input.slice(3);
        }

        node.isInside = {
          brace: this.isInside('brace'),
          paren: this.isInside('paren')
        };

        if (type === 'globstar') {
          this.state.globstar = true;
          node.val = '**';

        } else {
          this.state.star = true;
          node.val = '*';
        }

        return node;
      })

      /**
       * Star: "*"
       */

      .capture('star', function() {
        var pos = this.position();
        var starRe = /^(?:\*(?![*(])|[*]{3,}(?!\()|[*]{2}(?![(/]|$)|\*(?=\*\())/;
        var m = this.match(starRe);
        if (!m) return;

        this.state.metachar = true;
        this.state.star = true;
        return pos({
          type: 'star',
          val: m[0]
        });
      })

      /**
       * Slash: "/"
       */

      .capture('slash', function() {
        var pos = this.position();
        var m = this.match(/^\//);
        if (!m) return;

        this.state.slashes++;
        return pos({
          type: 'slash',
          val: m[0]
        });
      })

      /**
       * Backslash: "\\"
       */

      .capture('backslash', function() {
        var pos = this.position();
        var m = this.match(/^\\(?![*+?(){}[\]'"])/);
        if (!m) return;

        var val = m[0];

        if (this.isInside('bracket')) {
          val = '\\';
        } else if (val.length > 1) {
          val = '\\\\';
        }

        return pos({
          type: 'backslash',
          val: val
        });
      })

      /**
       * Square: "[.]"
       */

      .capture('square', function() {
        if (this.isInside('bracket')) return;
        var pos = this.position();
        var m = this.match(/^\[([^!^\\])\]/);
        if (!m) return;

        return pos({
          type: 'square',
          val: m[1]
        });
      })

      /**
       * Brackets: "[...]" (basic, this can be overridden by other parsers)
       */

      .capture('bracket', function() {
        var pos = this.position();
        var m = this.match(/^(?:\[([!^]?)([^\]]+|\]-)(\]|[^*+?]+)|\[)/);
        if (!m) return;

        var val = m[0];
        var negated = m[1] ? '^' : '';
        var inner = (m[2] || '').replace(/\\\\+/, '\\\\');
        var close = m[3] || '';

        if (m[2] && inner.length < m[2].length) {
          val = val.replace(/\\\\+/, '\\\\');
        }

        var esc = this.input.slice(0, 2);
        if (inner === '' && esc === '\\]') {
          inner += esc;
          this.consume(2);

          var str = this.input;
          var idx = -1;
          var ch;

          while ((ch = str[++idx])) {
            this.consume(1);
            if (ch === ']') {
              close = ch;
              break;
            }
            inner += ch;
          }
        }

        return pos({
          type: 'bracket',
          val: val,
          escaped: close !== ']',
          negated: negated,
          inner: inner,
          close: close
        });
      })

      /**
       * Text
       */

      .capture('text', function() {
        if (this.isInside('bracket')) return;
        var pos = this.position();
        var m = this.match(not);
        if (!m || !m[0]) return;

        return pos({
          type: 'text',
          val: m[0]
        });
      });

    /**
     * Allow custom parsers to be passed on options
     */

    if (options && typeof options.parsers === 'function') {
      options.parsers(nanomatch.parser);
    }
  };

  /**
   * Advance to the next non-escaped character
   */

  function advanceTo(input, endChar) {
    var ch = input.charAt(0);
    var tok = { len: 1, val: '', esc: '' };
    var idx = 0;

    function advance() {
      if (ch !== '\\') {
        tok.esc += '\\' + ch;
        tok.val += ch;
      }

      ch = input.charAt(++idx);
      tok.len++;

      if (ch === '\\') {
        advance();
        advance();
      }
    }

    while (ch && ch !== endChar) {
      advance();
    }
    return tok;
  }

  /**
   * Create text regex
   */

  function createTextRegex(pattern) {
    if (cached) return cached;
    var opts = {contains: true, strictClose: false};
    var not = regexNot.create(pattern, opts);
    var re = toRegex('^(?:[*]\\((?=.)|' + not + ')', opts);
    return (cached = re);
  }

  /**
   * Expose negation string
   */

  module.exports.not = NOT_REGEX;


  /***/ }),
  /* 380 */
  /***/ (function(module, exports, __webpack_require__) {

  module.exports = new (__webpack_require__(381))();


  /***/ }),
  /* 381 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * fragment-cache <https://github.com/jonschlinkert/fragment-cache>
   *
   * Copyright (c) 2016-2017, Jon Schlinkert.
   * Released under the MIT License.
   */



  var MapCache = __webpack_require__(374);

  /**
   * Create a new `FragmentCache` with an optional object to use for `caches`.
   *
   * ```js
   * var fragment = new FragmentCache();
   * ```
   * @name FragmentCache
   * @param {String} `cacheName`
   * @return {Object} Returns the [map-cache][] instance.
   * @api public
   */

  function FragmentCache(caches) {
    this.caches = caches || {};
  }

  /**
   * Prototype
   */

  FragmentCache.prototype = {

    /**
     * Get cache `name` from the `fragment.caches` object. Creates a new
     * `MapCache` if it doesn't already exist.
     *
     * ```js
     * var cache = fragment.cache('files');
     * console.log(fragment.caches.hasOwnProperty('files'));
     * //=> true
     * ```
     * @name .cache
     * @param {String} `cacheName`
     * @return {Object} Returns the [map-cache][] instance.
     * @api public
     */

    cache: function(cacheName) {
      return this.caches[cacheName] || (this.caches[cacheName] = new MapCache());
    },

    /**
     * Set a value for property `key` on cache `name`
     *
     * ```js
     * fragment.set('files', 'somefile.js', new File({path: 'somefile.js'}));
     * ```
     * @name .set
     * @param {String} `name`
     * @param {String} `key` Property name to set
     * @param {any} `val` The value of `key`
     * @return {Object} The cache instance for chaining
     * @api public
     */

    set: function(cacheName, key, val) {
      var cache = this.cache(cacheName);
      cache.set(key, val);
      return cache;
    },

    /**
     * Returns true if a non-undefined value is set for `key` on fragment cache `name`.
     *
     * ```js
     * var cache = fragment.cache('files');
     * cache.set('somefile.js');
     *
     * console.log(cache.has('somefile.js'));
     * //=> true
     *
     * console.log(cache.has('some-other-file.js'));
     * //=> false
     * ```
     * @name .has
     * @param {String} `name` Cache name
     * @param {String} `key` Optionally specify a property to check for on cache `name`
     * @return {Boolean}
     * @api public
     */

    has: function(cacheName, key) {
      return typeof this.get(cacheName, key) !== 'undefined';
    },

    /**
     * Get `name`, or if specified, the value of `key`. Invokes the [cache]() method,
     * so that cache `name` will be created it doesn't already exist. If `key` is not passed,
     * the entire cache (`name`) is returned.
     *
     * ```js
     * var Vinyl = require('vinyl');
     * var cache = fragment.cache('files');
     * cache.set('somefile.js', new Vinyl({path: 'somefile.js'}));
     * console.log(cache.get('somefile.js'));
     * //=> <File "somefile.js">
     * ```
     * @name .get
     * @param {String} `name`
     * @return {Object} Returns cache `name`, or the value of `key` if specified
     * @api public
     */

    get: function(name, key) {
      var cache = this.cache(name);
      if (typeof key === 'string') {
        return cache.get(key);
      }
      return cache;
    }
  };

  /**
   * Expose `FragmentCache`
   */

  exports = module.exports = FragmentCache;


  /***/ }),
  /* 382 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var utils = module.exports;
  var path = __webpack_require__(8);

  /**
   * Module dependencies
   */

  var isWindows = __webpack_require__(383)();
  var Snapdragon = __webpack_require__(320);
  utils.define = __webpack_require__(290);
  utils.diff = __webpack_require__(384);
  utils.extend = __webpack_require__(296);
  utils.pick = __webpack_require__(385);
  utils.typeOf = __webpack_require__(293);
  utils.unique = __webpack_require__(301);

  /**
   * Returns true if the given value is effectively an empty string
   */

  utils.isEmptyString = function(val) {
    return String(val) === '' || String(val) === './';
  };

  /**
   * Returns true if the platform is windows, or `path.sep` is `\\`.
   * This is defined as a function to allow `path.sep` to be set in unit tests,
   * or by the user, if there is a reason to do so.
   * @return {Boolean}
   */

  utils.isWindows = function() {
    return path.sep === '\\' || isWindows === true;
  };

  /**
   * Return the last element from an array
   */

  utils.last = function(arr, n) {
    return arr[arr.length - (n || 1)];
  };

  /**
   * Get the `Snapdragon` instance to use
   */

  utils.instantiate = function(ast, options) {
    var snapdragon;
    // if an instance was created by `.parse`, use that instance
    if (utils.typeOf(ast) === 'object' && ast.snapdragon) {
      snapdragon = ast.snapdragon;
    // if the user supplies an instance on options, use that instance
    } else if (utils.typeOf(options) === 'object' && options.snapdragon) {
      snapdragon = options.snapdragon;
    // create a new instance
    } else {
      snapdragon = new Snapdragon(options);
    }

    utils.define(snapdragon, 'parse', function(str, options) {
      var parsed = Snapdragon.prototype.parse.call(this, str, options);
      parsed.input = str;

      // escape unmatched brace/bracket/parens
      var last = this.parser.stack.pop();
      if (last && this.options.strictErrors !== true) {
        var open = last.nodes[0];
        var inner = last.nodes[1];
        if (last.type === 'bracket') {
          if (inner.val.charAt(0) === '[') {
            inner.val = '\\' + inner.val;
          }

        } else {
          open.val = '\\' + open.val;
          var sibling = open.parent.nodes[1];
          if (sibling.type === 'star') {
            sibling.loose = true;
          }
        }
      }

      // add non-enumerable parser reference
      utils.define(parsed, 'parser', this.parser);
      return parsed;
    });

    return snapdragon;
  };

  /**
   * Create the key to use for memoization. The key is generated
   * by iterating over the options and concatenating key-value pairs
   * to the pattern string.
   */

  utils.createKey = function(pattern, options) {
    if (typeof options === 'undefined') {
      return pattern;
    }
    var key = pattern;
    for (var prop in options) {
      if (options.hasOwnProperty(prop)) {
        key += ';' + prop + '=' + String(options[prop]);
      }
    }
    return key;
  };

  /**
   * Cast `val` to an array
   * @return {Array}
   */

  utils.arrayify = function(val) {
    if (typeof val === 'string') return [val];
    return val ? (Array.isArray(val) ? val : [val]) : [];
  };

  /**
   * Return true if `val` is a non-empty string
   */

  utils.isString = function(val) {
    return typeof val === 'string';
  };

  /**
   * Return true if `val` is a non-empty string
   */

  utils.isRegex = function(val) {
    return utils.typeOf(val) === 'regexp';
  };

  /**
   * Return true if `val` is a non-empty string
   */

  utils.isObject = function(val) {
    return utils.typeOf(val) === 'object';
  };

  /**
   * Escape regex characters in the given string
   */

  utils.escapeRegex = function(str) {
    return str.replace(/[-[\]{}()^$|*+?.\\/\s]/g, '\\$&');
  };

  /**
   * Combines duplicate characters in the provided `input` string.
   * @param {String} `input`
   * @returns {String}
   */

  utils.combineDupes = function(input, patterns) {
    patterns = utils.arrayify(patterns).join('|').split('|');
    patterns = patterns.map(function(s) {
      return s.replace(/\\?([+*\\/])/g, '\\$1');
    });
    var substr = patterns.join('|');
    var regex = new RegExp('(' + substr + ')(?=\\1)', 'g');
    return input.replace(regex, '');
  };

  /**
   * Returns true if the given `str` has special characters
   */

  utils.hasSpecialChars = function(str) {
    return /(?:(?:(^|\/)[!.])|[*?+()|[\]{}]|[+@]\()/.test(str);
  };

  /**
   * Normalize slashes in the given filepath.
   *
   * @param {String} `filepath`
   * @return {String}
   */

  utils.toPosixPath = function(str) {
    return str.replace(/\\+/g, '/');
  };

  /**
   * Strip backslashes before special characters in a string.
   *
   * @param {String} `str`
   * @return {String}
   */

  utils.unescape = function(str) {
    return utils.toPosixPath(str.replace(/\\(?=[*+?!.])/g, ''));
  };

  /**
   * Strip the drive letter from a windows filepath
   * @param {String} `fp`
   * @return {String}
   */

  utils.stripDrive = function(fp) {
    return utils.isWindows() ? fp.replace(/^[a-z]:[\\/]+?/i, '/') : fp;
  };

  /**
   * Strip the prefix from a filepath
   * @param {String} `fp`
   * @return {String}
   */

  utils.stripPrefix = function(str) {
    if (str.charAt(0) === '.' && (str.charAt(1) === '/' || str.charAt(1) === '\\')) {
      return str.slice(2);
    }
    return str;
  };

  /**
   * Returns true if `str` is a common character that doesn't need
   * to be processed to be used for matching.
   * @param {String} `str`
   * @return {Boolean}
   */

  utils.isSimpleChar = function(str) {
    return str.trim() === '' || str === '.';
  };

  /**
   * Returns true if the given str is an escaped or
   * unescaped path character
   */

  utils.isSlash = function(str) {
    return str === '/' || str === '\\/' || str === '\\' || str === '\\\\';
  };

  /**
   * Returns a function that returns true if the given
   * pattern matches or contains a `filepath`
   *
   * @param {String} `pattern`
   * @return {Function}
   */

  utils.matchPath = function(pattern, options) {
    return (options && options.contains)
      ? utils.containsPattern(pattern, options)
      : utils.equalsPattern(pattern, options);
  };

  /**
   * Returns true if the given (original) filepath or unixified path are equal
   * to the given pattern.
   */

  utils._equals = function(filepath, unixPath, pattern) {
    return pattern === filepath || pattern === unixPath;
  };

  /**
   * Returns true if the given (original) filepath or unixified path contain
   * the given pattern.
   */

  utils._contains = function(filepath, unixPath, pattern) {
    return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;
  };

  /**
   * Returns a function that returns true if the given
   * pattern is the same as a given `filepath`
   *
   * @param {String} `pattern`
   * @return {Function}
   */

  utils.equalsPattern = function(pattern, options) {
    var unixify = utils.unixify(options);
    options = options || {};

    return function fn(filepath) {
      var equal = utils._equals(filepath, unixify(filepath), pattern);
      if (equal === true || options.nocase !== true) {
        return equal;
      }
      var lower = filepath.toLowerCase();
      return utils._equals(lower, unixify(lower), pattern);
    };
  };

  /**
   * Returns a function that returns true if the given
   * pattern contains a `filepath`
   *
   * @param {String} `pattern`
   * @return {Function}
   */

  utils.containsPattern = function(pattern, options) {
    var unixify = utils.unixify(options);
    options = options || {};

    return function(filepath) {
      var contains = utils._contains(filepath, unixify(filepath), pattern);
      if (contains === true || options.nocase !== true) {
        return contains;
      }
      var lower = filepath.toLowerCase();
      return utils._contains(lower, unixify(lower), pattern);
    };
  };

  /**
   * Returns a function that returns true if the given
   * regex matches the `filename` of a file path.
   *
   * @param {RegExp} `re` Matching regex
   * @return {Function}
   */

  utils.matchBasename = function(re) {
    return function(filepath) {
      return re.test(filepath) || re.test(path.basename(filepath));
    };
  };

  /**
   * Returns the given value unchanced.
   * @return {any}
   */

  utils.identity = function(val) {
    return val;
  };

  /**
   * Determines the filepath to return based on the provided options.
   * @return {any}
   */

  utils.value = function(str, unixify, options) {
    if (options && options.unixify === false) {
      return str;
    }
    if (options && typeof options.unixify === 'function') {
      return options.unixify(str);
    }
    return unixify(str);
  };

  /**
   * Returns a function that normalizes slashes in a string to forward
   * slashes, strips `./` from beginning of paths, and optionally unescapes
   * special characters.
   * @return {Function}
   */

  utils.unixify = function(options) {
    var opts = options || {};
    return function(filepath) {
      if (opts.stripPrefix !== false) {
        filepath = utils.stripPrefix(filepath);
      }
      if (opts.unescape === true) {
        filepath = utils.unescape(filepath);
      }
      if (opts.unixify === true || utils.isWindows()) {
        filepath = utils.toPosixPath(filepath);
      }
      return filepath;
    };
  };


  /***/ }),
  /* 383 */
  /***/ (function(module, exports, __webpack_require__) {

  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
   * is-windows <https://github.com/jonschlinkert/is-windows>
   *
   * Copyright © 2015-2018, Jon Schlinkert.
   * Released under the MIT License.
   */

  (function(factory) {
    if (exports && typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = factory();
    } else if (true) {
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
  				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
  				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
  				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
  })(function() {
    'use strict';
    return function isWindows() {
      return process && (process.platform === 'win32' || /^(msys|cygwin)$/.test(process.env.OSTYPE));
    };
  });


  /***/ }),
  /* 384 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * arr-diff <https://github.com/jonschlinkert/arr-diff>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */



  module.exports = function diff(arr/*, arrays*/) {
    var len = arguments.length;
    var idx = 0;
    while (++idx < len) {
      arr = diffArray(arr, arguments[idx]);
    }
    return arr;
  };

  function diffArray(one, two) {
    if (!Array.isArray(two)) {
      return one.slice();
    }

    var tlen = two.length
    var olen = one.length;
    var idx = -1;
    var arr = [];

    while (++idx < olen) {
      var ele = one[idx];

      var hasEle = false;
      for (var i = 0; i < tlen; i++) {
        var val = two[i];

        if (ele === val) {
          hasEle = true;
          break;
        }
      }

      if (hasEle === false) {
        arr.push(ele);
      }
    }
    return arr;
  }


  /***/ }),
  /* 385 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  /*!
   * object.pick <https://github.com/jonschlinkert/object.pick>
   *
   * Copyright (c) 2014-2015 Jon Schlinkert, contributors.
   * Licensed under the MIT License
   */



  var isObject = __webpack_require__(291);

  module.exports = function pick(obj, keys) {
    if (!isObject(obj) && typeof obj !== 'function') {
      return {};
    }

    var res = {};
    if (typeof keys === 'string') {
      if (keys in obj) {
        res[keys] = obj[keys];
      }
      return res;
    }

    var len = keys.length;
    var idx = -1;

    while (++idx < len) {
      var key = keys[idx];
      if (key in obj) {
        res[key] = obj[key];
      }
    }
    return res;
  };


  /***/ }),
  /* 386 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  /**
   * Module dependencies
   */

  var extend = __webpack_require__(302);
  var unique = __webpack_require__(301);
  var toRegex = __webpack_require__(283);

  /**
   * Local dependencies
   */

  var compilers = __webpack_require__(387);
  var parsers = __webpack_require__(393);
  var Extglob = __webpack_require__(395);
  var utils = __webpack_require__(394);
  var MAX_LENGTH = 1024 * 64;

  /**
   * Convert the given `extglob` pattern into a regex-compatible string. Returns
   * an object with the compiled result and the parsed AST.
   *
   * ```js
   * var extglob = require('extglob');
   * console.log(extglob('*.!(*a)'));
   * //=> '(?!\\.)[^/]*?\\.(?!(?!\\.)[^/]*?a\\b).*?'
   * ```
   * @param {String} `pattern`
   * @param {Object} `options`
   * @return {String}
   * @api public
   */

  function extglob(pattern, options) {
    return extglob.create(pattern, options).output;
  }

  /**
   * Takes an array of strings and an extglob pattern and returns a new
   * array that contains only the strings that match the pattern.
   *
   * ```js
   * var extglob = require('extglob');
   * console.log(extglob.match(['a.a', 'a.b', 'a.c'], '*.!(*a)'));
   * //=> ['a.b', 'a.c']
   * ```
   * @param {Array} `list` Array of strings to match
   * @param {String} `pattern` Extglob pattern
   * @param {Object} `options`
   * @return {Array} Returns an array of matches
   * @api public
   */

  extglob.match = function(list, pattern, options) {
    if (typeof pattern !== 'string') {
      throw new TypeError('expected pattern to be a string');
    }

    list = utils.arrayify(list);
    var isMatch = extglob.matcher(pattern, options);
    var len = list.length;
    var idx = -1;
    var matches = [];

    while (++idx < len) {
      var ele = list[idx];

      if (isMatch(ele)) {
        matches.push(ele);
      }
    }

    // if no options were passed, uniquify results and return
    if (typeof options === 'undefined') {
      return unique(matches);
    }

    if (matches.length === 0) {
      if (options.failglob === true) {
        throw new Error('no matches found for "' + pattern + '"');
      }
      if (options.nonull === true || options.nullglob === true) {
        return [pattern.split('\\').join('')];
      }
    }

    return options.nodupes !== false ? unique(matches) : matches;
  };

  /**
   * Returns true if the specified `string` matches the given
   * extglob `pattern`.
   *
   * ```js
   * var extglob = require('extglob');
   *
   * console.log(extglob.isMatch('a.a', '*.!(*a)'));
   * //=> false
   * console.log(extglob.isMatch('a.b', '*.!(*a)'));
   * //=> true
   * ```
   * @param {String} `string` String to match
   * @param {String} `pattern` Extglob pattern
   * @param {String} `options`
   * @return {Boolean}
   * @api public
   */

  extglob.isMatch = function(str, pattern, options) {
    if (typeof pattern !== 'string') {
      throw new TypeError('expected pattern to be a string');
    }

    if (typeof str !== 'string') {
      throw new TypeError('expected a string');
    }

    if (pattern === str) {
      return true;
    }

    if (pattern === '' || pattern === ' ' || pattern === '.') {
      return pattern === str;
    }

    var isMatch = utils.memoize('isMatch', pattern, options, extglob.matcher);
    return isMatch(str);
  };

  /**
   * Returns true if the given `string` contains the given pattern. Similar to `.isMatch` but
   * the pattern can match any part of the string.
   *
   * ```js
   * var extglob = require('extglob');
   * console.log(extglob.contains('aa/bb/cc', '*b'));
   * //=> true
   * console.log(extglob.contains('aa/bb/cc', '*d'));
   * //=> false
   * ```
   * @param {String} `str` The string to match.
   * @param {String} `pattern` Glob pattern to use for matching.
   * @param {Object} `options`
   * @return {Boolean} Returns true if the patter matches any part of `str`.
   * @api public
   */

  extglob.contains = function(str, pattern, options) {
    if (typeof str !== 'string') {
      throw new TypeError('expected a string');
    }

    if (pattern === '' || pattern === ' ' || pattern === '.') {
      return pattern === str;
    }

    var opts = extend({}, options, {contains: true});
    opts.strictClose = false;
    opts.strictOpen = false;
    return extglob.isMatch(str, pattern, opts);
  };

  /**
   * Takes an extglob pattern and returns a matcher function. The returned
   * function takes the string to match as its only argument.
   *
   * ```js
   * var extglob = require('extglob');
   * var isMatch = extglob.matcher('*.!(*a)');
   *
   * console.log(isMatch('a.a'));
   * //=> false
   * console.log(isMatch('a.b'));
   * //=> true
   * ```
   * @param {String} `pattern` Extglob pattern
   * @param {String} `options`
   * @return {Boolean}
   * @api public
   */

  extglob.matcher = function(pattern, options) {
    if (typeof pattern !== 'string') {
      throw new TypeError('expected pattern to be a string');
    }

    function matcher() {
      var re = extglob.makeRe(pattern, options);
      return function(str) {
        return re.test(str);
      };
    }

    return utils.memoize('matcher', pattern, options, matcher);
  };

  /**
   * Convert the given `extglob` pattern into a regex-compatible string. Returns
   * an object with the compiled result and the parsed AST.
   *
   * ```js
   * var extglob = require('extglob');
   * console.log(extglob.create('*.!(*a)').output);
   * //=> '(?!\\.)[^/]*?\\.(?!(?!\\.)[^/]*?a\\b).*?'
   * ```
   * @param {String} `str`
   * @param {Object} `options`
   * @return {String}
   * @api public
   */

  extglob.create = function(pattern, options) {
    if (typeof pattern !== 'string') {
      throw new TypeError('expected pattern to be a string');
    }

    function create() {
      var ext = new Extglob(options);
      var ast = ext.parse(pattern, options);
      return ext.compile(ast, options);
    }

    return utils.memoize('create', pattern, options, create);
  };

  /**
   * Returns an array of matches captured by `pattern` in `string`, or `null`
   * if the pattern did not match.
   *
   * ```js
   * var extglob = require('extglob');
   * extglob.capture(pattern, string[, options]);
   *
   * console.log(extglob.capture('test/*.js', 'test/foo.js'));
   * //=> ['foo']
   * console.log(extglob.capture('test/*.js', 'foo/bar.css'));
   * //=> null
   * ```
   * @param {String} `pattern` Glob pattern to use for matching.
   * @param {String} `string` String to match
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.
   * @api public
   */

  extglob.capture = function(pattern, str, options) {
    var re = extglob.makeRe(pattern, extend({capture: true}, options));

    function match() {
      return function(string) {
        var match = re.exec(string);
        if (!match) {
          return null;
        }

        return match.slice(1);
      };
    }

    var capture = utils.memoize('capture', pattern, options, match);
    return capture(str);
  };

  /**
   * Create a regular expression from the given `pattern` and `options`.
   *
   * ```js
   * var extglob = require('extglob');
   * var re = extglob.makeRe('*.!(*a)');
   * console.log(re);
   * //=> /^[^\/]*?\.(?![^\/]*?a)[^\/]*?$/
   * ```
   * @param {String} `pattern` The pattern to convert to regex.
   * @param {Object} `options`
   * @return {RegExp}
   * @api public
   */

  extglob.makeRe = function(pattern, options) {
    if (pattern instanceof RegExp) {
      return pattern;
    }

    if (typeof pattern !== 'string') {
      throw new TypeError('expected pattern to be a string');
    }

    if (pattern.length > MAX_LENGTH) {
      throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');
    }

    function makeRe() {
      var opts = extend({strictErrors: false}, options);
      if (opts.strictErrors === true) opts.strict = true;
      var res = extglob.create(pattern, opts);
      return toRegex(res.output, opts);
    }

    var regex = utils.memoize('makeRe', pattern, options, makeRe);
    if (regex.source.length > MAX_LENGTH) {
      throw new SyntaxError('potentially malicious regex detected');
    }

    return regex;
  };

  /**
   * Cache
   */

  extglob.cache = utils.cache;
  extglob.clearCache = function() {
    extglob.cache.__data__ = {};
  };

  /**
   * Expose `Extglob` constructor, parsers and compilers
   */

  extglob.Extglob = Extglob;
  extglob.compilers = compilers;
  extglob.parsers = parsers;

  /**
   * Expose `extglob`
   * @type {Function}
   */

  module.exports = extglob;


  /***/ }),
  /* 387 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var brackets = __webpack_require__(388);

  /**
   * Extglob compilers
   */

  module.exports = function(extglob) {
    function star() {
      if (typeof extglob.options.star === 'function') {
        return extglob.options.star.apply(this, arguments);
      }
      if (typeof extglob.options.star === 'string') {
        return extglob.options.star;
      }
      return '.*?';
    }

    /**
     * Use `expand-brackets` compilers
     */

    extglob.use(brackets.compilers);
    extglob.compiler

      /**
       * Escaped: "\\*"
       */

      .set('escape', function(node) {
        return this.emit(node.val, node);
      })

      /**
       * Dot: "."
       */

      .set('dot', function(node) {
        return this.emit('\\' + node.val, node);
      })

      /**
       * Question mark: "?"
       */

      .set('qmark', function(node) {
        var val = '[^\\\\/.]';
        var prev = this.prev();

        if (node.parsed.slice(-1) === '(') {
          var ch = node.rest.charAt(0);
          if (ch !== '!' && ch !== '=' && ch !== ':') {
            return this.emit(val, node);
          }
          return this.emit(node.val, node);
        }

        if (prev.type === 'text' && prev.val) {
          return this.emit(val, node);
        }

        if (node.val.length > 1) {
          val += '{' + node.val.length + '}';
        }
        return this.emit(val, node);
      })

      /**
       * Plus: "+"
       */

      .set('plus', function(node) {
        var prev = node.parsed.slice(-1);
        if (prev === ']' || prev === ')') {
          return this.emit(node.val, node);
        }
        var ch = this.output.slice(-1);
        if (!this.output || (/[?*+]/.test(ch) && node.parent.type !== 'bracket')) {
          return this.emit('\\+', node);
        }
        if (/\w/.test(ch) && !node.inside) {
          return this.emit('+\\+?', node);
        }
        return this.emit('+', node);
      })

      /**
       * Star: "*"
       */

      .set('star', function(node) {
        var prev = this.prev();
        var prefix = prev.type !== 'text' && prev.type !== 'escape'
          ? '(?!\\.)'
          : '';

        return this.emit(prefix + star.call(this, node), node);
      })

      /**
       * Parens
       */

      .set('paren', function(node) {
        return this.mapVisit(node.nodes);
      })
      .set('paren.open', function(node) {
        var capture = this.options.capture ? '(' : '';

        switch (node.parent.prefix) {
          case '!':
          case '^':
            return this.emit(capture + '(?:(?!(?:', node);
          case '*':
          case '+':
          case '?':
          case '@':
            return this.emit(capture + '(?:', node);
          default: {
            var val = node.val;
            if (this.options.bash === true) {
              val = '\\' + val;
            } else if (!this.options.capture && val === '(' && node.parent.rest[0] !== '?') {
              val += '?:';
            }

            return this.emit(val, node);
          }
        }
      })
      .set('paren.close', function(node) {
        var capture = this.options.capture ? ')' : '';

        switch (node.prefix) {
          case '!':
          case '^':
            var prefix = /^(\)|$)/.test(node.rest) ? '$' : '';
            var str = star.call(this, node);

            // if the extglob has a slash explicitly defined, we know the user wants
            // to match slashes, so we need to ensure the "star" regex allows for it
            if (node.parent.hasSlash && !this.options.star && this.options.slash !== false) {
              str = '.*?';
            }

            return this.emit(prefix + ('))' + str + ')') + capture, node);
          case '*':
          case '+':
          case '?':
            return this.emit(')' + node.prefix + capture, node);
          case '@':
            return this.emit(')' + capture, node);
          default: {
            var val = (this.options.bash === true ? '\\' : '') + ')';
            return this.emit(val, node);
          }
        }
      })

      /**
       * Text
       */

      .set('text', function(node) {
        var val = node.val.replace(/[\[\]]/g, '\\$&');
        return this.emit(val, node);
      });
  };


  /***/ }),
  /* 388 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  /**
   * Local dependencies
   */

  var compilers = __webpack_require__(389);
  var parsers = __webpack_require__(391);

  /**
   * Module dependencies
   */

  var debug = __webpack_require__(354)('expand-brackets');
  var extend = __webpack_require__(302);
  var Snapdragon = __webpack_require__(320);
  var toRegex = __webpack_require__(283);

  /**
   * Parses the given POSIX character class `pattern` and returns a
   * string that can be used for creating regular expressions for matching.
   *
   * @param {String} `pattern`
   * @param {Object} `options`
   * @return {Object}
   * @api public
   */

  function brackets(pattern, options) {
    debug('initializing from <%s>', __filename);
    var res = brackets.create(pattern, options);
    return res.output;
  }

  /**
   * Takes an array of strings and a POSIX character class pattern, and returns a new
   * array with only the strings that matched the pattern.
   *
   * ```js
   * var brackets = require('expand-brackets');
   * console.log(brackets.match(['1', 'a', 'ab'], '[[:alpha:]]'));
   * //=> ['a']
   *
   * console.log(brackets.match(['1', 'a', 'ab'], '[[:alpha:]]+'));
   * //=> ['a', 'ab']
   * ```
   * @param {Array} `arr` Array of strings to match
   * @param {String} `pattern` POSIX character class pattern(s)
   * @param {Object} `options`
   * @return {Array}
   * @api public
   */

  brackets.match = function(arr, pattern, options) {
    arr = [].concat(arr);
    var opts = extend({}, options);
    var isMatch = brackets.matcher(pattern, opts);
    var len = arr.length;
    var idx = -1;
    var res = [];

    while (++idx < len) {
      var ele = arr[idx];
      if (isMatch(ele)) {
        res.push(ele);
      }
    }

    if (res.length === 0) {
      if (opts.failglob === true) {
        throw new Error('no matches found for "' + pattern + '"');
      }

      if (opts.nonull === true || opts.nullglob === true) {
        return [pattern.split('\\').join('')];
      }
    }
    return res;
  };

  /**
   * Returns true if the specified `string` matches the given
   * brackets `pattern`.
   *
   * ```js
   * var brackets = require('expand-brackets');
   *
   * console.log(brackets.isMatch('a.a', '[[:alpha:]].[[:alpha:]]'));
   * //=> true
   * console.log(brackets.isMatch('1.2', '[[:alpha:]].[[:alpha:]]'));
   * //=> false
   * ```
   * @param {String} `string` String to match
   * @param {String} `pattern` Poxis pattern
   * @param {String} `options`
   * @return {Boolean}
   * @api public
   */

  brackets.isMatch = function(str, pattern, options) {
    return brackets.matcher(pattern, options)(str);
  };

  /**
   * Takes a POSIX character class pattern and returns a matcher function. The returned
   * function takes the string to match as its only argument.
   *
   * ```js
   * var brackets = require('expand-brackets');
   * var isMatch = brackets.matcher('[[:lower:]].[[:upper:]]');
   *
   * console.log(isMatch('a.a'));
   * //=> false
   * console.log(isMatch('a.A'));
   * //=> true
   * ```
   * @param {String} `pattern` Poxis pattern
   * @param {String} `options`
   * @return {Boolean}
   * @api public
   */

  brackets.matcher = function(pattern, options) {
    var re = brackets.makeRe(pattern, options);
    return function(str) {
      return re.test(str);
    };
  };

  /**
   * Create a regular expression from the given `pattern`.
   *
   * ```js
   * var brackets = require('expand-brackets');
   * var re = brackets.makeRe('[[:alpha:]]');
   * console.log(re);
   * //=> /^(?:[a-zA-Z])$/
   * ```
   * @param {String} `pattern` The pattern to convert to regex.
   * @param {Object} `options`
   * @return {RegExp}
   * @api public
   */

  brackets.makeRe = function(pattern, options) {
    var res = brackets.create(pattern, options);
    var opts = extend({strictErrors: false}, options);
    return toRegex(res.output, opts);
  };

  /**
   * Parses the given POSIX character class `pattern` and returns an object
   * with the compiled `output` and optional source `map`.
   *
   * ```js
   * var brackets = require('expand-brackets');
   * console.log(brackets('[[:alpha:]]'));
   * // { options: { source: 'string' },
   * //   input: '[[:alpha:]]',
   * //   state: {},
   * //   compilers:
   * //    { eos: [Function],
   * //      noop: [Function],
   * //      bos: [Function],
   * //      not: [Function],
   * //      escape: [Function],
   * //      text: [Function],
   * //      posix: [Function],
   * //      bracket: [Function],
   * //      'bracket.open': [Function],
   * //      'bracket.inner': [Function],
   * //      'bracket.literal': [Function],
   * //      'bracket.close': [Function] },
   * //   output: '[a-zA-Z]',
   * //   ast:
   * //    { type: 'root',
   * //      errors: [],
   * //      nodes: [ [Object], [Object], [Object] ] },
   * //   parsingErrors: [] }
   * ```
   * @param {String} `pattern`
   * @param {Object} `options`
   * @return {Object}
   * @api public
   */

  brackets.create = function(pattern, options) {
    var snapdragon = (options && options.snapdragon) || new Snapdragon(options);
    compilers(snapdragon);
    parsers(snapdragon);

    var ast = snapdragon.parse(pattern, options);
    ast.input = pattern;
    var res = snapdragon.compile(ast, options);
    res.input = pattern;
    return res;
  };

  /**
   * Expose `brackets` constructor, parsers and compilers
   */

  brackets.compilers = compilers;
  brackets.parsers = parsers;

  /**
   * Expose `brackets`
   * @type {Function}
   */

  module.exports = brackets;


  /***/ }),
  /* 389 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var posix = __webpack_require__(390);

  module.exports = function(brackets) {
    brackets.compiler

      /**
       * Escaped characters
       */

      .set('escape', function(node) {
        return this.emit('\\' + node.val.replace(/^\\/, ''), node);
      })

      /**
       * Text
       */

      .set('text', function(node) {
        return this.emit(node.val.replace(/([{}])/g, '\\$1'), node);
      })

      /**
       * POSIX character classes
       */

      .set('posix', function(node) {
        if (node.val === '[::]') {
          return this.emit('\\[::\\]', node);
        }

        var val = posix[node.inner];
        if (typeof val === 'undefined') {
          val = '[' + node.inner + ']';
        }
        return this.emit(val, node);
      })

      /**
       * Non-posix brackets
       */

      .set('bracket', function(node) {
        return this.mapVisit(node.nodes);
      })
      .set('bracket.open', function(node) {
        return this.emit(node.val, node);
      })
      .set('bracket.inner', function(node) {
        var inner = node.val;

        if (inner === '[' || inner === ']') {
          return this.emit('\\' + node.val, node);
        }
        if (inner === '^]') {
          return this.emit('^\\]', node);
        }
        if (inner === '^') {
          return this.emit('^', node);
        }

        if (/-/.test(inner) && !/(\d-\d|\w-\w)/.test(inner)) {
          inner = inner.split('-').join('\\-');
        }

        var isNegated = inner.charAt(0) === '^';
        // add slashes to negated brackets, per spec
        if (isNegated && inner.indexOf('/') === -1) {
          inner += '/';
        }
        if (isNegated && inner.indexOf('.') === -1) {
          inner += '.';
        }

        // don't unescape `0` (octal literal)
        inner = inner.replace(/\\([1-9])/g, '$1');
        return this.emit(inner, node);
      })
      .set('bracket.close', function(node) {
        var val = node.val.replace(/^\\/, '');
        if (node.parent.escaped === true) {
          return this.emit('\\' + val, node);
        }
        return this.emit(val, node);
      });
  };


  /***/ }),
  /* 390 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  /**
   * POSIX character classes
   */

  module.exports = {
    alnum: 'a-zA-Z0-9',
    alpha: 'a-zA-Z',
    ascii: '\\x00-\\x7F',
    blank: ' \\t',
    cntrl: '\\x00-\\x1F\\x7F',
    digit: '0-9',
    graph: '\\x21-\\x7E',
    lower: 'a-z',
    print: '\\x20-\\x7E ',
    punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
    space: ' \\t\\r\\n\\v\\f',
    upper: 'A-Z',
    word: 'A-Za-z0-9_',
    xdigit: 'A-Fa-f0-9'
  };


  /***/ }),
  /* 391 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var utils = __webpack_require__(392);
  var define = __webpack_require__(344);

  /**
   * Text regex
   */

  var TEXT_REGEX = '(\\[(?=.*\\])|\\])+';
  var not = utils.createRegex(TEXT_REGEX);

  /**
   * Brackets parsers
   */

  function parsers(brackets) {
    brackets.state = brackets.state || {};
    brackets.parser.sets.bracket = brackets.parser.sets.bracket || [];
    brackets.parser

      .capture('escape', function() {
        if (this.isInside('bracket')) return;
        var pos = this.position();
        var m = this.match(/^\\(.)/);
        if (!m) return;

        return pos({
          type: 'escape',
          val: m[0]
        });
      })

      /**
       * Text parser
       */

      .capture('text', function() {
        if (this.isInside('bracket')) return;
        var pos = this.position();
        var m = this.match(not);
        if (!m || !m[0]) return;

        return pos({
          type: 'text',
          val: m[0]
        });
      })

      /**
       * POSIX character classes: "[[:alpha:][:digits:]]"
       */

      .capture('posix', function() {
        var pos = this.position();
        var m = this.match(/^\[:(.*?):\](?=.*\])/);
        if (!m) return;

        var inside = this.isInside('bracket');
        if (inside) {
          brackets.posix++;
        }

        return pos({
          type: 'posix',
          insideBracket: inside,
          inner: m[1],
          val: m[0]
        });
      })

      /**
       * Bracket (noop)
       */

      .capture('bracket', function() {})

      /**
       * Open: '['
       */

      .capture('bracket.open', function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\[(?=.*\])/);
        if (!m) return;

        var prev = this.prev();
        var last = utils.last(prev.nodes);

        if (parsed.slice(-1) === '\\' && !this.isInside('bracket')) {
          last.val = last.val.slice(0, last.val.length - 1);
          return pos({
            type: 'escape',
            val: m[0]
          });
        }

        var open = pos({
          type: 'bracket.open',
          val: m[0]
        });

        if (last.type === 'bracket.open' || this.isInside('bracket')) {
          open.val = '\\' + open.val;
          open.type = 'bracket.inner';
          open.escaped = true;
          return open;
        }

        var node = pos({
          type: 'bracket',
          nodes: [open]
        });

        define(node, 'parent', prev);
        define(open, 'parent', node);
        this.push('bracket', node);
        prev.nodes.push(node);
      })

      /**
       * Bracket text
       */

      .capture('bracket.inner', function() {
        if (!this.isInside('bracket')) return;
        var pos = this.position();
        var m = this.match(not);
        if (!m || !m[0]) return;

        var next = this.input.charAt(0);
        var val = m[0];

        var node = pos({
          type: 'bracket.inner',
          val: val
        });

        if (val === '\\\\') {
          return node;
        }

        var first = val.charAt(0);
        var last = val.slice(-1);

        if (first === '!') {
          val = '^' + val.slice(1);
        }

        if (last === '\\' || (val === '^' && next === ']')) {
          val += this.input[0];
          this.consume(1);
        }

        node.val = val;
        return node;
      })

      /**
       * Close: ']'
       */

      .capture('bracket.close', function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\]/);
        if (!m) return;

        var prev = this.prev();
        var last = utils.last(prev.nodes);

        if (parsed.slice(-1) === '\\' && !this.isInside('bracket')) {
          last.val = last.val.slice(0, last.val.length - 1);

          return pos({
            type: 'escape',
            val: m[0]
          });
        }

        var node = pos({
          type: 'bracket.close',
          rest: this.input,
          val: m[0]
        });

        if (last.type === 'bracket.open') {
          node.type = 'bracket.inner';
          node.escaped = true;
          return node;
        }

        var bracket = this.pop('bracket');
        if (!this.isType(bracket, 'bracket')) {
          if (this.options.strict) {
            throw new Error('missing opening "["');
          }
          node.type = 'bracket.inner';
          node.escaped = true;
          return node;
        }

        bracket.nodes.push(node);
        define(node, 'parent', bracket);
      });
  }

  /**
   * Brackets parsers
   */

  module.exports = parsers;

  /**
   * Expose text regex
   */

  module.exports.TEXT_REGEX = TEXT_REGEX;


  /***/ }),
  /* 392 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var toRegex = __webpack_require__(283);
  var regexNot = __webpack_require__(300);
  var cached;

  /**
   * Get the last element from `array`
   * @param {Array} `array`
   * @return {*}
   */

  exports.last = function(arr) {
    return arr[arr.length - 1];
  };

  /**
   * Create and cache regex to use for text nodes
   */

  exports.createRegex = function(pattern, include) {
    if (cached) return cached;
    var opts = {contains: true, strictClose: false};
    var not = regexNot.create(pattern, opts);
    var re;

    if (typeof include === 'string') {
      re = toRegex('^(?:' + include + '|' + not + ')', opts);
    } else {
      re = toRegex(not, opts);
    }

    return (cached = re);
  };


  /***/ }),
  /* 393 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var brackets = __webpack_require__(388);
  var define = __webpack_require__(317);
  var utils = __webpack_require__(394);

  /**
   * Characters to use in text regex (we want to "not" match
   * characters that are matched by other parsers)
   */

  var TEXT_REGEX = '([!@*?+]?\\(|\\)|[*?.+\\\\]|\\[:?(?=.*\\])|:?\\])+';
  var not = utils.createRegex(TEXT_REGEX);

  /**
   * Extglob parsers
   */

  function parsers(extglob) {
    extglob.state = extglob.state || {};

    /**
     * Use `expand-brackets` parsers
     */

    extglob.use(brackets.parsers);
    extglob.parser.sets.paren = extglob.parser.sets.paren || [];
    extglob.parser

      /**
       * Extglob open: "*("
       */

      .capture('paren.open', function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^([!@*?+])?\(/);
        if (!m) return;

        var prev = this.prev();
        var prefix = m[1];
        var val = m[0];

        var open = pos({
          type: 'paren.open',
          parsed: parsed,
          val: val
        });

        var node = pos({
          type: 'paren',
          prefix: prefix,
          nodes: [open]
        });

        // if nested negation extglobs, just cancel them out to simplify
        if (prefix === '!' && prev.type === 'paren' && prev.prefix === '!') {
          prev.prefix = '@';
          node.prefix = '@';
        }

        define(node, 'rest', this.input);
        define(node, 'parsed', parsed);
        define(node, 'parent', prev);
        define(open, 'parent', node);

        this.push('paren', node);
        prev.nodes.push(node);
      })

      /**
       * Extglob close: ")"
       */

      .capture('paren.close', function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\)/);
        if (!m) return;

        var parent = this.pop('paren');
        var node = pos({
          type: 'paren.close',
          rest: this.input,
          parsed: parsed,
          val: m[0]
        });

        if (!this.isType(parent, 'paren')) {
          if (this.options.strict) {
            throw new Error('missing opening paren: "("');
          }
          node.escaped = true;
          return node;
        }

        node.prefix = parent.prefix;
        parent.nodes.push(node);
        define(node, 'parent', parent);
      })

      /**
       * Escape: "\\."
       */

      .capture('escape', function() {
        var pos = this.position();
        var m = this.match(/^\\(.)/);
        if (!m) return;

        return pos({
          type: 'escape',
          val: m[0],
          ch: m[1]
        });
      })

      /**
       * Question marks: "?"
       */

      .capture('qmark', function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\?+(?!\()/);
        if (!m) return;
        extglob.state.metachar = true;
        return pos({
          type: 'qmark',
          rest: this.input,
          parsed: parsed,
          val: m[0]
        });
      })

      /**
       * Character parsers
       */

      .capture('star', /^\*(?!\()/)
      .capture('plus', /^\+(?!\()/)
      .capture('dot', /^\./)
      .capture('text', not);
  };

  /**
   * Expose text regex string
   */

  module.exports.TEXT_REGEX = TEXT_REGEX;

  /**
   * Extglob parsers
   */

  module.exports = parsers;


  /***/ }),
  /* 394 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var regex = __webpack_require__(300);
  var Cache = __webpack_require__(381);

  /**
   * Utils
   */

  var utils = module.exports;
  var cache = utils.cache = new Cache();

  /**
   * Cast `val` to an array
   * @return {Array}
   */

  utils.arrayify = function(val) {
    if (!Array.isArray(val)) {
      return [val];
    }
    return val;
  };

  /**
   * Memoize a generated regex or function
   */

  utils.memoize = function(type, pattern, options, fn) {
    var key = utils.createKey(type + pattern, options);

    if (cache.has(type, key)) {
      return cache.get(type, key);
    }

    var val = fn(pattern, options);
    if (options && options.cache === false) {
      return val;
    }

    cache.set(type, key, val);
    return val;
  };

  /**
   * Create the key to use for memoization. The key is generated
   * by iterating over the options and concatenating key-value pairs
   * to the pattern string.
   */

  utils.createKey = function(pattern, options) {
    var key = pattern;
    if (typeof options === 'undefined') {
      return key;
    }
    for (var prop in options) {
      key += ';' + prop + '=' + String(options[prop]);
    }
    return key;
  };

  /**
   * Create the regex to use for matching text
   */

  utils.createRegex = function(str) {
    var opts = {contains: true, strictClose: false};
    return regex(str, opts);
  };


  /***/ }),
  /* 395 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  /**
   * Module dependencies
   */

  var Snapdragon = __webpack_require__(320);
  var define = __webpack_require__(317);
  var extend = __webpack_require__(302);

  /**
   * Local dependencies
   */

  var compilers = __webpack_require__(387);
  var parsers = __webpack_require__(393);

  /**
   * Customize Snapdragon parser and renderer
   */

  function Extglob(options) {
    this.options = extend({source: 'extglob'}, options);
    this.snapdragon = this.options.snapdragon || new Snapdragon(this.options);
    this.snapdragon.patterns = this.snapdragon.patterns || {};
    this.compiler = this.snapdragon.compiler;
    this.parser = this.snapdragon.parser;

    compilers(this.snapdragon);
    parsers(this.snapdragon);

    /**
     * Override Snapdragon `.parse` method
     */

    define(this.snapdragon, 'parse', function(str, options) {
      var parsed = Snapdragon.prototype.parse.apply(this, arguments);
      parsed.input = str;

      // escape unmatched brace/bracket/parens
      var last = this.parser.stack.pop();
      if (last && this.options.strict !== true) {
        var node = last.nodes[0];
        node.val = '\\' + node.val;
        var sibling = node.parent.nodes[1];
        if (sibling.type === 'star') {
          sibling.loose = true;
        }
      }

      // add non-enumerable parser reference
      define(parsed, 'parser', this.parser);
      return parsed;
    });

    /**
     * Decorate `.parse` method
     */

    define(this, 'parse', function(ast, options) {
      return this.snapdragon.parse.apply(this.snapdragon, arguments);
    });

    /**
     * Decorate `.compile` method
     */

    define(this, 'compile', function(ast, options) {
      return this.snapdragon.compile.apply(this.snapdragon, arguments);
    });

  }

  /**
   * Expose `Extglob`
   */

  module.exports = Extglob;


  /***/ }),
  /* 396 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var extglob = __webpack_require__(386);
  var nanomatch = __webpack_require__(377);
  var regexNot = __webpack_require__(300);
  var toRegex = __webpack_require__(283);
  var not;

  /**
   * Characters to use in negation regex (we want to "not" match
   * characters that are matched by other parsers)
   */

  var TEXT = '([!@*?+]?\\(|\\)|\\[:?(?=.*?:?\\])|:?\\]|[*+?!^$.\\\\/])+';
  var createNotRegex = function(opts) {
    return not || (not = textRegex(TEXT));
  };

  /**
   * Parsers
   */

  module.exports = function(snapdragon) {
    var parsers = snapdragon.parser.parsers;

    // register nanomatch parsers
    snapdragon.use(nanomatch.parsers);

    // get references to some specific nanomatch parsers before they
    // are overridden by the extglob and/or parsers
    var escape = parsers.escape;
    var slash = parsers.slash;
    var qmark = parsers.qmark;
    var plus = parsers.plus;
    var star = parsers.star;
    var dot = parsers.dot;

    // register extglob parsers
    snapdragon.use(extglob.parsers);

    // custom micromatch parsers
    snapdragon.parser
      .use(function() {
        // override "notRegex" created in nanomatch parser
        this.notRegex = /^\!+(?!\()/;
      })
      // reset the referenced parsers
      .capture('escape', escape)
      .capture('slash', slash)
      .capture('qmark', qmark)
      .capture('star', star)
      .capture('plus', plus)
      .capture('dot', dot)

      /**
       * Override `text` parser
       */

      .capture('text', function() {
        if (this.isInside('bracket')) return;
        var pos = this.position();
        var m = this.match(createNotRegex(this.options));
        if (!m || !m[0]) return;

        // escape regex boundary characters and simple brackets
        var val = m[0].replace(/([[\]^$])/g, '\\$1');

        return pos({
          type: 'text',
          val: val
        });
      });
  };

  /**
   * Create text regex
   */

  function textRegex(pattern) {
    var notStr = regexNot.create(pattern, {contains: true, strictClose: false});
    var prefix = '(?:[\\^]|\\\\|';
    return toRegex(prefix + notStr + ')', {strictClose: false});
  }


  /***/ }),
  /* 397 */
  /***/ (function(module, exports, __webpack_require__) {

  module.exports = new (__webpack_require__(381))();


  /***/ }),
  /* 398 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var utils = module.exports;
  var path = __webpack_require__(8);

  /**
   * Module dependencies
   */

  var Snapdragon = __webpack_require__(320);
  utils.define = __webpack_require__(290);
  utils.diff = __webpack_require__(384);
  utils.extend = __webpack_require__(296);
  utils.pick = __webpack_require__(385);
  utils.typeOf = __webpack_require__(293);
  utils.unique = __webpack_require__(301);

  /**
   * Returns true if the platform is windows, or `path.sep` is `\\`.
   * This is defined as a function to allow `path.sep` to be set in unit tests,
   * or by the user, if there is a reason to do so.
   * @return {Boolean}
   */

  utils.isWindows = function() {
    return path.sep === '\\' || process.platform === 'win32';
  };

  /**
   * Get the `Snapdragon` instance to use
   */

  utils.instantiate = function(ast, options) {
    var snapdragon;
    // if an instance was created by `.parse`, use that instance
    if (utils.typeOf(ast) === 'object' && ast.snapdragon) {
      snapdragon = ast.snapdragon;
    // if the user supplies an instance on options, use that instance
    } else if (utils.typeOf(options) === 'object' && options.snapdragon) {
      snapdragon = options.snapdragon;
    // create a new instance
    } else {
      snapdragon = new Snapdragon(options);
    }

    utils.define(snapdragon, 'parse', function(str, options) {
      var parsed = Snapdragon.prototype.parse.apply(this, arguments);
      parsed.input = str;

      // escape unmatched brace/bracket/parens
      var last = this.parser.stack.pop();
      if (last && this.options.strictErrors !== true) {
        var open = last.nodes[0];
        var inner = last.nodes[1];
        if (last.type === 'bracket') {
          if (inner.val.charAt(0) === '[') {
            inner.val = '\\' + inner.val;
          }

        } else {
          open.val = '\\' + open.val;
          var sibling = open.parent.nodes[1];
          if (sibling.type === 'star') {
            sibling.loose = true;
          }
        }
      }

      // add non-enumerable parser reference
      utils.define(parsed, 'parser', this.parser);
      return parsed;
    });

    return snapdragon;
  };

  /**
   * Create the key to use for memoization. The key is generated
   * by iterating over the options and concatenating key-value pairs
   * to the pattern string.
   */

  utils.createKey = function(pattern, options) {
    if (utils.typeOf(options) !== 'object') {
      return pattern;
    }
    var val = pattern;
    var keys = Object.keys(options);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      val += ';' + key + '=' + String(options[key]);
    }
    return val;
  };

  /**
   * Cast `val` to an array
   * @return {Array}
   */

  utils.arrayify = function(val) {
    if (typeof val === 'string') return [val];
    return val ? (Array.isArray(val) ? val : [val]) : [];
  };

  /**
   * Return true if `val` is a non-empty string
   */

  utils.isString = function(val) {
    return typeof val === 'string';
  };

  /**
   * Return true if `val` is a non-empty string
   */

  utils.isObject = function(val) {
    return utils.typeOf(val) === 'object';
  };

  /**
   * Returns true if the given `str` has special characters
   */

  utils.hasSpecialChars = function(str) {
    return /(?:(?:(^|\/)[!.])|[*?+()|\[\]{}]|[+@]\()/.test(str);
  };

  /**
   * Escape regex characters in the given string
   */

  utils.escapeRegex = function(str) {
    return str.replace(/[-[\]{}()^$|*+?.\\\/\s]/g, '\\$&');
  };

  /**
   * Normalize slashes in the given filepath.
   *
   * @param {String} `filepath`
   * @return {String}
   */

  utils.toPosixPath = function(str) {
    return str.replace(/\\+/g, '/');
  };

  /**
   * Strip backslashes before special characters in a string.
   *
   * @param {String} `str`
   * @return {String}
   */

  utils.unescape = function(str) {
    return utils.toPosixPath(str.replace(/\\(?=[*+?!.])/g, ''));
  };

  /**
   * Strip the prefix from a filepath
   * @param {String} `fp`
   * @return {String}
   */

  utils.stripPrefix = function(str) {
    if (str.charAt(0) !== '.') {
      return str;
    }
    var ch = str.charAt(1);
    if (utils.isSlash(ch)) {
      return str.slice(2);
    }
    return str;
  };

  /**
   * Returns true if the given str is an escaped or
   * unescaped path character
   */

  utils.isSlash = function(str) {
    return str === '/' || str === '\\/' || str === '\\' || str === '\\\\';
  };

  /**
   * Returns a function that returns true if the given
   * pattern matches or contains a `filepath`
   *
   * @param {String} `pattern`
   * @return {Function}
   */

  utils.matchPath = function(pattern, options) {
    return (options && options.contains)
      ? utils.containsPattern(pattern, options)
      : utils.equalsPattern(pattern, options);
  };

  /**
   * Returns true if the given (original) filepath or unixified path are equal
   * to the given pattern.
   */

  utils._equals = function(filepath, unixPath, pattern) {
    return pattern === filepath || pattern === unixPath;
  };

  /**
   * Returns true if the given (original) filepath or unixified path contain
   * the given pattern.
   */

  utils._contains = function(filepath, unixPath, pattern) {
    return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;
  };

  /**
   * Returns a function that returns true if the given
   * pattern is the same as a given `filepath`
   *
   * @param {String} `pattern`
   * @return {Function}
   */

  utils.equalsPattern = function(pattern, options) {
    var unixify = utils.unixify(options);
    options = options || {};

    return function fn(filepath) {
      var equal = utils._equals(filepath, unixify(filepath), pattern);
      if (equal === true || options.nocase !== true) {
        return equal;
      }
      var lower = filepath.toLowerCase();
      return utils._equals(lower, unixify(lower), pattern);
    };
  };

  /**
   * Returns a function that returns true if the given
   * pattern contains a `filepath`
   *
   * @param {String} `pattern`
   * @return {Function}
   */

  utils.containsPattern = function(pattern, options) {
    var unixify = utils.unixify(options);
    options = options || {};

    return function(filepath) {
      var contains = utils._contains(filepath, unixify(filepath), pattern);
      if (contains === true || options.nocase !== true) {
        return contains;
      }
      var lower = filepath.toLowerCase();
      return utils._contains(lower, unixify(lower), pattern);
    };
  };

  /**
   * Returns a function that returns true if the given
   * regex matches the `filename` of a file path.
   *
   * @param {RegExp} `re` Matching regex
   * @return {Function}
   */

  utils.matchBasename = function(re) {
    return function(filepath) {
      return re.test(path.basename(filepath));
    };
  };

  /**
   * Determines the filepath to return based on the provided options.
   * @return {any}
   */

  utils.value = function(str, unixify, options) {
    if (options && options.unixify === false) {
      return str;
    }
    return unixify(str);
  };

  /**
   * Returns a function that normalizes slashes in a string to forward
   * slashes, strips `./` from beginning of paths, and optionally unescapes
   * special characters.
   * @return {Function}
   */

  utils.unixify = function(options) {
    options = options || {};
    return function(filepath) {
      if (utils.isWindows() || options.unixify === true) {
        filepath = utils.toPosixPath(filepath);
      }
      if (options.stripPrefix !== false) {
        filepath = utils.stripPrefix(filepath);
      }
      if (options.unescape === true) {
        filepath = utils.unescape(filepath);
      }
      return filepath;
    };
  };


  /***/ }),
  /* 399 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  
  var __extends = (this && this.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  Object.defineProperty(exports, "__esModule", { value: true });
  var readdir = __webpack_require__(400);
  var reader_1 = __webpack_require__(413);
  var fs_stream_1 = __webpack_require__(417);
  var ReaderAsync = /** @class */ (function (_super) {
      __extends(ReaderAsync, _super);
      function ReaderAsync() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      Object.defineProperty(ReaderAsync.prototype, "fsAdapter", {
          /**
           * Returns FileSystem adapter.
           */
          get: function () {
              return new fs_stream_1.default(this.options);
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Use async API to read entries for Task.
       */
      ReaderAsync.prototype.read = function (task) {
          var _this = this;
          var root = this.getRootDirectory(task);
          var options = this.getReaderOptions(task);
          var entries = [];
          return new Promise(function (resolve, reject) {
              var stream = _this.api(root, task, options);
              stream.on('error', function (err) {
                  _this.isEnoentCodeError(err) ? resolve([]) : reject(err);
                  stream.pause();
              });
              stream.on('data', function (entry) { return entries.push(_this.transform(entry)); });
              stream.on('end', function () { return resolve(entries); });
          });
      };
      /**
       * Returns founded paths.
       */
      ReaderAsync.prototype.api = function (root, task, options) {
          if (task.dynamic) {
              return this.dynamicApi(root, options);
          }
          return this.staticApi(task, options);
      };
      /**
       * Api for dynamic tasks.
       */
      ReaderAsync.prototype.dynamicApi = function (root, options) {
          return readdir.readdirStreamStat(root, options);
      };
      /**
       * Api for static tasks.
       */
      ReaderAsync.prototype.staticApi = function (task, options) {
          return this.fsAdapter.read(task.patterns, options.filter);
      };
      return ReaderAsync;
  }(reader_1.default));
  exports.default = ReaderAsync;


  /***/ }),
  /* 400 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const readdirSync = __webpack_require__(401);
  const readdirAsync = __webpack_require__(409);
  const readdirStream = __webpack_require__(412);

  module.exports = exports = readdirAsyncPath;
  exports.readdir = exports.readdirAsync = exports.async = readdirAsyncPath;
  exports.readdirAsyncStat = exports.async.stat = readdirAsyncStat;
  exports.readdirStream = exports.stream = readdirStreamPath;
  exports.readdirStreamStat = exports.stream.stat = readdirStreamStat;
  exports.readdirSync = exports.sync = readdirSyncPath;
  exports.readdirSyncStat = exports.sync.stat = readdirSyncStat;

  /**
   * Synchronous readdir that returns an array of string paths.
   *
   * @param {string} dir
   * @param {object} [options]
   * @returns {string[]}
   */
  function readdirSyncPath (dir, options) {
    return readdirSync(dir, options, {});
  }

  /**
   * Synchronous readdir that returns results as an array of {@link fs.Stats} objects
   *
   * @param {string} dir
   * @param {object} [options]
   * @returns {fs.Stats[]}
   */
  function readdirSyncStat (dir, options) {
    return readdirSync(dir, options, { stats: true });
  }

  /**
   * Aynchronous readdir (accepts an error-first callback or returns a {@link Promise}).
   * Results are an array of path strings.
   *
   * @param {string} dir
   * @param {object} [options]
   * @param {function} [callback]
   * @returns {Promise<string[]>}
   */
  function readdirAsyncPath (dir, options, callback) {
    return readdirAsync(dir, options, callback, {});
  }

  /**
   * Aynchronous readdir (accepts an error-first callback or returns a {@link Promise}).
   * Results are an array of {@link fs.Stats} objects.
   *
   * @param {string} dir
   * @param {object} [options]
   * @param {function} [callback]
   * @returns {Promise<fs.Stats[]>}
   */
  function readdirAsyncStat (dir, options, callback) {
    return readdirAsync(dir, options, callback, { stats: true });
  }

  /**
   * Aynchronous readdir that returns a {@link stream.Readable} (which is also an {@link EventEmitter}).
   * All stream data events ("data", "file", "directory", "symlink") are passed a path string.
   *
   * @param {string} dir
   * @param {object} [options]
   * @returns {stream.Readable}
   */
  function readdirStreamPath (dir, options) {
    return readdirStream(dir, options, {});
  }

  /**
   * Aynchronous readdir that returns a {@link stream.Readable} (which is also an {@link EventEmitter})
   * All stream data events ("data", "file", "directory", "symlink") are passed an {@link fs.Stats} object.
   *
   * @param {string} dir
   * @param {object} [options]
   * @returns {stream.Readable}
   */
  function readdirStreamStat (dir, options) {
    return readdirStream(dir, options, { stats: true });
  }


  /***/ }),
  /* 401 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  module.exports = readdirSync;

  const DirectoryReader = __webpack_require__(402);

  let syncFacade = {
    fs: __webpack_require__(407),
    forEach: __webpack_require__(408),
    sync: true
  };

  /**
   * Returns the buffered output from a synchronous {@link DirectoryReader}.
   *
   * @param {string} dir
   * @param {object} [options]
   * @param {object} internalOptions
   */
  function readdirSync (dir, options, internalOptions) {
    internalOptions.facade = syncFacade;

    let reader = new DirectoryReader(dir, options, internalOptions);
    let stream = reader.stream;

    let results = [];
    let data = stream.read();
    while (data !== null) {
      results.push(data);
      data = stream.read();
    }

    return results;
  }


  /***/ }),
  /* 402 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const Readable = __webpack_require__(24).Readable;
  const EventEmitter = __webpack_require__(67).EventEmitter;
  const path = __webpack_require__(8);
  const normalizeOptions = __webpack_require__(403);
  const stat = __webpack_require__(405);
  const call = __webpack_require__(406);

  /**
   * Asynchronously reads the contents of a directory and streams the results
   * via a {@link stream.Readable}.
   */
  class DirectoryReader {
    /**
     * @param {string} dir - The absolute or relative directory path to read
     * @param {object} [options] - User-specified options, if any (see {@link normalizeOptions})
     * @param {object} internalOptions - Internal options that aren't part of the public API
     * @class
     */
    constructor (dir, options, internalOptions) {
      this.options = options = normalizeOptions(options, internalOptions);

      // Indicates whether we should keep reading
      // This is set false if stream.Readable.push() returns false.
      this.shouldRead = true;

      // The directories to read
      // (initialized with the top-level directory)
      this.queue = [{
        path: dir,
        basePath: options.basePath,
        posixBasePath: options.posixBasePath,
        depth: 0
      }];

      // The number of directories that are currently being processed
      this.pending = 0;

      // The data that has been read, but not yet emitted
      this.buffer = [];

      this.stream = new Readable({ objectMode: true });
      this.stream._read = () => {
        // Start (or resume) reading
        this.shouldRead = true;

        // If we have data in the buffer, then send the next chunk
        if (this.buffer.length > 0) {
          this.pushFromBuffer();
        }

        // If we have directories queued, then start processing the next one
        if (this.queue.length > 0) {
          if (this.options.facade.sync) {
            while (this.queue.length > 0) {
              this.readNextDirectory();
            }
          }
          else {
            this.readNextDirectory();
          }
        }

        this.checkForEOF();
      };
    }

    /**
     * Reads the next directory in the queue
     */
    readNextDirectory () {
      let facade = this.options.facade;
      let dir = this.queue.shift();
      this.pending++;

      // Read the directory listing
      call.safe(facade.fs.readdir, dir.path, (err, items) => {
        if (err) {
          // fs.readdir threw an error
          this.emit('error', err);
          return this.finishedReadingDirectory();
        }

        try {
          // Process each item in the directory (simultaneously, if async)
          facade.forEach(
            items,
            this.processItem.bind(this, dir),
            this.finishedReadingDirectory.bind(this, dir)
          );
        }
        catch (err2) {
          // facade.forEach threw an error
          // (probably because fs.readdir returned an invalid result)
          this.emit('error', err2);
          this.finishedReadingDirectory();
        }
      });
    }

    /**
     * This method is called after all items in a directory have been processed.
     *
     * NOTE: This does not necessarily mean that the reader is finished, since there may still
     * be other directories queued or pending.
     */
    finishedReadingDirectory () {
      this.pending--;

      if (this.shouldRead) {
        // If we have directories queued, then start processing the next one
        if (this.queue.length > 0 && this.options.facade.async) {
          this.readNextDirectory();
        }

        this.checkForEOF();
      }
    }

    /**
     * Determines whether the reader has finished processing all items in all directories.
     * If so, then the "end" event is fired (via {@Readable#push})
     */
    checkForEOF () {
      if (this.buffer.length === 0 &&   // The stuff we've already read
      this.pending === 0 &&             // The stuff we're currently reading
      this.queue.length === 0) {        // The stuff we haven't read yet
        // There's no more stuff!
        this.stream.push(null);
      }
    }

    /**
     * Processes a single item in a directory.
     *
     * If the item is a directory, and `option.deep` is enabled, then the item will be added
     * to the directory queue.
     *
     * If the item meets the filter criteria, then it will be emitted to the reader's stream.
     *
     * @param {object} dir - A directory object from the queue
     * @param {string} item - The name of the item (name only, no path)
     * @param {function} done - A callback function that is called after the item has been processed
     */
    processItem (dir, item, done) {
      let stream = this.stream;
      let options = this.options;

      let itemPath = dir.basePath + item;
      let posixPath = dir.posixBasePath + item;
      let fullPath = path.join(dir.path, item);

      // If `options.deep` is a number, and we've already recursed to the max depth,
      // then there's no need to check fs.Stats to know if it's a directory.
      // If `options.deep` is a function, then we'll need fs.Stats
      let maxDepthReached = dir.depth >= options.recurseDepth;

      // Do we need to call `fs.stat`?
      let needStats =
        !maxDepthReached ||                                 // we need the fs.Stats to know if it's a directory
        options.stats ||                                    // the user wants fs.Stats objects returned
        options.recurseFn ||                                // we need fs.Stats for the recurse function
        options.filterFn ||                                 // we need fs.Stats for the filter function
        EventEmitter.listenerCount(stream, 'file') ||       // we need the fs.Stats to know if it's a file
        EventEmitter.listenerCount(stream, 'directory') ||  // we need the fs.Stats to know if it's a directory
        EventEmitter.listenerCount(stream, 'symlink');      // we need the fs.Stats to know if it's a symlink

      // If we don't need stats, then exit early
      if (!needStats) {
        if (this.filter(itemPath, posixPath)) {
          this.pushOrBuffer({ data: itemPath });
        }
        return done();
      }

      // Get the fs.Stats object for this path
      stat(options.facade.fs, fullPath, (err, stats) => {
        if (err) {
          // fs.stat threw an error
          this.emit('error', err);
          return done();
        }

        try {
          // Add the item's path to the fs.Stats object
          // The base of this path, and its separators are determined by the options
          // (i.e. options.basePath and options.sep)
          stats.path = itemPath;

          // Add depth of the path to the fs.Stats object for use this in the filter function
          stats.depth = dir.depth;

          if (this.shouldRecurse(stats, posixPath, maxDepthReached)) {
            // Add this subdirectory to the queue
            this.queue.push({
              path: fullPath,
              basePath: itemPath + options.sep,
              posixBasePath: posixPath + '/',
              depth: dir.depth + 1,
            });
          }

          // Determine whether this item matches the filter criteria
          if (this.filter(stats, posixPath)) {
            this.pushOrBuffer({
              data: options.stats ? stats : itemPath,
              file: stats.isFile(),
              directory: stats.isDirectory(),
              symlink: stats.isSymbolicLink(),
            });
          }

          done();
        }
        catch (err2) {
          // An error occurred while processing the item
          // (probably during a user-specified function, such as options.deep, options.filter, etc.)
          this.emit('error', err2);
          done();
        }
      });
    }

    /**
     * Pushes the given chunk of data to the stream, or adds it to the buffer,
     * depending on the state of the stream.
     *
     * @param {object} chunk
     */
    pushOrBuffer (chunk) {
      // Add the chunk to the buffer
      this.buffer.push(chunk);

      // If we're still reading, then immediately emit the next chunk in the buffer
      // (which may or may not be the chunk that we just added)
      if (this.shouldRead) {
        this.pushFromBuffer();
      }
    }

    /**
     * Immediately pushes the next chunk in the buffer to the reader's stream.
     * The "data" event will always be fired (via {@link Readable#push}).
     * In addition, the "file", "directory", and/or "symlink" events may be fired,
     * depending on the type of properties of the chunk.
     */
    pushFromBuffer () {
      let stream = this.stream;
      let chunk = this.buffer.shift();

      // Stream the data
      try {
        this.shouldRead = stream.push(chunk.data);
      }
      catch (err) {
        this.emit('error', err);
      }

      // Also emit specific events, based on the type of chunk
      chunk.file && this.emit('file', chunk.data);
      chunk.symlink && this.emit('symlink', chunk.data);
      chunk.directory && this.emit('directory', chunk.data);
    }

    /**
     * Determines whether the given directory meets the user-specified recursion criteria.
     * If the user didn't specify recursion criteria, then this function will default to true.
     *
     * @param {fs.Stats} stats - The directory's {@link fs.Stats} object
     * @param {string} posixPath - The item's POSIX path (used for glob matching)
     * @param {boolean} maxDepthReached - Whether we've already crawled the user-specified depth
     * @returns {boolean}
     */
    shouldRecurse (stats, posixPath, maxDepthReached) {
      let options = this.options;

      if (maxDepthReached) {
        // We've already crawled to the maximum depth. So no more recursion.
        return false;
      }
      else if (!stats.isDirectory()) {
        // It's not a directory. So don't try to crawl it.
        return false;
      }
      else if (options.recurseGlob) {
        // Glob patterns are always tested against the POSIX path, even on Windows
        // https://github.com/isaacs/node-glob#windows
        return options.recurseGlob.test(posixPath);
      }
      else if (options.recurseRegExp) {
        // Regular expressions are tested against the normal path
        // (based on the OS or options.sep)
        return options.recurseRegExp.test(stats.path);
      }
      else if (options.recurseFn) {
        try {
          // Run the user-specified recursion criteria
          return options.recurseFn.call(null, stats);
        }
        catch (err) {
          // An error occurred in the user's code.
          // In Sync and Async modes, this will return an error.
          // In Streaming mode, we emit an "error" event, but continue processing
          this.emit('error', err);
        }
      }
      else {
        // No recursion function was specified, and we're within the maximum depth.
        // So crawl this directory.
        return true;
      }
    }

    /**
     * Determines whether the given item meets the user-specified filter criteria.
     * If the user didn't specify a filter, then this function will always return true.
     *
     * @param {string|fs.Stats} value - Either the item's path, or the item's {@link fs.Stats} object
     * @param {string} posixPath - The item's POSIX path (used for glob matching)
     * @returns {boolean}
     */
    filter (value, posixPath) {
      let options = this.options;

      if (options.filterGlob) {
        // Glob patterns are always tested against the POSIX path, even on Windows
        // https://github.com/isaacs/node-glob#windows
        return options.filterGlob.test(posixPath);
      }
      else if (options.filterRegExp) {
        // Regular expressions are tested against the normal path
        // (based on the OS or options.sep)
        return options.filterRegExp.test(value.path || value);
      }
      else if (options.filterFn) {
        try {
          // Run the user-specified filter function
          return options.filterFn.call(null, value);
        }
        catch (err) {
          // An error occurred in the user's code.
          // In Sync and Async modes, this will return an error.
          // In Streaming mode, we emit an "error" event, but continue processing
          this.emit('error', err);
        }
      }
      else {
        // No filter was specified, so match everything
        return true;
      }
    }

    /**
     * Emits an event.  If one of the event listeners throws an error,
     * then an "error" event is emitted.
     *
     * @param {string} eventName
     * @param {*} data
     */
    emit (eventName, data) {
      let stream = this.stream;

      try {
        stream.emit(eventName, data);
      }
      catch (err) {
        if (eventName === 'error') {
          // Don't recursively emit "error" events.
          // If the first one fails, then just throw
          throw err;
        }
        else {
          stream.emit('error', err);
        }
      }
    }
  }

  module.exports = DirectoryReader;


  /***/ }),
  /* 403 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const path = __webpack_require__(8);
  const globToRegExp = __webpack_require__(404);

  module.exports = normalizeOptions;

  let isWindows = /^win/.test(process.platform);

  /**
   * @typedef {Object} FSFacade
   * @property {fs.readdir} readdir
   * @property {fs.stat} stat
   * @property {fs.lstat} lstat
   */

  /**
   * Validates and normalizes the options argument
   *
   * @param {object} [options] - User-specified options, if any
   * @param {object} internalOptions - Internal options that aren't part of the public API
   *
   * @param {number|boolean|function} [options.deep]
   * The number of directories to recursively traverse. Any falsy value or negative number will
   * default to zero, so only the top-level contents will be returned. Set to `true` or `Infinity`
   * to traverse all subdirectories.  Or provide a function that accepts a {@link fs.Stats} object
   * and returns a truthy value if the directory's contents should be crawled.
   *
   * @param {function|string|RegExp} [options.filter]
   * A function that accepts a {@link fs.Stats} object and returns a truthy value if the data should
   * be returned.  Or a RegExp or glob string pattern, to filter by file name.
   *
   * @param {string} [options.sep]
   * The path separator to use. By default, the OS-specific separator will be used, but this can be
   * set to a specific value to ensure consistency across platforms.
   *
   * @param {string} [options.basePath]
   * The base path to prepend to each result. If empty, then all results will be relative to `dir`.
   *
   * @param {FSFacade} [options.fs]
   * Synchronous or asynchronous facades for Node.js File System module
   *
   * @param {object} [internalOptions.facade]
   * Synchronous or asynchronous facades for various methods, including for the Node.js File System module
   *
   * @param {boolean} [internalOptions.emit]
   * Indicates whether the reader should emit "file", "directory", and "symlink" events
   *
   * @param {boolean} [internalOptions.stats]
   * Indicates whether the reader should emit {@link fs.Stats} objects instead of path strings
   *
   * @returns {object}
   */
  function normalizeOptions (options, internalOptions) {
    if (options === null || options === undefined) {
      options = {};
    }
    else if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }

    let recurseDepth, recurseFn, recurseRegExp, recurseGlob, deep = options.deep;
    if (deep === null || deep === undefined) {
      recurseDepth = 0;
    }
    else if (typeof deep === 'boolean') {
      recurseDepth = deep ? Infinity : 0;
    }
    else if (typeof deep === 'number') {
      if (deep < 0 || isNaN(deep)) {
        throw new Error('options.deep must be a positive number');
      }
      else if (Math.floor(deep) !== deep) {
        throw new Error('options.deep must be an integer');
      }
      else {
        recurseDepth = deep;
      }
    }
    else if (typeof deep === 'function') {
      recurseDepth = Infinity;
      recurseFn = deep;
    }
    else if (deep instanceof RegExp) {
      recurseDepth = Infinity;
      recurseRegExp = deep;
    }
    else if (typeof deep === 'string' && deep.length > 0) {
      recurseDepth = Infinity;
      recurseGlob = globToRegExp(deep, { extended: true, globstar: true });
    }
    else {
      throw new TypeError('options.deep must be a boolean, number, function, regular expression, or glob pattern');
    }

    let filterFn, filterRegExp, filterGlob, filter = options.filter;
    if (filter !== null && filter !== undefined) {
      if (typeof filter === 'function') {
        filterFn = filter;
      }
      else if (filter instanceof RegExp) {
        filterRegExp = filter;
      }
      else if (typeof filter === 'string' && filter.length > 0) {
        filterGlob = globToRegExp(filter, { extended: true, globstar: true });
      }
      else {
        throw new TypeError('options.filter must be a function, regular expression, or glob pattern');
      }
    }

    let sep = options.sep;
    if (sep === null || sep === undefined) {
      sep = path.sep;
    }
    else if (typeof sep !== 'string') {
      throw new TypeError('options.sep must be a string');
    }

    let basePath = options.basePath;
    if (basePath === null || basePath === undefined) {
      basePath = '';
    }
    else if (typeof basePath === 'string') {
      // Append a path separator to the basePath, if necessary
      if (basePath && basePath.substr(-1) !== sep) {
        basePath += sep;
      }
    }
    else {
      throw new TypeError('options.basePath must be a string');
    }

    // Convert the basePath to POSIX (forward slashes)
    // so that glob pattern matching works consistently, even on Windows
    let posixBasePath = basePath;
    if (posixBasePath && sep !== '/') {
      posixBasePath = posixBasePath.replace(new RegExp('\\' + sep, 'g'), '/');

      /* istanbul ignore if */
      if (isWindows) {
        // Convert Windows root paths (C:\) and UNCs (\\) to POSIX root paths
        posixBasePath = posixBasePath.replace(/^([a-zA-Z]\:\/|\/\/)/, '/');
      }
    }

    // Determine which facade methods to use
    let facade;
    if (options.fs === null || options.fs === undefined) {
      // The user didn't provide their own facades, so use our internal ones
      facade = internalOptions.facade;
    }
    else if (typeof options.fs === 'object') {
      // Merge the internal facade methods with the user-provided `fs` facades
      facade = Object.assign({}, internalOptions.facade);
      facade.fs = Object.assign({}, internalOptions.facade.fs, options.fs);
    }
    else {
      throw new TypeError('options.fs must be an object');
    }

    return {
      recurseDepth,
      recurseFn,
      recurseRegExp,
      recurseGlob,
      filterFn,
      filterRegExp,
      filterGlob,
      sep,
      basePath,
      posixBasePath,
      facade,
      emit: !!internalOptions.emit,
      stats: !!internalOptions.stats,
    };
  }


  /***/ }),
  /* 404 */
  /***/ (function(module, exports) {

  module.exports = function (glob, opts) {
    if (typeof glob !== 'string') {
      throw new TypeError('Expected a string');
    }

    var str = String(glob);

    // The regexp we are building, as a string.
    var reStr = "";

    // Whether we are matching so called "extended" globs (like bash) and should
    // support single character matching, matching ranges of characters, group
    // matching, etc.
    var extended = opts ? !!opts.extended : false;

    // When globstar is _false_ (default), '/foo/*' is translated a regexp like
    // '^\/foo\/.*$' which will match any string beginning with '/foo/'
    // When globstar is _true_, '/foo/*' is translated to regexp like
    // '^\/foo\/[^/]*$' which will match any string beginning with '/foo/' BUT
    // which does not have a '/' to the right of it.
    // E.g. with '/foo/*' these will match: '/foo/bar', '/foo/bar.txt' but
    // these will not '/foo/bar/baz', '/foo/bar/baz.txt'
    // Lastely, when globstar is _true_, '/foo/**' is equivelant to '/foo/*' when
    // globstar is _false_
    var globstar = opts ? !!opts.globstar : false;

    // If we are doing extended matching, this boolean is true when we are inside
    // a group (eg {*.html,*.js}), and false otherwise.
    var inGroup = false;

    // RegExp flags (eg "i" ) to pass in to RegExp constructor.
    var flags = opts && typeof( opts.flags ) === "string" ? opts.flags : "";

    var c;
    for (var i = 0, len = str.length; i < len; i++) {
      c = str[i];

      switch (c) {
      case "\\":
      case "/":
      case "$":
      case "^":
      case "+":
      case ".":
      case "(":
      case ")":
      case "=":
      case "!":
      case "|":
        reStr += "\\" + c;
        break;

      case "?":
        if (extended) {
          reStr += ".";
  	    break;
        }

      case "[":
      case "]":
        if (extended) {
          reStr += c;
  	    break;
        }

      case "{":
        if (extended) {
          inGroup = true;
  	    reStr += "(";
  	    break;
        }

      case "}":
        if (extended) {
          inGroup = false;
  	    reStr += ")";
  	    break;
        }

      case ",":
        if (inGroup) {
          reStr += "|";
  	    break;
        }
        reStr += "\\" + c;
        break;

      case "*":
        // Move over all consecutive "*"'s.
        // Also store the previous and next characters
        var prevChar = str[i - 1];
        var starCount = 1;
        while(str[i + 1] === "*") {
          starCount++;
          i++;
        }
        var nextChar = str[i + 1];

        if (!globstar) {
          // globstar is disabled, so treat any number of "*" as one
          reStr += ".*";
        } else {
          // globstar is enabled, so determine if this is a globstar segment
          var isGlobstar = starCount > 1                      // multiple "*"'s
            && (prevChar === "/" || prevChar === undefined)   // from the start of the segment
            && (nextChar === "/" || nextChar === undefined)   // to the end of the segment

          if (isGlobstar) {
            // it's a globstar, so match zero or more path segments
            reStr += "(?:[^/]*(?:\/|$))*";
            i++; // move over the "/"
          } else {
            // it's not a globstar, so only match one path segment
            reStr += "[^/]*";
          }
        }
        break;

      default:
        reStr += c;
      }
    }

    // When regexp 'g' flag is specified don't
    // constrain the regular expression with ^ & $
    if (!flags || !~flags.indexOf('g')) {
      reStr = "^" + reStr + "$";
    }

    return new RegExp(reStr, flags);
  };


  /***/ }),
  /* 405 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const call = __webpack_require__(406);

  module.exports = stat;

  /**
   * Retrieves the {@link fs.Stats} for the given path. If the path is a symbolic link,
   * then the Stats of the symlink's target are returned instead.  If the symlink is broken,
   * then the Stats of the symlink itself are returned.
   *
   * @param {object} fs - Synchronous or Asynchronouse facade for the "fs" module
   * @param {string} path - The path to return stats for
   * @param {function} callback
   */
  function stat (fs, path, callback) {
    let isSymLink = false;

    call.safe(fs.lstat, path, (err, lstats) => {
      if (err) {
        // fs.lstat threw an eror
        return callback(err);
      }

      try {
        isSymLink = lstats.isSymbolicLink();
      }
      catch (err2) {
        // lstats.isSymbolicLink() threw an error
        // (probably because fs.lstat returned an invalid result)
        return callback(err2);
      }

      if (isSymLink) {
        // Try to resolve the symlink
        symlinkStat(fs, path, lstats, callback);
      }
      else {
        // It's not a symlink, so return the stats as-is
        callback(null, lstats);
      }
    });
  }

  /**
   * Retrieves the {@link fs.Stats} for the target of the given symlink.
   * If the symlink is broken, then the Stats of the symlink itself are returned.
   *
   * @param {object} fs - Synchronous or Asynchronouse facade for the "fs" module
   * @param {string} path - The path of the symlink to return stats for
   * @param {object} lstats - The stats of the symlink
   * @param {function} callback
   */
  function symlinkStat (fs, path, lstats, callback) {
    call.safe(fs.stat, path, (err, stats) => {
      if (err) {
        // The symlink is broken, so return the stats for the link itself
        return callback(null, lstats);
      }

      try {
        // Return the stats for the resolved symlink target,
        // and override the `isSymbolicLink` method to indicate that it's a symlink
        stats.isSymbolicLink = () => true;
      }
      catch (err2) {
        // Setting stats.isSymbolicLink threw an error
        // (probably because fs.stat returned an invalid result)
        return callback(err2);
      }

      callback(null, stats);
    });
  }


  /***/ }),
  /* 406 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  let call = module.exports = {
    safe: safeCall,
    once: callOnce,
  };

  /**
   * Calls a function with the given arguments, and ensures that the error-first callback is _always_
   * invoked exactly once, even if the function throws an error.
   *
   * @param {function} fn - The function to invoke
   * @param {...*} args - The arguments to pass to the function. The final argument must be a callback function.
   */
  function safeCall (fn, args) {
    // Get the function arguments as an array
    args = Array.prototype.slice.call(arguments, 1);

    // Replace the callback function with a wrapper that ensures it will only be called once
    let callback = call.once(args.pop());
    args.push(callback);

    try {
      fn.apply(null, args);
    }
    catch (err) {
      callback(err);
    }
  }

  /**
   * Returns a wrapper function that ensures the given callback function is only called once.
   * Subsequent calls are ignored, unless the first argument is an Error, in which case the
   * error is thrown.
   *
   * @param {function} fn - The function that should only be called once
   * @returns {function}
   */
  function callOnce (fn) {
    let fulfilled = false;

    return function onceWrapper (err) {
      if (!fulfilled) {
        fulfilled = true;
        return fn.apply(this, arguments);
      }
      else if (err) {
        // The callback has already been called, but now an error has occurred
        // (most likely inside the callback function). So re-throw the error,
        // so it gets handled further up the call stack
        throw err;
      }
    };
  }


  /***/ }),
  /* 407 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const fs = __webpack_require__(7);
  const call = __webpack_require__(406);

  /**
   * A facade around {@link fs.readdirSync} that allows it to be called
   * the same way as {@link fs.readdir}.
   *
   * @param {string} dir
   * @param {function} callback
   */
  exports.readdir = function (dir, callback) {
    // Make sure the callback is only called once
    callback = call.once(callback);

    try {
      let items = fs.readdirSync(dir);
      callback(null, items);
    }
    catch (err) {
      callback(err);
    }
  };

  /**
   * A facade around {@link fs.statSync} that allows it to be called
   * the same way as {@link fs.stat}.
   *
   * @param {string} path
   * @param {function} callback
   */
  exports.stat = function (path, callback) {
    // Make sure the callback is only called once
    callback = call.once(callback);

    try {
      let stats = fs.statSync(path);
      callback(null, stats);
    }
    catch (err) {
      callback(err);
    }
  };

  /**
   * A facade around {@link fs.lstatSync} that allows it to be called
   * the same way as {@link fs.lstat}.
   *
   * @param {string} path
   * @param {function} callback
   */
  exports.lstat = function (path, callback) {
    // Make sure the callback is only called once
    callback = call.once(callback);

    try {
      let stats = fs.lstatSync(path);
      callback(null, stats);
    }
    catch (err) {
      callback(err);
    }
  };


  /***/ }),
  /* 408 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  module.exports = syncForEach;

  /**
   * A facade that allows {@link Array.forEach} to be called as though it were asynchronous.
   *
   * @param {array} array - The array to iterate over
   * @param {function} iterator - The function to call for each item in the array
   * @param {function} done - The function to call when all iterators have completed
   */
  function syncForEach (array, iterator, done) {
    array.forEach(item => {
      iterator(item, () => {
        // Note: No error-handling here because this is currently only ever called
        // by DirectoryReader, which never passes an `error` parameter to the callback.
        // Instead, DirectoryReader emits an "error" event if an error occurs.
      });
    });

    done();
  }


  /***/ }),
  /* 409 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  module.exports = readdirAsync;

  const maybe = __webpack_require__(410);
  const DirectoryReader = __webpack_require__(402);

  let asyncFacade = {
    fs: __webpack_require__(7),
    forEach: __webpack_require__(411),
    async: true
  };

  /**
   * Returns the buffered output from an asynchronous {@link DirectoryReader},
   * via an error-first callback or a {@link Promise}.
   *
   * @param {string} dir
   * @param {object} [options]
   * @param {function} [callback]
   * @param {object} internalOptions
   */
  function readdirAsync (dir, options, callback, internalOptions) {
    if (typeof options === 'function') {
      callback = options;
      options = undefined;
    }

    return maybe(callback, new Promise(((resolve, reject) => {
      let results = [];

      internalOptions.facade = asyncFacade;

      let reader = new DirectoryReader(dir, options, internalOptions);
      let stream = reader.stream;

      stream.on('error', err => {
        reject(err);
        stream.pause();
      });
      stream.on('data', result => {
        results.push(result);
      });
      stream.on('end', () => {
        resolve(results);
      });
    })));
  }


  /***/ }),
  /* 410 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var next = (global.process && process.nextTick) || global.setImmediate || function (f) {
    setTimeout(f, 0)
  }

  module.exports = function maybe (cb, promise) {
    if (cb) {
      promise
        .then(function (result) {
          next(function () { cb(null, result) })
        }, function (err) {
          next(function () { cb(err) })
        })
      return undefined
    }
    else {
      return promise
    }
  }


  /***/ }),
  /* 411 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  module.exports = asyncForEach;

  /**
   * Simultaneously processes all items in the given array.
   *
   * @param {array} array - The array to iterate over
   * @param {function} iterator - The function to call for each item in the array
   * @param {function} done - The function to call when all iterators have completed
   */
  function asyncForEach (array, iterator, done) {
    if (array.length === 0) {
      // NOTE: Normally a bad idea to mix sync and async, but it's safe here because
      // of the way that this method is currently used by DirectoryReader.
      done();
      return;
    }

    // Simultaneously process all items in the array.
    let pending = array.length;
    array.forEach(item => {
      iterator(item, () => {
        if (--pending === 0) {
          done();
        }
      });
    });
  }


  /***/ }),
  /* 412 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  module.exports = readdirStream;

  const DirectoryReader = __webpack_require__(402);

  let streamFacade = {
    fs: __webpack_require__(7),
    forEach: __webpack_require__(411),
    async: true
  };

  /**
   * Returns the {@link stream.Readable} of an asynchronous {@link DirectoryReader}.
   *
   * @param {string} dir
   * @param {object} [options]
   * @param {object} internalOptions
   */
  function readdirStream (dir, options, internalOptions) {
    internalOptions.facade = streamFacade;

    let reader = new DirectoryReader(dir, options, internalOptions);
    return reader.stream;
  }


  /***/ }),
  /* 413 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  
  Object.defineProperty(exports, "__esModule", { value: true });
  var path = __webpack_require__(8);
  var deep_1 = __webpack_require__(414);
  var entry_1 = __webpack_require__(416);
  var pathUtil = __webpack_require__(415);
  var Reader = /** @class */ (function () {
      function Reader(options) {
          this.options = options;
          this.micromatchOptions = this.getMicromatchOptions();
          this.entryFilter = new entry_1.default(options, this.micromatchOptions);
          this.deepFilter = new deep_1.default(options, this.micromatchOptions);
      }
      /**
       * Returns root path to scanner.
       */
      Reader.prototype.getRootDirectory = function (task) {
          return path.resolve(this.options.cwd, task.base);
      };
      /**
       * Returns options for reader.
       */
      Reader.prototype.getReaderOptions = function (task) {
          return {
              basePath: task.base === '.' ? '' : task.base,
              filter: this.entryFilter.getFilter(task.positive, task.negative),
              deep: this.deepFilter.getFilter(task.positive, task.negative),
              sep: '/'
          };
      };
      /**
       * Returns options for micromatch.
       */
      Reader.prototype.getMicromatchOptions = function () {
          return {
              dot: this.options.dot,
              nobrace: !this.options.brace,
              noglobstar: !this.options.globstar,
              noext: !this.options.extension,
              nocase: !this.options.case,
              matchBase: this.options.matchBase
          };
      };
      /**
       * Returns transformed entry.
       */
      Reader.prototype.transform = function (entry) {
          if (this.options.absolute) {
              entry.path = pathUtil.makeAbsolute(this.options.cwd, entry.path);
          }
          if (this.options.markDirectories && entry.isDirectory()) {
              entry.path += '/';
          }
          var item = this.options.stats ? entry : entry.path;
          if (this.options.transform === null) {
              return item;
          }
          return this.options.transform(item);
      };
      /**
       * Returns true if error has ENOENT code.
       */
      Reader.prototype.isEnoentCodeError = function (err) {
          return err.code === 'ENOENT';
      };
      return Reader;
  }());
  exports.default = Reader;


  /***/ }),
  /* 414 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  
  Object.defineProperty(exports, "__esModule", { value: true });
  var pathUtils = __webpack_require__(415);
  var patternUtils = __webpack_require__(275);
  var DeepFilter = /** @class */ (function () {
      function DeepFilter(options, micromatchOptions) {
          this.options = options;
          this.micromatchOptions = micromatchOptions;
      }
      /**
       * Returns filter for directories.
       */
      DeepFilter.prototype.getFilter = function (positive, negative) {
          var _this = this;
          var maxPatternDepth = this.getMaxPatternDepth(positive);
          var negativeRe = this.getNegativePatternsRe(negative);
          return function (entry) { return _this.filter(entry, negativeRe, maxPatternDepth); };
      };
      /**
       * Returns max depth of the provided patterns.
       */
      DeepFilter.prototype.getMaxPatternDepth = function (patterns) {
          var globstar = patterns.some(patternUtils.hasGlobStar);
          return globstar ? Infinity : patternUtils.getMaxNaivePatternsDepth(patterns);
      };
      /**
       * Returns RegExp's for patterns that can affect the depth of reading.
       */
      DeepFilter.prototype.getNegativePatternsRe = function (patterns) {
          var affectDepthOfReadingPatterns = patterns.filter(patternUtils.isAffectDepthOfReadingPattern);
          return patternUtils.convertPatternsToRe(affectDepthOfReadingPatterns, this.micromatchOptions);
      };
      /**
       * Returns «true» for directory that should be read.
       */
      DeepFilter.prototype.filter = function (entry, negativeRe, maxPatternDepth) {
          if (this.isSkippedByDeepOption(entry.depth)) {
              return false;
          }
          if (this.isSkippedByMaxPatternDepth(entry.depth, maxPatternDepth)) {
              return false;
          }
          if (this.isSkippedSymlinkedDirectory(entry)) {
              return false;
          }
          if (this.isSkippedDotDirectory(entry)) {
              return false;
          }
          return this.isSkippedByNegativePatterns(entry, negativeRe);
      };
      /**
       * Returns «true» when the «deep» option is disabled or number and depth of the entry is greater that the option value.
       */
      DeepFilter.prototype.isSkippedByDeepOption = function (entryDepth) {
          return !this.options.deep || (typeof this.options.deep === 'number' && entryDepth >= this.options.deep);
      };
      /**
       * Returns «true» when depth parameter is not an Infinity and entry depth greater that the parameter value.
       */
      DeepFilter.prototype.isSkippedByMaxPatternDepth = function (entryDepth, maxPatternDepth) {
          return maxPatternDepth !== Infinity && entryDepth >= maxPatternDepth;
      };
      /**
       * Returns «true» for symlinked directory if the «followSymlinkedDirectories» option is disabled.
       */
      DeepFilter.prototype.isSkippedSymlinkedDirectory = function (entry) {
          return !this.options.followSymlinkedDirectories && entry.isSymbolicLink();
      };
      /**
       * Returns «true» for a directory whose name starts with a period if «dot» option is disabled.
       */
      DeepFilter.prototype.isSkippedDotDirectory = function (entry) {
          return !this.options.dot && pathUtils.isDotDirectory(entry.path);
      };
      /**
       * Returns «true» for a directory whose path math to any negative pattern.
       */
      DeepFilter.prototype.isSkippedByNegativePatterns = function (entry, negativeRe) {
          return !patternUtils.matchAny(entry.path, negativeRe);
      };
      return DeepFilter;
  }());
  exports.default = DeepFilter;


  /***/ }),
  /* 415 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  
  Object.defineProperty(exports, "__esModule", { value: true });
  var path = __webpack_require__(8);
  /**
   * Returns «true» if the last partial of the path starting with a period.
   */
  function isDotDirectory(filepath) {
      return path.basename(filepath).startsWith('.');
  }
  exports.isDotDirectory = isDotDirectory;
  /**
   * Convert a windows-like path to a unix-style path.
   */
  function normalize(filepath) {
      return filepath.replace(/\\/g, '/');
  }
  exports.normalize = normalize;
  /**
   * Returns normalized absolute path of provided filepath.
   */
  function makeAbsolute(cwd, filepath) {
      return normalize(path.resolve(cwd, filepath));
  }
  exports.makeAbsolute = makeAbsolute;


  /***/ }),
  /* 416 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  
  Object.defineProperty(exports, "__esModule", { value: true });
  var pathUtils = __webpack_require__(415);
  var patternUtils = __webpack_require__(275);
  var EntryFilter = /** @class */ (function () {
      function EntryFilter(options, micromatchOptions) {
          this.options = options;
          this.micromatchOptions = micromatchOptions;
          this.index = new Map();
      }
      /**
       * Returns filter for directories.
       */
      EntryFilter.prototype.getFilter = function (positive, negative) {
          var _this = this;
          var positiveRe = patternUtils.convertPatternsToRe(positive, this.micromatchOptions);
          var negativeRe = patternUtils.convertPatternsToRe(negative, this.micromatchOptions);
          return function (entry) { return _this.filter(entry, positiveRe, negativeRe); };
      };
      /**
       * Returns true if entry must be added to result.
       */
      EntryFilter.prototype.filter = function (entry, positiveRe, negativeRe) {
          // Exclude duplicate results
          if (this.options.unique) {
              if (this.isDuplicateEntry(entry)) {
                  return false;
              }
              this.createIndexRecord(entry);
          }
          // Filter files and directories by options
          if (this.onlyFileFilter(entry) || this.onlyDirectoryFilter(entry)) {
              return false;
          }
          if (this.isSkippedByAbsoluteNegativePatterns(entry, negativeRe)) {
              return false;
          }
          return this.isMatchToPatterns(entry.path, positiveRe) && !this.isMatchToPatterns(entry.path, negativeRe);
      };
      /**
       * Return true if the entry already has in the cross reader index.
       */
      EntryFilter.prototype.isDuplicateEntry = function (entry) {
          return this.index.has(entry.path);
      };
      /**
       * Create record in the cross reader index.
       */
      EntryFilter.prototype.createIndexRecord = function (entry) {
          this.index.set(entry.path, undefined);
      };
      /**
       * Returns true for non-files if the «onlyFiles» option is enabled.
       */
      EntryFilter.prototype.onlyFileFilter = function (entry) {
          return this.options.onlyFiles && !entry.isFile();
      };
      /**
       * Returns true for non-directories if the «onlyDirectories» option is enabled.
       */
      EntryFilter.prototype.onlyDirectoryFilter = function (entry) {
          return this.options.onlyDirectories && !entry.isDirectory();
      };
      /**
       * Return true when `absolute` option is enabled and matched to the negative patterns.
       */
      EntryFilter.prototype.isSkippedByAbsoluteNegativePatterns = function (entry, negativeRe) {
          if (!this.options.absolute) {
              return false;
          }
          var fullpath = pathUtils.makeAbsolute(this.options.cwd, entry.path);
          return this.isMatchToPatterns(fullpath, negativeRe);
      };
      /**
       * Return true when entry match to provided patterns.
       *
       * First, just trying to apply patterns to the path.
       * Second, trying to apply patterns to the path with final slash (need to micromatch to support «directory/**» patterns).
       */
      EntryFilter.prototype.isMatchToPatterns = function (filepath, patternsRe) {
          return patternUtils.matchAny(filepath, patternsRe) || patternUtils.matchAny(filepath + '/', patternsRe);
      };
      return EntryFilter;
  }());
  exports.default = EntryFilter;


  /***/ }),
  /* 417 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  
  var __extends = (this && this.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  Object.defineProperty(exports, "__esModule", { value: true });
  var stream = __webpack_require__(24);
  var fsStat = __webpack_require__(418);
  var fs_1 = __webpack_require__(422);
  var FileSystemStream = /** @class */ (function (_super) {
      __extends(FileSystemStream, _super);
      function FileSystemStream() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Use stream API to read entries for Task.
       */
      FileSystemStream.prototype.read = function (patterns, filter) {
          var _this = this;
          var filepaths = patterns.map(this.getFullEntryPath, this);
          var transform = new stream.Transform({ objectMode: true });
          transform._transform = function (index, _enc, done) {
              return _this.getEntry(filepaths[index], patterns[index]).then(function (entry) {
                  if (entry !== null && filter(entry)) {
                      transform.push(entry);
                  }
                  if (index === filepaths.length - 1) {
                      transform.end();
                  }
                  done();
              });
          };
          for (var i = 0; i < filepaths.length; i++) {
              transform.write(i);
          }
          return transform;
      };
      /**
       * Return entry for the provided path.
       */
      FileSystemStream.prototype.getEntry = function (filepath, pattern) {
          var _this = this;
          return this.getStat(filepath)
              .then(function (stat) { return _this.makeEntry(stat, pattern); })
              .catch(function () { return null; });
      };
      /**
       * Return fs.Stats for the provided path.
       */
      FileSystemStream.prototype.getStat = function (filepath) {
          return fsStat.stat(filepath, { throwErrorOnBrokenSymlinks: false });
      };
      return FileSystemStream;
  }(fs_1.default));
  exports.default = FileSystemStream;


  /***/ }),
  /* 418 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const optionsManager = __webpack_require__(419);
  const statProvider = __webpack_require__(421);
  /**
   * Asynchronous API.
   */
  function stat(path, opts) {
      return new Promise((resolve, reject) => {
          statProvider.async(path, optionsManager.prepare(opts), (err, stats) => err ? reject(err) : resolve(stats));
      });
  }
  exports.stat = stat;
  function statCallback(path, optsOrCallback, callback) {
      if (typeof optsOrCallback === 'function') {
          callback = optsOrCallback; /* tslint:disable-line: no-parameter-reassignment */
          optsOrCallback = undefined; /* tslint:disable-line: no-parameter-reassignment */
      }
      if (typeof callback === 'undefined') {
          throw new TypeError('The "callback" argument must be of type Function.');
      }
      statProvider.async(path, optionsManager.prepare(optsOrCallback), callback);
  }
  exports.statCallback = statCallback;
  /**
   * Synchronous API.
   */
  function statSync(path, opts) {
      return statProvider.sync(path, optionsManager.prepare(opts));
  }
  exports.statSync = statSync;


  /***/ }),
  /* 419 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const fsAdapter = __webpack_require__(420);
  function prepare(opts) {
      const options = Object.assign({
          fs: fsAdapter.getFileSystemAdapter(opts ? opts.fs : undefined),
          throwErrorOnBrokenSymlinks: true,
          followSymlinks: true
      }, opts);
      return options;
  }
  exports.prepare = prepare;


  /***/ }),
  /* 420 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  const fs = __webpack_require__(7);
  exports.FILE_SYSTEM_ADAPTER = {
      lstat: fs.lstat,
      stat: fs.stat,
      lstatSync: fs.lstatSync,
      statSync: fs.statSync
  };
  function getFileSystemAdapter(fsMethods) {
      if (!fsMethods) {
          return exports.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign({}, exports.FILE_SYSTEM_ADAPTER, fsMethods);
  }
  exports.getFileSystemAdapter = getFileSystemAdapter;


  /***/ }),
  /* 421 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", { value: true });
  function sync(path, options) {
      const lstat = options.fs.lstatSync(path);
      if (!isFollowedSymlink(lstat, options)) {
          return lstat;
      }
      try {
          const stat = options.fs.statSync(path);
          stat.isSymbolicLink = () => true;
          return stat;
      }
      catch (err) {
          if (!options.throwErrorOnBrokenSymlinks) {
              return lstat;
          }
          throw err;
      }
  }
  exports.sync = sync;
  function async(path, options, callback) {
      options.fs.lstat(path, (err0, lstat) => {
          if (err0) {
              return callback(err0, undefined);
          }
          if (!isFollowedSymlink(lstat, options)) {
              return callback(null, lstat);
          }
          options.fs.stat(path, (err1, stat) => {
              if (err1) {
                  return options.throwErrorOnBrokenSymlinks ? callback(err1) : callback(null, lstat);
              }
              stat.isSymbolicLink = () => true;
              callback(null, stat);
          });
      });
  }
  exports.async = async;
  /**
   * Returns `true` for followed symlink.
   */
  function isFollowedSymlink(stat, options) {
      return stat.isSymbolicLink() && options.followSymlinks;
  }
  exports.isFollowedSymlink = isFollowedSymlink;


  /***/ }),
  /* 422 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  
  Object.defineProperty(exports, "__esModule", { value: true });
  var path = __webpack_require__(8);
  var FileSystem = /** @class */ (function () {
      function FileSystem(options) {
          this.options = options;
      }
      /**
       * Return full path to entry.
       */
      FileSystem.prototype.getFullEntryPath = function (filepath) {
          return path.resolve(this.options.cwd, filepath);
      };
      /**
       * Return an implementation of the Entry interface.
       */
      FileSystem.prototype.makeEntry = function (stat, pattern) {
          stat.path = pattern;
          stat.depth = pattern.split('/').length;
          return stat;
      };
      return FileSystem;
  }());
  exports.default = FileSystem;


  /***/ }),
  /* 423 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  
  var __extends = (this && this.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  Object.defineProperty(exports, "__esModule", { value: true });
  var stream = __webpack_require__(24);
  var readdir = __webpack_require__(400);
  var reader_1 = __webpack_require__(413);
  var fs_stream_1 = __webpack_require__(417);
  var TransformStream = /** @class */ (function (_super) {
      __extends(TransformStream, _super);
      function TransformStream(reader) {
          var _this = _super.call(this, { objectMode: true }) || this;
          _this.reader = reader;
          return _this;
      }
      TransformStream.prototype._transform = function (entry, _encoding, callback) {
          callback(null, this.reader.transform(entry));
      };
      return TransformStream;
  }(stream.Transform));
  var ReaderStream = /** @class */ (function (_super) {
      __extends(ReaderStream, _super);
      function ReaderStream() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      Object.defineProperty(ReaderStream.prototype, "fsAdapter", {
          /**
           * Returns FileSystem adapter.
           */
          get: function () {
              return new fs_stream_1.default(this.options);
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Use stream API to read entries for Task.
       */
      ReaderStream.prototype.read = function (task) {
          var _this = this;
          var root = this.getRootDirectory(task);
          var options = this.getReaderOptions(task);
          var transform = new TransformStream(this);
          var readable = this.api(root, task, options);
          return readable
              .on('error', function (err) { return _this.isEnoentCodeError(err) ? null : transform.emit('error', err); })
              .pipe(transform);
      };
      /**
       * Returns founded paths.
       */
      ReaderStream.prototype.api = function (root, task, options) {
          if (task.dynamic) {
              return this.dynamicApi(root, options);
          }
          return this.staticApi(task, options);
      };
      /**
       * Api for dynamic tasks.
       */
      ReaderStream.prototype.dynamicApi = function (root, options) {
          return readdir.readdirStreamStat(root, options);
      };
      /**
       * Api for static tasks.
       */
      ReaderStream.prototype.staticApi = function (task, options) {
          return this.fsAdapter.read(task.patterns, options.filter);
      };
      return ReaderStream;
  }(reader_1.default));
  exports.default = ReaderStream;


  /***/ }),
  /* 424 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  
  var __extends = (this && this.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  Object.defineProperty(exports, "__esModule", { value: true });
  var readdir = __webpack_require__(400);
  var reader_1 = __webpack_require__(413);
  var fs_sync_1 = __webpack_require__(425);
  var ReaderSync = /** @class */ (function (_super) {
      __extends(ReaderSync, _super);
      function ReaderSync() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      Object.defineProperty(ReaderSync.prototype, "fsAdapter", {
          /**
           * Returns FileSystem adapter.
           */
          get: function () {
              return new fs_sync_1.default(this.options);
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Use sync API to read entries for Task.
       */
      ReaderSync.prototype.read = function (task) {
          var root = this.getRootDirectory(task);
          var options = this.getReaderOptions(task);
          try {
              var entries = this.api(root, task, options);
              return entries.map(this.transform, this);
          }
          catch (err) {
              if (this.isEnoentCodeError(err)) {
                  return [];
              }
              throw err;
          }
      };
      /**
       * Returns founded paths.
       */
      ReaderSync.prototype.api = function (root, task, options) {
          if (task.dynamic) {
              return this.dynamicApi(root, options);
          }
          return this.staticApi(task, options);
      };
      /**
       * Api for dynamic tasks.
       */
      ReaderSync.prototype.dynamicApi = function (root, options) {
          return readdir.readdirSyncStat(root, options);
      };
      /**
       * Api for static tasks.
       */
      ReaderSync.prototype.staticApi = function (task, options) {
          return this.fsAdapter.read(task.patterns, options.filter);
      };
      return ReaderSync;
  }(reader_1.default));
  exports.default = ReaderSync;


  /***/ }),
  /* 425 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  
  var __extends = (this && this.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  Object.defineProperty(exports, "__esModule", { value: true });
  var fsStat = __webpack_require__(418);
  var fs_1 = __webpack_require__(422);
  var FileSystemSync = /** @class */ (function (_super) {
      __extends(FileSystemSync, _super);
      function FileSystemSync() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Use sync API to read entries for Task.
       */
      FileSystemSync.prototype.read = function (patterns, filter) {
          var _this = this;
          var entries = [];
          patterns.forEach(function (pattern) {
              var filepath = _this.getFullEntryPath(pattern);
              var entry = _this.getEntry(filepath, pattern);
              if (entry === null || !filter(entry)) {
                  return;
              }
              entries.push(entry);
          });
          return entries;
      };
      /**
       * Return entry for the provided path.
       */
      FileSystemSync.prototype.getEntry = function (filepath, pattern) {
          try {
              var stat = this.getStat(filepath);
              return this.makeEntry(stat, pattern);
          }
          catch (err) {
              return null;
          }
      };
      /**
       * Return fs.Stats for the provided path.
       */
      FileSystemSync.prototype.getStat = function (filepath) {
          return fsStat.statSync(filepath, { throwErrorOnBrokenSymlinks: false });
      };
      return FileSystemSync;
  }(fs_1.default));
  exports.default = FileSystemSync;


  /***/ }),
  /* 426 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  
  Object.defineProperty(exports, "__esModule", { value: true });
  /**
   * Flatten nested arrays (max depth is 2) into a non-nested array of non-array items.
   */
  function flatten(items) {
      return items.reduce(function (collection, item) { return [].concat(collection, item); }, []);
  }
  exports.flatten = flatten;


  /***/ }),
  /* 427 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";
  
  Object.defineProperty(exports, "__esModule", { value: true });
  var merge2 = __webpack_require__(428);
  /**
   * Merge multiple streams and propagate their errors into one stream in parallel.
   */
  function merge(streams) {
      var mergedStream = merge2(streams);
      streams.forEach(function (stream) {
          stream.on('error', function (err) { return mergedStream.emit('error', err); });
      });
      return mergedStream;
  }
  exports.merge = merge;


  /***/ }),
  /* 428 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  /*
   * merge2
   * https://github.com/teambition/merge2
   *
   * Copyright (c) 2014-2016 Teambition
   * Licensed under the MIT license.
   */
  const Stream = __webpack_require__(24)
  const PassThrough = Stream.PassThrough
  const slice = Array.prototype.slice

  module.exports = merge2

  function merge2 () {
    const streamsQueue = []
    let merging = false
    const args = slice.call(arguments)
    let options = args[args.length - 1]

    if (options && !Array.isArray(options) && options.pipe == null) args.pop()
    else options = {}

    const doEnd = options.end !== false
    if (options.objectMode == null) options.objectMode = true
    if (options.highWaterMark == null) options.highWaterMark = 64 * 1024
    const mergedStream = PassThrough(options)

    function addStream () {
      for (let i = 0, len = arguments.length; i < len; i++) {
        streamsQueue.push(pauseStreams(arguments[i], options))
      }
      mergeStream()
      return this
    }

    function mergeStream () {
      if (merging) return
      merging = true

      let streams = streamsQueue.shift()
      if (!streams) {
        process.nextTick(endStream)
        return
      }
      if (!Array.isArray(streams)) streams = [streams]

      let pipesCount = streams.length + 1

      function next () {
        if (--pipesCount > 0) return
        merging = false
        mergeStream()
      }

      function pipe (stream) {
        function onend () {
          stream.removeListener('merge2UnpipeEnd', onend)
          stream.removeListener('end', onend)
          next()
        }
        // skip ended stream
        if (stream._readableState.endEmitted) return next()

        stream.on('merge2UnpipeEnd', onend)
        stream.on('end', onend)
        stream.pipe(mergedStream, { end: false })
        // compatible for old stream
        stream.resume()
      }

      for (let i = 0; i < streams.length; i++) pipe(streams[i])

      next()
    }

    function endStream () {
      merging = false
      // emit 'queueDrain' when all streams merged.
      mergedStream.emit('queueDrain')
      return doEnd && mergedStream.end()
    }

    mergedStream.setMaxListeners(0)
    mergedStream.add = addStream
    mergedStream.on('unpipe', function (stream) {
      stream.emit('merge2UnpipeEnd')
    })

    if (args.length) addStream.apply(null, args)
    return mergedStream
  }

  // check and pause streams for pipe.
  function pauseStreams (streams, options) {
    if (!Array.isArray(streams)) {
      // Backwards-compat with old-style streams
      if (!streams._readableState && streams.pipe) streams = streams.pipe(PassThrough(options))
      if (!streams._readableState || !streams.pause || !streams.pipe) {
        throw new Error('Only readable stream can be merged.')
      }
      streams.pause()
    } else {
      for (let i = 0, len = streams.length; i < len; i++) streams[i] = pauseStreams(streams[i], options)
    }
    return streams
  }


  /***/ }),
  /* 429 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const path = __webpack_require__(8);
  const arrify = __webpack_require__(430);
  const pathType = __webpack_require__(431);

  const getExtensions = extensions => extensions.length > 1 ? `{${extensions.join(',')}}` : extensions[0];
  const getPath = filepath => filepath[0] === '!' ? filepath.slice(1) : filepath;

  const addExtensions = (file, extensions) => {
  	if (path.extname(file)) {
  		return `**/${file}`;
  	}

  	return `**/${file}.${getExtensions(extensions)}`;
  };

  const getGlob = (dir, opts) => {
  	opts = Object.assign({}, opts);

  	if (opts.files && !Array.isArray(opts.files)) {
  		throw new TypeError(`\`options.files\` must be an \`Array\`, not \`${typeof opts.files}\``);
  	}

  	if (opts.extensions && !Array.isArray(opts.extensions)) {
  		throw new TypeError(`\`options.extensions\` must be an \`Array\`, not \`${typeof opts.extensions}\``);
  	}

  	if (opts.files && opts.extensions) {
  		return opts.files.map(x => path.join(dir, addExtensions(x, opts.extensions)));
  	} else if (opts.files) {
  		return opts.files.map(x => path.join(dir, `**/${x}`));
  	} else if (opts.extensions) {
  		return [path.join(dir, `**/*.${getExtensions(opts.extensions)}`)];
  	}

  	return [path.join(dir, '**')];
  };

  module.exports = (input, opts) => {
  	return Promise.all(arrify(input).map(x => pathType.dir(getPath(x))
  		.then(isDir => isDir ? getGlob(x, opts) : x)))
  		.then(globs => [].concat.apply([], globs));
  };

  module.exports.sync = (input, opts) => {
  	const globs = arrify(input).map(x => pathType.dirSync(getPath(x)) ? getGlob(x, opts) : x);
  	return [].concat.apply([], globs);
  };


  /***/ }),
  /* 430 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  module.exports = function (val) {
  	if (val === null || val === undefined) {
  		return [];
  	}

  	return Array.isArray(val) ? val : [val];
  };


  /***/ }),
  /* 431 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const fs = __webpack_require__(7);
  const pify = __webpack_require__(432);

  function type(fn, fn2, fp) {
  	if (typeof fp !== 'string') {
  		return Promise.reject(new TypeError(`Expected a string, got ${typeof fp}`));
  	}

  	return pify(fs[fn])(fp)
  		.then(stats => stats[fn2]())
  		.catch(err => {
  			if (err.code === 'ENOENT') {
  				return false;
  			}

  			throw err;
  		});
  }

  function typeSync(fn, fn2, fp) {
  	if (typeof fp !== 'string') {
  		throw new TypeError(`Expected a string, got ${typeof fp}`);
  	}

  	try {
  		return fs[fn](fp)[fn2]();
  	} catch (err) {
  		if (err.code === 'ENOENT') {
  			return false;
  		}

  		throw err;
  	}
  }

  exports.file = type.bind(null, 'stat', 'isFile');
  exports.dir = type.bind(null, 'stat', 'isDirectory');
  exports.symlink = type.bind(null, 'lstat', 'isSymbolicLink');
  exports.fileSync = typeSync.bind(null, 'statSync', 'isFile');
  exports.dirSync = typeSync.bind(null, 'statSync', 'isDirectory');
  exports.symlinkSync = typeSync.bind(null, 'lstatSync', 'isSymbolicLink');


  /***/ }),
  /* 432 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  const processFn = (fn, opts) => function () {
  	const P = opts.promiseModule;
  	const args = new Array(arguments.length);

  	for (let i = 0; i < arguments.length; i++) {
  		args[i] = arguments[i];
  	}

  	return new P((resolve, reject) => {
  		if (opts.errorFirst) {
  			args.push(function (err, result) {
  				if (opts.multiArgs) {
  					const results = new Array(arguments.length - 1);

  					for (let i = 1; i < arguments.length; i++) {
  						results[i - 1] = arguments[i];
  					}

  					if (err) {
  						results.unshift(err);
  						reject(results);
  					} else {
  						resolve(results);
  					}
  				} else if (err) {
  					reject(err);
  				} else {
  					resolve(result);
  				}
  			});
  		} else {
  			args.push(function (result) {
  				if (opts.multiArgs) {
  					const results = new Array(arguments.length - 1);

  					for (let i = 0; i < arguments.length; i++) {
  						results[i] = arguments[i];
  					}

  					resolve(results);
  				} else {
  					resolve(result);
  				}
  			});
  		}

  		fn.apply(this, args);
  	});
  };

  module.exports = (obj, opts) => {
  	opts = Object.assign({
  		exclude: [/.+(Sync|Stream)$/],
  		errorFirst: true,
  		promiseModule: Promise
  	}, opts);

  	const filter = key => {
  		const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
  		return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
  	};

  	let ret;
  	if (typeof obj === 'function') {
  		ret = function () {
  			if (opts.excludeMain) {
  				return obj.apply(this, arguments);
  			}

  			return processFn(obj, opts).apply(this, arguments);
  		};
  	} else {
  		ret = Object.create(Object.getPrototypeOf(obj));
  	}

  	for (const key in obj) { // eslint-disable-line guard-for-in
  		const x = obj[key];
  		ret[key] = typeof x === 'function' && filter(key) ? processFn(x, opts) : x;
  	}

  	return ret;
  };


  /***/ }),
  /* 433 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  const fs = __webpack_require__(7);
  const path = __webpack_require__(8);
  const fastGlob = __webpack_require__(271);
  const gitIgnore = __webpack_require__(434);
  const pify = __webpack_require__(432);
  const slash = __webpack_require__(435);

  const DEFAULT_IGNORE = [
  	'**/node_modules/**',
  	'**/bower_components/**',
  	'**/flow-typed/**',
  	'**/coverage/**',
  	'**/.git'
  ];

  const readFileP = pify(fs.readFile);

  const mapGitIgnorePatternTo = base => ignore => {
  	if (ignore.startsWith('!')) {
  		return '!' + path.posix.join(base, ignore.substr(1));
  	}

  	return path.posix.join(base, ignore);
  };

  const parseGitIgnore = (content, opts) => {
  	const base = slash(path.relative(opts.cwd, path.dirname(opts.fileName)));

  	return content
  		.split(/\r?\n/)
  		.filter(Boolean)
  		.filter(l => l.charAt(0) !== '#')
  		.map(mapGitIgnorePatternTo(base));
  };

  const reduceIgnore = files => {
  	return files.reduce((ignores, file) => {
  		ignores.add(parseGitIgnore(file.content, {
  			cwd: file.cwd,
  			fileName: file.filePath
  		}));
  		return ignores;
  	}, gitIgnore());
  };

  const getIsIgnoredPredecate = (ignores, cwd) => {
  	return p => ignores.ignores(slash(path.relative(cwd, p)));
  };

  const getFile = (file, cwd) => {
  	const filePath = path.join(cwd, file);
  	return readFileP(filePath, 'utf8')
  		.then(content => ({
  			content,
  			cwd,
  			filePath
  		}));
  };

  const getFileSync = (file, cwd) => {
  	const filePath = path.join(cwd, file);
  	const content = fs.readFileSync(filePath, 'utf8');

  	return {
  		content,
  		cwd,
  		filePath
  	};
  };

  const normalizeOpts = opts => {
  	opts = opts || {};
  	const ignore = opts.ignore || [];
  	const cwd = opts.cwd || process.cwd();
  	return {ignore, cwd};
  };

  module.exports = o => {
  	const opts = normalizeOpts(o);

  	return fastGlob('**/.gitignore', {ignore: DEFAULT_IGNORE.concat(opts.ignore), cwd: opts.cwd})
  		.then(paths => Promise.all(paths.map(file => getFile(file, opts.cwd))))
  		.then(files => reduceIgnore(files))
  		.then(ignores => getIsIgnoredPredecate(ignores, opts.cwd));
  };

  module.exports.sync = o => {
  	const opts = normalizeOpts(o);

  	const paths = fastGlob.sync('**/.gitignore', {ignore: DEFAULT_IGNORE.concat(opts.ignore), cwd: opts.cwd});
  	const files = paths.map(file => getFileSync(file, opts.cwd));
  	const ignores = reduceIgnore(files);
  	return getIsIgnoredPredecate(ignores, opts.cwd);
  };


  /***/ }),
  /* 434 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";


  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  module.exports = function () {
    return new IgnoreBase();
  };

  // A simple implementation of make-array
  function make_array(subject) {
    return Array.isArray(subject) ? subject : [subject];
  }

  var REGEX_BLANK_LINE = /^\s+$/;
  var REGEX_LEADING_EXCAPED_EXCLAMATION = /^\\\!/;
  var REGEX_LEADING_EXCAPED_HASH = /^\\#/;
  var SLASH = '/';
  var KEY_IGNORE = typeof Symbol !== 'undefined' ? Symbol.for('node-ignore')
  /* istanbul ignore next */
  : 'node-ignore';

  var IgnoreBase = function () {
    function IgnoreBase() {
      _classCallCheck(this, IgnoreBase);

      this._rules = [];
      this[KEY_IGNORE] = true;
      this._initCache();
    }

    _createClass(IgnoreBase, [{
      key: '_initCache',
      value: function _initCache() {
        this._cache = {};
      }

      // @param {Array.<string>|string|Ignore} pattern

    }, {
      key: 'add',
      value: function add(pattern) {
        this._added = false;

        if (typeof pattern === 'string') {
          pattern = pattern.split(/\r?\n/g);
        }

        make_array(pattern).forEach(this._addPattern, this);

        // Some rules have just added to the ignore,
        // making the behavior changed.
        if (this._added) {
          this._initCache();
        }

        return this;
      }

      // legacy

    }, {
      key: 'addPattern',
      value: function addPattern(pattern) {
        return this.add(pattern);
      }
    }, {
      key: '_addPattern',
      value: function _addPattern(pattern) {
        // #32
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules);
          this._added = true;
          return;
        }

        if (this._checkPattern(pattern)) {
          var rule = this._createRule(pattern);
          this._added = true;
          this._rules.push(rule);
        }
      }
    }, {
      key: '_checkPattern',
      value: function _checkPattern(pattern) {
        // > A blank line matches no files, so it can serve as a separator for readability.
        return pattern && typeof pattern === 'string' && !REGEX_BLANK_LINE.test(pattern)

        // > A line starting with # serves as a comment.
        && pattern.indexOf('#') !== 0;
      }
    }, {
      key: 'filter',
      value: function filter(paths) {
        var _this = this;

        return make_array(paths).filter(function (path) {
          return _this._filter(path);
        });
      }
    }, {
      key: 'createFilter',
      value: function createFilter() {
        var _this2 = this;

        return function (path) {
          return _this2._filter(path);
        };
      }
    }, {
      key: 'ignores',
      value: function ignores(path) {
        return !this._filter(path);
      }
    }, {
      key: '_createRule',
      value: function _createRule(pattern) {
        var origin = pattern;
        var negative = false;

        // > An optional prefix "!" which negates the pattern;
        if (pattern.indexOf('!') === 0) {
          negative = true;
          pattern = pattern.substr(1);
        }

        pattern = pattern
        // > Put a backslash ("\") in front of the first "!" for patterns that begin with a literal "!", for example, `"\!important!.txt"`.
        .replace(REGEX_LEADING_EXCAPED_EXCLAMATION, '!')
        // > Put a backslash ("\") in front of the first hash for patterns that begin with a hash.
        .replace(REGEX_LEADING_EXCAPED_HASH, '#');

        var regex = make_regex(pattern, negative);

        return {
          origin: origin,
          pattern: pattern,
          negative: negative,
          regex: regex
        };
      }

      // @returns `Boolean` true if the `path` is NOT ignored

    }, {
      key: '_filter',
      value: function _filter(path, slices) {
        if (!path) {
          return false;
        }

        if (path in this._cache) {
          return this._cache[path];
        }

        if (!slices) {
          // path/to/a.js
          // ['path', 'to', 'a.js']
          slices = path.split(SLASH);
        }

        slices.pop();

        return this._cache[path] = slices.length
        // > It is not possible to re-include a file if a parent directory of that file is excluded.
        // If the path contains a parent directory, check the parent first
        ? this._filter(slices.join(SLASH) + SLASH, slices) && this._test(path)

        // Or only test the path
        : this._test(path);
      }

      // @returns {Boolean} true if a file is NOT ignored

    }, {
      key: '_test',
      value: function _test(path) {
        // Explicitly define variable type by setting matched to `0`
        var matched = 0;

        this._rules.forEach(function (rule) {
          // if matched = true, then we only test negative rules
          // if matched = false, then we test non-negative rules
          if (!(matched ^ rule.negative)) {
            matched = rule.negative ^ rule.regex.test(path);
          }
        });

        return !matched;
      }
    }]);

    return IgnoreBase;
  }();

  // > If the pattern ends with a slash,
  // > it is removed for the purpose of the following description,
  // > but it would only find a match with a directory.
  // > In other words, foo/ will match a directory foo and paths underneath it,
  // > but will not match a regular file or a symbolic link foo
  // >  (this is consistent with the way how pathspec works in general in Git).
  // '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
  // -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
  //      you could use option `mark: true` with `glob`

  // '`foo/`' should not continue with the '`..`'


  var DEFAULT_REPLACER_PREFIX = [

  // > Trailing spaces are ignored unless they are quoted with backslash ("\")
  [
  // (a\ ) -> (a )
  // (a  ) -> (a)
  // (a \ ) -> (a  )
  /\\?\s+$/, function (match) {
    return match.indexOf('\\') === 0 ? ' ' : '';
  }],

  // replace (\ ) with ' '
  [/\\\s/g, function () {
    return ' ';
  }],

  // Escape metacharacters
  // which is written down by users but means special for regular expressions.

  // > There are 12 characters with special meanings:
  // > - the backslash \,
  // > - the caret ^,
  // > - the dollar sign $,
  // > - the period or dot .,
  // > - the vertical bar or pipe symbol |,
  // > - the question mark ?,
  // > - the asterisk or star *,
  // > - the plus sign +,
  // > - the opening parenthesis (,
  // > - the closing parenthesis ),
  // > - and the opening square bracket [,
  // > - the opening curly brace {,
  // > These special characters are often called "metacharacters".
  [/[\\\^$.|?*+()\[{]/g, function (match) {
    return '\\' + match;
  }],

  // leading slash
  [

  // > A leading slash matches the beginning of the pathname.
  // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
  // A leading slash matches the beginning of the pathname
  /^\//, function () {
    return '^';
  }],

  // replace special metacharacter slash after the leading slash
  [/\//g, function () {
    return '\\/';
  }], [
  // > A leading "**" followed by a slash means match in all directories.
  // > For example, "**/foo" matches file or directory "foo" anywhere,
  // > the same as pattern "foo".
  // > "**/foo/bar" matches file or directory "bar" anywhere that is directly under directory "foo".
  // Notice that the '*'s have been replaced as '\\*'
  /^\^*\\\*\\\*\\\//,

  // '**/foo' <-> 'foo'
  function () {
    return '^(?:.*\\/)?';
  }]];

  var DEFAULT_REPLACER_SUFFIX = [
  // starting
  [
  // there will be no leading '/' (which has been replaced by section "leading slash")
  // If starts with '**', adding a '^' to the regular expression also works
  /^(?=[^\^])/, function () {
    return !/\/(?!$)/.test(this)
    // > If the pattern does not contain a slash /, Git treats it as a shell glob pattern
    // Actually, if there is only a trailing slash, git also treats it as a shell glob pattern
    ? '(?:^|\\/)'

    // > Otherwise, Git treats the pattern as a shell glob suitable for consumption by fnmatch(3)
    : '^';
  }],

  // two globstars
  [
  // Use lookahead assertions so that we could match more than one `'/**'`
  /\\\/\\\*\\\*(?=\\\/|$)/g,

  // Zero, one or several directories
  // should not use '*', or it will be replaced by the next replacer

  // Check if it is not the last `'/**'`
  function (match, index, str) {
    return index + 6 < str.length

    // case: /**/
    // > A slash followed by two consecutive asterisks then a slash matches zero or more directories.
    // > For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
    // '/**/'
    ? '(?:\\/[^\\/]+)*'

    // case: /**
    // > A trailing `"/**"` matches everything inside.

    // #21: everything inside but it should not include the current folder
    : '\\/.+';
  }],

  // intermediate wildcards
  [
  // Never replace escaped '*'
  // ignore rule '\*' will match the path '*'

  // 'abc.*/' -> go
  // 'abc.*'  -> skip this rule
  /(^|[^\\]+)\\\*(?=.+)/g,

  // '*.js' matches '.js'
  // '*.js' doesn't match 'abc'
  function (match, p1) {
    return p1 + '[^\\/]*';
  }],

  // trailing wildcard
  [/(\^|\\\/)?\\\*$/, function (match, p1) {
    return (p1
    // '\^':
    // '/*' does not match ''
    // '/*' does not match everything

    // '\\\/':
    // 'abc/*' does not match 'abc/'
    ? p1 + '[^/]+'

    // 'a*' matches 'a'
    // 'a*' matches 'aa'
    : '[^/]*') + '(?=$|\\/$)';
  }], [
  // unescape
  /\\\\\\/g, function () {
    return '\\';
  }]];

  var POSITIVE_REPLACERS = [].concat(DEFAULT_REPLACER_PREFIX, [

  // 'f'
  // matches
  // - /f(end)
  // - /f/
  // - (start)f(end)
  // - (start)f/
  // doesn't match
  // - oof
  // - foo
  // pseudo:
  // -> (^|/)f(/|$)

  // ending
  [
  // 'js' will not match 'js.'
  // 'ab' will not match 'abc'
  /(?:[^*\/])$/,

  // 'js*' will not match 'a.js'
  // 'js/' will not match 'a.js'
  // 'js' will match 'a.js' and 'a.js/'
  function (match) {
    return match + '(?=$|\\/)';
  }]], DEFAULT_REPLACER_SUFFIX);

  var NEGATIVE_REPLACERS = [].concat(DEFAULT_REPLACER_PREFIX, [

  // #24, #38
  // The MISSING rule of [gitignore docs](https://git-scm.com/docs/gitignore)
  // A negative pattern without a trailing wildcard should not
  // re-include the things inside that directory.

  // eg:
  // ['node_modules/*', '!node_modules']
  // should ignore `node_modules/a.js`
  [/(?:[^*])$/, function (match) {
    return match + '(?=$|\\/$)';
  }]], DEFAULT_REPLACER_SUFFIX);

  // A simple cache, because an ignore rule only has only one certain meaning
  var cache = {};

  // @param {pattern}
  function make_regex(pattern, negative) {
    var r = cache[pattern];
    if (r) {
      return r;
    }

    var replacers = negative ? NEGATIVE_REPLACERS : POSITIVE_REPLACERS;

    var source = replacers.reduce(function (prev, current) {
      return prev.replace(current[0], current[1].bind(pattern));
    }, pattern);

    return cache[pattern] = new RegExp(source, 'i');
  }

  // Windows
  // --------------------------------------------------------------
  /* istanbul ignore if  */
  if (
  // Detect `process` so that it can run in browsers.
  typeof process !== 'undefined' && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === 'win32')) {

    var filter = IgnoreBase.prototype._filter;
    var make_posix = function make_posix(str) {
      return (/^\\\\\?\\/.test(str) || /[^\x00-\x80]+/.test(str) ? str : str.replace(/\\/g, '/')
      );
    };

    IgnoreBase.prototype._filter = function (path, slices) {
      path = make_posix(path);
      return filter.call(this, path, slices);
    };
  }


  /***/ }),
  /* 435 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  module.exports = function (str) {
  	var isExtendedLengthPath = /^\\\\\?\\/.test(str);
  	var hasNonAscii = /[^\x00-\x80]+/.test(str);

  	if (isExtendedLengthPath || hasNonAscii) {
  		return str;
  	}

  	return str.replace(/\\/g, '/');
  };


  /***/ }),
  /* 436 */
  /***/ (function(module, exports, __webpack_require__) {

  "use strict";

  var __importDefault = (this && this.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      result["default"] = mod;
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const fslib_1 = __webpack_require__(5);
  const parsers_1 = __webpack_require__(132);
  const semver_1 = __importDefault(__webpack_require__(41));
  const Report_1 = __webpack_require__(177);
  const structUtils = __importStar(__webpack_require__(173));
  const IMPORTED_PATTERNS = [
      // These ones come from Git urls
      [/^git\+(?:https|ssh):\/\/.*\.git#.*$/, (version, $0) => $0],
      // These ones come from the GitHub HTTP endpoints
      [/^https:\/\/codeload\.github\.com\/([^\/]+\/[^\/]+)\/tar\.gz\/([0-9a-f]+)$/, (version, $0, $1, $2) => `github:${$1}#${$2}`],
      [/^https:\/\/github\.com\/([^\/]+\/[^\/]+)#([0-9a-f]+)$/, (version, $0, $1, $2) => `github:${$1}#${$2}`],
      // These ones come from the npm registry
      [/^https?:\/\/[^\/]+\/(?:@[^\/]+\/)?([^\/]+)\/-\/\1-[^\/]+\.tgz(?:#|$)/, version => `npm:${version}`],
      // These ones come from the old Yarn offline mirror - we assume they came from npm
      [/^[^\/]+\.tgz#[0-9a-f]+$/, version => `npm:${version}`],
  ];
  class YarnResolver {
      constructor() {
          this.resolutions = null;
      }
      async setup(project, { report }) {
          const lockfilePath = fslib_1.ppath.join(project.cwd, project.configuration.get(`lockfileFilename`));
          // No need to enable it if the lockfile doesn't exist
          if (!fslib_1.xfs.existsSync(lockfilePath))
              return;
          const content = await fslib_1.xfs.readFilePromise(lockfilePath, `utf8`);
          const parsed = parsers_1.parseSyml(content);
          // No need to enable it either if the lockfile is modern
          if (Object.prototype.hasOwnProperty.call(parsed, `__metadata`))
              return;
          const resolutions = this.resolutions = new Map();
          for (const key of Object.keys(parsed)) {
              let descriptor = structUtils.tryParseDescriptor(key);
              if (!descriptor) {
                  report.reportWarning(Report_1.MessageName.YARN_IMPORT_FAILED, `Failed to parse the string "${key}" into a proper descriptor`);
                  continue;
              }
              if (semver_1.default.validRange(descriptor.range))
                  descriptor = structUtils.makeDescriptor(descriptor, `npm:${descriptor.range}`);
              const { version, resolved } = parsed[key];
              // Workspaces don't have the "resolved" key; we can skip them, as their
              // resolution will be recomputed when needed anyway
              if (!resolved)
                  continue;
              let reference;
              for (const [pattern, matcher] of IMPORTED_PATTERNS) {
                  const match = resolved.match(pattern);
                  if (match) {
                      reference = matcher(version, ...match);
                      break;
                  }
              }
              if (!reference) {
                  report.reportWarning(Report_1.MessageName.YARN_IMPORT_FAILED, `${structUtils.prettyDescriptor(project.configuration, descriptor)}: Only some patterns can be imported from legacy lockfiles (not "${resolved}")`);
                  continue;
              }
              const resolution = structUtils.makeLocator(descriptor, reference);
              resolutions.set(descriptor.descriptorHash, resolution);
          }
      }
      supportsDescriptor(descriptor, opts) {
          if (!this.resolutions)
              return false;
          return this.resolutions.has(descriptor.descriptorHash);
      }
      supportsLocator(locator, opts) {
          // This resolver only supports the descriptor -> locator part of the
          // resolution, not the locator -> package one.
          return false;
      }
      shouldPersistResolution(locator, opts) {
          throw new Error(`Assertion failed: This resolver doesn't support resolving locators to packages`);
      }
      bindDescriptor(descriptor, fromLocator, opts) {
          return descriptor;
      }
      async getCandidates(descriptor, opts) {
          if (!this.resolutions)
              throw new Error(`Assertion failed: The resolution store should have been setup`);
          const resolution = this.resolutions.get(descriptor.descriptorHash);
          if (!resolution)
              throw new Error(`Assertion failed: The resolution should have been registered`);
          return [resolution];
      }
      async resolve(locator, opts) {
          throw new Error(`Assertion failed: This resolver doesn't support resolving locators to packages`);
      }
  }
  exports.YarnResolver = YarnResolver;


  /***/ }),
  /* 437 */
  /***/ (function(module, exports) {

  exports = module.exports = SemVer

  var debug
  /* istanbul ignore next */
  if (typeof process === 'object' &&
      process.env &&
      process.env.NODE_DEBUG &&
      /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug = function () {
      var args = Array.prototype.slice.call(arguments, 0)
      args.unshift('SEMVER')
      console.log.apply(console, args)
    }
  } else {
    debug = function () {}
  }

  // Note: this is the semver.org version of the spec that it implements
  // Not necessarily the package version of this code.
  exports.SEMVER_SPEC_VERSION = '2.0.0'

  var MAX_LENGTH = 256
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
    /* istanbul ignore next */ 9007199254740991

  // Max safe segment length for coercion.
  var MAX_SAFE_COMPONENT_LENGTH = 16

  // The actual regexps go on exports.re
  var re = exports.re = []
  var src = exports.src = []
  var t = exports.tokens = {}
  var R = 0

  function tok (n) {
    t[n] = R++
  }

  // The following Regular Expressions can be used for tokenizing,
  // validating, and parsing SemVer version strings.

  // ## Numeric Identifier
  // A single `0`, or a non-zero digit followed by zero or more digits.

  tok('NUMERICIDENTIFIER')
  src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*'
  tok('NUMERICIDENTIFIERLOOSE')
  src[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+'

  // ## Non-numeric Identifier
  // Zero or more digits, followed by a letter or hyphen, and then zero or
  // more letters, digits, or hyphens.

  tok('NONNUMERICIDENTIFIER')
  src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

  // ## Main Version
  // Three dot-separated numeric identifiers.

  tok('MAINVERSION')
  src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\.' +
                     '(' + src[t.NUMERICIDENTIFIER] + ')\\.' +
                     '(' + src[t.NUMERICIDENTIFIER] + ')'

  tok('MAINVERSIONLOOSE')
  src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' +
                          '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' +
                          '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')'

  // ## Pre-release Version Identifier
  // A numeric identifier, or a non-numeric identifier.

  tok('PRERELEASEIDENTIFIER')
  src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] +
                              '|' + src[t.NONNUMERICIDENTIFIER] + ')'

  tok('PRERELEASEIDENTIFIERLOOSE')
  src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] +
                                   '|' + src[t.NONNUMERICIDENTIFIER] + ')'

  // ## Pre-release Version
  // Hyphen, followed by one or more dot-separated pre-release version
  // identifiers.

  tok('PRERELEASE')
  src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] +
                    '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))'

  tok('PRERELEASELOOSE')
  src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] +
                         '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))'

  // ## Build Metadata Identifier
  // Any combination of digits, letters, or hyphens.

  tok('BUILDIDENTIFIER')
  src[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

  // ## Build Metadata
  // Plus sign, followed by one or more period-separated build metadata
  // identifiers.

  tok('BUILD')
  src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] +
               '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))'

  // ## Full Version String
  // A main version, followed optionally by a pre-release version and
  // build metadata.

  // Note that the only major, minor, patch, and pre-release sections of
  // the version string are capturing groups.  The build metadata is not a
  // capturing group, because it should not ever be used in version
  // comparison.

  tok('FULL')
  tok('FULLPLAIN')
  src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] +
                    src[t.PRERELEASE] + '?' +
                    src[t.BUILD] + '?'

  src[t.FULL] = '^' + src[t.FULLPLAIN] + '$'

  // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
  // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
  // common in the npm registry.
  tok('LOOSEPLAIN')
  src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] +
                    src[t.PRERELEASELOOSE] + '?' +
                    src[t.BUILD] + '?'

  tok('LOOSE')
  src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$'

  tok('GTLT')
  src[t.GTLT] = '((?:<|>)?=?)'

  // Something like "2.*" or "1.2.x".
  // Note that "x.x" is a valid xRange identifer, meaning "any version"
  // Only the first item is strictly required.
  tok('XRANGEIDENTIFIERLOOSE')
  src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
  tok('XRANGEIDENTIFIER')
  src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*'

  tok('XRANGEPLAIN')
  src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' +
                     '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' +
                     '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' +
                     '(?:' + src[t.PRERELEASE] + ')?' +
                     src[t.BUILD] + '?' +
                     ')?)?'

  tok('XRANGEPLAINLOOSE')
  src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                          '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                          '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                          '(?:' + src[t.PRERELEASELOOSE] + ')?' +
                          src[t.BUILD] + '?' +
                          ')?)?'

  tok('XRANGE')
  src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$'
  tok('XRANGELOOSE')
  src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$'

  // Coercion.
  // Extract anything that could conceivably be a part of a valid semver
  tok('COERCE')
  src[t.COERCE] = '(^|[^\\d])' +
                '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
                '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
                '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
                '(?:$|[^\\d])'
  tok('COERCERTL')
  re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g')

  // Tilde ranges.
  // Meaning is "reasonably at or greater than"
  tok('LONETILDE')
  src[t.LONETILDE] = '(?:~>?)'

  tok('TILDETRIM')
  src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+'
  re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g')
  var tildeTrimReplace = '$1~'

  tok('TILDE')
  src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$'
  tok('TILDELOOSE')
  src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$'

  // Caret ranges.
  // Meaning is "at least and backwards compatible with"
  tok('LONECARET')
  src[t.LONECARET] = '(?:\\^)'

  tok('CARETTRIM')
  src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+'
  re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g')
  var caretTrimReplace = '$1^'

  tok('CARET')
  src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$'
  tok('CARETLOOSE')
  src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$'

  // A simple gt/lt/eq thing, or just "" to indicate "any version"
  tok('COMPARATORLOOSE')
  src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$'
  tok('COMPARATOR')
  src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$'

  // An expression to strip any whitespace between the gtlt and the thing
  // it modifies, so that `> 1.2.3` ==> `>1.2.3`
  tok('COMPARATORTRIM')
  src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] +
                        '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')'

  // this one has to use the /g flag
  re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g')
  var comparatorTrimReplace = '$1$2$3'

  // Something like `1.2.3 - 1.2.4`
  // Note that these all use the loose form, because they'll be
  // checked against either the strict or loose comparator form
  // later.
  tok('HYPHENRANGE')
  src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ')' +
                     '\\s+-\\s+' +
                     '(' + src[t.XRANGEPLAIN] + ')' +
                     '\\s*$'

  tok('HYPHENRANGELOOSE')
  src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' +
                          '\\s+-\\s+' +
                          '(' + src[t.XRANGEPLAINLOOSE] + ')' +
                          '\\s*$'

  // Star ranges basically just allow anything at all.
  tok('STAR')
  src[t.STAR] = '(<|>)?=?\\s*\\*'

  // Compile to actual regexp objects.
  // All are flag-free, unless they were created above with a flag.
  for (var i = 0; i < R; i++) {
    debug(i, src[i])
    if (!re[i]) {
      re[i] = new RegExp(src[i])
    }
  }

  exports.parse = parse
  function parse (version, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    if (version instanceof SemVer) {
      return version
    }

    if (typeof version !== 'string') {
      return null
    }

    if (version.length > MAX_LENGTH) {
      return null
    }

    var r = options.loose ? re[t.LOOSE] : re[t.FULL]
    if (!r.test(version)) {
      return null
    }

    try {
      return new SemVer(version, options)
    } catch (er) {
      return null
    }
  }

  exports.valid = valid
  function valid (version, options) {
    var v = parse(version, options)
    return v ? v.version : null
  }

  exports.clean = clean
  function clean (version, options) {
    var s = parse(version.trim().replace(/^[=v]+/, ''), options)
    return s ? s.version : null
  }

  exports.SemVer = SemVer

  function SemVer (version, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }
    if (version instanceof SemVer) {
      if (version.loose === options.loose) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError('Invalid Version: ' + version)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
    }

    if (!(this instanceof SemVer)) {
      return new SemVer(version, options)
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose

    var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError('Invalid Version: ' + version)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map(function (id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  SemVer.prototype.format = function () {
    this.version = this.major + '.' + this.minor + '.' + this.patch
    if (this.prerelease.length) {
      this.version += '-' + this.prerelease.join('.')
    }
    return this.version
  }

  SemVer.prototype.toString = function () {
    return this.version
  }

  SemVer.prototype.compare = function (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  SemVer.prototype.compareMain = function (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return compareIdentifiers(this.major, other.major) ||
           compareIdentifiers(this.minor, other.minor) ||
           compareIdentifiers(this.patch, other.patch)
  }

  SemVer.prototype.comparePre = function (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    var i = 0
    do {
      var a = this.prerelease[i]
      var b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  SemVer.prototype.compareBuild = function (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    var i = 0
    do {
      var a = this.build[i]
      var b = other.build[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  SemVer.prototype.inc = function (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier)
        this.inc('pre', identifier)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier)
        }
        this.inc('pre', identifier)
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (this.minor !== 0 ||
            this.patch !== 0 ||
            this.prerelease.length === 0) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0]
        } else {
          var i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            this.prerelease.push(0)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0]
            }
          } else {
            this.prerelease = [identifier, 0]
          }
        }
        break

      default:
        throw new Error('invalid increment argument: ' + release)
    }
    this.format()
    this.raw = this.version
    return this
  }

  exports.inc = inc
  function inc (version, release, loose, identifier) {
    if (typeof (loose) === 'string') {
      identifier = loose
      loose = undefined
    }

    try {
      return new SemVer(version, loose).inc(release, identifier).version
    } catch (er) {
      return null
    }
  }

  exports.diff = diff
  function diff (version1, version2) {
    if (eq(version1, version2)) {
      return null
    } else {
      var v1 = parse(version1)
      var v2 = parse(version2)
      var prefix = ''
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = 'pre'
        var defaultResult = 'prerelease'
      }
      for (var key in v1) {
        if (key === 'major' || key === 'minor' || key === 'patch') {
          if (v1[key] !== v2[key]) {
            return prefix + key
          }
        }
      }
      return defaultResult // may be undefined
    }
  }

  exports.compareIdentifiers = compareIdentifiers

  var numeric = /^[0-9]+$/
  function compareIdentifiers (a, b) {
    var anum = numeric.test(a)
    var bnum = numeric.test(b)

    if (anum && bnum) {
      a = +a
      b = +b
    }

    return a === b ? 0
      : (anum && !bnum) ? -1
      : (bnum && !anum) ? 1
      : a < b ? -1
      : 1
  }

  exports.rcompareIdentifiers = rcompareIdentifiers
  function rcompareIdentifiers (a, b) {
    return compareIdentifiers(b, a)
  }

  exports.major = major
  function major (a, loose) {
    return new SemVer(a, loose).major
  }

  exports.minor = minor
  function minor (a, loose) {
    return new SemVer(a, loose).minor
  }

  exports.patch = patch
  function patch (a, loose) {
    return new SemVer(a, loose).patch
  }

  exports.compare = compare
  function compare (a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose))
  }

  exports.compareLoose = compareLoose
  function compareLoose (a, b) {
    return compare(a, b, true)
  }

  exports.compareBuild = compareBuild
  function compareBuild (a, b, loose) {
    var versionA = new SemVer(a, loose)
    var versionB = new SemVer(b, loose)
    return versionA.compare(versionB) || versionA.compareBuild(versionB)
  }

  exports.rcompare = rcompare
  function rcompare (a, b, loose) {
    return compare(b, a, loose)
  }

  exports.sort = sort
  function sort (list, loose) {
    return list.sort(function (a, b) {
      return exports.compareBuild(a, b, loose)
    })
  }

  exports.rsort = rsort
  function rsort (list, loose) {
    return list.sort(function (a, b) {
      return exports.compareBuild(b, a, loose)
    })
  }

  exports.gt = gt
  function gt (a, b, loose) {
    return compare(a, b, loose) > 0
  }

  exports.lt = lt
  function lt (a, b, loose) {
    return compare(a, b, loose) < 0
  }

  exports.eq = eq
  function eq (a, b, loose) {
    return compare(a, b, loose) === 0
  }

  exports.neq = neq
  function neq (a, b, loose) {
    return compare(a, b, loose) !== 0
  }

  exports.gte = gte
  function gte (a, b, loose) {
    return compare(a, b, loose) >= 0
  }

  exports.lte = lte
  function lte (a, b, loose) {
    return compare(a, b, loose) <= 0
  }

  exports.cmp = cmp
  function cmp (a, op, b, loose) {
    switch (op) {
      case '===':
        if (typeof a === 'object')
          a = a.version
        if (typeof b === 'object')
          b = b.version
        return a === b

      case '!==':
        if (typeof a === 'object')
          a = a.version
        if (typeof b === 'object')
          b = b.version
        return a !== b

      case '':
      case '=':
      case '==':
        return eq(a, b, loose)

      case '!=':
        return neq(a, b, loose)

      case '>':
        return gt(a, b, loose)

      case '>=':
        return gte(a, b, loose)

      case '<':
        return lt(a, b, loose)

      case '<=':
        return lte(a, b, loose)

      default:
        throw new TypeError('Invalid operator: ' + op)
    }
  }

  exports.Comparator = Comparator
  function Comparator (comp, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value
      }
    }

    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options)
    }

    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    } else {
      this.value = this.operator + this.semver.version
    }

    debug('comp', this)
  }

  var ANY = {}
  Comparator.prototype.parse = function (comp) {
    var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    var m = comp.match(r)

    if (!m) {
      throw new TypeError('Invalid comparator: ' + comp)
    }

    this.operator = m[1] !== undefined ? m[1] : ''
    if (this.operator === '=') {
      this.operator = ''
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    } else {
      this.semver = new SemVer(m[2], this.options.loose)
    }
  }

  Comparator.prototype.toString = function () {
    return this.value
  }

  Comparator.prototype.test = function (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  Comparator.prototype.intersects = function (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    var rangeTmp

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      rangeTmp = new Range(comp.value, options)
      return satisfies(this.value, rangeTmp, options)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      rangeTmp = new Range(this.value, options)
      return satisfies(comp.semver, rangeTmp, options)
    }

    var sameDirectionIncreasing =
      (this.operator === '>=' || this.operator === '>') &&
      (comp.operator === '>=' || comp.operator === '>')
    var sameDirectionDecreasing =
      (this.operator === '<=' || this.operator === '<') &&
      (comp.operator === '<=' || comp.operator === '<')
    var sameSemVer = this.semver.version === comp.semver.version
    var differentDirectionsInclusive =
      (this.operator === '>=' || this.operator === '<=') &&
      (comp.operator === '>=' || comp.operator === '<=')
    var oppositeDirectionsLessThan =
      cmp(this.semver, '<', comp.semver, options) &&
      ((this.operator === '>=' || this.operator === '>') &&
      (comp.operator === '<=' || comp.operator === '<'))
    var oppositeDirectionsGreaterThan =
      cmp(this.semver, '>', comp.semver, options) &&
      ((this.operator === '<=' || this.operator === '<') &&
      (comp.operator === '>=' || comp.operator === '>'))

    return sameDirectionIncreasing || sameDirectionDecreasing ||
      (sameSemVer && differentDirectionsInclusive) ||
      oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
  }

  exports.Range = Range
  function Range (range, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    if (range instanceof Range) {
      if (range.loose === !!options.loose &&
          range.includePrerelease === !!options.includePrerelease) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      return new Range(range.value, options)
    }

    if (!(this instanceof Range)) {
      return new Range(range, options)
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First, split based on boolean or ||
    this.raw = range
    this.set = range.split(/\s*\|\|\s*/).map(function (range) {
      return this.parseRange(range.trim())
    }, this).filter(function (c) {
      // throw out any that are not relevant for whatever reason
      return c.length
    })

    if (!this.set.length) {
      throw new TypeError('Invalid SemVer Range: ' + range)
    }

    this.format()
  }

  Range.prototype.format = function () {
    this.range = this.set.map(function (comps) {
      return comps.join(' ').trim()
    }).join('||').trim()
    return this.range
  }

  Range.prototype.toString = function () {
    return this.range
  }

  Range.prototype.parseRange = function (range) {
    var loose = this.options.loose
    range = range.trim()
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace)
    debug('hyphen replace', range)
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range, re[t.COMPARATORTRIM])

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)

    // normalize spaces
    range = range.split(/\s+/).join(' ')

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    var set = range.split(' ').map(function (comp) {
      return parseComparator(comp, this.options)
    }, this).join(' ').split(/\s+/)
    if (this.options.loose) {
      // in loose mode, throw out any that are not valid comparators
      set = set.filter(function (comp) {
        return !!comp.match(compRe)
      })
    }
    set = set.map(function (comp) {
      return new Comparator(comp, this.options)
    }, this)

    return set
  }

  Range.prototype.intersects = function (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some(function (thisComparators) {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some(function (rangeComparators) {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every(function (thisComparator) {
              return rangeComparators.every(function (rangeComparator) {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // take a set of comparators and determine whether there
  // exists a version which can satisfy it
  function isSatisfiable (comparators, options) {
    var result = true
    var remainingComparators = comparators.slice()
    var testComparator = remainingComparators.pop()

    while (result && remainingComparators.length) {
      result = remainingComparators.every(function (otherComparator) {
        return testComparator.intersects(otherComparator, options)
      })

      testComparator = remainingComparators.pop()
    }

    return result
  }

  // Mostly just for testing and legacy API reasons
  exports.toComparators = toComparators
  function toComparators (range, options) {
    return new Range(range, options).set.map(function (comp) {
      return comp.map(function (c) {
        return c.value
      }).join(' ').trim().split(' ')
    })
  }

  // comprised of xranges, tildes, stars, and gtlt's at this point.
  // already replaced the hyphen ranges
  // turn into a set of JUST comparators.
  function parseComparator (comp, options) {
    debug('comp', comp, options)
    comp = replaceCarets(comp, options)
    debug('caret', comp)
    comp = replaceTildes(comp, options)
    debug('tildes', comp)
    comp = replaceXRanges(comp, options)
    debug('xrange', comp)
    comp = replaceStars(comp, options)
    debug('stars', comp)
    return comp
  }

  function isX (id) {
    return !id || id.toLowerCase() === 'x' || id === '*'
  }

  // ~, ~> --> * (any, kinda silly)
  // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
  // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
  // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
  // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
  // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
  function replaceTildes (comp, options) {
    return comp.trim().split(/\s+/).map(function (comp) {
      return replaceTilde(comp, options)
    }).join(' ')
  }

  function replaceTilde (comp, options) {
    var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
    return comp.replace(r, function (_, M, m, p, pr) {
      debug('tilde', comp, _, M, m, p, pr)
      var ret

      if (isX(M)) {
        ret = ''
      } else if (isX(m)) {
        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
      } else if (isX(p)) {
        // ~1.2 == >=1.2.0 <1.3.0
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else if (pr) {
        debug('replaceTilde pr', pr)
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + M + '.' + (+m + 1) + '.0'
      } else {
        // ~1.2.3 == >=1.2.3 <1.3.0
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + M + '.' + (+m + 1) + '.0'
      }

      debug('tilde return', ret)
      return ret
    })
  }

  // ^ --> * (any, kinda silly)
  // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
  // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
  // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
  // ^1.2.3 --> >=1.2.3 <2.0.0
  // ^1.2.0 --> >=1.2.0 <2.0.0
  function replaceCarets (comp, options) {
    return comp.trim().split(/\s+/).map(function (comp) {
      return replaceCaret(comp, options)
    }).join(' ')
  }

  function replaceCaret (comp, options) {
    debug('caret', comp, options)
    var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
    return comp.replace(r, function (_, M, m, p, pr) {
      debug('caret', comp, _, M, m, p, pr)
      var ret

      if (isX(M)) {
        ret = ''
      } else if (isX(m)) {
        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
      } else if (isX(p)) {
        if (M === '0') {
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
        } else {
          ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
        }
      } else if (pr) {
        debug('replaceCaret pr', pr)
        if (M === '0') {
          if (m === '0') {
            ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                  ' <' + M + '.' + m + '.' + (+p + 1)
          } else {
            ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                  ' <' + M + '.' + (+m + 1) + '.0'
          }
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + (+M + 1) + '.0.0'
        }
      } else {
        debug('no pr')
        if (M === '0') {
          if (m === '0') {
            ret = '>=' + M + '.' + m + '.' + p +
                  ' <' + M + '.' + m + '.' + (+p + 1)
          } else {
            ret = '>=' + M + '.' + m + '.' + p +
                  ' <' + M + '.' + (+m + 1) + '.0'
          }
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + (+M + 1) + '.0.0'
        }
      }

      debug('caret return', ret)
      return ret
    })
  }

  function replaceXRanges (comp, options) {
    debug('replaceXRanges', comp, options)
    return comp.split(/\s+/).map(function (comp) {
      return replaceXRange(comp, options)
    }).join(' ')
  }

  function replaceXRange (comp, options) {
    comp = comp.trim()
    var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
    return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
      debug('xRange', comp, ret, gtlt, M, m, p, pr)
      var xM = isX(M)
      var xm = xM || isX(m)
      var xp = xm || isX(p)
      var anyX = xp

      if (gtlt === '=' && anyX) {
        gtlt = ''
      }

      // if we're including prereleases in the match, then we need
      // to fix this to -0, the lowest possible prerelease value
      pr = options.includePrerelease ? '-0' : ''

      if (xM) {
        if (gtlt === '>' || gtlt === '<') {
          // nothing is allowed
          ret = '<0.0.0-0'
        } else {
          // nothing is forbidden
          ret = '*'
        }
      } else if (gtlt && anyX) {
        // we know patch is an x, because we have any x at all.
        // replace X with 0
        if (xm) {
          m = 0
        }
        p = 0

        if (gtlt === '>') {
          // >1 => >=2.0.0
          // >1.2 => >=1.3.0
          // >1.2.3 => >= 1.2.4
          gtlt = '>='
          if (xm) {
            M = +M + 1
            m = 0
            p = 0
          } else {
            m = +m + 1
            p = 0
          }
        } else if (gtlt === '<=') {
          // <=0.7.x is actually <0.8.0, since any 0.7.x should
          // pass.  Similarly, <=7.x is actually <8.0.0, etc.
          gtlt = '<'
          if (xm) {
            M = +M + 1
          } else {
            m = +m + 1
          }
        }

        ret = gtlt + M + '.' + m + '.' + p + pr
      } else if (xm) {
        ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr
      } else if (xp) {
        ret = '>=' + M + '.' + m + '.0' + pr +
          ' <' + M + '.' + (+m + 1) + '.0' + pr
      }

      debug('xRange return', ret)

      return ret
    })
  }

  // Because * is AND-ed with everything else in the comparator,
  // and '' means "any version", just remove the *s entirely.
  function replaceStars (comp, options) {
    debug('replaceStars', comp, options)
    // Looseness is ignored here.  star is always as loose as it gets!
    return comp.trim().replace(re[t.STAR], '')
  }

  // This function is passed to string.replace(re[t.HYPHENRANGE])
  // M, m, patch, prerelease, build
  // 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
  // 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
  // 1.2 - 3.4 => >=1.2.0 <3.5.0
  function hyphenReplace ($0,
    from, fM, fm, fp, fpr, fb,
    to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = ''
    } else if (isX(fm)) {
      from = '>=' + fM + '.0.0'
    } else if (isX(fp)) {
      from = '>=' + fM + '.' + fm + '.0'
    } else {
      from = '>=' + from
    }

    if (isX(tM)) {
      to = ''
    } else if (isX(tm)) {
      to = '<' + (+tM + 1) + '.0.0'
    } else if (isX(tp)) {
      to = '<' + tM + '.' + (+tm + 1) + '.0'
    } else if (tpr) {
      to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
    } else {
      to = '<=' + to
    }

    return (from + ' ' + to).trim()
  }

  // if ANY of the sets match ALL of its comparators, then pass
  Range.prototype.test = function (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (var i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }

  function testSet (set, version, options) {
    for (var i = 0; i < set.length; i++) {
      if (!set[i].test(version)) {
        return false
      }
    }

    if (version.prerelease.length && !options.includePrerelease) {
      // Find the set of versions that are allowed to have prereleases
      // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
      // That should allow `1.2.3-pr.2` to pass.
      // However, `1.2.4-alpha.notready` should NOT be allowed,
      // even though it's within the range set by the comparators.
      for (i = 0; i < set.length; i++) {
        debug(set[i].semver)
        if (set[i].semver === ANY) {
          continue
        }

        if (set[i].semver.prerelease.length > 0) {
          var allowed = set[i].semver
          if (allowed.major === version.major &&
              allowed.minor === version.minor &&
              allowed.patch === version.patch) {
            return true
          }
        }
      }

      // Version has a -pre, but it's not one of the ones we like.
      return false
    }

    return true
  }

  exports.satisfies = satisfies
  function satisfies (version, range, options) {
    try {
      range = new Range(range, options)
    } catch (er) {
      return false
    }
    return range.test(version)
  }

  exports.maxSatisfying = maxSatisfying
  function maxSatisfying (versions, range, options) {
    var max = null
    var maxSV = null
    try {
      var rangeObj = new Range(range, options)
    } catch (er) {
      return null
    }
    versions.forEach(function (v) {
      if (rangeObj.test(v)) {
        // satisfies(v, range, options)
        if (!max || maxSV.compare(v) === -1) {
          // compare(max, v, true)
          max = v
          maxSV = new SemVer(max, options)
        }
      }
    })
    return max
  }

  exports.minSatisfying = minSatisfying
  function minSatisfying (versions, range, options) {
    var min = null
    var minSV = null
    try {
      var rangeObj = new Range(range, options)
    } catch (er) {
      return null
    }
    versions.forEach(function (v) {
      if (rangeObj.test(v)) {
        // satisfies(v, range, options)
        if (!min || minSV.compare(v) === 1) {
          // compare(min, v, true)
          min = v
          minSV = new SemVer(min, options)
        }
      }
    })
    return min
  }

  exports.minVersion = minVersion
  function minVersion (range, loose) {
    range = new Range(range, loose)

    var minver = new SemVer('0.0.0')
    if (range.test(minver)) {
      return minver
    }

    minver = new SemVer('0.0.0-0')
    if (range.test(minver)) {
      return minver
    }

    minver = null
    for (var i = 0; i < range.set.length; ++i) {
      var comparators = range.set[i]

      comparators.forEach(function (comparator) {
        // Clone to avoid manipulating the comparator's semver object.
        var compver = new SemVer(comparator.semver.version)
        switch (comparator.operator) {
          case '>':
            if (compver.prerelease.length === 0) {
              compver.patch++
            } else {
              compver.prerelease.push(0)
            }
            compver.raw = compver.format()
            /* fallthrough */
          case '':
          case '>=':
            if (!minver || gt(minver, compver)) {
              minver = compver
            }
            break
          case '<':
          case '<=':
            /* Ignore maximum versions */
            break
          /* istanbul ignore next */
          default:
            throw new Error('Unexpected operation: ' + comparator.operator)
        }
      })
    }

    if (minver && range.test(minver)) {
      return minver
    }

    return null
  }

  exports.validRange = validRange
  function validRange (range, options) {
    try {
      // Return '*' instead of '' so that truthiness works.
      // This will throw if it's invalid anyway
      return new Range(range, options).range || '*'
    } catch (er) {
      return null
    }
  }

  // Determine if version is less than all the versions possible in the range
  exports.ltr = ltr
  function ltr (version, range, options) {
    return outside(version, range, '<', options)
  }

  // Determine if version is greater than all the versions possible in the range.
  exports.gtr = gtr
  function gtr (version, range, options) {
    return outside(version, range, '>', options)
  }

  exports.outside = outside
  function outside (version, range, hilo, options) {
    version = new SemVer(version, options)
    range = new Range(range, options)

    var gtfn, ltefn, ltfn, comp, ecomp
    switch (hilo) {
      case '>':
        gtfn = gt
        ltefn = lte
        ltfn = lt
        comp = '>'
        ecomp = '>='
        break
      case '<':
        gtfn = lt
        ltefn = gte
        ltfn = gt
        comp = '<'
        ecomp = '<='
        break
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"')
    }

    // If it satisifes the range it is not outside
    if (satisfies(version, range, options)) {
      return false
    }

    // From now on, variable terms are as if we're in "gtr" mode.
    // but note that everything is flipped for the "ltr" function.

    for (var i = 0; i < range.set.length; ++i) {
      var comparators = range.set[i]

      var high = null
      var low = null

      comparators.forEach(function (comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator('>=0.0.0')
        }
        high = high || comparator
        low = low || comparator
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator
        }
      })

      // If the edge version comparator has a operator then our version
      // isn't outside it
      if (high.operator === comp || high.operator === ecomp) {
        return false
      }

      // If the lowest version comparator has an operator and our version
      // is less than it then it isn't higher than the range
      if ((!low.operator || low.operator === comp) &&
          ltefn(version, low.semver)) {
        return false
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false
      }
    }
    return true
  }

  exports.prerelease = prerelease
  function prerelease (version, options) {
    var parsed = parse(version, options)
    return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
  }

  exports.intersects = intersects
  function intersects (r1, r2, options) {
    r1 = new Range(r1, options)
    r2 = new Range(r2, options)
    return r1.intersects(r2)
  }

  exports.coerce = coerce
  function coerce (version, options) {
    if (version instanceof SemVer) {
      return version
    }

    if (typeof version === 'number') {
      version = String(version)
    }

    if (typeof version !== 'string') {
      return null
    }

    options = options || {}

    var match = null
    if (!options.rtl) {
      match = version.match(re[t.COERCE])
    } else {
      // Find the right-most coercible string that does not share
      // a terminus with a more left-ward coercible string.
      // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
      //
      // Walk through the string checking with a /g regexp
      // Manually set the index so as to pick up overlapping matches.
      // Stop when we get a match that ends at the string end, since no
      // coercible string can be more right-ward without the same terminus.
      var next
      while ((next = re[t.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
      ) {
        if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
          match = next
        }
        re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
      }
      // leave it in a clean state
      re[t.COERCERTL].lastIndex = -1
    }

    if (match === null) {
      return null
    }

    return parse(match[2] +
      '.' + (match[3] || '0') +
      '.' + (match[4] || '0'), options)
  }


  /***/ })
  /******/ ]);
  return plugin;
};

module.exports.name = "@yarnpkg/plugin-deduplicate";
